{"ast":null,"code":"'use strict';\n\nmodule.exports = function (dialect) {\n  var buildComparisonCondition = function (field, operator, value) {\n    return [field, operator, value].join(' ');\n  };\n\n  dialect.operators.comparison.add('$jsonContains', {\n    defaultFetchingOperator: '$json',\n    fn: function (field, value) {\n      return buildComparisonCondition(field, '@>', value);\n    }\n  });\n  dialect.operators.comparison.add('$jsonIn', {\n    defaultFetchingOperator: '$json',\n    fn: function (field, value) {\n      return buildComparisonCondition(field, '<@', value);\n    }\n  });\n  dialect.operators.comparison.add('$jsonHas', {\n    defaultFetchingOperator: '$value',\n    fn: function (field, value) {\n      return buildComparisonCondition(field, '?', value);\n    }\n  });\n  dialect.operators.comparison.add('$jsonHasAny', {\n    defaultFetchingOperator: '$value',\n    fn: function (field, value) {\n      return buildComparisonCondition(field, '?|', value);\n    }\n  });\n  dialect.operators.comparison.add('$jsonHasAll', {\n    defaultFetchingOperator: '$value',\n    fn: function (field, value) {\n      return buildComparisonCondition(field, '?&', value);\n    }\n  });\n  dialect.operators.comparison.add('$ilike', {\n    inversedOperator: '$nilike',\n    defaultFetchingOperator: '$value',\n    fn: function (field, value) {\n      return buildComparisonCondition(field, 'ilike', value);\n    }\n  });\n  dialect.operators.comparison.add('$nilike', {\n    inversedOperator: '$ilike',\n    defaultFetchingOperator: '$value',\n    fn: function (field, value) {\n      return buildComparisonCondition(field, 'not ilike', value);\n    }\n  });\n  dialect.operators.comparison.add('$arrayContains', {\n    defaultFetchingOperator: '$array',\n    fn: function (field, value) {\n      return buildComparisonCondition(field, '@>', value);\n    }\n  });\n  dialect.operators.comparison.add('$arrayIn', {\n    defaultFetchingOperator: '$array',\n    fn: function (field, value) {\n      return buildComparisonCondition(field, '<@', value);\n    }\n  });\n  dialect.operators.comparison.add('$arrayOverlap', {\n    defaultFetchingOperator: '$array',\n    fn: function (field, value) {\n      return buildComparisonCondition(field, '&&', value);\n    }\n  });\n};","map":{"version":3,"sources":["D:/Postgres_workingFolder/QuaLISWeb/node_modules/json-sql/lib/dialects/postgresql/operators/comparison.js"],"names":["module","exports","dialect","buildComparisonCondition","field","operator","value","join","operators","comparison","add","defaultFetchingOperator","fn","inversedOperator"],"mappings":"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","sourcesContent":["'use strict';\n\nmodule.exports = function(dialect) {\n\tvar buildComparisonCondition = function(field, operator, value) {\n\t\treturn [field, operator, value].join(' ');\n\t};\n\n\tdialect.operators.comparison.add('$jsonContains', {\n\t\tdefaultFetchingOperator: '$json',\n\t\tfn: function(field, value) {\n\t\t\treturn buildComparisonCondition(field, '@>', value);\n\t\t}\n\t});\n\n\tdialect.operators.comparison.add('$jsonIn', {\n\t\tdefaultFetchingOperator: '$json',\n\t\tfn: function(field, value) {\n\t\t\treturn buildComparisonCondition(field, '<@', value);\n\t\t}\n\t});\n\n\tdialect.operators.comparison.add('$jsonHas', {\n\t\tdefaultFetchingOperator: '$value',\n\t\tfn: function(field, value) {\n\t\t\treturn buildComparisonCondition(field, '?', value);\n\t\t}\n\t});\n\n\tdialect.operators.comparison.add('$jsonHasAny', {\n\t\tdefaultFetchingOperator: '$value',\n\t\tfn: function(field, value) {\n\t\t\treturn buildComparisonCondition(field, '?|', value);\n\t\t}\n\t});\n\n\tdialect.operators.comparison.add('$jsonHasAll', {\n\t\tdefaultFetchingOperator: '$value',\n\t\tfn: function(field, value) {\n\t\t\treturn buildComparisonCondition(field, '?&', value);\n\t\t}\n\t});\n\n\tdialect.operators.comparison.add('$ilike', {\n\t\tinversedOperator: '$nilike',\n\t\tdefaultFetchingOperator: '$value',\n\t\tfn: function(field, value) {\n\t\t\treturn buildComparisonCondition(field, 'ilike', value);\n\t\t}\n\t});\n\n\tdialect.operators.comparison.add('$nilike', {\n\t\tinversedOperator: '$ilike',\n\t\tdefaultFetchingOperator: '$value',\n\t\tfn: function(field, value) {\n\t\t\treturn buildComparisonCondition(field, 'not ilike', value);\n\t\t}\n\t});\n\n\tdialect.operators.comparison.add('$arrayContains', {\n\t\tdefaultFetchingOperator: '$array',\n\t\tfn: function(field, value) {\n\t\t\treturn buildComparisonCondition(field, '@>', value);\n\t\t}\n\t});\n\n\tdialect.operators.comparison.add('$arrayIn', {\n\t\tdefaultFetchingOperator: '$array',\n\t\tfn: function(field, value) {\n\t\t\treturn buildComparisonCondition(field, '<@', value);\n\t\t}\n\t});\n\n\tdialect.operators.comparison.add('$arrayOverlap', {\n\t\tdefaultFetchingOperator: '$array',\n\t\tfn: function(field, value) {\n\t\t\treturn buildComparisonCondition(field, '&&', value);\n\t\t}\n\t});\n};\n"]},"metadata":{},"sourceType":"script"}