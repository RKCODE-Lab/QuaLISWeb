{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _typeof from \"@babel/runtime/helpers/typeof\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nimport { SpelExpressionEvaluator } from \"spel2js\";\nimport uuid from \"../utils/uuid\";\nimport { getFieldConfig, extendConfig, normalizeField } from \"../utils/configUtils\";\nimport { getWidgetForFieldOp } from \"../utils/ruleUtils\";\nimport { loadTree } from \"./tree\";\nimport { defaultConjunction, defaultGroupConjunction } from \"../utils/defaultUtils\";\nimport { logger } from \"../utils/stuff\";\nimport moment from \"moment\";\nexport var loadFromSpel = function loadFromSpel(logicTree, config) {\n  return _loadFromSpel(logicTree, config, true);\n};\nexport var _loadFromSpel = function _loadFromSpel(spelStr, config) {\n  var returnErrors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true; //meta is mutable\n\n  var meta = {\n    errors: []\n  };\n  var extendedConfig = extendConfig(config);\n  var conv = buildConv(extendedConfig);\n  var compiledExpression;\n  var convertedObj;\n  var jsTree = undefined;\n\n  try {\n    var compileRes = SpelExpressionEvaluator.compile(spelStr);\n    compiledExpression = compileRes._compiledExpression;\n  } catch (e) {\n    meta.errors.push(e);\n  }\n\n  if (compiledExpression) {\n    logger.debug(\"compiledExpression:\", compiledExpression);\n    convertedObj = convertCompiled(compiledExpression, meta);\n    logger.debug(\"convertedObj:\", convertedObj, meta);\n    jsTree = convertToTree(convertedObj, conv, extendedConfig, meta);\n\n    if (jsTree && jsTree.type != \"group\" && jsTree.type != \"switch_group\") {\n      jsTree = wrapInDefaultConj(jsTree, extendedConfig, convertedObj[\"not\"]);\n    }\n\n    logger.debug(\"jsTree:\", jsTree);\n  }\n\n  var immTree = jsTree ? loadTree(jsTree) : undefined;\n\n  if (returnErrors) {\n    return [immTree, meta.errors];\n  } else {\n    if (meta.errors.length) console.warn(\"Errors while importing from SpEL:\", meta.errors);\n    return immTree;\n  }\n};\n\nvar convertCompiled = function convertCompiled(expr, meta) {\n  var parentExpr = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var type = expr.getType();\n  var children = expr.getChildren().map(function (child) {\n    return convertCompiled(child, meta, expr);\n  }); // flatize OR/AND\n\n  if (type == \"op-or\" || type == \"op-and\") {\n    children = children.reduce(function (acc, child) {\n      var canFlatize = child.type == type && !child.not;\n      var flat = canFlatize ? child.children : [child];\n      return [].concat(_toConsumableArray(acc), _toConsumableArray(flat));\n    }, []);\n  } // unwrap NOT\n\n\n  if (type == \"op-not\") {\n    if (children.length != 1) {\n      meta.errors.push(\"Operator NOT should have 1 child, but got \".concat(children.length, \"}\"));\n    }\n\n    return _objectSpread(_objectSpread({}, children[0]), {}, {\n      not: !(children[0].not || false)\n    });\n  }\n\n  if (type == \"compound\") {\n    // remove `.?[true]`\n    children = children.filter(function (child) {\n      var isListFix = child.type == \"selection\" && child.children.length == 1 && child.children[0].type == \"boolean\" && child.children[0].val == true;\n      return !isListFix;\n    }); // aggregation\n    // eg. `results.?[product == 'abc'].length`\n\n    var selection = children.find(function (child) {\n      return child.type == \"selection\";\n    });\n\n    if (selection && selection.children.length != 1) {\n      meta.errors.push(\"Selection should have 1 child, but got \".concat(selection.children.length));\n    }\n\n    var filter = selection ? selection.children[0] : null;\n    var lastChild = children[children.length - 1];\n    var isSize = lastChild.type == \"method\" && lastChild.val.methodName == \"size\" || lastChild.type == \"!func\" && lastChild.methodName == \"size\";\n    var isLength = lastChild.type == \"property\" && lastChild.val == \"length\";\n    var sourceParts = children.filter(function (child) {\n      return child !== selection && child !== lastChild;\n    });\n    var source = {\n      type: \"compound\",\n      children: sourceParts\n    };\n\n    if (isSize || isLength) {\n      return {\n        type: \"!aggr\",\n        filter: filter,\n        source: source\n      };\n    } // remove `#this`, `#root`\n\n\n    children = children.filter(function (child) {\n      var isThis = child.type == \"variable\" && child.val == \"this\";\n      var isRoot = child.type == \"variable\" && child.val == \"root\";\n      return !(isThis || isRoot);\n    }); // indexer\n\n    children = children.map(function (child) {\n      if (child.type == \"indexer\" && child.children.length == 1) {\n        return {\n          type: \"indexer\",\n          val: child.children[0].val,\n          itype: child.children[0].type\n        };\n      } else {\n        return child;\n      }\n    }); // method\n\n    if (lastChild.type == \"method\") {\n      var obj = children.filter(function (child) {\n        return child !== lastChild;\n      });\n      return {\n        type: \"!func\",\n        obj: obj,\n        methodName: lastChild.val.methodName,\n        args: lastChild.val.args\n      };\n    } // !func\n\n\n    if (lastChild.type == \"!func\") {\n      var _obj = children.filter(function (child) {\n        return child !== lastChild;\n      });\n\n      return _objectSpread(_objectSpread({}, lastChild), {}, {\n        obj: _obj\n      });\n    }\n  } // getRaw || getValue\n\n\n  var val;\n\n  try {\n    if (expr.getRaw) {\n      // use my fork\n      val = expr.getRaw();\n    } else if (expr.getValue.length == 0) {\n      // getValue not requires context arg -> can use\n      val = expr.getValue();\n    }\n  } catch (e) {\n    logger.error(\"[spel2js] Error in getValue()\", e);\n  } // ternary\n\n\n  if (type == \"ternary\") {\n    val = flatizeTernary(children);\n  } // convert method/function args\n\n\n  if (_typeof(val) === \"object\" && val !== null) {\n    if (val.methodName || val.functionName) {\n      val.args = val.args.map(function (child) {\n        return convertCompiled(child, meta, expr);\n      });\n    }\n  } // convert list\n\n\n  if (type == \"list\") {\n    val = val.map(function (item) {\n      return convertCompiled(item, meta, expr);\n    }); // fix whole expression wrapped in `{}`\n\n    if (!parentExpr && val.length == 1) {\n      return val[0];\n    }\n  } // convert constructor\n\n\n  if (type == \"constructorref\") {\n    var qid = children.find(function (child) {\n      return child.type == \"qualifiedidentifier\";\n    });\n    var cls = qid === null || qid === void 0 ? void 0 : qid.val;\n\n    if (!cls) {\n      meta.errors.push(\"Can't find qualifiedidentifier in constructorref children: \".concat(JSON.stringify(children)));\n      return undefined;\n    }\n\n    var args = children.filter(function (child) {\n      return child.type != \"qualifiedidentifier\";\n    });\n    return {\n      type: \"!new\",\n      cls: cls,\n      args: args\n    };\n  } // convert type\n\n\n  if (type == \"typeref\") {\n    var _qid = children.find(function (child) {\n      return child.type == \"qualifiedidentifier\";\n    });\n\n    var _cls = _qid === null || _qid === void 0 ? void 0 : _qid.val;\n\n    if (!_cls) {\n      meta.errors.push(\"Can't find qualifiedidentifier in typeref children: \".concat(JSON.stringify(children)));\n      return undefined;\n    }\n\n    var _args = children.filter(function (child) {\n      return child.type != \"qualifiedidentifier\";\n    });\n\n    return {\n      type: \"!type\",\n      cls: _cls\n    };\n  } // convert function/method\n\n\n  if (type == \"function\" || type == \"method\") {\n    // `foo()` is method, `#foo()` is function\n    // let's use common property `methodName` and just add `isVar` for function\n    var _val = val,\n        functionName = _val.functionName,\n        methodName = _val.methodName,\n        _args2 = _val.args;\n    return {\n      type: \"!func\",\n      methodName: functionName || methodName,\n      isVar: type == \"function\",\n      args: _args2\n    };\n  }\n\n  return {\n    type: type,\n    children: children,\n    val: val\n  };\n};\n\nvar flatizeTernary = function flatizeTernary(children) {\n  var flat = [];\n\n  function _processTernaryChildren(tern) {\n    var _tern = _slicedToArray(tern, 3),\n        cond = _tern[0],\n        if_val = _tern[1],\n        else_val = _tern[2];\n\n    flat.push([cond, if_val]);\n\n    if ((else_val === null || else_val === void 0 ? void 0 : else_val.type) == \"ternary\") {\n      _processTernaryChildren(else_val.children);\n    } else {\n      flat.push([undefined, else_val]);\n    }\n  }\n\n  _processTernaryChildren(children);\n\n  return flat;\n};\n\nvar buildConv = function buildConv(config) {\n  var operators = {};\n\n  var _loop = function _loop(opKey) {\n    var opConfig = config.operators[opKey];\n\n    if (opConfig.spelOps) {\n      // examples: \"==\", \"eq\", \".contains\", \"matches\" (can be used for starts_with, ends_with)\n      opConfig.spelOps.forEach(function (spelOp) {\n        var opk = spelOp; // + \"/\" + defaultValue(opConfig.cardinality, 1);\n\n        if (!operators[opk]) operators[opk] = [];\n        operators[opk].push(opKey);\n      });\n    } else if (opConfig.spelOp) {\n      var opk = opConfig.spelOp; // + \"/\" + defaultValue(opConfig.cardinality, 1);\n\n      if (!operators[opk]) operators[opk] = [];\n      operators[opk].push(opKey);\n    } else {\n      logger.log(\"[spel] No spelOp for operator \".concat(opKey));\n    }\n  };\n\n  for (var opKey in config.operators) {\n    _loop(opKey);\n  }\n\n  var conjunctions = {};\n\n  for (var conjKey in config.conjunctions) {\n    var conjunctionDefinition = config.conjunctions[conjKey];\n    var ck = conjunctionDefinition.spelConj || conjKey.toLowerCase();\n    conjunctions[ck] = conjKey;\n  }\n\n  var funcs = {};\n\n  for (var funcKey in config.funcs) {\n    var funcConfig = config.funcs[funcKey];\n    var fk = void 0;\n\n    if (typeof funcConfig.spelFunc == \"string\") {\n      fk = funcConfig.spelFunc;\n    }\n\n    if (fk) {\n      if (!funcs[fk]) funcs[fk] = [];\n      funcs[fk].push(funcKey);\n    }\n  }\n\n  return {\n    operators: operators,\n    conjunctions: conjunctions,\n    funcs: funcs\n  };\n};\n\nvar convertPath = function convertPath(parts, meta) {\n  var isError = false;\n  var res = parts.map(function (c) {\n    if (c.type == \"variable\" || c.type == \"property\" || c.type == \"indexer\" && c.itype == \"string\") {\n      return c.val;\n    } else {\n      isError = true;\n      meta.errors.push(\"Unexpected item in compound: \".concat(JSON.stringify(c)));\n    }\n  });\n  return !isError ? res : undefined;\n};\n\nvar convertArg = function convertArg(spel, conv, config, meta, parentSpel) {\n  if (spel == undefined) return undefined;\n  var fieldSeparator = config.settings.fieldSeparator;\n  var literalTypes = {\n    number: \"number\",\n    string: \"text\",\n    \"boolean\": \"boolean\",\n    \"null\": \"null\" // should not be\n\n  };\n  var groupFieldParts = parentSpel !== null && parentSpel !== void 0 && parentSpel._groupField ? [parentSpel === null || parentSpel === void 0 ? void 0 : parentSpel._groupField] : [];\n\n  if (spel.type == \"compound\") {\n    var _spel$children, _spel$children$; // complex field\n\n\n    var parts = convertPath(spel.children, meta);\n\n    if (!parts) {\n      return undefined;\n    }\n\n    var fullParts = [].concat(groupFieldParts, _toConsumableArray(parts));\n    var isVariable = ((_spel$children = spel.children) === null || _spel$children === void 0 ? void 0 : (_spel$children$ = _spel$children[0]) === null || _spel$children$ === void 0 ? void 0 : _spel$children$.type) == \"variable\";\n    return {\n      valueSrc: \"field\",\n      //valueType: todo\n      isVariable: isVariable,\n      value: fullParts.join(fieldSeparator)\n    };\n  } else if (spel.type == \"variable\" || spel.type == \"property\") {\n    // normal field\n    var _fullParts = [].concat(groupFieldParts, [spel.val]);\n\n    var _isVariable = spel.type == \"variable\";\n\n    return {\n      valueSrc: \"field\",\n      //valueType: todo\n      isVariable: _isVariable,\n      value: _fullParts.join(fieldSeparator)\n    };\n  } else if (literalTypes[spel.type]) {\n    var value = spel.val;\n    var valueType = literalTypes[spel.type];\n\n    if (parentSpel !== null && parentSpel !== void 0 && parentSpel.isUnary) {\n      value = -value;\n    }\n\n    return {\n      valueSrc: \"value\",\n      valueType: valueType,\n      value: value\n    };\n  } else if (spel.type == \"list\") {\n    var _values$;\n\n    var values = spel.val.map(function (v) {\n      return convertArg(v, conv, config, meta, spel);\n    });\n\n    var _itemType = values.length ? (_values$ = values[0]) === null || _values$ === void 0 ? void 0 : _values$.valueType : null;\n\n    var _value = values.map(function (v) {\n      return v === null || v === void 0 ? void 0 : v.value;\n    });\n\n    var _valueType = \"multiselect\";\n    return {\n      valueSrc: \"value\",\n      valueType: _valueType,\n      value: _value\n    };\n  } else if (spel.type == \"!func\") {\n    var _funcToOpMap;\n\n    var obj = spel.obj,\n        methodName = spel.methodName,\n        args = spel.args,\n        isVar = spel.isVar; // todo: get from conv\n\n    var funcToOpMap = (_funcToOpMap = {}, _defineProperty(_funcToOpMap, \".contains\", \"like\"), _defineProperty(_funcToOpMap, \".startsWith\", \"starts_with\"), _defineProperty(_funcToOpMap, \".endsWith\", \"ends_with\"), _defineProperty(_funcToOpMap, \"$contains\", \"select_any_in\"), _defineProperty(_funcToOpMap, \".equals\", \"multiselect_equals\"), _defineProperty(_funcToOpMap, \"CollectionUtils.containsAny()\", \"multiselect_contains\"), _funcToOpMap);\n    var convertedArgs = args.map(function (v) {\n      return convertArg(v, conv, config, meta, _objectSpread(_objectSpread({}, spel), {}, {\n        _groupField: parentSpel === null || parentSpel === void 0 ? void 0 : parentSpel._groupField\n      }));\n    }); //todo: make dynamic: use funcToOpMap and check obj type in basic config\n\n    if (methodName == \"contains\" && obj && obj[0].type == \"list\") {\n      var convertedObj = obj.map(function (v) {\n        return convertArg(v, conv, config, meta, spel);\n      }); // {'yellow', 'green'}.?[true].contains(color)\n\n      if (!(convertedArgs.length == 1 && convertedArgs[0].valueSrc == \"field\")) {\n        meta.errors.push(\"Expected arg to method \".concat(methodName, \" to be field but got: \").concat(JSON.stringify(convertedArgs)));\n        return undefined;\n      }\n\n      var field = convertedArgs[0].value;\n\n      if (!(convertedObj.length == 1 && convertedObj[0].valueType == \"multiselect\")) {\n        meta.errors.push(\"Expected object of method \".concat(methodName, \" to be inline list but got: \").concat(JSON.stringify(convertedObj)));\n        return undefined;\n      }\n\n      var opKey = funcToOpMap[\"$\" + methodName];\n      var list = convertedObj[0];\n      return buildRule(config, meta, field, opKey, [list], spel);\n    } else if (obj && obj[0].type == \"property\" && funcToOpMap[obj[0].val + \".\" + methodName + \"()\"]) {\n      // CollectionUtils.containsAny(multicolor, {'yellow', 'green'})\n      var _opKey = funcToOpMap[obj[0].val + \".\" + methodName + \"()\"];\n      var _field = convertedArgs[0].value;\n\n      var _args3 = convertedArgs.slice(1);\n\n      return buildRule(config, meta, _field, _opKey, _args3, spel);\n    } else if (funcToOpMap[\".\" + methodName]) {\n      // user.login.startsWith('gg')\n      var _opKey2 = funcToOpMap[\".\" + methodName];\n\n      var _parts = convertPath(obj, meta);\n\n      if (_parts && convertedArgs.length == 1) {\n        var _fullParts2 = [].concat(groupFieldParts, _toConsumableArray(_parts));\n\n        var _field2 = _fullParts2.join(fieldSeparator);\n\n        return buildRule(config, meta, _field2, _opKey2, convertedArgs, spel);\n      }\n    } else if (methodName == \"parse\" && obj && obj[0].type == \"!new\" && obj[0].cls.at(-1) == \"SimpleDateFormat\") {\n      // new java.text.SimpleDateFormat('yyyy-MM-dd').parse('2022-01-15')\n      var _args4 = obj[0].args.map(function (v) {\n        return convertArg(v, conv, config, meta, _objectSpread(_objectSpread({}, spel), {}, {\n          _groupField: parentSpel === null || parentSpel === void 0 ? void 0 : parentSpel._groupField\n        }));\n      });\n\n      if (!(_args4.length == 1 && _args4[0].valueType == \"text\")) {\n        meta.errors.push(\"Expected args of \".concat(obj[0].cls.join(\".\"), \".\").concat(methodName, \" to be 1 string but got: \").concat(JSON.stringify(_args4)));\n        return undefined;\n      }\n\n      if (!(convertedArgs.length == 1 && convertedArgs[0].valueType == \"text\")) {\n        meta.errors.push(\"Expected args of \".concat(obj[0].cls.join(\".\"), \" to be 1 string but got: \").concat(JSON.stringify(convertedArgs)));\n        return undefined;\n      }\n\n      var dateFormat = _args4[0].value;\n      var dateString = convertedArgs[0].value;\n\n      var _valueType2 = dateFormat.includes(\" \") ? \"datetime\" : \"date\";\n\n      var _field3 = null; // todo\n\n      var widget = _valueType2;\n      var fieldConfig = getFieldConfig(config, _field3);\n      var widgetConfig = config.widgets[widget || (fieldConfig === null || fieldConfig === void 0 ? void 0 : fieldConfig.mainWidget)];\n      var valueFormat = widgetConfig.valueFormat;\n      var dateVal = moment(dateString, moment.ISO_8601);\n\n      var _value2 = dateVal.isValid() ? dateVal.format(valueFormat) : undefined;\n\n      return {\n        valueSrc: \"value\",\n        valueType: _valueType2,\n        value: _value2\n      };\n    } else if (methodName == \"parse\" && obj && obj[0].type == \"!type\" && obj[0].cls.at(-1) == \"LocalTime\") {\n      // time == T(java.time.LocalTime).parse('02:03:00')\n      if (!(convertedArgs.length == 1 && convertedArgs[0].valueType == \"text\")) {\n        meta.errors.push(\"Expected args of \".concat(obj[0].cls.join(\".\"), \" to be 1 string but got: \").concat(JSON.stringify(convertedArgs)));\n        return undefined;\n      }\n\n      var timeString = convertedArgs[0].value;\n      var _valueType3 = \"time\";\n      var _field4 = null; // todo\n\n      var _widget = _valueType3;\n\n      var _fieldConfig = getFieldConfig(config, _field4);\n\n      var _widgetConfig = config.widgets[_widget || (_fieldConfig === null || _fieldConfig === void 0 ? void 0 : _fieldConfig.mainWidget)];\n      var _valueFormat = _widgetConfig.valueFormat;\n\n      var _dateVal = moment(timeString, \"HH:mm:ss\");\n\n      var _value3 = _dateVal.isValid() ? _dateVal.format(_valueFormat) : undefined;\n\n      return {\n        valueSrc: \"value\",\n        valueType: _valueType3,\n        value: _value3\n      };\n    } else {\n      // todo: conv.funcs\n      meta.errors.push(\"Unsupported method \".concat(methodName));\n    }\n  } else if (spel.type == \"op-plus\" && (parentSpel === null || parentSpel === void 0 ? void 0 : parentSpel.type) == \"ternary\") {\n    return buildCaseValueConcat(spel, conv, config, meta);\n  } else {\n    meta.errors.push(\"Can't convert arg of type \".concat(spel.type));\n  }\n\n  return undefined;\n};\n\nvar buildRule = function buildRule(config, meta, field, opKey, convertedArgs, spel) {\n  if (convertedArgs.filter(function (v) {\n    return v === undefined;\n  }).length) {\n    return undefined;\n  }\n\n  var fieldConfig = getFieldConfig(config, field);\n\n  if (!fieldConfig) {\n    meta.errors.push(\"No config for field \".concat(field));\n    return undefined;\n  }\n\n  var canRev = true;\n  var needWrapReverse = false;\n\n  if (spel !== null && spel !== void 0 && spel.not && canRev) {\n    var opConfig = config.operators[opKey];\n\n    if (opConfig.reversedOp) {\n      opKey = opConfig.reversedOp;\n      spel.not = false;\n    } else {\n      needWrapReverse = true;\n    }\n  }\n\n  var widget = getWidgetForFieldOp(config, field, opKey);\n  var widgetConfig = config.widgets[widget || fieldConfig.mainWidget];\n  var asyncListValuesArr = convertedArgs.map(function (v) {\n    return v.asyncListValues;\n  }).filter(function (v) {\n    return v != undefined;\n  });\n  var asyncListValues = asyncListValuesArr.length ? asyncListValuesArr[0] : undefined;\n  var res = {\n    type: \"rule\",\n    id: uuid(),\n    properties: {\n      field: field,\n      operator: opKey,\n      value: convertedArgs.map(function (v) {\n        return v.value;\n      }),\n      valueSrc: convertedArgs.map(function (v) {\n        return v.valueSrc;\n      }),\n      valueType: convertedArgs.map(function (v) {\n        if (v.valueSrc == \"value\") {\n          return (widgetConfig === null || widgetConfig === void 0 ? void 0 : widgetConfig.type) || (fieldConfig === null || fieldConfig === void 0 ? void 0 : fieldConfig.type) || v.valueType;\n        }\n\n        return v.valueType;\n      }),\n      asyncListValues: asyncListValues\n    }\n  };\n\n  if (needWrapReverse) {\n    res = wrapInDefaultConj(res, config, spel === null || spel === void 0 ? void 0 : spel.not);\n\n    if (spel !== null && spel !== void 0 && spel.not) {\n      spel.not = false;\n    }\n  }\n\n  return res;\n};\n\nvar buildRuleGroup = function buildRuleGroup(_ref, opKey, convertedArgs, config, meta) {\n  var groupFilter = _ref.groupFilter,\n      groupFieldValue = _ref.groupFieldValue;\n  if (groupFieldValue.valueSrc != \"field\") throw \"Bad groupFieldValue: \".concat(JSON.stringify(groupFieldValue));\n  var groupField = groupFieldValue.value;\n  var groupOpRule = buildRule(config, meta, groupField, opKey, convertedArgs);\n  if (!groupOpRule) return undefined;\n  var fieldConfig = getFieldConfig(config, groupField);\n  var mode = fieldConfig === null || fieldConfig === void 0 ? void 0 : fieldConfig.mode;\n\n  var res = _objectSpread(_objectSpread({}, groupFilter || {}), {}, {\n    type: \"rule_group\",\n    properties: _objectSpread(_objectSpread(_objectSpread({}, groupOpRule.properties), (groupFilter === null || groupFilter === void 0 ? void 0 : groupFilter.properties) || {}), {}, {\n      mode: mode\n    })\n  });\n\n  if (!res.id) res.id = uuid();\n  return res;\n};\n\nvar compareArgs = function compareArgs(left, right, spel, conv, config, meta) {\n  var parentSpel = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n\n  if (left.type == right.type) {\n    if (left.type == \"!aggr\") {\n      var _map = [left.source, right.source].map(function (v) {\n        return convertArg(v, conv, config, meta, _objectSpread(_objectSpread({}, spel), {}, {\n          _groupField: parentSpel === null || parentSpel === void 0 ? void 0 : parentSpel._groupField\n        }));\n      }),\n          _map2 = _slicedToArray(_map, 2),\n          leftSource = _map2[0],\n          rightSource = _map2[1]; //todo: check same filter\n\n\n      return leftSource.value == rightSource.value;\n    } else {\n      var _map3 = [left, right].map(function (v) {\n        return convertArg(v, conv, config, meta, _objectSpread(_objectSpread({}, spel), {}, {\n          _groupField: parentSpel === null || parentSpel === void 0 ? void 0 : parentSpel._groupField\n        }));\n      }),\n          _map4 = _slicedToArray(_map3, 2),\n          leftVal = _map4[0],\n          rightVal = _map4[1];\n\n      return leftVal.value == rightVal.value;\n    }\n  }\n\n  return false;\n};\n\nvar convertToTree = function convertToTree(spel, conv, config, meta) {\n  var parentSpel = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  if (!spel) return undefined;\n  var res;\n\n  if (spel.type.indexOf(\"op-\") == 0) {\n    var op = spel.type.slice(\"op-\".length); // unary\n\n    var isUnary = (op == \"minus\" || op == \"plus\") && spel.children.length == 1;\n\n    if (isUnary) {\n      spel.isUnary = true;\n      return convertToTree(spel.children[0], conv, config, meta, spel);\n    } // between\n\n\n    var isBetweenNormal = op == \"and\" && spel.children.length == 2 && spel.children[0].type == \"op-ge\" && spel.children[1].type == \"op-le\";\n    var isBetweenRev = op == \"or\" && spel.children.length == 2 && spel.children[0].type == \"op-lt\" && spel.children[1].type == \"op-gt\";\n    var isBetween = isBetweenNormal || isBetweenRev;\n\n    if (isBetween) {\n      var _spel$children$0$chil = _slicedToArray(spel.children[0].children, 2),\n          left = _spel$children$0$chil[0],\n          from = _spel$children$0$chil[1];\n\n      var _spel$children$1$chil = _slicedToArray(spel.children[1].children, 2),\n          right = _spel$children$1$chil[0],\n          to = _spel$children$1$chil[1];\n\n      var isNumbers = from.type == \"number\" && to.type == \"number\";\n      var isSameSource = compareArgs(left, right, spel, conv, config, meta, parentSpel);\n\n      if (isNumbers && isSameSource) {\n        var _fromValue = from.val;\n        var _toValue = to.val;\n        var oneSpel = {\n          type: \"op-between\",\n          children: [left, from, to]\n        };\n        return convertToTree(oneSpel, conv, config, meta, parentSpel);\n      }\n    } // find op\n\n\n    var opKeys = conv.operators[op]; // todo: make dynamic, use basic config\n\n    if (op == \"eq\" && spel.children[1].type == \"null\") {\n      opKeys = [\"is_null\"];\n    } else if (op == \"ne\" && spel.children[1].type == \"null\") {\n      opKeys = [\"is_not_null\"];\n    } else if (op == \"le\" && spel.children[1].type == \"string\" && spel.children[1].val == \"\") {\n      opKeys = [\"is_empty\"];\n    } else if (op == \"gt\" && spel.children[1].type == \"string\" && spel.children[1].val == \"\") {\n      opKeys = [\"is_not_empty\"];\n    } else if (op == \"between\") {\n      opKeys = [\"between\"];\n    } // convert children\n\n\n    var convertChildren = function convertChildren() {\n      return spel.children.map(function (child) {\n        return convertToTree(child, conv, config, meta, _objectSpread(_objectSpread({}, spel), {}, {\n          _groupField: parentSpel === null || parentSpel === void 0 ? void 0 : parentSpel._groupField\n        }));\n      });\n    };\n\n    if (op == \"and\" || op == \"or\") {\n      var children1 = {};\n      var vals = convertChildren();\n      vals.forEach(function (v) {\n        if (v) {\n          var id = uuid();\n          v.id = id;\n\n          if (v.type != undefined) {\n            children1[id] = v;\n          } else {\n            meta.errors.push(\"Bad item in AND/OR: \".concat(JSON.stringify(v)));\n          }\n        }\n      });\n      res = {\n        type: \"group\",\n        id: uuid(),\n        children1: children1,\n        properties: {\n          conjunction: conv.conjunctions[op],\n          not: spel.not\n        }\n      };\n    } else if (opKeys) {\n      var _fieldObj$groupFieldV, _convertedArgs;\n\n      var _vals = convertChildren();\n\n      var fieldObj = _vals[0];\n\n      var convertedArgs = _vals.slice(1);\n\n      var groupField = fieldObj === null || fieldObj === void 0 ? void 0 : (_fieldObj$groupFieldV = fieldObj.groupFieldValue) === null || _fieldObj$groupFieldV === void 0 ? void 0 : _fieldObj$groupFieldV.value;\n      var opArg = (_convertedArgs = convertedArgs) === null || _convertedArgs === void 0 ? void 0 : _convertedArgs[0];\n      var opKey = opKeys[0];\n\n      if (opKeys.length > 1) {\n        logger.warn(\"[spel] Spel operator \".concat(op, \" can be mapped to \").concat(opKeys)); //todo: it's naive\n\n        var field = fieldObj === null || fieldObj === void 0 ? void 0 : fieldObj.value;\n        var widgets = opKeys.map(function (op) {\n          return {\n            op: op,\n            widget: getWidgetForFieldOp(config, field, op)\n          };\n        });\n\n        if (op == \"eq\" || op == \"ne\") {\n          var ws = widgets.find(function (_ref2) {\n            var op = _ref2.op,\n                widget = _ref2.widget;\n            return widget && widget != \"field\";\n          });\n\n          if (ws) {\n            opKey = ws.op;\n          }\n        }\n      } // some/all/none\n\n\n      if (fieldObj !== null && fieldObj !== void 0 && fieldObj.groupFieldValue) {\n        if (opArg && opArg.groupFieldValue && opArg.groupFieldValue.valueSrc == \"field\" && opArg.groupFieldValue.value == groupField) {\n          // group.?[...].size() == group.size()\n          opKey = \"all\";\n          convertedArgs = [];\n        } else if (opKey == \"equal\" && opArg.valueSrc == \"value\" && opArg.valueType == \"number\" && opArg.value == 0) {\n          opKey = \"none\";\n          convertedArgs = [];\n        } else if (opKey == \"greater\" && opArg.valueSrc == \"value\" && opArg.valueType == \"number\" && opArg.value == 0) {\n          opKey = \"some\";\n          convertedArgs = [];\n        }\n      }\n\n      var canRev = true;\n      var needWrapReverse = false;\n\n      if (spel.not && canRev) {\n        var opConfig = config.operators[opKey];\n\n        if (opConfig.reversedOp) {\n          opKey = opConfig.reversedOp;\n          spel.not = false;\n        } else {\n          needWrapReverse = true;\n        }\n      }\n\n      if (!fieldObj) {// LHS can't be parsed\n      } else if (fieldObj.groupFieldValue) {\n        // 1. group\n        if (fieldObj.groupFieldValue.valueSrc != \"field\") {\n          meta.errors.push(\"Expected group field \".concat(JSON.stringify(fieldObj)));\n        }\n\n        res = buildRuleGroup(fieldObj, opKey, convertedArgs, config, meta);\n      } else {\n        // 2. not group\n        if (fieldObj.valueSrc != \"field\") {\n          meta.errors.push(\"Expected field \".concat(JSON.stringify(fieldObj)));\n        }\n\n        var _field5 = fieldObj.value;\n        res = buildRule(config, meta, _field5, opKey, convertedArgs);\n      }\n\n      if (needWrapReverse) {\n        if (res.type !== \"group\") {\n          res = wrapInDefaultConj(res, config, spel.not);\n        } else {\n          res.properties.not = !res.properties.not;\n        }\n      }\n    } else {\n      if (!parentSpel) {\n        // try to parse whole `\"str\" + prop + #var` as ternary\n        res = buildSimpleSwitch(spel, conv, config, meta);\n      }\n\n      if (!res) {\n        meta.errors.push(\"Can't convert op \".concat(op));\n      }\n    }\n  } else if (spel.type == \"!aggr\") {\n    var _groupFilter;\n\n    var groupFieldValue = convertToTree(spel.source, conv, config, meta, _objectSpread(_objectSpread({}, spel), {}, {\n      _groupField: parentSpel === null || parentSpel === void 0 ? void 0 : parentSpel._groupField\n    }));\n    var groupFilter = convertToTree(spel.filter, conv, config, meta, _objectSpread(_objectSpread({}, spel), {}, {\n      _groupField: groupFieldValue === null || groupFieldValue === void 0 ? void 0 : groupFieldValue.value\n    }));\n\n    if (((_groupFilter = groupFilter) === null || _groupFilter === void 0 ? void 0 : _groupFilter.type) == \"rule\") {\n      groupFilter = wrapInDefaultConj(groupFilter, config, spel.filter.not);\n    }\n\n    res = {\n      groupFilter: groupFilter,\n      groupFieldValue: groupFieldValue\n    };\n\n    if (!parentSpel) {\n      // !aggr can't be in root, it should be compared with something\n      res = undefined;\n      meta.errors.push(\"Unexpected !aggr in root\");\n    }\n  } else if (spel.type == \"ternary\") {\n    var _children = {};\n    spel.val.forEach(function (v) {\n      var _v = _slicedToArray(v, 2),\n          cond = _v[0],\n          val = _v[1];\n\n      var caseI = buildCase(cond, val, conv, config, meta, spel);\n\n      if (caseI) {\n        _children[caseI.id] = caseI;\n      }\n    });\n    res = {\n      type: \"switch_group\",\n      id: uuid(),\n      children1: _children,\n      properties: {}\n    };\n  } else {\n    res = convertArg(spel, conv, config, meta, parentSpel);\n\n    if (res && !res.type && !parentSpel) {\n      // try to parse whole `\"1\"` as ternary\n      var sw = buildSimpleSwitch(spel, conv, config, meta);\n\n      if (sw) {\n        res = sw;\n      } else {\n        res = undefined;\n        meta.errors.push(\"Can't convert rule of type \".concat(spel.type, \", it looks like var/literal\"));\n      }\n    } else {// res is a rule\n    }\n  }\n\n  return res;\n};\n\nvar buildSimpleSwitch = function buildSimpleSwitch(val, conv, config, meta) {\n  var children1 = {};\n  var cond = null;\n  var caseI = buildCase(cond, val, conv, config, meta);\n\n  if (caseI) {\n    children1[caseI.id] = caseI;\n  }\n\n  var res = {\n    type: \"switch_group\",\n    id: uuid(),\n    children1: children1,\n    properties: {}\n  };\n  return res;\n};\n\nvar buildCase = function buildCase(cond, val, conv, config, meta) {\n  var spel = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n  var valProperties = buildCaseValProperties(config, meta, conv, val, spel);\n  var caseI;\n\n  if (cond) {\n    caseI = convertToTree(cond, conv, config, meta, spel);\n\n    if (caseI && caseI.type) {\n      if (caseI.type != \"group\") {\n        caseI = wrapInDefaultConj(caseI, config);\n      }\n\n      caseI.type = \"case_group\";\n    } else {\n      meta.errors.push(\"Unexpected case: \".concat(JSON.stringify(caseI)));\n      caseI = undefined;\n    }\n  } else {\n    caseI = {\n      id: uuid(),\n      type: \"case_group\",\n      properties: {}\n    };\n  }\n\n  if (caseI) {\n    caseI.properties = _objectSpread(_objectSpread({}, caseI.properties), valProperties);\n  }\n\n  return caseI;\n};\n\nvar buildCaseValueConcat = function buildCaseValueConcat(spel, conv, config, meta) {\n  var flat = [];\n\n  function _processConcatChildren(children) {\n    children.map(function (child) {\n      if (child.type == \"op-plus\") {\n        _processConcatChildren(child.children);\n      } else {\n        var convertedChild = convertArg(child, conv, config, meta, spel);\n\n        if (convertedChild) {\n          flat.push(convertedChild);\n        } else {\n          meta.errors.push(\"Can't convert \".concat(child.type, \" in concatenation\"));\n        }\n      }\n    });\n  }\n\n  _processConcatChildren(spel.children);\n\n  return {\n    valueSrc: \"value\",\n    valueType: \"case_value\",\n    value: flat\n  };\n};\n\nvar buildCaseValProperties = function buildCaseValProperties(config, meta, conv, val) {\n  var spel = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  var valProperties = {};\n  var convVal;\n\n  if ((val === null || val === void 0 ? void 0 : val.type) == \"op-plus\") {\n    convVal = buildCaseValueConcat(val, conv, config, meta);\n  } else {\n    convVal = convertArg(val, conv, config, meta, spel);\n  }\n\n  var widgetDef = config.widgets[\"case_value\"];\n  var importCaseValue = widgetDef === null || widgetDef === void 0 ? void 0 : widgetDef.spelImportValue;\n\n  if (importCaseValue) {\n    var _importCaseValue = importCaseValue(convVal),\n        _importCaseValue2 = _slicedToArray(_importCaseValue, 2),\n        normVal = _importCaseValue2[0],\n        normErrors = _importCaseValue2[1];\n\n    normErrors.map(function (e) {\n      return meta.errors.push(e);\n    });\n\n    if (normVal) {\n      valProperties = {\n        value: [normVal],\n        valueSrc: [\"value\"],\n        valueType: [\"case_value\"]\n      };\n    }\n  } else {\n    meta.errors.push(\"No fucntion to import case value\");\n  }\n\n  return valProperties;\n};\n\nvar wrapInDefaultConjRuleGroup = function wrapInDefaultConjRuleGroup(rule, parentField, parentFieldConfig, config, conj) {\n  if (!rule) return undefined;\n  return {\n    type: \"rule_group\",\n    id: uuid(),\n    children1: _defineProperty({}, rule.id, rule),\n    properties: {\n      conjunction: conj || defaultGroupConjunction(config, parentFieldConfig),\n      not: false,\n      field: parentField\n    }\n  };\n};\n\nvar wrapInDefaultConj = function wrapInDefaultConj(rule, config) {\n  var not = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  return {\n    type: \"group\",\n    id: uuid(),\n    children1: _defineProperty({}, rule.id, rule),\n    properties: {\n      conjunction: defaultConjunction(config),\n      not: not || false\n    }\n  };\n};","map":{"version":3,"sources":["E:/WorkingFolder/React_Postgres/ALPD/SOURCE-512/QuaLISWeb/node_modules/@react-awesome-query-builder/core/esm/import/spel.js"],"names":["_slicedToArray","_typeof","_defineProperty","_toConsumableArray","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","SpelExpressionEvaluator","uuid","getFieldConfig","extendConfig","normalizeField","getWidgetForFieldOp","loadTree","defaultConjunction","defaultGroupConjunction","logger","moment","loadFromSpel","logicTree","config","_loadFromSpel","spelStr","returnErrors","undefined","meta","errors","extendedConfig","conv","buildConv","compiledExpression","convertedObj","jsTree","compileRes","compile","_compiledExpression","e","debug","convertCompiled","convertToTree","type","wrapInDefaultConj","immTree","console","warn","expr","parentExpr","getType","children","getChildren","map","child","reduce","acc","canFlatize","not","flat","concat","isListFix","val","selection","find","lastChild","isSize","methodName","isLength","sourceParts","isThis","isRoot","itype","obj","args","_obj","getRaw","getValue","error","flatizeTernary","functionName","item","qid","cls","JSON","stringify","_qid","_cls","_args","_val","_args2","isVar","_processTernaryChildren","tern","_tern","cond","if_val","else_val","operators","_loop","opKey","opConfig","spelOps","spelOp","opk","log","conjunctions","conjKey","conjunctionDefinition","ck","spelConj","toLowerCase","funcs","funcKey","funcConfig","fk","spelFunc","convertPath","parts","isError","res","c","convertArg","spel","parentSpel","fieldSeparator","settings","literalTypes","number","string","groupFieldParts","_groupField","_spel$children","_spel$children$","fullParts","isVariable","valueSrc","value","join","_fullParts","_isVariable","valueType","isUnary","_values$","values","v","_itemType","_value","_valueType","_funcToOpMap","funcToOpMap","convertedArgs","field","list","buildRule","_opKey","_field","_args3","slice","_opKey2","_parts","_fullParts2","_field2","at","_args4","dateFormat","dateString","_valueType2","includes","_field3","widget","fieldConfig","widgetConfig","widgets","mainWidget","valueFormat","dateVal","ISO_8601","_value2","isValid","format","timeString","_valueType3","_field4","_widget","_fieldConfig","_widgetConfig","_valueFormat","_dateVal","_value3","buildCaseValueConcat","canRev","needWrapReverse","reversedOp","asyncListValuesArr","asyncListValues","id","properties","operator","buildRuleGroup","_ref","groupFilter","groupFieldValue","groupField","groupOpRule","mode","compareArgs","left","right","_map","_map2","leftSource","rightSource","_map3","_map4","leftVal","rightVal","indexOf","op","isBetweenNormal","isBetweenRev","isBetween","_spel$children$0$chil","from","_spel$children$1$chil","to","isNumbers","isSameSource","_fromValue","_toValue","oneSpel","opKeys","convertChildren","children1","vals","conjunction","_fieldObj$groupFieldV","_convertedArgs","_vals","fieldObj","opArg","ws","_ref2","_field5","buildSimpleSwitch","_groupFilter","_children","_v","caseI","buildCase","sw","valProperties","buildCaseValProperties","_processConcatChildren","convertedChild","convVal","widgetDef","importCaseValue","spelImportValue","_importCaseValue","_importCaseValue2","normVal","normErrors","wrapInDefaultConjRuleGroup","rule","parentField","parentFieldConfig","conj"],"mappings":"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","sourcesContent":["import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _typeof from \"@babel/runtime/helpers/typeof\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nimport { SpelExpressionEvaluator } from \"spel2js\";\nimport uuid from \"../utils/uuid\";\nimport { getFieldConfig, extendConfig, normalizeField } from \"../utils/configUtils\";\nimport { getWidgetForFieldOp } from \"../utils/ruleUtils\";\nimport { loadTree } from \"./tree\";\nimport { defaultConjunction, defaultGroupConjunction } from \"../utils/defaultUtils\";\nimport { logger } from \"../utils/stuff\";\nimport moment from \"moment\";\nexport var loadFromSpel = function loadFromSpel(logicTree, config) {\n  return _loadFromSpel(logicTree, config, true);\n};\nexport var _loadFromSpel = function _loadFromSpel(spelStr, config) {\n  var returnErrors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  //meta is mutable\n  var meta = {\n    errors: []\n  };\n  var extendedConfig = extendConfig(config);\n  var conv = buildConv(extendedConfig);\n  var compiledExpression;\n  var convertedObj;\n  var jsTree = undefined;\n  try {\n    var compileRes = SpelExpressionEvaluator.compile(spelStr);\n    compiledExpression = compileRes._compiledExpression;\n  } catch (e) {\n    meta.errors.push(e);\n  }\n  if (compiledExpression) {\n    logger.debug(\"compiledExpression:\", compiledExpression);\n    convertedObj = convertCompiled(compiledExpression, meta);\n    logger.debug(\"convertedObj:\", convertedObj, meta);\n    jsTree = convertToTree(convertedObj, conv, extendedConfig, meta);\n    if (jsTree && jsTree.type != \"group\" && jsTree.type != \"switch_group\") {\n      jsTree = wrapInDefaultConj(jsTree, extendedConfig, convertedObj[\"not\"]);\n    }\n    logger.debug(\"jsTree:\", jsTree);\n  }\n  var immTree = jsTree ? loadTree(jsTree) : undefined;\n  if (returnErrors) {\n    return [immTree, meta.errors];\n  } else {\n    if (meta.errors.length) console.warn(\"Errors while importing from SpEL:\", meta.errors);\n    return immTree;\n  }\n};\nvar convertCompiled = function convertCompiled(expr, meta) {\n  var parentExpr = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var type = expr.getType();\n  var children = expr.getChildren().map(function (child) {\n    return convertCompiled(child, meta, expr);\n  });\n\n  // flatize OR/AND\n  if (type == \"op-or\" || type == \"op-and\") {\n    children = children.reduce(function (acc, child) {\n      var canFlatize = child.type == type && !child.not;\n      var flat = canFlatize ? child.children : [child];\n      return [].concat(_toConsumableArray(acc), _toConsumableArray(flat));\n    }, []);\n  }\n\n  // unwrap NOT\n  if (type == \"op-not\") {\n    if (children.length != 1) {\n      meta.errors.push(\"Operator NOT should have 1 child, but got \".concat(children.length, \"}\"));\n    }\n    return _objectSpread(_objectSpread({}, children[0]), {}, {\n      not: !(children[0].not || false)\n    });\n  }\n  if (type == \"compound\") {\n    // remove `.?[true]`\n    children = children.filter(function (child) {\n      var isListFix = child.type == \"selection\" && child.children.length == 1 && child.children[0].type == \"boolean\" && child.children[0].val == true;\n      return !isListFix;\n    });\n    // aggregation\n    // eg. `results.?[product == 'abc'].length`\n    var selection = children.find(function (child) {\n      return child.type == \"selection\";\n    });\n    if (selection && selection.children.length != 1) {\n      meta.errors.push(\"Selection should have 1 child, but got \".concat(selection.children.length));\n    }\n    var filter = selection ? selection.children[0] : null;\n    var lastChild = children[children.length - 1];\n    var isSize = lastChild.type == \"method\" && lastChild.val.methodName == \"size\" || lastChild.type == \"!func\" && lastChild.methodName == \"size\";\n    var isLength = lastChild.type == \"property\" && lastChild.val == \"length\";\n    var sourceParts = children.filter(function (child) {\n      return child !== selection && child !== lastChild;\n    });\n    var source = {\n      type: \"compound\",\n      children: sourceParts\n    };\n    if (isSize || isLength) {\n      return {\n        type: \"!aggr\",\n        filter: filter,\n        source: source\n      };\n    }\n    // remove `#this`, `#root`\n    children = children.filter(function (child) {\n      var isThis = child.type == \"variable\" && child.val == \"this\";\n      var isRoot = child.type == \"variable\" && child.val == \"root\";\n      return !(isThis || isRoot);\n    });\n    // indexer\n    children = children.map(function (child) {\n      if (child.type == \"indexer\" && child.children.length == 1) {\n        return {\n          type: \"indexer\",\n          val: child.children[0].val,\n          itype: child.children[0].type\n        };\n      } else {\n        return child;\n      }\n    });\n    // method\n    if (lastChild.type == \"method\") {\n      var obj = children.filter(function (child) {\n        return child !== lastChild;\n      });\n      return {\n        type: \"!func\",\n        obj: obj,\n        methodName: lastChild.val.methodName,\n        args: lastChild.val.args\n      };\n    }\n    // !func\n    if (lastChild.type == \"!func\") {\n      var _obj = children.filter(function (child) {\n        return child !== lastChild;\n      });\n      return _objectSpread(_objectSpread({}, lastChild), {}, {\n        obj: _obj\n      });\n    }\n  }\n\n  // getRaw || getValue\n  var val;\n  try {\n    if (expr.getRaw) {\n      // use my fork\n      val = expr.getRaw();\n    } else if (expr.getValue.length == 0) {\n      // getValue not requires context arg -> can use\n      val = expr.getValue();\n    }\n  } catch (e) {\n    logger.error(\"[spel2js] Error in getValue()\", e);\n  }\n\n  // ternary\n  if (type == \"ternary\") {\n    val = flatizeTernary(children);\n  }\n\n  // convert method/function args\n  if (_typeof(val) === \"object\" && val !== null) {\n    if (val.methodName || val.functionName) {\n      val.args = val.args.map(function (child) {\n        return convertCompiled(child, meta, expr);\n      });\n    }\n  }\n  // convert list\n  if (type == \"list\") {\n    val = val.map(function (item) {\n      return convertCompiled(item, meta, expr);\n    });\n\n    // fix whole expression wrapped in `{}`\n    if (!parentExpr && val.length == 1) {\n      return val[0];\n    }\n  }\n  // convert constructor\n  if (type == \"constructorref\") {\n    var qid = children.find(function (child) {\n      return child.type == \"qualifiedidentifier\";\n    });\n    var cls = qid === null || qid === void 0 ? void 0 : qid.val;\n    if (!cls) {\n      meta.errors.push(\"Can't find qualifiedidentifier in constructorref children: \".concat(JSON.stringify(children)));\n      return undefined;\n    }\n    var args = children.filter(function (child) {\n      return child.type != \"qualifiedidentifier\";\n    });\n    return {\n      type: \"!new\",\n      cls: cls,\n      args: args\n    };\n  }\n  // convert type\n  if (type == \"typeref\") {\n    var _qid = children.find(function (child) {\n      return child.type == \"qualifiedidentifier\";\n    });\n    var _cls = _qid === null || _qid === void 0 ? void 0 : _qid.val;\n    if (!_cls) {\n      meta.errors.push(\"Can't find qualifiedidentifier in typeref children: \".concat(JSON.stringify(children)));\n      return undefined;\n    }\n    var _args = children.filter(function (child) {\n      return child.type != \"qualifiedidentifier\";\n    });\n    return {\n      type: \"!type\",\n      cls: _cls\n    };\n  }\n  // convert function/method\n  if (type == \"function\" || type == \"method\") {\n    // `foo()` is method, `#foo()` is function\n    // let's use common property `methodName` and just add `isVar` for function\n    var _val = val,\n      functionName = _val.functionName,\n      methodName = _val.methodName,\n      _args2 = _val.args;\n    return {\n      type: \"!func\",\n      methodName: functionName || methodName,\n      isVar: type == \"function\",\n      args: _args2\n    };\n  }\n  return {\n    type: type,\n    children: children,\n    val: val\n  };\n};\nvar flatizeTernary = function flatizeTernary(children) {\n  var flat = [];\n  function _processTernaryChildren(tern) {\n    var _tern = _slicedToArray(tern, 3),\n      cond = _tern[0],\n      if_val = _tern[1],\n      else_val = _tern[2];\n    flat.push([cond, if_val]);\n    if ((else_val === null || else_val === void 0 ? void 0 : else_val.type) == \"ternary\") {\n      _processTernaryChildren(else_val.children);\n    } else {\n      flat.push([undefined, else_val]);\n    }\n  }\n  _processTernaryChildren(children);\n  return flat;\n};\nvar buildConv = function buildConv(config) {\n  var operators = {};\n  var _loop = function _loop(opKey) {\n    var opConfig = config.operators[opKey];\n    if (opConfig.spelOps) {\n      // examples: \"==\", \"eq\", \".contains\", \"matches\" (can be used for starts_with, ends_with)\n      opConfig.spelOps.forEach(function (spelOp) {\n        var opk = spelOp; // + \"/\" + defaultValue(opConfig.cardinality, 1);\n        if (!operators[opk]) operators[opk] = [];\n        operators[opk].push(opKey);\n      });\n    } else if (opConfig.spelOp) {\n      var opk = opConfig.spelOp; // + \"/\" + defaultValue(opConfig.cardinality, 1);\n      if (!operators[opk]) operators[opk] = [];\n      operators[opk].push(opKey);\n    } else {\n      logger.log(\"[spel] No spelOp for operator \".concat(opKey));\n    }\n  };\n  for (var opKey in config.operators) {\n    _loop(opKey);\n  }\n  var conjunctions = {};\n  for (var conjKey in config.conjunctions) {\n    var conjunctionDefinition = config.conjunctions[conjKey];\n    var ck = conjunctionDefinition.spelConj || conjKey.toLowerCase();\n    conjunctions[ck] = conjKey;\n  }\n  var funcs = {};\n  for (var funcKey in config.funcs) {\n    var funcConfig = config.funcs[funcKey];\n    var fk = void 0;\n    if (typeof funcConfig.spelFunc == \"string\") {\n      fk = funcConfig.spelFunc;\n    }\n    if (fk) {\n      if (!funcs[fk]) funcs[fk] = [];\n      funcs[fk].push(funcKey);\n    }\n  }\n  return {\n    operators: operators,\n    conjunctions: conjunctions,\n    funcs: funcs\n  };\n};\nvar convertPath = function convertPath(parts, meta) {\n  var isError = false;\n  var res = parts.map(function (c) {\n    if (c.type == \"variable\" || c.type == \"property\" || c.type == \"indexer\" && c.itype == \"string\") {\n      return c.val;\n    } else {\n      isError = true;\n      meta.errors.push(\"Unexpected item in compound: \".concat(JSON.stringify(c)));\n    }\n  });\n  return !isError ? res : undefined;\n};\nvar convertArg = function convertArg(spel, conv, config, meta, parentSpel) {\n  if (spel == undefined) return undefined;\n  var fieldSeparator = config.settings.fieldSeparator;\n  var literalTypes = {\n    number: \"number\",\n    string: \"text\",\n    \"boolean\": \"boolean\",\n    \"null\": \"null\" // should not be\n  };\n\n  var groupFieldParts = parentSpel !== null && parentSpel !== void 0 && parentSpel._groupField ? [parentSpel === null || parentSpel === void 0 ? void 0 : parentSpel._groupField] : [];\n  if (spel.type == \"compound\") {\n    var _spel$children, _spel$children$;\n    // complex field\n    var parts = convertPath(spel.children, meta);\n    if (!parts) {\n      return undefined;\n    }\n    var fullParts = [].concat(groupFieldParts, _toConsumableArray(parts));\n    var isVariable = ((_spel$children = spel.children) === null || _spel$children === void 0 ? void 0 : (_spel$children$ = _spel$children[0]) === null || _spel$children$ === void 0 ? void 0 : _spel$children$.type) == \"variable\";\n    return {\n      valueSrc: \"field\",\n      //valueType: todo\n      isVariable: isVariable,\n      value: fullParts.join(fieldSeparator)\n    };\n  } else if (spel.type == \"variable\" || spel.type == \"property\") {\n    // normal field\n    var _fullParts = [].concat(groupFieldParts, [spel.val]);\n    var _isVariable = spel.type == \"variable\";\n    return {\n      valueSrc: \"field\",\n      //valueType: todo\n      isVariable: _isVariable,\n      value: _fullParts.join(fieldSeparator)\n    };\n  } else if (literalTypes[spel.type]) {\n    var value = spel.val;\n    var valueType = literalTypes[spel.type];\n    if (parentSpel !== null && parentSpel !== void 0 && parentSpel.isUnary) {\n      value = -value;\n    }\n    return {\n      valueSrc: \"value\",\n      valueType: valueType,\n      value: value\n    };\n  } else if (spel.type == \"list\") {\n    var _values$;\n    var values = spel.val.map(function (v) {\n      return convertArg(v, conv, config, meta, spel);\n    });\n    var _itemType = values.length ? (_values$ = values[0]) === null || _values$ === void 0 ? void 0 : _values$.valueType : null;\n    var _value = values.map(function (v) {\n      return v === null || v === void 0 ? void 0 : v.value;\n    });\n    var _valueType = \"multiselect\";\n    return {\n      valueSrc: \"value\",\n      valueType: _valueType,\n      value: _value\n    };\n  } else if (spel.type == \"!func\") {\n    var _funcToOpMap;\n    var obj = spel.obj,\n      methodName = spel.methodName,\n      args = spel.args,\n      isVar = spel.isVar;\n\n    // todo: get from conv\n    var funcToOpMap = (_funcToOpMap = {}, _defineProperty(_funcToOpMap, \".contains\", \"like\"), _defineProperty(_funcToOpMap, \".startsWith\", \"starts_with\"), _defineProperty(_funcToOpMap, \".endsWith\", \"ends_with\"), _defineProperty(_funcToOpMap, \"$contains\", \"select_any_in\"), _defineProperty(_funcToOpMap, \".equals\", \"multiselect_equals\"), _defineProperty(_funcToOpMap, \"CollectionUtils.containsAny()\", \"multiselect_contains\"), _funcToOpMap);\n    var convertedArgs = args.map(function (v) {\n      return convertArg(v, conv, config, meta, _objectSpread(_objectSpread({}, spel), {}, {\n        _groupField: parentSpel === null || parentSpel === void 0 ? void 0 : parentSpel._groupField\n      }));\n    });\n\n    //todo: make dynamic: use funcToOpMap and check obj type in basic config\n    if (methodName == \"contains\" && obj && obj[0].type == \"list\") {\n      var convertedObj = obj.map(function (v) {\n        return convertArg(v, conv, config, meta, spel);\n      });\n      // {'yellow', 'green'}.?[true].contains(color)\n      if (!(convertedArgs.length == 1 && convertedArgs[0].valueSrc == \"field\")) {\n        meta.errors.push(\"Expected arg to method \".concat(methodName, \" to be field but got: \").concat(JSON.stringify(convertedArgs)));\n        return undefined;\n      }\n      var field = convertedArgs[0].value;\n      if (!(convertedObj.length == 1 && convertedObj[0].valueType == \"multiselect\")) {\n        meta.errors.push(\"Expected object of method \".concat(methodName, \" to be inline list but got: \").concat(JSON.stringify(convertedObj)));\n        return undefined;\n      }\n      var opKey = funcToOpMap[\"$\" + methodName];\n      var list = convertedObj[0];\n      return buildRule(config, meta, field, opKey, [list], spel);\n    } else if (obj && obj[0].type == \"property\" && funcToOpMap[obj[0].val + \".\" + methodName + \"()\"]) {\n      // CollectionUtils.containsAny(multicolor, {'yellow', 'green'})\n      var _opKey = funcToOpMap[obj[0].val + \".\" + methodName + \"()\"];\n      var _field = convertedArgs[0].value;\n      var _args3 = convertedArgs.slice(1);\n      return buildRule(config, meta, _field, _opKey, _args3, spel);\n    } else if (funcToOpMap[\".\" + methodName]) {\n      // user.login.startsWith('gg')\n      var _opKey2 = funcToOpMap[\".\" + methodName];\n      var _parts = convertPath(obj, meta);\n      if (_parts && convertedArgs.length == 1) {\n        var _fullParts2 = [].concat(groupFieldParts, _toConsumableArray(_parts));\n        var _field2 = _fullParts2.join(fieldSeparator);\n        return buildRule(config, meta, _field2, _opKey2, convertedArgs, spel);\n      }\n    } else if (methodName == \"parse\" && obj && obj[0].type == \"!new\" && obj[0].cls.at(-1) == \"SimpleDateFormat\") {\n      // new java.text.SimpleDateFormat('yyyy-MM-dd').parse('2022-01-15')\n      var _args4 = obj[0].args.map(function (v) {\n        return convertArg(v, conv, config, meta, _objectSpread(_objectSpread({}, spel), {}, {\n          _groupField: parentSpel === null || parentSpel === void 0 ? void 0 : parentSpel._groupField\n        }));\n      });\n      if (!(_args4.length == 1 && _args4[0].valueType == \"text\")) {\n        meta.errors.push(\"Expected args of \".concat(obj[0].cls.join(\".\"), \".\").concat(methodName, \" to be 1 string but got: \").concat(JSON.stringify(_args4)));\n        return undefined;\n      }\n      if (!(convertedArgs.length == 1 && convertedArgs[0].valueType == \"text\")) {\n        meta.errors.push(\"Expected args of \".concat(obj[0].cls.join(\".\"), \" to be 1 string but got: \").concat(JSON.stringify(convertedArgs)));\n        return undefined;\n      }\n      var dateFormat = _args4[0].value;\n      var dateString = convertedArgs[0].value;\n      var _valueType2 = dateFormat.includes(\" \") ? \"datetime\" : \"date\";\n      var _field3 = null; // todo\n      var widget = _valueType2;\n      var fieldConfig = getFieldConfig(config, _field3);\n      var widgetConfig = config.widgets[widget || (fieldConfig === null || fieldConfig === void 0 ? void 0 : fieldConfig.mainWidget)];\n      var valueFormat = widgetConfig.valueFormat;\n      var dateVal = moment(dateString, moment.ISO_8601);\n      var _value2 = dateVal.isValid() ? dateVal.format(valueFormat) : undefined;\n      return {\n        valueSrc: \"value\",\n        valueType: _valueType2,\n        value: _value2\n      };\n    } else if (methodName == \"parse\" && obj && obj[0].type == \"!type\" && obj[0].cls.at(-1) == \"LocalTime\") {\n      // time == T(java.time.LocalTime).parse('02:03:00')\n      if (!(convertedArgs.length == 1 && convertedArgs[0].valueType == \"text\")) {\n        meta.errors.push(\"Expected args of \".concat(obj[0].cls.join(\".\"), \" to be 1 string but got: \").concat(JSON.stringify(convertedArgs)));\n        return undefined;\n      }\n      var timeString = convertedArgs[0].value;\n      var _valueType3 = \"time\";\n      var _field4 = null; // todo\n      var _widget = _valueType3;\n      var _fieldConfig = getFieldConfig(config, _field4);\n      var _widgetConfig = config.widgets[_widget || (_fieldConfig === null || _fieldConfig === void 0 ? void 0 : _fieldConfig.mainWidget)];\n      var _valueFormat = _widgetConfig.valueFormat;\n      var _dateVal = moment(timeString, \"HH:mm:ss\");\n      var _value3 = _dateVal.isValid() ? _dateVal.format(_valueFormat) : undefined;\n      return {\n        valueSrc: \"value\",\n        valueType: _valueType3,\n        value: _value3\n      };\n    } else {\n      // todo: conv.funcs\n      meta.errors.push(\"Unsupported method \".concat(methodName));\n    }\n  } else if (spel.type == \"op-plus\" && (parentSpel === null || parentSpel === void 0 ? void 0 : parentSpel.type) == \"ternary\") {\n    return buildCaseValueConcat(spel, conv, config, meta);\n  } else {\n    meta.errors.push(\"Can't convert arg of type \".concat(spel.type));\n  }\n  return undefined;\n};\nvar buildRule = function buildRule(config, meta, field, opKey, convertedArgs, spel) {\n  if (convertedArgs.filter(function (v) {\n    return v === undefined;\n  }).length) {\n    return undefined;\n  }\n  var fieldConfig = getFieldConfig(config, field);\n  if (!fieldConfig) {\n    meta.errors.push(\"No config for field \".concat(field));\n    return undefined;\n  }\n  var canRev = true;\n  var needWrapReverse = false;\n  if (spel !== null && spel !== void 0 && spel.not && canRev) {\n    var opConfig = config.operators[opKey];\n    if (opConfig.reversedOp) {\n      opKey = opConfig.reversedOp;\n      spel.not = false;\n    } else {\n      needWrapReverse = true;\n    }\n  }\n  var widget = getWidgetForFieldOp(config, field, opKey);\n  var widgetConfig = config.widgets[widget || fieldConfig.mainWidget];\n  var asyncListValuesArr = convertedArgs.map(function (v) {\n    return v.asyncListValues;\n  }).filter(function (v) {\n    return v != undefined;\n  });\n  var asyncListValues = asyncListValuesArr.length ? asyncListValuesArr[0] : undefined;\n  var res = {\n    type: \"rule\",\n    id: uuid(),\n    properties: {\n      field: field,\n      operator: opKey,\n      value: convertedArgs.map(function (v) {\n        return v.value;\n      }),\n      valueSrc: convertedArgs.map(function (v) {\n        return v.valueSrc;\n      }),\n      valueType: convertedArgs.map(function (v) {\n        if (v.valueSrc == \"value\") {\n          return (widgetConfig === null || widgetConfig === void 0 ? void 0 : widgetConfig.type) || (fieldConfig === null || fieldConfig === void 0 ? void 0 : fieldConfig.type) || v.valueType;\n        }\n        return v.valueType;\n      }),\n      asyncListValues: asyncListValues\n    }\n  };\n  if (needWrapReverse) {\n    res = wrapInDefaultConj(res, config, spel === null || spel === void 0 ? void 0 : spel.not);\n    if (spel !== null && spel !== void 0 && spel.not) {\n      spel.not = false;\n    }\n  }\n  return res;\n};\nvar buildRuleGroup = function buildRuleGroup(_ref, opKey, convertedArgs, config, meta) {\n  var groupFilter = _ref.groupFilter,\n    groupFieldValue = _ref.groupFieldValue;\n  if (groupFieldValue.valueSrc != \"field\") throw \"Bad groupFieldValue: \".concat(JSON.stringify(groupFieldValue));\n  var groupField = groupFieldValue.value;\n  var groupOpRule = buildRule(config, meta, groupField, opKey, convertedArgs);\n  if (!groupOpRule) return undefined;\n  var fieldConfig = getFieldConfig(config, groupField);\n  var mode = fieldConfig === null || fieldConfig === void 0 ? void 0 : fieldConfig.mode;\n  var res = _objectSpread(_objectSpread({}, groupFilter || {}), {}, {\n    type: \"rule_group\",\n    properties: _objectSpread(_objectSpread(_objectSpread({}, groupOpRule.properties), (groupFilter === null || groupFilter === void 0 ? void 0 : groupFilter.properties) || {}), {}, {\n      mode: mode\n    })\n  });\n  if (!res.id) res.id = uuid();\n  return res;\n};\nvar compareArgs = function compareArgs(left, right, spel, conv, config, meta) {\n  var parentSpel = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n  if (left.type == right.type) {\n    if (left.type == \"!aggr\") {\n      var _map = [left.source, right.source].map(function (v) {\n          return convertArg(v, conv, config, meta, _objectSpread(_objectSpread({}, spel), {}, {\n            _groupField: parentSpel === null || parentSpel === void 0 ? void 0 : parentSpel._groupField\n          }));\n        }),\n        _map2 = _slicedToArray(_map, 2),\n        leftSource = _map2[0],\n        rightSource = _map2[1];\n      //todo: check same filter\n      return leftSource.value == rightSource.value;\n    } else {\n      var _map3 = [left, right].map(function (v) {\n          return convertArg(v, conv, config, meta, _objectSpread(_objectSpread({}, spel), {}, {\n            _groupField: parentSpel === null || parentSpel === void 0 ? void 0 : parentSpel._groupField\n          }));\n        }),\n        _map4 = _slicedToArray(_map3, 2),\n        leftVal = _map4[0],\n        rightVal = _map4[1];\n      return leftVal.value == rightVal.value;\n    }\n  }\n  return false;\n};\nvar convertToTree = function convertToTree(spel, conv, config, meta) {\n  var parentSpel = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  if (!spel) return undefined;\n  var res;\n  if (spel.type.indexOf(\"op-\") == 0) {\n    var op = spel.type.slice(\"op-\".length);\n\n    // unary\n    var isUnary = (op == \"minus\" || op == \"plus\") && spel.children.length == 1;\n    if (isUnary) {\n      spel.isUnary = true;\n      return convertToTree(spel.children[0], conv, config, meta, spel);\n    }\n\n    // between\n    var isBetweenNormal = op == \"and\" && spel.children.length == 2 && spel.children[0].type == \"op-ge\" && spel.children[1].type == \"op-le\";\n    var isBetweenRev = op == \"or\" && spel.children.length == 2 && spel.children[0].type == \"op-lt\" && spel.children[1].type == \"op-gt\";\n    var isBetween = isBetweenNormal || isBetweenRev;\n    if (isBetween) {\n      var _spel$children$0$chil = _slicedToArray(spel.children[0].children, 2),\n        left = _spel$children$0$chil[0],\n        from = _spel$children$0$chil[1];\n      var _spel$children$1$chil = _slicedToArray(spel.children[1].children, 2),\n        right = _spel$children$1$chil[0],\n        to = _spel$children$1$chil[1];\n      var isNumbers = from.type == \"number\" && to.type == \"number\";\n      var isSameSource = compareArgs(left, right, spel, conv, config, meta, parentSpel);\n      if (isNumbers && isSameSource) {\n        var _fromValue = from.val;\n        var _toValue = to.val;\n        var oneSpel = {\n          type: \"op-between\",\n          children: [left, from, to]\n        };\n        return convertToTree(oneSpel, conv, config, meta, parentSpel);\n      }\n    }\n\n    // find op\n    var opKeys = conv.operators[op];\n    // todo: make dynamic, use basic config\n    if (op == \"eq\" && spel.children[1].type == \"null\") {\n      opKeys = [\"is_null\"];\n    } else if (op == \"ne\" && spel.children[1].type == \"null\") {\n      opKeys = [\"is_not_null\"];\n    } else if (op == \"le\" && spel.children[1].type == \"string\" && spel.children[1].val == \"\") {\n      opKeys = [\"is_empty\"];\n    } else if (op == \"gt\" && spel.children[1].type == \"string\" && spel.children[1].val == \"\") {\n      opKeys = [\"is_not_empty\"];\n    } else if (op == \"between\") {\n      opKeys = [\"between\"];\n    }\n\n    // convert children\n    var convertChildren = function convertChildren() {\n      return spel.children.map(function (child) {\n        return convertToTree(child, conv, config, meta, _objectSpread(_objectSpread({}, spel), {}, {\n          _groupField: parentSpel === null || parentSpel === void 0 ? void 0 : parentSpel._groupField\n        }));\n      });\n    };\n    if (op == \"and\" || op == \"or\") {\n      var children1 = {};\n      var vals = convertChildren();\n      vals.forEach(function (v) {\n        if (v) {\n          var id = uuid();\n          v.id = id;\n          if (v.type != undefined) {\n            children1[id] = v;\n          } else {\n            meta.errors.push(\"Bad item in AND/OR: \".concat(JSON.stringify(v)));\n          }\n        }\n      });\n      res = {\n        type: \"group\",\n        id: uuid(),\n        children1: children1,\n        properties: {\n          conjunction: conv.conjunctions[op],\n          not: spel.not\n        }\n      };\n    } else if (opKeys) {\n      var _fieldObj$groupFieldV, _convertedArgs;\n      var _vals = convertChildren();\n      var fieldObj = _vals[0];\n      var convertedArgs = _vals.slice(1);\n      var groupField = fieldObj === null || fieldObj === void 0 ? void 0 : (_fieldObj$groupFieldV = fieldObj.groupFieldValue) === null || _fieldObj$groupFieldV === void 0 ? void 0 : _fieldObj$groupFieldV.value;\n      var opArg = (_convertedArgs = convertedArgs) === null || _convertedArgs === void 0 ? void 0 : _convertedArgs[0];\n      var opKey = opKeys[0];\n      if (opKeys.length > 1) {\n        logger.warn(\"[spel] Spel operator \".concat(op, \" can be mapped to \").concat(opKeys));\n\n        //todo: it's naive\n        var field = fieldObj === null || fieldObj === void 0 ? void 0 : fieldObj.value;\n        var widgets = opKeys.map(function (op) {\n          return {\n            op: op,\n            widget: getWidgetForFieldOp(config, field, op)\n          };\n        });\n        if (op == \"eq\" || op == \"ne\") {\n          var ws = widgets.find(function (_ref2) {\n            var op = _ref2.op,\n              widget = _ref2.widget;\n            return widget && widget != \"field\";\n          });\n          if (ws) {\n            opKey = ws.op;\n          }\n        }\n      }\n\n      // some/all/none\n      if (fieldObj !== null && fieldObj !== void 0 && fieldObj.groupFieldValue) {\n        if (opArg && opArg.groupFieldValue && opArg.groupFieldValue.valueSrc == \"field\" && opArg.groupFieldValue.value == groupField) {\n          // group.?[...].size() == group.size()\n          opKey = \"all\";\n          convertedArgs = [];\n        } else if (opKey == \"equal\" && opArg.valueSrc == \"value\" && opArg.valueType == \"number\" && opArg.value == 0) {\n          opKey = \"none\";\n          convertedArgs = [];\n        } else if (opKey == \"greater\" && opArg.valueSrc == \"value\" && opArg.valueType == \"number\" && opArg.value == 0) {\n          opKey = \"some\";\n          convertedArgs = [];\n        }\n      }\n      var canRev = true;\n      var needWrapReverse = false;\n      if (spel.not && canRev) {\n        var opConfig = config.operators[opKey];\n        if (opConfig.reversedOp) {\n          opKey = opConfig.reversedOp;\n          spel.not = false;\n        } else {\n          needWrapReverse = true;\n        }\n      }\n      if (!fieldObj) {\n        // LHS can't be parsed\n      } else if (fieldObj.groupFieldValue) {\n        // 1. group\n        if (fieldObj.groupFieldValue.valueSrc != \"field\") {\n          meta.errors.push(\"Expected group field \".concat(JSON.stringify(fieldObj)));\n        }\n        res = buildRuleGroup(fieldObj, opKey, convertedArgs, config, meta);\n      } else {\n        // 2. not group\n        if (fieldObj.valueSrc != \"field\") {\n          meta.errors.push(\"Expected field \".concat(JSON.stringify(fieldObj)));\n        }\n        var _field5 = fieldObj.value;\n        res = buildRule(config, meta, _field5, opKey, convertedArgs);\n      }\n      if (needWrapReverse) {\n        if (res.type !== \"group\") {\n          res = wrapInDefaultConj(res, config, spel.not);\n        } else {\n          res.properties.not = !res.properties.not;\n        }\n      }\n    } else {\n      if (!parentSpel) {\n        // try to parse whole `\"str\" + prop + #var` as ternary\n        res = buildSimpleSwitch(spel, conv, config, meta);\n      }\n      if (!res) {\n        meta.errors.push(\"Can't convert op \".concat(op));\n      }\n    }\n  } else if (spel.type == \"!aggr\") {\n    var _groupFilter;\n    var groupFieldValue = convertToTree(spel.source, conv, config, meta, _objectSpread(_objectSpread({}, spel), {}, {\n      _groupField: parentSpel === null || parentSpel === void 0 ? void 0 : parentSpel._groupField\n    }));\n    var groupFilter = convertToTree(spel.filter, conv, config, meta, _objectSpread(_objectSpread({}, spel), {}, {\n      _groupField: groupFieldValue === null || groupFieldValue === void 0 ? void 0 : groupFieldValue.value\n    }));\n    if (((_groupFilter = groupFilter) === null || _groupFilter === void 0 ? void 0 : _groupFilter.type) == \"rule\") {\n      groupFilter = wrapInDefaultConj(groupFilter, config, spel.filter.not);\n    }\n    res = {\n      groupFilter: groupFilter,\n      groupFieldValue: groupFieldValue\n    };\n    if (!parentSpel) {\n      // !aggr can't be in root, it should be compared with something\n      res = undefined;\n      meta.errors.push(\"Unexpected !aggr in root\");\n    }\n  } else if (spel.type == \"ternary\") {\n    var _children = {};\n    spel.val.forEach(function (v) {\n      var _v = _slicedToArray(v, 2),\n        cond = _v[0],\n        val = _v[1];\n      var caseI = buildCase(cond, val, conv, config, meta, spel);\n      if (caseI) {\n        _children[caseI.id] = caseI;\n      }\n    });\n    res = {\n      type: \"switch_group\",\n      id: uuid(),\n      children1: _children,\n      properties: {}\n    };\n  } else {\n    res = convertArg(spel, conv, config, meta, parentSpel);\n    if (res && !res.type && !parentSpel) {\n      // try to parse whole `\"1\"` as ternary\n      var sw = buildSimpleSwitch(spel, conv, config, meta);\n      if (sw) {\n        res = sw;\n      } else {\n        res = undefined;\n        meta.errors.push(\"Can't convert rule of type \".concat(spel.type, \", it looks like var/literal\"));\n      }\n    } else {\n      // res is a rule\n    }\n  }\n  return res;\n};\nvar buildSimpleSwitch = function buildSimpleSwitch(val, conv, config, meta) {\n  var children1 = {};\n  var cond = null;\n  var caseI = buildCase(cond, val, conv, config, meta);\n  if (caseI) {\n    children1[caseI.id] = caseI;\n  }\n  var res = {\n    type: \"switch_group\",\n    id: uuid(),\n    children1: children1,\n    properties: {}\n  };\n  return res;\n};\nvar buildCase = function buildCase(cond, val, conv, config, meta) {\n  var spel = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n  var valProperties = buildCaseValProperties(config, meta, conv, val, spel);\n  var caseI;\n  if (cond) {\n    caseI = convertToTree(cond, conv, config, meta, spel);\n    if (caseI && caseI.type) {\n      if (caseI.type != \"group\") {\n        caseI = wrapInDefaultConj(caseI, config);\n      }\n      caseI.type = \"case_group\";\n    } else {\n      meta.errors.push(\"Unexpected case: \".concat(JSON.stringify(caseI)));\n      caseI = undefined;\n    }\n  } else {\n    caseI = {\n      id: uuid(),\n      type: \"case_group\",\n      properties: {}\n    };\n  }\n  if (caseI) {\n    caseI.properties = _objectSpread(_objectSpread({}, caseI.properties), valProperties);\n  }\n  return caseI;\n};\nvar buildCaseValueConcat = function buildCaseValueConcat(spel, conv, config, meta) {\n  var flat = [];\n  function _processConcatChildren(children) {\n    children.map(function (child) {\n      if (child.type == \"op-plus\") {\n        _processConcatChildren(child.children);\n      } else {\n        var convertedChild = convertArg(child, conv, config, meta, spel);\n        if (convertedChild) {\n          flat.push(convertedChild);\n        } else {\n          meta.errors.push(\"Can't convert \".concat(child.type, \" in concatenation\"));\n        }\n      }\n    });\n  }\n  _processConcatChildren(spel.children);\n  return {\n    valueSrc: \"value\",\n    valueType: \"case_value\",\n    value: flat\n  };\n};\nvar buildCaseValProperties = function buildCaseValProperties(config, meta, conv, val) {\n  var spel = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  var valProperties = {};\n  var convVal;\n  if ((val === null || val === void 0 ? void 0 : val.type) == \"op-plus\") {\n    convVal = buildCaseValueConcat(val, conv, config, meta);\n  } else {\n    convVal = convertArg(val, conv, config, meta, spel);\n  }\n  var widgetDef = config.widgets[\"case_value\"];\n  var importCaseValue = widgetDef === null || widgetDef === void 0 ? void 0 : widgetDef.spelImportValue;\n  if (importCaseValue) {\n    var _importCaseValue = importCaseValue(convVal),\n      _importCaseValue2 = _slicedToArray(_importCaseValue, 2),\n      normVal = _importCaseValue2[0],\n      normErrors = _importCaseValue2[1];\n    normErrors.map(function (e) {\n      return meta.errors.push(e);\n    });\n    if (normVal) {\n      valProperties = {\n        value: [normVal],\n        valueSrc: [\"value\"],\n        valueType: [\"case_value\"]\n      };\n    }\n  } else {\n    meta.errors.push(\"No fucntion to import case value\");\n  }\n  return valProperties;\n};\nvar wrapInDefaultConjRuleGroup = function wrapInDefaultConjRuleGroup(rule, parentField, parentFieldConfig, config, conj) {\n  if (!rule) return undefined;\n  return {\n    type: \"rule_group\",\n    id: uuid(),\n    children1: _defineProperty({}, rule.id, rule),\n    properties: {\n      conjunction: conj || defaultGroupConjunction(config, parentFieldConfig),\n      not: false,\n      field: parentField\n    }\n  };\n};\nvar wrapInDefaultConj = function wrapInDefaultConj(rule, config) {\n  var not = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  return {\n    type: \"group\",\n    id: uuid(),\n    children1: _defineProperty({}, rule.id, rule),\n    properties: {\n      conjunction: defaultConjunction(config),\n      not: not || false\n    }\n  };\n};"]},"metadata":{},"sourceType":"module"}