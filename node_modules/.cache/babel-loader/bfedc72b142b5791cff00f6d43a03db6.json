{"ast":null,"code":"import { sinkListItem, liftListItem } from 'prosemirror-schema-list';\nimport { indentRules, outdentRules } from './config/indent-rules';\nimport { blockNodes, addStyles, changeTextBlock, hasNode } from './blockNode';\nimport { findNthParentNodeOfType } from './utils';\n/**\n * Indenting block elements in the selection.\n *\n * @returns {boolean} - Returns true if any indentation is applied.\n */\n\nexport var indentBlocks = function indentBlocks(actions, command, dir) {\n  return function (state, dispatch) {\n    var blocks = blockNodes(state);\n    var tr = state.tr;\n    tr.setMeta('commandName', command);\n    blocks.forEach(function (node) {\n      if (node.type.isTextblock) {\n        var newAttrs = void 0;\n        var action = actions.find(function (a) {\n          return a.node === node.type.name;\n        });\n\n        if (action) {\n          var style = dir === 'rtl' ? action.rtlStyle : action.style;\n          var newStyle = {\n            name: style,\n            value: action.step > 0 ? \"\" + action.step + action.unit : ''\n          };\n\n          if (node.attrs.style) {\n            var re = new RegExp(style + \":\\\\s?(\\\\d+)\" + action.unit, 'i');\n            var match = node.attrs.style.match(re);\n\n            if (match) {\n              var newMargin = parseFloat(match[1]) + action.step;\n              newMargin = newMargin <= 0 ? '' : newMargin;\n              newStyle.value = \"\" + newMargin + (newMargin ? action.unit : '');\n            }\n          }\n\n          newAttrs = addStyles(node, [newStyle]);\n        }\n\n        if (newAttrs) {\n          changeTextBlock(tr, node, node.type, newAttrs);\n        }\n      }\n    });\n    var result = tr.docChanged;\n\n    if (result) {\n      dispatch(tr.scrollIntoView());\n    }\n\n    return result;\n  };\n};\nexport var isIndented = function isIndented(state, rules, dir) {\n  var blocks = blockNodes(state);\n  var result = false;\n  blocks.forEach(function (node) {\n    if (!result && node.type.isTextblock && node.attrs.style) {\n      var action = rules.find(function (a) {\n        return a.node === node.type.name;\n      });\n\n      if (action) {\n        var style = dir === 'rtl' ? action.rtlStyle : action.style;\n        var reIndent = new RegExp(style + \":\\\\s?\\\\d+\" + action.unit, 'i');\n        result = reIndent.test(node.attrs.style);\n      }\n    }\n  });\n  return result;\n};\nexport var canIndentAsListItem = function canIndentAsListItem(state, nodeType) {\n  return sinkListItem(nodeType)(state);\n};\nexport var canOutdentAsListItem = function canOutdentAsListItem(state, rules) {\n  var listItem = state.schema.nodes[rules.listsTypes.listItem];\n  var orderedList = state.schema.nodes[rules.listsTypes.orderedList];\n  var bulletList = state.schema.nodes[rules.listsTypes.bulletList];\n  var isNestedInOL = !!findNthParentNodeOfType(orderedList, 2)(state.selection);\n  var isNestedInUL = !!findNthParentNodeOfType(bulletList, 2)(state.selection);\n  return (isNestedInOL || isNestedInUL) && liftListItem(listItem)(state);\n};\nexport var canBeIndented = function canBeIndented(state, rules) {\n  var nodes = state.schema.nodes;\n  var listItem = nodes[indentRules.listsTypes.listItem];\n  return (isIndented(state, rules.nodes) || indentRules.nodes.some(function (rule) {\n    return nodes[rule.node] && hasNode(state, nodes[rule.node]);\n  })) && !hasNode(state, listItem);\n};\nexport var indent = function indent(state, dispatch) {\n  var listItem = state.schema.nodes[indentRules.listsTypes.listItem];\n  var isIndentableBlock = canBeIndented(state, indentRules);\n\n  if (canIndentAsListItem(state, listItem)) {\n    sinkListItem(listItem)(state, dispatch);\n  } else if (isIndentableBlock) {\n    indentBlocks(indentRules.nodes)(state, dispatch);\n  }\n};\nexport var outdent = function outdent(state, dispatch) {\n  var listItem = state.schema.nodes[outdentRules.listsTypes.listItem];\n  var isIndentableBlock = canBeIndented(state, outdentRules);\n\n  if (canOutdentAsListItem(state, outdentRules)) {\n    liftListItem(listItem)(state, dispatch);\n  } else if (isIndentableBlock) {\n    indentBlocks(outdentRules.nodes)(state, dispatch);\n  }\n};","map":{"version":3,"sources":["D:/Postgres_workingFolder/QuaLISWeb/node_modules/@progress/kendo-editor-common/dist/es/indent.js"],"names":["sinkListItem","liftListItem","indentRules","outdentRules","blockNodes","addStyles","changeTextBlock","hasNode","findNthParentNodeOfType","indentBlocks","actions","command","dir","state","dispatch","blocks","tr","setMeta","forEach","node","type","isTextblock","newAttrs","action","find","a","name","style","rtlStyle","newStyle","value","step","unit","attrs","re","RegExp","match","newMargin","parseFloat","result","docChanged","scrollIntoView","isIndented","rules","reIndent","test","canIndentAsListItem","nodeType","canOutdentAsListItem","listItem","schema","nodes","listsTypes","orderedList","bulletList","isNestedInOL","selection","isNestedInUL","canBeIndented","some","rule","indent","isIndentableBlock","outdent"],"mappings":"AAAA,SAASA,YAAT,EAAuBC,YAAvB,QAA2C,yBAA3C;AACA,SAASC,WAAT,EAAsBC,YAAtB,QAA0C,uBAA1C;AACA,SAASC,UAAT,EAAqBC,SAArB,EAAgCC,eAAhC,EAAiDC,OAAjD,QAAgE,aAAhE;AACA,SAASC,uBAAT,QAAwC,SAAxC;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAIC,YAAY,GAAG,SAAfA,YAAe,CAAUC,OAAV,EAAmBC,OAAnB,EAA4BC,GAA5B,EAAiC;AAAE,SAAO,UAAUC,KAAV,EAAiBC,QAAjB,EAA2B;AAC3F,QAAIC,MAAM,GAAGX,UAAU,CAACS,KAAD,CAAvB;AACA,QAAIG,EAAE,GAAGH,KAAK,CAACG,EAAf;AACAA,IAAAA,EAAE,CAACC,OAAH,CAAW,aAAX,EAA0BN,OAA1B;AACAI,IAAAA,MAAM,CAACG,OAAP,CAAe,UAAUC,IAAV,EAAgB;AAC3B,UAAIA,IAAI,CAACC,IAAL,CAAUC,WAAd,EAA2B;AACvB,YAAIC,QAAQ,GAAG,KAAK,CAApB;AACA,YAAIC,MAAM,GAAGb,OAAO,CAACc,IAAR,CAAa,UAAUC,CAAV,EAAa;AAAE,iBAAOA,CAAC,CAACN,IAAF,KAAWA,IAAI,CAACC,IAAL,CAAUM,IAA5B;AAAmC,SAA/D,CAAb;;AACA,YAAIH,MAAJ,EAAY;AACR,cAAII,KAAK,GAAGf,GAAG,KAAK,KAAR,GAAgBW,MAAM,CAACK,QAAvB,GAAkCL,MAAM,CAACI,KAArD;AACA,cAAIE,QAAQ,GAAG;AACXH,YAAAA,IAAI,EAAEC,KADK;AAEXG,YAAAA,KAAK,EAAEP,MAAM,CAACQ,IAAP,GAAc,CAAd,GAAkB,KAAKR,MAAM,CAACQ,IAAZ,GAAmBR,MAAM,CAACS,IAA5C,GAAmD;AAF/C,WAAf;;AAIA,cAAIb,IAAI,CAACc,KAAL,CAAWN,KAAf,EAAsB;AAClB,gBAAIO,EAAE,GAAG,IAAIC,MAAJ,CAAWR,KAAK,GAAG,aAAR,GAAwBJ,MAAM,CAACS,IAA1C,EAAgD,GAAhD,CAAT;AACA,gBAAII,KAAK,GAAGjB,IAAI,CAACc,KAAL,CAAWN,KAAX,CAAiBS,KAAjB,CAAuBF,EAAvB,CAAZ;;AACA,gBAAIE,KAAJ,EAAW;AACP,kBAAIC,SAAS,GAAGC,UAAU,CAACF,KAAK,CAAC,CAAD,CAAN,CAAV,GAAuBb,MAAM,CAACQ,IAA9C;AACAM,cAAAA,SAAS,GAAGA,SAAS,IAAI,CAAb,GAAiB,EAAjB,GAAsBA,SAAlC;AACAR,cAAAA,QAAQ,CAACC,KAAT,GAAiB,KAAKO,SAAL,IAAkBA,SAAS,GAAGd,MAAM,CAACS,IAAV,GAAiB,EAA5C,CAAjB;AACH;AACJ;;AACDV,UAAAA,QAAQ,GAAGjB,SAAS,CAACc,IAAD,EAAO,CAACU,QAAD,CAAP,CAApB;AACH;;AACD,YAAIP,QAAJ,EAAc;AACVhB,UAAAA,eAAe,CAACU,EAAD,EAAKG,IAAL,EAAWA,IAAI,CAACC,IAAhB,EAAsBE,QAAtB,CAAf;AACH;AACJ;AACJ,KAzBD;AA0BA,QAAIiB,MAAM,GAAGvB,EAAE,CAACwB,UAAhB;;AACA,QAAID,MAAJ,EAAY;AACRzB,MAAAA,QAAQ,CAACE,EAAE,CAACyB,cAAH,EAAD,CAAR;AACH;;AACD,WAAOF,MAAP;AACH,GAnC4D;AAmCzD,CAnCG;AAoCP,OAAO,IAAIG,UAAU,GAAG,SAAbA,UAAa,CAAU7B,KAAV,EAAiB8B,KAAjB,EAAwB/B,GAAxB,EAA6B;AACjD,MAAIG,MAAM,GAAGX,UAAU,CAACS,KAAD,CAAvB;AACA,MAAI0B,MAAM,GAAG,KAAb;AACAxB,EAAAA,MAAM,CAACG,OAAP,CAAe,UAAUC,IAAV,EAAgB;AAC3B,QAAI,CAACoB,MAAD,IAAWpB,IAAI,CAACC,IAAL,CAAUC,WAArB,IAAoCF,IAAI,CAACc,KAAL,CAAWN,KAAnD,EAA0D;AACtD,UAAIJ,MAAM,GAAGoB,KAAK,CAACnB,IAAN,CAAW,UAAUC,CAAV,EAAa;AAAE,eAAOA,CAAC,CAACN,IAAF,KAAWA,IAAI,CAACC,IAAL,CAAUM,IAA5B;AAAmC,OAA7D,CAAb;;AACA,UAAIH,MAAJ,EAAY;AACR,YAAII,KAAK,GAAGf,GAAG,KAAK,KAAR,GAAgBW,MAAM,CAACK,QAAvB,GAAkCL,MAAM,CAACI,KAArD;AACA,YAAIiB,QAAQ,GAAG,IAAIT,MAAJ,CAAWR,KAAK,GAAG,WAAR,GAAsBJ,MAAM,CAACS,IAAxC,EAA8C,GAA9C,CAAf;AACAO,QAAAA,MAAM,GAAGK,QAAQ,CAACC,IAAT,CAAc1B,IAAI,CAACc,KAAL,CAAWN,KAAzB,CAAT;AACH;AACJ;AACJ,GATD;AAUA,SAAOY,MAAP;AACH,CAdM;AAeP,OAAO,IAAIO,mBAAmB,GAAG,SAAtBA,mBAAsB,CAAUjC,KAAV,EAAiBkC,QAAjB,EAA2B;AACxD,SAAO/C,YAAY,CAAC+C,QAAD,CAAZ,CAAuBlC,KAAvB,CAAP;AACH,CAFM;AAGP,OAAO,IAAImC,oBAAoB,GAAG,SAAvBA,oBAAuB,CAAUnC,KAAV,EAAiB8B,KAAjB,EAAwB;AACtD,MAAIM,QAAQ,GAAGpC,KAAK,CAACqC,MAAN,CAAaC,KAAb,CAAmBR,KAAK,CAACS,UAAN,CAAiBH,QAApC,CAAf;AACA,MAAII,WAAW,GAAGxC,KAAK,CAACqC,MAAN,CAAaC,KAAb,CAAmBR,KAAK,CAACS,UAAN,CAAiBC,WAApC,CAAlB;AACA,MAAIC,UAAU,GAAGzC,KAAK,CAACqC,MAAN,CAAaC,KAAb,CAAmBR,KAAK,CAACS,UAAN,CAAiBE,UAApC,CAAjB;AACA,MAAIC,YAAY,GAAG,CAAC,CAAC/C,uBAAuB,CAAC6C,WAAD,EAAc,CAAd,CAAvB,CAAwCxC,KAAK,CAAC2C,SAA9C,CAArB;AACA,MAAIC,YAAY,GAAG,CAAC,CAACjD,uBAAuB,CAAC8C,UAAD,EAAa,CAAb,CAAvB,CAAuCzC,KAAK,CAAC2C,SAA7C,CAArB;AACA,SAAO,CAACD,YAAY,IAAIE,YAAjB,KAAkCxD,YAAY,CAACgD,QAAD,CAAZ,CAAuBpC,KAAvB,CAAzC;AACH,CAPM;AAQP,OAAO,IAAI6C,aAAa,GAAG,SAAhBA,aAAgB,CAAU7C,KAAV,EAAiB8B,KAAjB,EAAwB;AAC/C,MAAIQ,KAAK,GAAGtC,KAAK,CAACqC,MAAN,CAAaC,KAAzB;AACA,MAAIF,QAAQ,GAAGE,KAAK,CAACjD,WAAW,CAACkD,UAAZ,CAAuBH,QAAxB,CAApB;AACA,SAAQ,CAACP,UAAU,CAAC7B,KAAD,EAAQ8B,KAAK,CAACQ,KAAd,CAAV,IAAkCjD,WAAW,CAACiD,KAAZ,CAAkBQ,IAAlB,CAAuB,UAAUC,IAAV,EAAgB;AAAE,WAAOT,KAAK,CAACS,IAAI,CAACzC,IAAN,CAAL,IAAoBZ,OAAO,CAACM,KAAD,EAAQsC,KAAK,CAACS,IAAI,CAACzC,IAAN,CAAb,CAAlC;AAA8D,GAAvG,CAAnC,KACJ,CAACZ,OAAO,CAACM,KAAD,EAAQoC,QAAR,CADZ;AAEH,CALM;AAMP,OAAO,IAAIY,MAAM,GAAG,SAATA,MAAS,CAAUhD,KAAV,EAAiBC,QAAjB,EAA2B;AAC3C,MAAImC,QAAQ,GAAGpC,KAAK,CAACqC,MAAN,CAAaC,KAAb,CAAmBjD,WAAW,CAACkD,UAAZ,CAAuBH,QAA1C,CAAf;AACA,MAAIa,iBAAiB,GAAGJ,aAAa,CAAC7C,KAAD,EAAQX,WAAR,CAArC;;AACA,MAAI4C,mBAAmB,CAACjC,KAAD,EAAQoC,QAAR,CAAvB,EAA0C;AACtCjD,IAAAA,YAAY,CAACiD,QAAD,CAAZ,CAAuBpC,KAAvB,EAA8BC,QAA9B;AACH,GAFD,MAGK,IAAIgD,iBAAJ,EAAuB;AACxBrD,IAAAA,YAAY,CAACP,WAAW,CAACiD,KAAb,CAAZ,CAAgCtC,KAAhC,EAAuCC,QAAvC;AACH;AACJ,CATM;AAUP,OAAO,IAAIiD,OAAO,GAAG,SAAVA,OAAU,CAAUlD,KAAV,EAAiBC,QAAjB,EAA2B;AAC5C,MAAImC,QAAQ,GAAGpC,KAAK,CAACqC,MAAN,CAAaC,KAAb,CAAmBhD,YAAY,CAACiD,UAAb,CAAwBH,QAA3C,CAAf;AACA,MAAIa,iBAAiB,GAAGJ,aAAa,CAAC7C,KAAD,EAAQV,YAAR,CAArC;;AACA,MAAI6C,oBAAoB,CAACnC,KAAD,EAAQV,YAAR,CAAxB,EAA+C;AAC3CF,IAAAA,YAAY,CAACgD,QAAD,CAAZ,CAAuBpC,KAAvB,EAA8BC,QAA9B;AACH,GAFD,MAGK,IAAIgD,iBAAJ,EAAuB;AACxBrD,IAAAA,YAAY,CAACN,YAAY,CAACgD,KAAd,CAAZ,CAAiCtC,KAAjC,EAAwCC,QAAxC;AACH;AACJ,CATM","sourcesContent":["import { sinkListItem, liftListItem } from 'prosemirror-schema-list';\nimport { indentRules, outdentRules } from './config/indent-rules';\nimport { blockNodes, addStyles, changeTextBlock, hasNode } from './blockNode';\nimport { findNthParentNodeOfType } from './utils';\n/**\n * Indenting block elements in the selection.\n *\n * @returns {boolean} - Returns true if any indentation is applied.\n */\nexport var indentBlocks = function (actions, command, dir) { return function (state, dispatch) {\n    var blocks = blockNodes(state);\n    var tr = state.tr;\n    tr.setMeta('commandName', command);\n    blocks.forEach(function (node) {\n        if (node.type.isTextblock) {\n            var newAttrs = void 0;\n            var action = actions.find(function (a) { return a.node === node.type.name; });\n            if (action) {\n                var style = dir === 'rtl' ? action.rtlStyle : action.style;\n                var newStyle = {\n                    name: style,\n                    value: action.step > 0 ? \"\" + action.step + action.unit : ''\n                };\n                if (node.attrs.style) {\n                    var re = new RegExp(style + \":\\\\s?(\\\\d+)\" + action.unit, 'i');\n                    var match = node.attrs.style.match(re);\n                    if (match) {\n                        var newMargin = parseFloat(match[1]) + action.step;\n                        newMargin = newMargin <= 0 ? '' : newMargin;\n                        newStyle.value = \"\" + newMargin + (newMargin ? action.unit : '');\n                    }\n                }\n                newAttrs = addStyles(node, [newStyle]);\n            }\n            if (newAttrs) {\n                changeTextBlock(tr, node, node.type, newAttrs);\n            }\n        }\n    });\n    var result = tr.docChanged;\n    if (result) {\n        dispatch(tr.scrollIntoView());\n    }\n    return result;\n}; };\nexport var isIndented = function (state, rules, dir) {\n    var blocks = blockNodes(state);\n    var result = false;\n    blocks.forEach(function (node) {\n        if (!result && node.type.isTextblock && node.attrs.style) {\n            var action = rules.find(function (a) { return a.node === node.type.name; });\n            if (action) {\n                var style = dir === 'rtl' ? action.rtlStyle : action.style;\n                var reIndent = new RegExp(style + \":\\\\s?\\\\d+\" + action.unit, 'i');\n                result = reIndent.test(node.attrs.style);\n            }\n        }\n    });\n    return result;\n};\nexport var canIndentAsListItem = function (state, nodeType) {\n    return sinkListItem(nodeType)(state);\n};\nexport var canOutdentAsListItem = function (state, rules) {\n    var listItem = state.schema.nodes[rules.listsTypes.listItem];\n    var orderedList = state.schema.nodes[rules.listsTypes.orderedList];\n    var bulletList = state.schema.nodes[rules.listsTypes.bulletList];\n    var isNestedInOL = !!findNthParentNodeOfType(orderedList, 2)(state.selection);\n    var isNestedInUL = !!findNthParentNodeOfType(bulletList, 2)(state.selection);\n    return (isNestedInOL || isNestedInUL) && liftListItem(listItem)(state);\n};\nexport var canBeIndented = function (state, rules) {\n    var nodes = state.schema.nodes;\n    var listItem = nodes[indentRules.listsTypes.listItem];\n    return ((isIndented(state, rules.nodes) || indentRules.nodes.some(function (rule) { return nodes[rule.node] && hasNode(state, nodes[rule.node]); })) &&\n        !hasNode(state, listItem));\n};\nexport var indent = function (state, dispatch) {\n    var listItem = state.schema.nodes[indentRules.listsTypes.listItem];\n    var isIndentableBlock = canBeIndented(state, indentRules);\n    if (canIndentAsListItem(state, listItem)) {\n        sinkListItem(listItem)(state, dispatch);\n    }\n    else if (isIndentableBlock) {\n        indentBlocks(indentRules.nodes)(state, dispatch);\n    }\n};\nexport var outdent = function (state, dispatch) {\n    var listItem = state.schema.nodes[outdentRules.listsTypes.listItem];\n    var isIndentableBlock = canBeIndented(state, outdentRules);\n    if (canOutdentAsListItem(state, outdentRules)) {\n        liftListItem(listItem)(state, dispatch);\n    }\n    else if (isIndentableBlock) {\n        indentBlocks(outdentRules.nodes)(state, dispatch);\n    }\n};\n"]},"metadata":{},"sourceType":"module"}