{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n  if (!it) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nimport Immutable from \"immutable\";\nimport { expandTreePath, expandTreeSubpath, getItemByPath, fixPathsInTree, getTotalRulesCountInTree, fixEmptyGroupsInTree, isEmptyTree, hasChildren, removeIsLockedInTree } from \"../utils/treeUtils\";\nimport { defaultRuleProperties, defaultGroupProperties, defaultOperator, defaultOperatorOptions, defaultRoot, defaultItemProperties } from \"../utils/defaultUtils\";\nimport * as constants from \"./constants\";\nimport uuid from \"../utils/uuid\";\nimport { getFuncConfig, getFieldConfig, getFieldWidgetConfig, getOperatorConfig } from \"../utils/configUtils\";\nimport { getOperatorsForField, getFirstOperator, getWidgetForFieldOp, getNewValueForFieldOp } from \"../utils/ruleUtils\";\nimport { deepEqual, defaultValue, applyToJS } from \"../utils/stuff\";\nimport { validateValue } from \"../utils/validation\";\nimport omit from \"lodash/omit\";\nimport mapValues from \"lodash/mapValues\";\n/**\n * @param {object} config\n * @param {Immutable.List} path\n * @param {Immutable.Map} properties\n */\n\nvar addNewGroup = function addNewGroup(state, path, type, groupUuid, properties, config) {\n  var children = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n  var meta = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : {};\n  var shouldCreateEmptyGroup = config.settings.shouldCreateEmptyGroup;\n  var groupPath = path.push(groupUuid);\n  var canAddNewRule = !shouldCreateEmptyGroup;\n  var isDefaultCase = !!(meta !== null && meta !== void 0 && meta.isDefaultCase);\n  var origState = state;\n  state = addItem(state, path, type, groupUuid, defaultGroupProperties(config).merge(properties || {}), config, children);\n\n  if (state !== origState) {\n    if (!children && !isDefaultCase) {\n      state = state.setIn(expandTreePath(groupPath, \"children1\"), new Immutable.OrderedMap()); // Add one empty rule into new group\n\n      if (canAddNewRule) {\n        state = addItem(state, groupPath, \"rule\", uuid(), defaultRuleProperties(config), config);\n      }\n    }\n\n    state = fixPathsInTree(state);\n  }\n\n  return state;\n};\n/**\n * @param {object} config\n * @param {Immutable.List} path\n * @param {Immutable.Map} properties\n */\n\n\nvar removeGroup = function removeGroup(state, path, config) {\n  state = removeItem(state, path);\n  var canLeaveEmptyGroup = config.settings.canLeaveEmptyGroup;\n  var parentPath = path.slice(0, -1);\n  var isEmptyParentGroup = !hasChildren(state, parentPath);\n\n  if (isEmptyParentGroup && !canLeaveEmptyGroup) {\n    // check ancestors for emptiness (and delete 'em if empty)\n    state = fixEmptyGroupsInTree(state);\n\n    if (isEmptyTree(state) && !canLeaveEmptyGroup) {\n      // if whole query is empty, add one empty rule to root\n      state = addItem(state, new Immutable.List(), \"rule\", uuid(), defaultRuleProperties(config), config);\n    }\n  }\n\n  state = fixPathsInTree(state);\n  return state;\n};\n/**\n * @param {object} config\n * @param {Immutable.List} path\n */\n\n\nvar removeRule = function removeRule(state, path, config) {\n  state = removeItem(state, path);\n  var canLeaveEmptyGroup = config.settings.canLeaveEmptyGroup;\n  var parentPath = path.pop();\n  var parent = state.getIn(expandTreePath(parentPath));\n  var parentField = parent.getIn([\"properties\", \"field\"]);\n  var parentOperator = parent.getIn([\"properties\", \"operator\"]);\n  var parentValue = parent.getIn([\"properties\", \"value\", 0]);\n  var parentFieldConfig = parentField ? getFieldConfig(config, parentField) : null;\n  var parentOperatorConfig = parentOperator ? getOperatorConfig(config, parentOperator, parentField) : null;\n  var hasGroupCountRule = parentField && parentOperator && parentOperatorConfig.cardinality != 0; // && parentValue != undefined;\n\n  var isParentRuleGroup = parent.get(\"type\") == \"rule_group\";\n  var isEmptyParentGroup = !hasChildren(state, parentPath);\n  var canLeaveEmpty = isParentRuleGroup ? hasGroupCountRule && parentFieldConfig.initialEmptyWhere : canLeaveEmptyGroup;\n\n  if (isEmptyParentGroup && !canLeaveEmpty) {\n    if (isParentRuleGroup) {\n      // deleted last rule from rule_group, so delete whole rule_group\n      state = state.deleteIn(expandTreePath(parentPath));\n    } // check ancestors for emptiness (and delete 'em if empty)\n\n\n    state = fixEmptyGroupsInTree(state);\n\n    if (isEmptyTree(state) && !canLeaveEmptyGroup) {\n      // if whole query is empty, add one empty rule to root\n      state = addItem(state, new Immutable.List(), \"rule\", uuid(), defaultRuleProperties(config), config);\n    }\n  }\n\n  state = fixPathsInTree(state);\n  return state;\n};\n/**\n * @param {Immutable.Map} state\n * @param {Immutable.List} path\n * @param {bool} not\n */\n\n\nvar setNot = function setNot(state, path, not) {\n  return state.setIn(expandTreePath(path, \"properties\", \"not\"), not);\n};\n/**\n * @param {Immutable.Map} state\n * @param {Immutable.List} path\n * @param {bool} lock\n */\n\n\nvar setLock = function setLock(state, path, lock) {\n  return removeIsLockedInTree(state.setIn(expandTreePath(path, \"properties\", \"isLocked\"), lock));\n};\n/**\n * @param {Immutable.Map} state\n * @param {Immutable.List} path\n * @param {string} conjunction\n */\n\n\nvar setConjunction = function setConjunction(state, path, conjunction) {\n  return state.setIn(expandTreePath(path, \"properties\", \"conjunction\"), conjunction);\n}; // convert children deeply from JS to Immutable\n\n\nvar _addChildren1 = function _addChildren1(config, item, children) {\n  if (children && Array.isArray(children)) {\n    item.children1 = new Immutable.OrderedMap(children.reduce(function (map, it) {\n      var id1 = uuid();\n\n      var it1 = _objectSpread(_objectSpread({}, it), {}, {\n        properties: defaultItemProperties(config, it).merge(it.properties || {}),\n        id: id1\n      });\n\n      _addChildren1(config, it1, it1.children1); //todo: guarantee order\n\n\n      return _objectSpread(_objectSpread({}, map), {}, _defineProperty({}, id1, new Immutable.Map(it1)));\n    }, {}));\n  }\n};\n/**\n * @param {Immutable.Map} state\n * @param {Immutable.List} path\n * @param {string} type\n * @param {string} id\n * @param {Immutable.OrderedMap} properties\n * @param {object} config\n */\n\n\nvar addItem = function addItem(state, path, type, id, properties, config) {\n  var children = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n  if (type == \"switch_group\") throw new Error(\"Can't add switch_group programmatically\");\n  var _config$settings = config.settings,\n      maxNumberOfCases = _config$settings.maxNumberOfCases,\n      maxNumberOfRules = _config$settings.maxNumberOfRules,\n      maxNesting = _config$settings.maxNesting;\n  var rootType = state.get(\"type\");\n  var isTernary = rootType == \"switch_group\";\n  var targetItem = state.getIn(expandTreePath(path));\n  var caseGroup = isTernary ? state.getIn(expandTreePath(path.take(2))) : null;\n  var childrenPath = expandTreePath(path, \"children1\");\n  var targetChildren = state.getIn(childrenPath);\n  var hasChildren = !!targetChildren && targetChildren.size;\n  var targetChildrenSize = hasChildren ? targetChildren.size : null;\n  var currentNumber, maxNumber;\n\n  if (type == \"case_group\") {\n    currentNumber = targetChildrenSize;\n    maxNumber = maxNumberOfCases;\n  } else if (type == \"group\") {\n    currentNumber = path.size;\n    maxNumber = maxNesting;\n  } else if ((targetItem === null || targetItem === void 0 ? void 0 : targetItem.get(\"type\")) == \"rule_group\") {// don't restrict\n  } else {\n    currentNumber = isTernary ? getTotalRulesCountInTree(caseGroup) : getTotalRulesCountInTree(state);\n    maxNumber = maxNumberOfRules;\n  }\n\n  var canAdd = maxNumber && currentNumber ? currentNumber < maxNumber : true;\n  var item = {\n    type: type,\n    id: id,\n    properties: properties\n  };\n\n  _addChildren1(config, item, children);\n\n  var isLastDefaultCase = type == \"case_group\" && hasChildren && targetChildren.last().get(\"children1\") == null;\n\n  if (canAdd) {\n    var newChildren = new Immutable.OrderedMap(_defineProperty({}, id, new Immutable.Map(item)));\n\n    if (!hasChildren) {\n      state = state.setIn(childrenPath, newChildren);\n    } else if (isLastDefaultCase) {\n      var _Immutable$OrderedMap2;\n\n      var last = targetChildren.last();\n      var newChildrenWithLast = new Immutable.OrderedMap((_Immutable$OrderedMap2 = {}, _defineProperty(_Immutable$OrderedMap2, id, new Immutable.Map(item)), _defineProperty(_Immutable$OrderedMap2, last.get(\"id\"), last), _Immutable$OrderedMap2));\n      state = state.deleteIn(expandTreePath(childrenPath, \"children1\", last.get(\"id\")));\n      state = state.mergeIn(childrenPath, newChildrenWithLast);\n    } else {\n      state = state.mergeIn(childrenPath, newChildren);\n    }\n\n    state = fixPathsInTree(state);\n  }\n\n  return state;\n};\n/**\n * @param {Immutable.Map} state\n * @param {Immutable.List} path\n */\n\n\nvar removeItem = function removeItem(state, path) {\n  state = state.deleteIn(expandTreePath(path));\n  state = fixPathsInTree(state);\n  return state;\n};\n/**\n * @param {Immutable.Map} state\n * @param {Immutable.List} fromPath\n * @param {Immutable.List} toPath\n * @param {string} placement, see constants PLACEMENT_*: PLACEMENT_AFTER, PLACEMENT_BEFORE, PLACEMENT_APPEND, PLACEMENT_PREPEND\n * @param {object} config\n */\n\n\nvar moveItem = function moveItem(state, fromPath, toPath, placement, config) {\n  var from = getItemByPath(state, fromPath);\n  var sourcePath = fromPath.pop();\n  var source = fromPath.size > 1 ? getItemByPath(state, sourcePath) : null;\n  var sourceChildren = source ? source.get(\"children1\") : null;\n  var to = getItemByPath(state, toPath);\n  var targetPath = placement == constants.PLACEMENT_APPEND || placement == constants.PLACEMENT_PREPEND ? toPath : toPath.pop();\n  var target = placement == constants.PLACEMENT_APPEND || placement == constants.PLACEMENT_PREPEND ? to : toPath.size > 1 ? getItemByPath(state, targetPath) : null;\n  var targetChildren = target ? target.get(\"children1\") : null;\n  if (!source || !target || !from) return state;\n  var isSameParent = source.get(\"id\") == target.get(\"id\");\n  var isSourceInsideTarget = targetPath.size < sourcePath.size && deepEqual(targetPath.toArray(), sourcePath.toArray().slice(0, targetPath.size));\n  var isTargetInsideSource = targetPath.size > sourcePath.size && deepEqual(sourcePath.toArray(), targetPath.toArray().slice(0, sourcePath.size));\n  var sourceSubpathFromTarget = null;\n  var targetSubpathFromSource = null;\n\n  if (isSourceInsideTarget) {\n    sourceSubpathFromTarget = Immutable.List(sourcePath.toArray().slice(targetPath.size));\n  } else if (isTargetInsideSource) {\n    targetSubpathFromSource = Immutable.List(targetPath.toArray().slice(sourcePath.size));\n  }\n\n  var newTargetChildren = targetChildren,\n      newSourceChildren = sourceChildren;\n  if (!isTargetInsideSource) newSourceChildren = newSourceChildren[\"delete\"](from.get(\"id\"));\n\n  if (isSameParent) {\n    newTargetChildren = newSourceChildren;\n  } else if (isSourceInsideTarget) {\n    newTargetChildren = newTargetChildren.updateIn(expandTreeSubpath(sourceSubpathFromTarget, \"children1\"), function (_oldChildren) {\n      return newSourceChildren;\n    });\n  }\n\n  if (placement == constants.PLACEMENT_BEFORE || placement == constants.PLACEMENT_AFTER) {\n    newTargetChildren = Immutable.OrderedMap().withMutations(function (r) {\n      var _iterator = _createForOfIteratorHelper(newTargetChildren.entries()),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _step$value = _slicedToArray(_step.value, 2),\n              itemId = _step$value[0],\n              item = _step$value[1];\n\n          if (itemId == to.get(\"id\") && placement == constants.PLACEMENT_BEFORE) {\n            r.set(from.get(\"id\"), from);\n          }\n\n          r.set(itemId, item);\n\n          if (itemId == to.get(\"id\") && placement == constants.PLACEMENT_AFTER) {\n            r.set(from.get(\"id\"), from);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    });\n  } else if (placement == constants.PLACEMENT_APPEND) {\n    newTargetChildren = newTargetChildren.merge(_defineProperty({}, from.get(\"id\"), from));\n  } else if (placement == constants.PLACEMENT_PREPEND) {\n    newTargetChildren = Immutable.OrderedMap(_defineProperty({}, from.get(\"id\"), from)).merge(newTargetChildren);\n  }\n\n  if (isTargetInsideSource) {\n    newSourceChildren = newSourceChildren.updateIn(expandTreeSubpath(targetSubpathFromSource, \"children1\"), function (_oldChildren) {\n      return newTargetChildren;\n    });\n    newSourceChildren = newSourceChildren[\"delete\"](from.get(\"id\"));\n  }\n\n  if (!isSameParent && !isSourceInsideTarget) state = state.updateIn(expandTreePath(sourcePath, \"children1\"), function (_oldChildren) {\n    return newSourceChildren;\n  });\n  if (!isTargetInsideSource) state = state.updateIn(expandTreePath(targetPath, \"children1\"), function (_oldChildren) {\n    return newTargetChildren;\n  });\n  state = fixPathsInTree(state);\n  return state;\n};\n/**\n * @param {Immutable.Map} state\n * @param {Immutable.List} path\n * @param {string} field\n */\n\n\nvar setField = function setField(state, path, newField, config) {\n  if (!newField) return removeItem(state, path);\n  var _config$settings2 = config.settings,\n      fieldSeparator = _config$settings2.fieldSeparator,\n      setOpOnChangeField = _config$settings2.setOpOnChangeField,\n      showErrorMessage = _config$settings2.showErrorMessage;\n  if (Array.isArray(newField)) newField = newField.join(fieldSeparator);\n  var currentType = state.getIn(expandTreePath(path, \"type\"));\n  var currentProperties = state.getIn(expandTreePath(path, \"properties\"));\n  var wasRuleGroup = currentType == \"rule_group\";\n  var newFieldConfig = getFieldConfig(config, newField);\n  var isRuleGroup = newFieldConfig.type == \"!group\";\n  var isRuleGroupExt = isRuleGroup && newFieldConfig.mode == \"array\";\n  var isChangeToAnotherType = wasRuleGroup != isRuleGroup;\n  var currentOperator = currentProperties.get(\"operator\");\n  var currentOperatorOptions = currentProperties.get(\"operatorOptions\");\n\n  var _currentField = currentProperties.get(\"field\");\n\n  var _currentValue = currentProperties.get(\"value\");\n\n  var _currentValueSrc = currentProperties.get(\"valueSrc\", new Immutable.List());\n\n  var _currentValueType = currentProperties.get(\"valueType\", new Immutable.List()); // If the newly selected field supports the same operator the rule currently\n  // uses, keep it selected.\n\n\n  var lastOp = newFieldConfig && newFieldConfig.operators.indexOf(currentOperator) !== -1 ? currentOperator : null;\n  var newOperator = null;\n  var availOps = getOperatorsForField(config, newField);\n  if (availOps && availOps.length == 1) newOperator = availOps[0];else if (availOps && availOps.length > 1) {\n    var _iterator2 = _createForOfIteratorHelper(setOpOnChangeField || []),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var strategy = _step2.value;\n        if (strategy == \"keep\" && !isChangeToAnotherType) newOperator = lastOp;else if (strategy == \"default\") newOperator = defaultOperator(config, newField, false);else if (strategy == \"first\") newOperator = getFirstOperator(config, newField);\n        if (newOperator) //found op for strategy\n          break;\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  }\n\n  if (!isRuleGroup && !newFieldConfig.operators) {\n    console.warn(\"Type \".concat(newFieldConfig.type, \" is not supported\"));\n    return state;\n  }\n\n  if (wasRuleGroup && !isRuleGroup) {\n    state = state.setIn(expandTreePath(path, \"type\"), \"rule\");\n    state = state.deleteIn(expandTreePath(path, \"children1\"));\n    state = state.setIn(expandTreePath(path, \"properties\"), new Immutable.OrderedMap());\n  }\n\n  if (isRuleGroup) {\n    state = state.setIn(expandTreePath(path, \"type\"), \"rule_group\");\n\n    var _getNewValueForFieldO = getNewValueForFieldOp(config, config, currentProperties, newField, newOperator, \"field\", true),\n        canReuseValue = _getNewValueForFieldO.canReuseValue,\n        newValue = _getNewValueForFieldO.newValue,\n        newValueSrc = _getNewValueForFieldO.newValueSrc,\n        newValueType = _getNewValueForFieldO.newValueType,\n        operatorCardinality = _getNewValueForFieldO.operatorCardinality;\n\n    var groupProperties = defaultGroupProperties(config, newFieldConfig).merge({\n      field: newField,\n      mode: newFieldConfig.mode\n    });\n\n    if (isRuleGroupExt) {\n      groupProperties = groupProperties.merge({\n        operator: newOperator,\n        value: newValue,\n        valueSrc: newValueSrc,\n        valueType: newValueType\n      });\n    }\n\n    state = state.setIn(expandTreePath(path, \"children1\"), new Immutable.OrderedMap());\n    state = state.setIn(expandTreePath(path, \"properties\"), groupProperties);\n\n    if (newFieldConfig.initialEmptyWhere && operatorCardinality == 1) {// just `COUNT(grp) > 1` without `HAVING ..`\n      // no childeren\n    } else {\n      state = addItem(state, path, \"rule\", uuid(), defaultRuleProperties(config, newField), config);\n    }\n\n    state = fixPathsInTree(state);\n    return state;\n  }\n\n  return state.updateIn(expandTreePath(path, \"properties\"), function (map) {\n    return map.withMutations(function (current) {\n      var _getNewValueForFieldO2 = getNewValueForFieldOp(config, config, current, newField, newOperator, \"field\", true),\n          canReuseValue = _getNewValueForFieldO2.canReuseValue,\n          newValue = _getNewValueForFieldO2.newValue,\n          newValueSrc = _getNewValueForFieldO2.newValueSrc,\n          newValueType = _getNewValueForFieldO2.newValueType,\n          newValueError = _getNewValueForFieldO2.newValueError;\n\n      if (showErrorMessage) {\n        current = current.set(\"valueError\", newValueError);\n      }\n\n      var newOperatorOptions = canReuseValue ? currentOperatorOptions : defaultOperatorOptions(config, newOperator, newField);\n      return current.set(\"field\", newField).set(\"operator\", newOperator).set(\"operatorOptions\", newOperatorOptions).set(\"value\", newValue).set(\"valueSrc\", newValueSrc).set(\"valueType\", newValueType)[\"delete\"](\"asyncListValues\");\n    });\n  });\n};\n/**\n * @param {Immutable.Map} state\n * @param {Immutable.List} path\n * @param {string} operator\n */\n\n\nvar setOperator = function setOperator(state, path, newOperator, config) {\n  var showErrorMessage = config.settings.showErrorMessage;\n  var properties = state.getIn(expandTreePath(path, \"properties\"));\n  var children = state.getIn(expandTreePath(path, \"children1\"));\n  var currentField = properties.get(\"field\");\n  var fieldConfig = getFieldConfig(config, currentField);\n  var isRuleGroup = fieldConfig.type == \"!group\";\n  var operatorConfig = getOperatorConfig(config, newOperator, currentField);\n  var operatorCardinality = operatorConfig ? defaultValue(operatorConfig.cardinality, 1) : null;\n  state = state.updateIn(expandTreePath(path, \"properties\"), function (map) {\n    return map.withMutations(function (current) {\n      var currentField = current.get(\"field\");\n      var currentOperatorOptions = current.get(\"operatorOptions\");\n\n      var _currentValue = current.get(\"value\", new Immutable.List());\n\n      var _currentValueSrc = current.get(\"valueSrc\", new Immutable.List());\n\n      var _currentOperator = current.get(\"operator\");\n\n      var _getNewValueForFieldO3 = getNewValueForFieldOp(config, config, current, currentField, newOperator, \"operator\", true),\n          canReuseValue = _getNewValueForFieldO3.canReuseValue,\n          newValue = _getNewValueForFieldO3.newValue,\n          newValueSrc = _getNewValueForFieldO3.newValueSrc,\n          newValueType = _getNewValueForFieldO3.newValueType,\n          newValueError = _getNewValueForFieldO3.newValueError;\n\n      if (showErrorMessage) {\n        current = current.set(\"valueError\", newValueError);\n      }\n\n      var newOperatorOptions = canReuseValue ? currentOperatorOptions : defaultOperatorOptions(config, newOperator, currentField);\n\n      if (!canReuseValue) {\n        current = current[\"delete\"](\"asyncListValues\");\n      }\n\n      return current.set(\"operator\", newOperator).set(\"operatorOptions\", newOperatorOptions).set(\"value\", newValue).set(\"valueSrc\", newValueSrc).set(\"valueType\", newValueType);\n    });\n  });\n\n  if (isRuleGroup) {\n    if (operatorCardinality == 0 && children.size == 0) {\n      state = addItem(state, path, \"rule\", uuid(), defaultRuleProperties(config, currentField), config);\n    }\n  }\n\n  return state;\n};\n/**\n * @param {Immutable.Map} state\n * @param {Immutable.List} path\n * @param {integer} delta\n * @param {*} value\n * @param {string} valueType\n * @param {*} asyncListValues\n * @param {boolean} __isInternal\n */\n\n\nvar setValue = function setValue(state, path, delta, value, valueType, config, asyncListValues, __isInternal) {\n  var _config$settings3 = config.settings,\n      fieldSeparator = _config$settings3.fieldSeparator,\n      showErrorMessage = _config$settings3.showErrorMessage;\n  var isInternalValueChange;\n  var valueSrc = state.getIn(expandTreePath(path, \"properties\", \"valueSrc\", delta + \"\")) || null;\n  if (valueSrc === \"field\" && Array.isArray(value)) value = value.join(fieldSeparator);\n  var field = state.getIn(expandTreePath(path, \"properties\", \"field\")) || null;\n  var operator = state.getIn(expandTreePath(path, \"properties\", \"operator\")) || null;\n  var operatorConfig = getOperatorConfig(config, operator, field);\n  var operatorCardinality = operator ? defaultValue(operatorConfig.cardinality, 1) : null;\n  var isEndValue = false;\n  var calculatedValueType = valueType || calculateValueType(value, valueSrc, config);\n  var canFix = false;\n\n  var _validateValue = validateValue(config, field, field, operator, value, calculatedValueType, valueSrc, asyncListValues, canFix, isEndValue),\n      _validateValue2 = _slicedToArray(_validateValue, 2),\n      validateError = _validateValue2[0],\n      fixedValue = _validateValue2[1];\n\n  var isValid = !validateError;\n\n  if (fixedValue !== value) {\n    // eg, get exact value from listValues (not string)\n    value = fixedValue;\n  } // Additional validation for range values\n\n\n  if (showErrorMessage) {\n    var w = getWidgetForFieldOp(config, field, operator, valueSrc);\n    var fieldWidgetDefinition = getFieldWidgetConfig(config, field, operator, w, valueSrc);\n    var valueSrcs = Array.from({\n      length: operatorCardinality\n    }, function (_, i) {\n      return state.getIn(expandTreePath(path, \"properties\", \"valueSrc\", i + \"\")) || null;\n    });\n\n    if (operatorConfig && operatorConfig.validateValues && valueSrcs.filter(function (vs) {\n      return vs == \"value\" || vs == null;\n    }).length == operatorCardinality) {\n      var values = Array.from({\n        length: operatorCardinality\n      }, function (_, i) {\n        return i == delta ? value : state.getIn(expandTreePath(path, \"properties\", \"value\", i + \"\")) || null;\n      });\n      var jsValues = fieldWidgetDefinition && fieldWidgetDefinition.toJS ? values.map(function (v) {\n        return fieldWidgetDefinition.toJS(v, fieldWidgetDefinition);\n      }) : values;\n      var rangeValidateError = operatorConfig.validateValues(jsValues);\n      state = state.setIn(expandTreePath(path, \"properties\", \"valueError\", operatorCardinality), rangeValidateError);\n    }\n  }\n\n  var lastValueArr = state.getIn(expandTreePath(path, \"properties\", \"value\"));\n\n  if (!lastValueArr) {\n    state = state.setIn(expandTreePath(path, \"properties\", \"value\"), new Immutable.List(new Array(operatorCardinality))).setIn(expandTreePath(path, \"properties\", \"valueType\"), new Immutable.List(new Array(operatorCardinality))).setIn(expandTreePath(path, \"properties\", \"valueError\"), new Immutable.List(new Array(operatorCardinality)));\n  }\n\n  var lastValue = state.getIn(expandTreePath(path, \"properties\", \"value\", delta + \"\"));\n  var lastError = state.getIn(expandTreePath(path, \"properties\", \"valueError\", delta));\n  var isLastEmpty = lastValue == undefined;\n  var isLastError = !!lastError;\n\n  if (isValid || showErrorMessage) {\n    state = state.deleteIn(expandTreePath(path, \"properties\", \"asyncListValues\")); // set only good value\n\n    if (typeof value === \"undefined\") {\n      state = state.setIn(expandTreePath(path, \"properties\", \"value\", delta + \"\"), undefined);\n      state = state.setIn(expandTreePath(path, \"properties\", \"valueType\", delta + \"\"), null);\n    } else {\n      if (asyncListValues) {\n        state = state.setIn(expandTreePath(path, \"properties\", \"asyncListValues\"), asyncListValues);\n      }\n\n      state = state.setIn(expandTreePath(path, \"properties\", \"value\", delta + \"\"), value);\n      state = state.setIn(expandTreePath(path, \"properties\", \"valueType\", delta + \"\"), calculatedValueType);\n      isInternalValueChange = __isInternal && !isLastEmpty && !isLastError;\n    }\n  }\n\n  if (showErrorMessage) {\n    state = state.setIn(expandTreePath(path, \"properties\", \"valueError\", delta), validateError);\n  }\n\n  if (__isInternal && (isValid && isLastError || !isValid && !isLastError)) {\n    state = state.setIn(expandTreePath(path, \"properties\", \"valueError\", delta), validateError);\n    isInternalValueChange = false;\n  }\n\n  return {\n    tree: state,\n    isInternalValueChange: isInternalValueChange\n  };\n};\n/**\n * @param {Immutable.Map} state\n * @param {Immutable.List} path\n * @param {integer} delta\n * @param {*} srcKey\n */\n\n\nvar setValueSrc = function setValueSrc(state, path, delta, srcKey, config) {\n  var showErrorMessage = config.settings.showErrorMessage;\n  var field = state.getIn(expandTreePath(path, \"properties\", \"field\")) || null;\n  var operator = state.getIn(expandTreePath(path, \"properties\", \"operator\")) || null;\n  state = state.setIn(expandTreePath(path, \"properties\", \"value\", delta + \"\"), undefined);\n  state = state.setIn(expandTreePath(path, \"properties\", \"valueType\", delta + \"\"), null);\n  state = state.deleteIn(expandTreePath(path, \"properties\", \"asyncListValues\"));\n\n  if (showErrorMessage) {\n    // clear value error\n    state = state.setIn(expandTreePath(path, \"properties\", \"valueError\", delta), null); // if current operator is range, clear possible range error\n\n    var operatorConfig = getOperatorConfig(config, operator, field);\n    var operatorCardinality = operator ? defaultValue(operatorConfig.cardinality, 1) : null;\n\n    if (operatorConfig.validateValues) {\n      state = state.setIn(expandTreePath(path, \"properties\", \"valueError\", operatorCardinality), null);\n    }\n  } // set valueSrc\n\n\n  if (typeof srcKey === \"undefined\") {\n    state = state.setIn(expandTreePath(path, \"properties\", \"valueSrc\", delta + \"\"), null);\n  } else {\n    state = state.setIn(expandTreePath(path, \"properties\", \"valueSrc\", delta + \"\"), srcKey);\n  } // maybe set default value\n\n\n  if (srcKey) {\n    var properties = state.getIn(expandTreePath(path, \"properties\")); // this call should return canReuseValue = false and provide default value\n\n    var _getNewValueForFieldO4 = getNewValueForFieldOp(config, config, properties, field, operator, \"valueSrc\", true),\n        canReuseValue = _getNewValueForFieldO4.canReuseValue,\n        newValue = _getNewValueForFieldO4.newValue,\n        newValueSrc = _getNewValueForFieldO4.newValueSrc,\n        newValueType = _getNewValueForFieldO4.newValueType,\n        newValueError = _getNewValueForFieldO4.newValueError;\n\n    if (!canReuseValue && newValueSrc.get(delta) == srcKey) {\n      state = state.setIn(expandTreePath(path, \"properties\", \"value\", delta + \"\"), newValue.get(delta));\n      state = state.setIn(expandTreePath(path, \"properties\", \"valueType\", delta + \"\"), newValueType.get(delta));\n    }\n  }\n\n  return state;\n};\n/**\n * @param {Immutable.Map} state\n * @param {Immutable.List} path\n * @param {string} name\n * @param {*} value\n */\n\n\nvar setOperatorOption = function setOperatorOption(state, path, name, value) {\n  return state.setIn(expandTreePath(path, \"properties\", \"operatorOptions\", name), value);\n};\n/**\n * @param {Immutable.Map} state\n */\n\n\nvar checkEmptyGroups = function checkEmptyGroups(state, config) {\n  var canLeaveEmptyGroup = config.settings.canLeaveEmptyGroup;\n\n  if (!canLeaveEmptyGroup) {\n    state = fixEmptyGroupsInTree(state);\n  }\n\n  return state;\n};\n/**\n * \n */\n\n\nvar calculateValueType = function calculateValueType(value, valueSrc, config) {\n  var calculatedValueType = null;\n\n  if (value) {\n    if (valueSrc === \"field\") {\n      var fieldConfig = getFieldConfig(config, value);\n\n      if (fieldConfig) {\n        calculatedValueType = fieldConfig.type;\n      }\n    } else if (valueSrc === \"func\") {\n      var funcKey = value.get(\"func\");\n\n      if (funcKey) {\n        var funcConfig = getFuncConfig(config, funcKey);\n\n        if (funcConfig) {\n          calculatedValueType = funcConfig.returnType;\n        }\n      }\n    }\n  }\n\n  return calculatedValueType;\n};\n\nvar getField = function getField(state, path) {\n  var field = state.getIn(expandTreePath(path, \"properties\", \"field\")) || null;\n  return field;\n};\n\nvar emptyDrag = {\n  dragging: {\n    id: null,\n    x: null,\n    y: null,\n    w: null,\n    h: null\n  },\n  mousePos: {},\n  dragStart: {\n    id: null\n  }\n};\n\nvar getActionMeta = function getActionMeta(action, state) {\n  if (!action || !action.type) return null;\n  var actionKeysToOmit = [\"config\", \"asyncListValues\", \"__isInternal\"];\n  var actionTypesToIgnore = [constants.SET_TREE, constants.SET_DRAG_START, constants.SET_DRAG_PROGRESS, constants.SET_DRAG_END];\n  var meta = mapValues(omit(action, actionKeysToOmit), applyToJS);\n  var affectedField = action.path && getField(state.tree, action.path) || action.field;\n  if (affectedField) meta.affectedField = affectedField;\n  if (actionTypesToIgnore.includes(action.type) || action.type.indexOf(\"@@redux\") == 0) meta = null;\n  return meta;\n};\n/**\n * @param {Immutable.Map} state\n * @param {object} action\n */\n\n\nexport default (function (config, tree, getMemoizedTree) {\n  var emptyTree = defaultRoot(config);\n  var initTree = tree || emptyTree;\n\n  var emptyState = _objectSpread({\n    tree: initTree\n  }, emptyDrag);\n\n  return function () {\n    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : emptyState;\n    var action = arguments.length > 1 ? arguments[1] : undefined;\n    var unset = {\n      __isInternalValueChange: undefined,\n      __lastAction: undefined\n    };\n    var set = {};\n    var actionMeta = getActionMeta(action, state);\n\n    switch (action === null || action === void 0 ? void 0 : action.type) {\n      case constants.SET_TREE:\n        {\n          var validatedTree = getMemoizedTree(action.config, action.tree);\n          set.tree = validatedTree;\n          break;\n        }\n\n      case constants.ADD_CASE_GROUP:\n        {\n          set.tree = addNewGroup(state.tree, action.path, \"case_group\", action.id, action.properties, action.config, action.children, action.meta);\n          break;\n        }\n\n      case constants.ADD_GROUP:\n        {\n          set.tree = addNewGroup(state.tree, action.path, \"group\", action.id, action.properties, action.config, action.children, action.meta);\n          break;\n        }\n\n      case constants.REMOVE_GROUP:\n        {\n          set.tree = removeGroup(state.tree, action.path, action.config);\n          break;\n        }\n\n      case constants.ADD_RULE:\n        {\n          set.tree = addItem(state.tree, action.path, action.ruleType, action.id, action.properties, action.config, action.children);\n          break;\n        }\n\n      case constants.REMOVE_RULE:\n        {\n          set.tree = removeRule(state.tree, action.path, action.config);\n          break;\n        }\n\n      case constants.SET_CONJUNCTION:\n        {\n          set.tree = setConjunction(state.tree, action.path, action.conjunction);\n          break;\n        }\n\n      case constants.SET_NOT:\n        {\n          set.tree = setNot(state.tree, action.path, action.not);\n          break;\n        }\n\n      case constants.SET_FIELD:\n        {\n          set.tree = setField(state.tree, action.path, action.field, action.config);\n          break;\n        }\n\n      case constants.SET_LOCK:\n        {\n          set.tree = setLock(state.tree, action.path, action.lock);\n          break;\n        }\n\n      case constants.SET_OPERATOR:\n        {\n          set.tree = setOperator(state.tree, action.path, action.operator, action.config);\n          break;\n        }\n\n      case constants.SET_VALUE:\n        {\n          var _setValue = setValue(state.tree, action.path, action.delta, action.value, action.valueType, action.config, action.asyncListValues, action.__isInternal),\n              _tree = _setValue.tree,\n              isInternalValueChange = _setValue.isInternalValueChange;\n\n          set.__isInternalValueChange = isInternalValueChange;\n          set.tree = _tree;\n          break;\n        }\n\n      case constants.SET_VALUE_SRC:\n        {\n          set.tree = setValueSrc(state.tree, action.path, action.delta, action.srcKey, action.config);\n          break;\n        }\n\n      case constants.SET_OPERATOR_OPTION:\n        {\n          set.tree = setOperatorOption(state.tree, action.path, action.name, action.value);\n          break;\n        }\n\n      case constants.MOVE_ITEM:\n        {\n          set.tree = moveItem(state.tree, action.fromPath, action.toPath, action.placement, action.config);\n          break;\n        }\n\n      case constants.SET_DRAG_START:\n        {\n          set.dragStart = action.dragStart;\n          set.dragging = action.dragging;\n          set.mousePos = action.mousePos;\n          break;\n        }\n\n      case constants.SET_DRAG_PROGRESS:\n        {\n          set.mousePos = action.mousePos;\n          set.dragging = action.dragging;\n          break;\n        }\n\n      case constants.SET_DRAG_END:\n        {\n          set.tree = checkEmptyGroups(state.tree, config);\n          set = _objectSpread(_objectSpread({}, set), emptyDrag);\n          break;\n        }\n\n      default:\n        {\n          break;\n        }\n    }\n\n    if (actionMeta) {\n      set.__lastAction = actionMeta;\n    }\n\n    return _objectSpread(_objectSpread(_objectSpread({}, state), unset), set);\n  };\n});","map":{"version":3,"sources":["D:/LIMSWFH/LIMSPOSTGRESQL/QuaLISWeb/node_modules/@react-awesome-query-builder/core/esm/stores/tree.js"],"names":["_slicedToArray","_defineProperty","_createForOfIteratorHelper","o","allowArrayLike","it","Symbol","iterator","Array","isArray","_unsupportedIterableToArray","length","i","F","s","n","done","value","e","_e","f","TypeError","normalCompletion","didErr","err","call","step","next","_e2","minLen","_arrayLikeToArray","Object","prototype","toString","slice","constructor","name","from","test","arr","len","arr2","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","arguments","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","Immutable","expandTreePath","expandTreeSubpath","getItemByPath","fixPathsInTree","getTotalRulesCountInTree","fixEmptyGroupsInTree","isEmptyTree","hasChildren","removeIsLockedInTree","defaultRuleProperties","defaultGroupProperties","defaultOperator","defaultOperatorOptions","defaultRoot","defaultItemProperties","constants","uuid","getFuncConfig","getFieldConfig","getFieldWidgetConfig","getOperatorConfig","getOperatorsForField","getFirstOperator","getWidgetForFieldOp","getNewValueForFieldOp","deepEqual","defaultValue","applyToJS","validateValue","omit","mapValues","addNewGroup","state","path","type","groupUuid","properties","config","children","undefined","meta","shouldCreateEmptyGroup","settings","groupPath","canAddNewRule","isDefaultCase","origState","addItem","merge","setIn","OrderedMap","removeGroup","removeItem","canLeaveEmptyGroup","parentPath","isEmptyParentGroup","List","removeRule","pop","parent","getIn","parentField","parentOperator","parentValue","parentFieldConfig","parentOperatorConfig","hasGroupCountRule","cardinality","isParentRuleGroup","get","canLeaveEmpty","initialEmptyWhere","deleteIn","setNot","not","setLock","lock","setConjunction","conjunction","_addChildren1","item","children1","reduce","map","id1","it1","id","Map","Error","_config$settings","maxNumberOfCases","maxNumberOfRules","maxNesting","rootType","isTernary","targetItem","caseGroup","take","childrenPath","targetChildren","size","targetChildrenSize","currentNumber","maxNumber","canAdd","isLastDefaultCase","last","newChildren","_Immutable$OrderedMap2","newChildrenWithLast","mergeIn","moveItem","fromPath","toPath","placement","sourcePath","sourceChildren","to","targetPath","PLACEMENT_APPEND","PLACEMENT_PREPEND","isSameParent","isSourceInsideTarget","toArray","isTargetInsideSource","sourceSubpathFromTarget","targetSubpathFromSource","newTargetChildren","newSourceChildren","updateIn","_oldChildren","PLACEMENT_BEFORE","PLACEMENT_AFTER","withMutations","r","_iterator","entries","_step","_step$value","itemId","set","setField","newField","_config$settings2","fieldSeparator","setOpOnChangeField","showErrorMessage","join","currentType","currentProperties","wasRuleGroup","newFieldConfig","isRuleGroup","isRuleGroupExt","mode","isChangeToAnotherType","currentOperator","currentOperatorOptions","_currentField","_currentValue","_currentValueSrc","_currentValueType","lastOp","operators","indexOf","newOperator","availOps","_iterator2","_step2","strategy","console","warn","concat","_getNewValueForFieldO","canReuseValue","newValue","newValueSrc","newValueType","operatorCardinality","groupProperties","field","operator","valueSrc","valueType","current","_getNewValueForFieldO2","newValueError","newOperatorOptions","setOperator","currentField","fieldConfig","operatorConfig","_currentOperator","_getNewValueForFieldO3","setValue","delta","asyncListValues","__isInternal","_config$settings3","isInternalValueChange","isEndValue","calculatedValueType","calculateValueType","canFix","_validateValue","_validateValue2","validateError","fixedValue","isValid","w","fieldWidgetDefinition","valueSrcs","_","validateValues","vs","values","jsValues","toJS","v","rangeValidateError","lastValueArr","lastValue","lastError","isLastEmpty","isLastError","tree","setValueSrc","srcKey","_getNewValueForFieldO4","setOperatorOption","checkEmptyGroups","funcKey","funcConfig","returnType","getField","emptyDrag","dragging","x","y","h","mousePos","dragStart","getActionMeta","action","actionKeysToOmit","actionTypesToIgnore","SET_TREE","SET_DRAG_START","SET_DRAG_PROGRESS","SET_DRAG_END","affectedField","includes","getMemoizedTree","emptyTree","initTree","emptyState","unset","__isInternalValueChange","__lastAction","actionMeta","validatedTree","ADD_CASE_GROUP","ADD_GROUP","REMOVE_GROUP","ADD_RULE","ruleType","REMOVE_RULE","SET_CONJUNCTION","SET_NOT","SET_FIELD","SET_LOCK","SET_OPERATOR","SET_VALUE","_setValue","_tree","SET_VALUE_SRC","SET_OPERATOR_OPTION","MOVE_ITEM"],"mappings":"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","sourcesContent":["import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nimport Immutable from \"immutable\";\nimport { expandTreePath, expandTreeSubpath, getItemByPath, fixPathsInTree, getTotalRulesCountInTree, fixEmptyGroupsInTree, isEmptyTree, hasChildren, removeIsLockedInTree } from \"../utils/treeUtils\";\nimport { defaultRuleProperties, defaultGroupProperties, defaultOperator, defaultOperatorOptions, defaultRoot, defaultItemProperties } from \"../utils/defaultUtils\";\nimport * as constants from \"./constants\";\nimport uuid from \"../utils/uuid\";\nimport { getFuncConfig, getFieldConfig, getFieldWidgetConfig, getOperatorConfig } from \"../utils/configUtils\";\nimport { getOperatorsForField, getFirstOperator, getWidgetForFieldOp, getNewValueForFieldOp } from \"../utils/ruleUtils\";\nimport { deepEqual, defaultValue, applyToJS } from \"../utils/stuff\";\nimport { validateValue } from \"../utils/validation\";\nimport omit from \"lodash/omit\";\nimport mapValues from \"lodash/mapValues\";\n\n/**\n * @param {object} config\n * @param {Immutable.List} path\n * @param {Immutable.Map} properties\n */\nvar addNewGroup = function addNewGroup(state, path, type, groupUuid, properties, config) {\n  var children = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n  var meta = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : {};\n  var shouldCreateEmptyGroup = config.settings.shouldCreateEmptyGroup;\n  var groupPath = path.push(groupUuid);\n  var canAddNewRule = !shouldCreateEmptyGroup;\n  var isDefaultCase = !!(meta !== null && meta !== void 0 && meta.isDefaultCase);\n  var origState = state;\n  state = addItem(state, path, type, groupUuid, defaultGroupProperties(config).merge(properties || {}), config, children);\n  if (state !== origState) {\n    if (!children && !isDefaultCase) {\n      state = state.setIn(expandTreePath(groupPath, \"children1\"), new Immutable.OrderedMap());\n\n      // Add one empty rule into new group\n      if (canAddNewRule) {\n        state = addItem(state, groupPath, \"rule\", uuid(), defaultRuleProperties(config), config);\n      }\n    }\n    state = fixPathsInTree(state);\n  }\n  return state;\n};\n\n/**\n * @param {object} config\n * @param {Immutable.List} path\n * @param {Immutable.Map} properties\n */\nvar removeGroup = function removeGroup(state, path, config) {\n  state = removeItem(state, path);\n  var canLeaveEmptyGroup = config.settings.canLeaveEmptyGroup;\n  var parentPath = path.slice(0, -1);\n  var isEmptyParentGroup = !hasChildren(state, parentPath);\n  if (isEmptyParentGroup && !canLeaveEmptyGroup) {\n    // check ancestors for emptiness (and delete 'em if empty)\n    state = fixEmptyGroupsInTree(state);\n    if (isEmptyTree(state) && !canLeaveEmptyGroup) {\n      // if whole query is empty, add one empty rule to root\n      state = addItem(state, new Immutable.List(), \"rule\", uuid(), defaultRuleProperties(config), config);\n    }\n  }\n  state = fixPathsInTree(state);\n  return state;\n};\n\n/**\n * @param {object} config\n * @param {Immutable.List} path\n */\nvar removeRule = function removeRule(state, path, config) {\n  state = removeItem(state, path);\n  var canLeaveEmptyGroup = config.settings.canLeaveEmptyGroup;\n  var parentPath = path.pop();\n  var parent = state.getIn(expandTreePath(parentPath));\n  var parentField = parent.getIn([\"properties\", \"field\"]);\n  var parentOperator = parent.getIn([\"properties\", \"operator\"]);\n  var parentValue = parent.getIn([\"properties\", \"value\", 0]);\n  var parentFieldConfig = parentField ? getFieldConfig(config, parentField) : null;\n  var parentOperatorConfig = parentOperator ? getOperatorConfig(config, parentOperator, parentField) : null;\n  var hasGroupCountRule = parentField && parentOperator && parentOperatorConfig.cardinality != 0; // && parentValue != undefined;\n\n  var isParentRuleGroup = parent.get(\"type\") == \"rule_group\";\n  var isEmptyParentGroup = !hasChildren(state, parentPath);\n  var canLeaveEmpty = isParentRuleGroup ? hasGroupCountRule && parentFieldConfig.initialEmptyWhere : canLeaveEmptyGroup;\n  if (isEmptyParentGroup && !canLeaveEmpty) {\n    if (isParentRuleGroup) {\n      // deleted last rule from rule_group, so delete whole rule_group\n      state = state.deleteIn(expandTreePath(parentPath));\n    }\n\n    // check ancestors for emptiness (and delete 'em if empty)\n    state = fixEmptyGroupsInTree(state);\n    if (isEmptyTree(state) && !canLeaveEmptyGroup) {\n      // if whole query is empty, add one empty rule to root\n      state = addItem(state, new Immutable.List(), \"rule\", uuid(), defaultRuleProperties(config), config);\n    }\n  }\n  state = fixPathsInTree(state);\n  return state;\n};\n\n/**\n * @param {Immutable.Map} state\n * @param {Immutable.List} path\n * @param {bool} not\n */\nvar setNot = function setNot(state, path, not) {\n  return state.setIn(expandTreePath(path, \"properties\", \"not\"), not);\n};\n\n/**\n * @param {Immutable.Map} state\n * @param {Immutable.List} path\n * @param {bool} lock\n */\nvar setLock = function setLock(state, path, lock) {\n  return removeIsLockedInTree(state.setIn(expandTreePath(path, \"properties\", \"isLocked\"), lock));\n};\n\n/**\n * @param {Immutable.Map} state\n * @param {Immutable.List} path\n * @param {string} conjunction\n */\nvar setConjunction = function setConjunction(state, path, conjunction) {\n  return state.setIn(expandTreePath(path, \"properties\", \"conjunction\"), conjunction);\n};\n\n// convert children deeply from JS to Immutable\nvar _addChildren1 = function _addChildren1(config, item, children) {\n  if (children && Array.isArray(children)) {\n    item.children1 = new Immutable.OrderedMap(children.reduce(function (map, it) {\n      var id1 = uuid();\n      var it1 = _objectSpread(_objectSpread({}, it), {}, {\n        properties: defaultItemProperties(config, it).merge(it.properties || {}),\n        id: id1\n      });\n      _addChildren1(config, it1, it1.children1);\n      //todo: guarantee order\n      return _objectSpread(_objectSpread({}, map), {}, _defineProperty({}, id1, new Immutable.Map(it1)));\n    }, {}));\n  }\n};\n\n/**\n * @param {Immutable.Map} state\n * @param {Immutable.List} path\n * @param {string} type\n * @param {string} id\n * @param {Immutable.OrderedMap} properties\n * @param {object} config\n */\nvar addItem = function addItem(state, path, type, id, properties, config) {\n  var children = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n  if (type == \"switch_group\") throw new Error(\"Can't add switch_group programmatically\");\n  var _config$settings = config.settings,\n    maxNumberOfCases = _config$settings.maxNumberOfCases,\n    maxNumberOfRules = _config$settings.maxNumberOfRules,\n    maxNesting = _config$settings.maxNesting;\n  var rootType = state.get(\"type\");\n  var isTernary = rootType == \"switch_group\";\n  var targetItem = state.getIn(expandTreePath(path));\n  var caseGroup = isTernary ? state.getIn(expandTreePath(path.take(2))) : null;\n  var childrenPath = expandTreePath(path, \"children1\");\n  var targetChildren = state.getIn(childrenPath);\n  var hasChildren = !!targetChildren && targetChildren.size;\n  var targetChildrenSize = hasChildren ? targetChildren.size : null;\n  var currentNumber, maxNumber;\n  if (type == \"case_group\") {\n    currentNumber = targetChildrenSize;\n    maxNumber = maxNumberOfCases;\n  } else if (type == \"group\") {\n    currentNumber = path.size;\n    maxNumber = maxNesting;\n  } else if ((targetItem === null || targetItem === void 0 ? void 0 : targetItem.get(\"type\")) == \"rule_group\") {\n    // don't restrict\n  } else {\n    currentNumber = isTernary ? getTotalRulesCountInTree(caseGroup) : getTotalRulesCountInTree(state);\n    maxNumber = maxNumberOfRules;\n  }\n  var canAdd = maxNumber && currentNumber ? currentNumber < maxNumber : true;\n  var item = {\n    type: type,\n    id: id,\n    properties: properties\n  };\n  _addChildren1(config, item, children);\n  var isLastDefaultCase = type == \"case_group\" && hasChildren && targetChildren.last().get(\"children1\") == null;\n  if (canAdd) {\n    var newChildren = new Immutable.OrderedMap(_defineProperty({}, id, new Immutable.Map(item)));\n    if (!hasChildren) {\n      state = state.setIn(childrenPath, newChildren);\n    } else if (isLastDefaultCase) {\n      var _Immutable$OrderedMap2;\n      var last = targetChildren.last();\n      var newChildrenWithLast = new Immutable.OrderedMap((_Immutable$OrderedMap2 = {}, _defineProperty(_Immutable$OrderedMap2, id, new Immutable.Map(item)), _defineProperty(_Immutable$OrderedMap2, last.get(\"id\"), last), _Immutable$OrderedMap2));\n      state = state.deleteIn(expandTreePath(childrenPath, \"children1\", last.get(\"id\")));\n      state = state.mergeIn(childrenPath, newChildrenWithLast);\n    } else {\n      state = state.mergeIn(childrenPath, newChildren);\n    }\n    state = fixPathsInTree(state);\n  }\n  return state;\n};\n\n/**\n * @param {Immutable.Map} state\n * @param {Immutable.List} path\n */\nvar removeItem = function removeItem(state, path) {\n  state = state.deleteIn(expandTreePath(path));\n  state = fixPathsInTree(state);\n  return state;\n};\n\n/**\n * @param {Immutable.Map} state\n * @param {Immutable.List} fromPath\n * @param {Immutable.List} toPath\n * @param {string} placement, see constants PLACEMENT_*: PLACEMENT_AFTER, PLACEMENT_BEFORE, PLACEMENT_APPEND, PLACEMENT_PREPEND\n * @param {object} config\n */\nvar moveItem = function moveItem(state, fromPath, toPath, placement, config) {\n  var from = getItemByPath(state, fromPath);\n  var sourcePath = fromPath.pop();\n  var source = fromPath.size > 1 ? getItemByPath(state, sourcePath) : null;\n  var sourceChildren = source ? source.get(\"children1\") : null;\n  var to = getItemByPath(state, toPath);\n  var targetPath = placement == constants.PLACEMENT_APPEND || placement == constants.PLACEMENT_PREPEND ? toPath : toPath.pop();\n  var target = placement == constants.PLACEMENT_APPEND || placement == constants.PLACEMENT_PREPEND ? to : toPath.size > 1 ? getItemByPath(state, targetPath) : null;\n  var targetChildren = target ? target.get(\"children1\") : null;\n  if (!source || !target || !from) return state;\n  var isSameParent = source.get(\"id\") == target.get(\"id\");\n  var isSourceInsideTarget = targetPath.size < sourcePath.size && deepEqual(targetPath.toArray(), sourcePath.toArray().slice(0, targetPath.size));\n  var isTargetInsideSource = targetPath.size > sourcePath.size && deepEqual(sourcePath.toArray(), targetPath.toArray().slice(0, sourcePath.size));\n  var sourceSubpathFromTarget = null;\n  var targetSubpathFromSource = null;\n  if (isSourceInsideTarget) {\n    sourceSubpathFromTarget = Immutable.List(sourcePath.toArray().slice(targetPath.size));\n  } else if (isTargetInsideSource) {\n    targetSubpathFromSource = Immutable.List(targetPath.toArray().slice(sourcePath.size));\n  }\n  var newTargetChildren = targetChildren,\n    newSourceChildren = sourceChildren;\n  if (!isTargetInsideSource) newSourceChildren = newSourceChildren[\"delete\"](from.get(\"id\"));\n  if (isSameParent) {\n    newTargetChildren = newSourceChildren;\n  } else if (isSourceInsideTarget) {\n    newTargetChildren = newTargetChildren.updateIn(expandTreeSubpath(sourceSubpathFromTarget, \"children1\"), function (_oldChildren) {\n      return newSourceChildren;\n    });\n  }\n  if (placement == constants.PLACEMENT_BEFORE || placement == constants.PLACEMENT_AFTER) {\n    newTargetChildren = Immutable.OrderedMap().withMutations(function (r) {\n      var _iterator = _createForOfIteratorHelper(newTargetChildren.entries()),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _step$value = _slicedToArray(_step.value, 2),\n            itemId = _step$value[0],\n            item = _step$value[1];\n          if (itemId == to.get(\"id\") && placement == constants.PLACEMENT_BEFORE) {\n            r.set(from.get(\"id\"), from);\n          }\n          r.set(itemId, item);\n          if (itemId == to.get(\"id\") && placement == constants.PLACEMENT_AFTER) {\n            r.set(from.get(\"id\"), from);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    });\n  } else if (placement == constants.PLACEMENT_APPEND) {\n    newTargetChildren = newTargetChildren.merge(_defineProperty({}, from.get(\"id\"), from));\n  } else if (placement == constants.PLACEMENT_PREPEND) {\n    newTargetChildren = Immutable.OrderedMap(_defineProperty({}, from.get(\"id\"), from)).merge(newTargetChildren);\n  }\n  if (isTargetInsideSource) {\n    newSourceChildren = newSourceChildren.updateIn(expandTreeSubpath(targetSubpathFromSource, \"children1\"), function (_oldChildren) {\n      return newTargetChildren;\n    });\n    newSourceChildren = newSourceChildren[\"delete\"](from.get(\"id\"));\n  }\n  if (!isSameParent && !isSourceInsideTarget) state = state.updateIn(expandTreePath(sourcePath, \"children1\"), function (_oldChildren) {\n    return newSourceChildren;\n  });\n  if (!isTargetInsideSource) state = state.updateIn(expandTreePath(targetPath, \"children1\"), function (_oldChildren) {\n    return newTargetChildren;\n  });\n  state = fixPathsInTree(state);\n  return state;\n};\n\n/**\n * @param {Immutable.Map} state\n * @param {Immutable.List} path\n * @param {string} field\n */\nvar setField = function setField(state, path, newField, config) {\n  if (!newField) return removeItem(state, path);\n  var _config$settings2 = config.settings,\n    fieldSeparator = _config$settings2.fieldSeparator,\n    setOpOnChangeField = _config$settings2.setOpOnChangeField,\n    showErrorMessage = _config$settings2.showErrorMessage;\n  if (Array.isArray(newField)) newField = newField.join(fieldSeparator);\n  var currentType = state.getIn(expandTreePath(path, \"type\"));\n  var currentProperties = state.getIn(expandTreePath(path, \"properties\"));\n  var wasRuleGroup = currentType == \"rule_group\";\n  var newFieldConfig = getFieldConfig(config, newField);\n  var isRuleGroup = newFieldConfig.type == \"!group\";\n  var isRuleGroupExt = isRuleGroup && newFieldConfig.mode == \"array\";\n  var isChangeToAnotherType = wasRuleGroup != isRuleGroup;\n  var currentOperator = currentProperties.get(\"operator\");\n  var currentOperatorOptions = currentProperties.get(\"operatorOptions\");\n  var _currentField = currentProperties.get(\"field\");\n  var _currentValue = currentProperties.get(\"value\");\n  var _currentValueSrc = currentProperties.get(\"valueSrc\", new Immutable.List());\n  var _currentValueType = currentProperties.get(\"valueType\", new Immutable.List());\n\n  // If the newly selected field supports the same operator the rule currently\n  // uses, keep it selected.\n  var lastOp = newFieldConfig && newFieldConfig.operators.indexOf(currentOperator) !== -1 ? currentOperator : null;\n  var newOperator = null;\n  var availOps = getOperatorsForField(config, newField);\n  if (availOps && availOps.length == 1) newOperator = availOps[0];else if (availOps && availOps.length > 1) {\n    var _iterator2 = _createForOfIteratorHelper(setOpOnChangeField || []),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var strategy = _step2.value;\n        if (strategy == \"keep\" && !isChangeToAnotherType) newOperator = lastOp;else if (strategy == \"default\") newOperator = defaultOperator(config, newField, false);else if (strategy == \"first\") newOperator = getFirstOperator(config, newField);\n        if (newOperator)\n          //found op for strategy\n          break;\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  }\n  if (!isRuleGroup && !newFieldConfig.operators) {\n    console.warn(\"Type \".concat(newFieldConfig.type, \" is not supported\"));\n    return state;\n  }\n  if (wasRuleGroup && !isRuleGroup) {\n    state = state.setIn(expandTreePath(path, \"type\"), \"rule\");\n    state = state.deleteIn(expandTreePath(path, \"children1\"));\n    state = state.setIn(expandTreePath(path, \"properties\"), new Immutable.OrderedMap());\n  }\n  if (isRuleGroup) {\n    state = state.setIn(expandTreePath(path, \"type\"), \"rule_group\");\n    var _getNewValueForFieldO = getNewValueForFieldOp(config, config, currentProperties, newField, newOperator, \"field\", true),\n      canReuseValue = _getNewValueForFieldO.canReuseValue,\n      newValue = _getNewValueForFieldO.newValue,\n      newValueSrc = _getNewValueForFieldO.newValueSrc,\n      newValueType = _getNewValueForFieldO.newValueType,\n      operatorCardinality = _getNewValueForFieldO.operatorCardinality;\n    var groupProperties = defaultGroupProperties(config, newFieldConfig).merge({\n      field: newField,\n      mode: newFieldConfig.mode\n    });\n    if (isRuleGroupExt) {\n      groupProperties = groupProperties.merge({\n        operator: newOperator,\n        value: newValue,\n        valueSrc: newValueSrc,\n        valueType: newValueType\n      });\n    }\n    state = state.setIn(expandTreePath(path, \"children1\"), new Immutable.OrderedMap());\n    state = state.setIn(expandTreePath(path, \"properties\"), groupProperties);\n    if (newFieldConfig.initialEmptyWhere && operatorCardinality == 1) {// just `COUNT(grp) > 1` without `HAVING ..`\n      // no childeren\n    } else {\n      state = addItem(state, path, \"rule\", uuid(), defaultRuleProperties(config, newField), config);\n    }\n    state = fixPathsInTree(state);\n    return state;\n  }\n  return state.updateIn(expandTreePath(path, \"properties\"), function (map) {\n    return map.withMutations(function (current) {\n      var _getNewValueForFieldO2 = getNewValueForFieldOp(config, config, current, newField, newOperator, \"field\", true),\n        canReuseValue = _getNewValueForFieldO2.canReuseValue,\n        newValue = _getNewValueForFieldO2.newValue,\n        newValueSrc = _getNewValueForFieldO2.newValueSrc,\n        newValueType = _getNewValueForFieldO2.newValueType,\n        newValueError = _getNewValueForFieldO2.newValueError;\n      if (showErrorMessage) {\n        current = current.set(\"valueError\", newValueError);\n      }\n      var newOperatorOptions = canReuseValue ? currentOperatorOptions : defaultOperatorOptions(config, newOperator, newField);\n      return current.set(\"field\", newField).set(\"operator\", newOperator).set(\"operatorOptions\", newOperatorOptions).set(\"value\", newValue).set(\"valueSrc\", newValueSrc).set(\"valueType\", newValueType)[\"delete\"](\"asyncListValues\");\n    });\n  });\n};\n\n/**\n * @param {Immutable.Map} state\n * @param {Immutable.List} path\n * @param {string} operator\n */\nvar setOperator = function setOperator(state, path, newOperator, config) {\n  var showErrorMessage = config.settings.showErrorMessage;\n  var properties = state.getIn(expandTreePath(path, \"properties\"));\n  var children = state.getIn(expandTreePath(path, \"children1\"));\n  var currentField = properties.get(\"field\");\n  var fieldConfig = getFieldConfig(config, currentField);\n  var isRuleGroup = fieldConfig.type == \"!group\";\n  var operatorConfig = getOperatorConfig(config, newOperator, currentField);\n  var operatorCardinality = operatorConfig ? defaultValue(operatorConfig.cardinality, 1) : null;\n  state = state.updateIn(expandTreePath(path, \"properties\"), function (map) {\n    return map.withMutations(function (current) {\n      var currentField = current.get(\"field\");\n      var currentOperatorOptions = current.get(\"operatorOptions\");\n      var _currentValue = current.get(\"value\", new Immutable.List());\n      var _currentValueSrc = current.get(\"valueSrc\", new Immutable.List());\n      var _currentOperator = current.get(\"operator\");\n      var _getNewValueForFieldO3 = getNewValueForFieldOp(config, config, current, currentField, newOperator, \"operator\", true),\n        canReuseValue = _getNewValueForFieldO3.canReuseValue,\n        newValue = _getNewValueForFieldO3.newValue,\n        newValueSrc = _getNewValueForFieldO3.newValueSrc,\n        newValueType = _getNewValueForFieldO3.newValueType,\n        newValueError = _getNewValueForFieldO3.newValueError;\n      if (showErrorMessage) {\n        current = current.set(\"valueError\", newValueError);\n      }\n      var newOperatorOptions = canReuseValue ? currentOperatorOptions : defaultOperatorOptions(config, newOperator, currentField);\n      if (!canReuseValue) {\n        current = current[\"delete\"](\"asyncListValues\");\n      }\n      return current.set(\"operator\", newOperator).set(\"operatorOptions\", newOperatorOptions).set(\"value\", newValue).set(\"valueSrc\", newValueSrc).set(\"valueType\", newValueType);\n    });\n  });\n  if (isRuleGroup) {\n    if (operatorCardinality == 0 && children.size == 0) {\n      state = addItem(state, path, \"rule\", uuid(), defaultRuleProperties(config, currentField), config);\n    }\n  }\n  return state;\n};\n\n/**\n * @param {Immutable.Map} state\n * @param {Immutable.List} path\n * @param {integer} delta\n * @param {*} value\n * @param {string} valueType\n * @param {*} asyncListValues\n * @param {boolean} __isInternal\n */\nvar setValue = function setValue(state, path, delta, value, valueType, config, asyncListValues, __isInternal) {\n  var _config$settings3 = config.settings,\n    fieldSeparator = _config$settings3.fieldSeparator,\n    showErrorMessage = _config$settings3.showErrorMessage;\n  var isInternalValueChange;\n  var valueSrc = state.getIn(expandTreePath(path, \"properties\", \"valueSrc\", delta + \"\")) || null;\n  if (valueSrc === \"field\" && Array.isArray(value)) value = value.join(fieldSeparator);\n  var field = state.getIn(expandTreePath(path, \"properties\", \"field\")) || null;\n  var operator = state.getIn(expandTreePath(path, \"properties\", \"operator\")) || null;\n  var operatorConfig = getOperatorConfig(config, operator, field);\n  var operatorCardinality = operator ? defaultValue(operatorConfig.cardinality, 1) : null;\n  var isEndValue = false;\n  var calculatedValueType = valueType || calculateValueType(value, valueSrc, config);\n  var canFix = false;\n  var _validateValue = validateValue(config, field, field, operator, value, calculatedValueType, valueSrc, asyncListValues, canFix, isEndValue),\n    _validateValue2 = _slicedToArray(_validateValue, 2),\n    validateError = _validateValue2[0],\n    fixedValue = _validateValue2[1];\n  var isValid = !validateError;\n  if (fixedValue !== value) {\n    // eg, get exact value from listValues (not string)\n    value = fixedValue;\n  }\n\n  // Additional validation for range values\n  if (showErrorMessage) {\n    var w = getWidgetForFieldOp(config, field, operator, valueSrc);\n    var fieldWidgetDefinition = getFieldWidgetConfig(config, field, operator, w, valueSrc);\n    var valueSrcs = Array.from({\n      length: operatorCardinality\n    }, function (_, i) {\n      return state.getIn(expandTreePath(path, \"properties\", \"valueSrc\", i + \"\")) || null;\n    });\n    if (operatorConfig && operatorConfig.validateValues && valueSrcs.filter(function (vs) {\n      return vs == \"value\" || vs == null;\n    }).length == operatorCardinality) {\n      var values = Array.from({\n        length: operatorCardinality\n      }, function (_, i) {\n        return i == delta ? value : state.getIn(expandTreePath(path, \"properties\", \"value\", i + \"\")) || null;\n      });\n      var jsValues = fieldWidgetDefinition && fieldWidgetDefinition.toJS ? values.map(function (v) {\n        return fieldWidgetDefinition.toJS(v, fieldWidgetDefinition);\n      }) : values;\n      var rangeValidateError = operatorConfig.validateValues(jsValues);\n      state = state.setIn(expandTreePath(path, \"properties\", \"valueError\", operatorCardinality), rangeValidateError);\n    }\n  }\n  var lastValueArr = state.getIn(expandTreePath(path, \"properties\", \"value\"));\n  if (!lastValueArr) {\n    state = state.setIn(expandTreePath(path, \"properties\", \"value\"), new Immutable.List(new Array(operatorCardinality))).setIn(expandTreePath(path, \"properties\", \"valueType\"), new Immutable.List(new Array(operatorCardinality))).setIn(expandTreePath(path, \"properties\", \"valueError\"), new Immutable.List(new Array(operatorCardinality)));\n  }\n  var lastValue = state.getIn(expandTreePath(path, \"properties\", \"value\", delta + \"\"));\n  var lastError = state.getIn(expandTreePath(path, \"properties\", \"valueError\", delta));\n  var isLastEmpty = lastValue == undefined;\n  var isLastError = !!lastError;\n  if (isValid || showErrorMessage) {\n    state = state.deleteIn(expandTreePath(path, \"properties\", \"asyncListValues\"));\n    // set only good value\n    if (typeof value === \"undefined\") {\n      state = state.setIn(expandTreePath(path, \"properties\", \"value\", delta + \"\"), undefined);\n      state = state.setIn(expandTreePath(path, \"properties\", \"valueType\", delta + \"\"), null);\n    } else {\n      if (asyncListValues) {\n        state = state.setIn(expandTreePath(path, \"properties\", \"asyncListValues\"), asyncListValues);\n      }\n      state = state.setIn(expandTreePath(path, \"properties\", \"value\", delta + \"\"), value);\n      state = state.setIn(expandTreePath(path, \"properties\", \"valueType\", delta + \"\"), calculatedValueType);\n      isInternalValueChange = __isInternal && !isLastEmpty && !isLastError;\n    }\n  }\n  if (showErrorMessage) {\n    state = state.setIn(expandTreePath(path, \"properties\", \"valueError\", delta), validateError);\n  }\n  if (__isInternal && (isValid && isLastError || !isValid && !isLastError)) {\n    state = state.setIn(expandTreePath(path, \"properties\", \"valueError\", delta), validateError);\n    isInternalValueChange = false;\n  }\n  return {\n    tree: state,\n    isInternalValueChange: isInternalValueChange\n  };\n};\n\n/**\n * @param {Immutable.Map} state\n * @param {Immutable.List} path\n * @param {integer} delta\n * @param {*} srcKey\n */\nvar setValueSrc = function setValueSrc(state, path, delta, srcKey, config) {\n  var showErrorMessage = config.settings.showErrorMessage;\n  var field = state.getIn(expandTreePath(path, \"properties\", \"field\")) || null;\n  var operator = state.getIn(expandTreePath(path, \"properties\", \"operator\")) || null;\n  state = state.setIn(expandTreePath(path, \"properties\", \"value\", delta + \"\"), undefined);\n  state = state.setIn(expandTreePath(path, \"properties\", \"valueType\", delta + \"\"), null);\n  state = state.deleteIn(expandTreePath(path, \"properties\", \"asyncListValues\"));\n  if (showErrorMessage) {\n    // clear value error\n    state = state.setIn(expandTreePath(path, \"properties\", \"valueError\", delta), null);\n\n    // if current operator is range, clear possible range error\n    var operatorConfig = getOperatorConfig(config, operator, field);\n    var operatorCardinality = operator ? defaultValue(operatorConfig.cardinality, 1) : null;\n    if (operatorConfig.validateValues) {\n      state = state.setIn(expandTreePath(path, \"properties\", \"valueError\", operatorCardinality), null);\n    }\n  }\n\n  // set valueSrc\n  if (typeof srcKey === \"undefined\") {\n    state = state.setIn(expandTreePath(path, \"properties\", \"valueSrc\", delta + \"\"), null);\n  } else {\n    state = state.setIn(expandTreePath(path, \"properties\", \"valueSrc\", delta + \"\"), srcKey);\n  }\n\n  // maybe set default value\n  if (srcKey) {\n    var properties = state.getIn(expandTreePath(path, \"properties\"));\n    // this call should return canReuseValue = false and provide default value\n    var _getNewValueForFieldO4 = getNewValueForFieldOp(config, config, properties, field, operator, \"valueSrc\", true),\n      canReuseValue = _getNewValueForFieldO4.canReuseValue,\n      newValue = _getNewValueForFieldO4.newValue,\n      newValueSrc = _getNewValueForFieldO4.newValueSrc,\n      newValueType = _getNewValueForFieldO4.newValueType,\n      newValueError = _getNewValueForFieldO4.newValueError;\n    if (!canReuseValue && newValueSrc.get(delta) == srcKey) {\n      state = state.setIn(expandTreePath(path, \"properties\", \"value\", delta + \"\"), newValue.get(delta));\n      state = state.setIn(expandTreePath(path, \"properties\", \"valueType\", delta + \"\"), newValueType.get(delta));\n    }\n  }\n  return state;\n};\n\n/**\n * @param {Immutable.Map} state\n * @param {Immutable.List} path\n * @param {string} name\n * @param {*} value\n */\nvar setOperatorOption = function setOperatorOption(state, path, name, value) {\n  return state.setIn(expandTreePath(path, \"properties\", \"operatorOptions\", name), value);\n};\n\n/**\n * @param {Immutable.Map} state\n */\nvar checkEmptyGroups = function checkEmptyGroups(state, config) {\n  var canLeaveEmptyGroup = config.settings.canLeaveEmptyGroup;\n  if (!canLeaveEmptyGroup) {\n    state = fixEmptyGroupsInTree(state);\n  }\n  return state;\n};\n\n/**\n * \n */\nvar calculateValueType = function calculateValueType(value, valueSrc, config) {\n  var calculatedValueType = null;\n  if (value) {\n    if (valueSrc === \"field\") {\n      var fieldConfig = getFieldConfig(config, value);\n      if (fieldConfig) {\n        calculatedValueType = fieldConfig.type;\n      }\n    } else if (valueSrc === \"func\") {\n      var funcKey = value.get(\"func\");\n      if (funcKey) {\n        var funcConfig = getFuncConfig(config, funcKey);\n        if (funcConfig) {\n          calculatedValueType = funcConfig.returnType;\n        }\n      }\n    }\n  }\n  return calculatedValueType;\n};\nvar getField = function getField(state, path) {\n  var field = state.getIn(expandTreePath(path, \"properties\", \"field\")) || null;\n  return field;\n};\nvar emptyDrag = {\n  dragging: {\n    id: null,\n    x: null,\n    y: null,\n    w: null,\n    h: null\n  },\n  mousePos: {},\n  dragStart: {\n    id: null\n  }\n};\nvar getActionMeta = function getActionMeta(action, state) {\n  if (!action || !action.type) return null;\n  var actionKeysToOmit = [\"config\", \"asyncListValues\", \"__isInternal\"];\n  var actionTypesToIgnore = [constants.SET_TREE, constants.SET_DRAG_START, constants.SET_DRAG_PROGRESS, constants.SET_DRAG_END];\n  var meta = mapValues(omit(action, actionKeysToOmit), applyToJS);\n  var affectedField = action.path && getField(state.tree, action.path) || action.field;\n  if (affectedField) meta.affectedField = affectedField;\n  if (actionTypesToIgnore.includes(action.type) || action.type.indexOf(\"@@redux\") == 0) meta = null;\n  return meta;\n};\n\n/**\n * @param {Immutable.Map} state\n * @param {object} action\n */\nexport default (function (config, tree, getMemoizedTree) {\n  var emptyTree = defaultRoot(config);\n  var initTree = tree || emptyTree;\n  var emptyState = _objectSpread({\n    tree: initTree\n  }, emptyDrag);\n  return function () {\n    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : emptyState;\n    var action = arguments.length > 1 ? arguments[1] : undefined;\n    var unset = {\n      __isInternalValueChange: undefined,\n      __lastAction: undefined\n    };\n    var set = {};\n    var actionMeta = getActionMeta(action, state);\n    switch (action === null || action === void 0 ? void 0 : action.type) {\n      case constants.SET_TREE:\n        {\n          var validatedTree = getMemoizedTree(action.config, action.tree);\n          set.tree = validatedTree;\n          break;\n        }\n      case constants.ADD_CASE_GROUP:\n        {\n          set.tree = addNewGroup(state.tree, action.path, \"case_group\", action.id, action.properties, action.config, action.children, action.meta);\n          break;\n        }\n      case constants.ADD_GROUP:\n        {\n          set.tree = addNewGroup(state.tree, action.path, \"group\", action.id, action.properties, action.config, action.children, action.meta);\n          break;\n        }\n      case constants.REMOVE_GROUP:\n        {\n          set.tree = removeGroup(state.tree, action.path, action.config);\n          break;\n        }\n      case constants.ADD_RULE:\n        {\n          set.tree = addItem(state.tree, action.path, action.ruleType, action.id, action.properties, action.config, action.children);\n          break;\n        }\n      case constants.REMOVE_RULE:\n        {\n          set.tree = removeRule(state.tree, action.path, action.config);\n          break;\n        }\n      case constants.SET_CONJUNCTION:\n        {\n          set.tree = setConjunction(state.tree, action.path, action.conjunction);\n          break;\n        }\n      case constants.SET_NOT:\n        {\n          set.tree = setNot(state.tree, action.path, action.not);\n          break;\n        }\n      case constants.SET_FIELD:\n        {\n          set.tree = setField(state.tree, action.path, action.field, action.config);\n          break;\n        }\n      case constants.SET_LOCK:\n        {\n          set.tree = setLock(state.tree, action.path, action.lock);\n          break;\n        }\n      case constants.SET_OPERATOR:\n        {\n          set.tree = setOperator(state.tree, action.path, action.operator, action.config);\n          break;\n        }\n      case constants.SET_VALUE:\n        {\n          var _setValue = setValue(state.tree, action.path, action.delta, action.value, action.valueType, action.config, action.asyncListValues, action.__isInternal),\n            _tree = _setValue.tree,\n            isInternalValueChange = _setValue.isInternalValueChange;\n          set.__isInternalValueChange = isInternalValueChange;\n          set.tree = _tree;\n          break;\n        }\n      case constants.SET_VALUE_SRC:\n        {\n          set.tree = setValueSrc(state.tree, action.path, action.delta, action.srcKey, action.config);\n          break;\n        }\n      case constants.SET_OPERATOR_OPTION:\n        {\n          set.tree = setOperatorOption(state.tree, action.path, action.name, action.value);\n          break;\n        }\n      case constants.MOVE_ITEM:\n        {\n          set.tree = moveItem(state.tree, action.fromPath, action.toPath, action.placement, action.config);\n          break;\n        }\n      case constants.SET_DRAG_START:\n        {\n          set.dragStart = action.dragStart;\n          set.dragging = action.dragging;\n          set.mousePos = action.mousePos;\n          break;\n        }\n      case constants.SET_DRAG_PROGRESS:\n        {\n          set.mousePos = action.mousePos;\n          set.dragging = action.dragging;\n          break;\n        }\n      case constants.SET_DRAG_END:\n        {\n          set.tree = checkEmptyGroups(state.tree, config);\n          set = _objectSpread(_objectSpread({}, set), emptyDrag);\n          break;\n        }\n      default:\n        {\n          break;\n        }\n    }\n    if (actionMeta) {\n      set.__lastAction = actionMeta;\n    }\n    return _objectSpread(_objectSpread(_objectSpread({}, state), unset), set);\n  };\n});"]},"metadata":{},"sourceType":"module"}