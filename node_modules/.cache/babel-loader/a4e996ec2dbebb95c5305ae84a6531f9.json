{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\n\nimport { getNestedValue } from './index';\nimport { filterBy as filterByCommon, orderBy as orderByCommon } from '@progress/kendo-react-data-tools';\nimport { mapTree as mapTreeCommon, mapTreeItem as mapTreeItemCommon, extendDataItem as extendDataItemCommon, getItemPath as getItemPathCommon } from '@progress/kendo-react-common';\n/**\n * Orders the specified tree according to the provided sort descriptors.\n *\n * @param {T[]} data - The data that will be sorted.\n * @param {SortDescriptor[]} descriptors - The descriptors by which the data will be sorted.\n * @param {string} subItemsField - The field which points to the subitems collection of each data item.\n * @returns {T[]} - The sorted data.\n */\n\nexport function orderBy(data, descriptors, subItemsField) {\n  return orderByCommon(data, descriptors, subItemsField);\n}\n/**\n * Filters the provided data tree according to the specified `Array<FilterDescriptor|CompositeFilterDescriptor>`.\n *\n * @param {T[]} data - The data that will be filtered.\n * @param {FilterDescriptor[]|CompositeFilterDescriptor[]} descriptors - The filter criteria that will be applied.\n * @param {string} subItemsField - The field which points to the subitems collection of each data item.\n * @returns {T[]} - The filtered data.\n */\n\nexport function filterBy(data, descriptors, subItemsField) {\n  return filterByCommon(data, descriptors, subItemsField);\n}\n/**\n * Creates a new array with the results of calling the provided callback function\n * on every element in the provided data tree.\n *\n * @param {any[]} tree - The data tree.\n * @param {string} subItemsField - The field which points to the subitems collection of each data item.\n * @param {(value: any) => any} callback - The callback function.\n * @returns {any[]} - The new data tree.\n */\n\nexport var mapTree = function (tree, subItemsField, callback) {\n  return mapTreeCommon(tree, subItemsField, callback);\n};\n/**\n * Creates a new array with the results of calling the provided callback function\n * on the element which match the `level` in the provided data tree.\n *\n * @param {any[]} tree - The data tree.\n * @param {number[]} level - An array of indexes of each parent and current item in the data tree.\n * @param {string} subItemsField - The field which points to the subitems collection of each data item.\n * @param {(value: any) => any} callback - The callback function.\n * @returns {any[]} - The new data tree.\n */\n\nexport var mapTreeItem = function (tree, level, subItemsField, callback) {\n  return mapTreeItemCommon(tree, level, subItemsField, callback);\n};\n/**\n * @hidden\n */\n\nexport function flatData(data, getChildren, itemMap) {\n  var stack = [];\n  var flatted = []; // we start from end as push() improves performance by up to 50%\n\n  for (var i = data.length - 1; i >= 0; i--) {\n    var root = data[i];\n    stack.push({\n      root: root,\n      data: getChildren(root),\n      level: [i],\n      levelCount: data.length\n    });\n  }\n\n  while (stack.length > 0) {\n    var stackItem = stack.pop();\n    flatted.push(__assign(__assign({\n      dataItem: stackItem.root,\n      level: __spreadArray([], stackItem.level, true)\n    }, itemMap(stackItem.root)), {\n      levelCount: stackItem.levelCount\n    }));\n\n    if (stackItem.data.length) {\n      for (var i = stackItem.data.length - 1; i >= 0; i--) {\n        var root = stackItem.data[i];\n        stack.push({\n          root: root,\n          data: getChildren(root),\n          level: __spreadArray(__spreadArray([], stackItem.level, true), [i], false),\n          levelCount: stackItem.data.length\n        });\n      }\n    }\n  }\n\n  return flatted;\n}\n/**\n * Creates a flat data array from the passed tree dataset.\n *\n * @param {object[]} dataset - The source dataset of data items.\n * @param {string} expandField - The field which points to the expanded value of each data item.\n * @param {string} subItemsField - The field which points to the subitems collection of each data item.\n * @returns {object[]} - A collection of the generated data items that are in a flat structure.\n */\n\nexport var treeToFlat = function (data, expandField, subItemsField) {\n  var expanded = function (dataItem) {\n    return Boolean(getNestedValue(expandField, dataItem));\n  };\n\n  var hasChildren = function (dataItem) {\n    return Boolean(getNestedValue(subItemsField, dataItem));\n  };\n\n  var getChildren = function (dataItem) {\n    var items = [];\n\n    if (expanded(dataItem) && hasChildren(dataItem)) {\n      items.push.apply(items, getNestedValue(subItemsField, dataItem));\n    }\n\n    return items;\n  };\n\n  var flatItems = function (dataItem, flatted, level) {\n    flatted.push(__assign(__assign({}, dataItem), {\n      level: level\n    }));\n    getChildren(dataItem).forEach(function (root) {\n      return flatItems(root, flatted, level + 1);\n    });\n  };\n\n  var flattedData = [];\n  data.forEach(function (root) {\n    return flatItems(root, flattedData, 0);\n  });\n  return flattedData;\n};\n/**\n * Creates a tree from the passed dataset.\n *\n * @param {object[]} dataset - The source dataset of data items.\n * @param {(item: object) => any} getId - A function which will return the id of the data item.\n * @param {(item: object) => any} getParentId - A function which will return the data item id of its parent data item.\n * @param {string} subItemsField - The field which points to the subitems collection of each data item.\n * @returns {object[]} - A collection of the generated data items that are structured in a tree.\n */\n\nexport var createDataTree = function (dataset, getId, getParentId, subItemsField) {\n  var hashTable = {},\n      dataTree = [],\n      parentItem;\n  dataset.forEach(function (dataItem) {\n    return hashTable[getId(dataItem)] = __assign({}, dataItem);\n  });\n  dataset.forEach(function (dataItem) {\n    parentItem = hashTable[getParentId(dataItem)];\n\n    if (parentItem) {\n      parentItem[subItemsField] = parentItem[subItemsField] || [];\n      parentItem[subItemsField].push(hashTable[getId(dataItem)]);\n    } else {\n      dataTree.push(hashTable[getId(dataItem)]);\n    }\n  });\n  return dataTree;\n};\n/**\n * Similar to the `Object.assign` function. Additionally, creates a new array for the subitems.\n *\n * @param {object} item - The source data item.\n * @param {string} subItemsField - The field which points to the subitems collection of each data item.\n * @param {object} propsToExtend - The props with which the source data item will be extended.\n * @returns {object} - The target data item.\n */\n\nexport var extendDataItem = function (item, subItemsField, propsToExtend) {\n  return extendDataItemCommon(item, subItemsField, propsToExtend);\n};\n/**\n * Removes the items from the passed `data` which match the passed `condition`.\n *\n * @param {any[]} data - The data tree.\n * @param {string} subItemsField - The field which points to the subitems collection of each data item.\n * @param {(item: object) => Boolean} condition - A function that will be executed for each data item\n * in the tree data and the items for which returns true will be removed.\n * @returns {any[]} - The new data tree.\n */\n\nexport var removeItems = function (data, subItemsField, condition) {\n  var _a;\n\n  var newData = mapTree([(_a = {}, _a[subItemsField] = __spreadArray([], data, true), _a)], subItemsField, function (item) {\n    return removeChild(item, condition, subItemsField);\n  });\n  return __spreadArray([], newData[0][subItemsField], true);\n};\n/**\n * @hidden\n */\n\nvar removeChild = function (item, condition, subItemsField) {\n  var _a;\n\n  var subItems = item[subItemsField] || [];\n  var childIndex = subItems.findIndex(condition);\n\n  if (childIndex !== -1) {\n    var newChildren = __spreadArray([], subItems, true);\n\n    newChildren.splice(childIndex, 1);\n    return __assign(__assign({}, item), (_a = {}, _a[subItemsField] = newChildren, _a));\n  }\n\n  return item;\n};\n/**\n * Changes the `subItems` collection of each data item which matches the passed `condition`.\n *\n * @param {any[]} data - The data tree.\n * @param {string} subItemsField - The field which points to the subitems collection of each data item.\n * @param {(item: object) => Boolean} condition - A function that will be executed for each data item and\n * will return `true` for items that have to change the subitems collection.\n * @param {(subItems: object[]) => object[]} change - A function which\n * has as a parameter the subitems collection of the matched items and which will return the new subitems collection.\n * @returns {any[]} - The new data tree.\n */\n\n\nexport var modifySubItems = function (data, subItemsField, condition, change) {\n  return mapTree(data, subItemsField, function (item) {\n    var _a;\n\n    return condition(item) ? __assign(__assign({}, item), (_a = {}, _a[subItemsField] = change(item[subItemsField] || []), _a)) : item;\n  });\n};\n/**\n * Returns the data item path in the tree based on the level parameter.\n *\n * @param {any[]} tree - The data tree.\n * @param {number[]} level - The level of the target tree item.\n * @param {string} subItemsField - The field which points to the subitems collection of each data item.\n * @returns {any[]} - The path of the data item.\n */\n\nexport var getItemPath = function (tree, level, subItemsField) {\n  return getItemPathCommon(tree, level, subItemsField);\n};\n/**\n * Moves the targeted item in the tree to another position.\n *\n * @param {any[]} data - The data tree.\n * @param {number[]} target - The level of the target tree item which will be moved.\n * @param {number[] | null} destination - The level of the destination tree item where the target item will be moved in.\n * If it is null, the target item will be added at the root level.\n * @param {string} subItemsField - The field which points to the subitems collection of each data item.\n * @returns {any[]} - The new data tree.\n */\n\nexport var moveTreeItem = function (data, target, destination, subItemsField) {\n  var tree = __spreadArray([], data, true);\n\n  var targetItemPath = getItemPath(tree, target, subItemsField);\n  var targetItem = targetItemPath.pop();\n  var targetParent = targetItemPath.pop();\n  var targetItemIndex = target[target.length - 1];\n\n  if (destination) {\n    var destinationItemPath = getItemPath(tree, destination, subItemsField);\n    var destinationItem = destinationItemPath.pop();\n    (targetParent ? targetParent[subItemsField] : tree).splice(targetItemIndex, 1);\n    destinationItem[subItemsField] = destinationItem[subItemsField] || [];\n    destinationItem[subItemsField].push(targetItem);\n  } else {\n    (targetParent ? targetParent[subItemsField] : tree).splice(targetItemIndex, 1);\n    tree.push(targetItem);\n  }\n\n  return tree;\n};","map":{"version":3,"sources":["E:/WorkingFolder/React_Postgres/ALPD/SOURCE-512/QuaLISWeb/node_modules/@progress/kendo-react-treelist/dist/es/utils/data-operations.js"],"names":["__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","__spreadArray","to","from","pack","l","ar","Array","slice","concat","getNestedValue","filterBy","filterByCommon","orderBy","orderByCommon","mapTree","mapTreeCommon","mapTreeItem","mapTreeItemCommon","extendDataItem","extendDataItemCommon","getItemPath","getItemPathCommon","data","descriptors","subItemsField","tree","callback","level","flatData","getChildren","itemMap","stack","flatted","root","push","levelCount","stackItem","pop","dataItem","treeToFlat","expandField","expanded","Boolean","hasChildren","items","flatItems","forEach","flattedData","createDataTree","dataset","getId","getParentId","hashTable","dataTree","parentItem","item","propsToExtend","removeItems","condition","_a","newData","removeChild","subItems","childIndex","findIndex","newChildren","splice","modifySubItems","change","moveTreeItem","target","destination","targetItemPath","targetItem","targetParent","targetItemIndex","destinationItemPath","destinationItem"],"mappings":"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","sourcesContent":["var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { getNestedValue } from './index';\nimport { filterBy as filterByCommon, orderBy as orderByCommon } from '@progress/kendo-react-data-tools';\nimport { mapTree as mapTreeCommon, mapTreeItem as mapTreeItemCommon, extendDataItem as extendDataItemCommon, getItemPath as getItemPathCommon } from '@progress/kendo-react-common';\n/**\n * Orders the specified tree according to the provided sort descriptors.\n *\n * @param {T[]} data - The data that will be sorted.\n * @param {SortDescriptor[]} descriptors - The descriptors by which the data will be sorted.\n * @param {string} subItemsField - The field which points to the subitems collection of each data item.\n * @returns {T[]} - The sorted data.\n */\nexport function orderBy(data, descriptors, subItemsField) {\n    return orderByCommon(data, descriptors, subItemsField);\n}\n/**\n * Filters the provided data tree according to the specified `Array<FilterDescriptor|CompositeFilterDescriptor>`.\n *\n * @param {T[]} data - The data that will be filtered.\n * @param {FilterDescriptor[]|CompositeFilterDescriptor[]} descriptors - The filter criteria that will be applied.\n * @param {string} subItemsField - The field which points to the subitems collection of each data item.\n * @returns {T[]} - The filtered data.\n */\nexport function filterBy(data, descriptors, subItemsField) {\n    return filterByCommon(data, descriptors, subItemsField);\n}\n/**\n * Creates a new array with the results of calling the provided callback function\n * on every element in the provided data tree.\n *\n * @param {any[]} tree - The data tree.\n * @param {string} subItemsField - The field which points to the subitems collection of each data item.\n * @param {(value: any) => any} callback - The callback function.\n * @returns {any[]} - The new data tree.\n */\nexport var mapTree = function (tree, subItemsField, callback) {\n    return mapTreeCommon(tree, subItemsField, callback);\n};\n/**\n * Creates a new array with the results of calling the provided callback function\n * on the element which match the `level` in the provided data tree.\n *\n * @param {any[]} tree - The data tree.\n * @param {number[]} level - An array of indexes of each parent and current item in the data tree.\n * @param {string} subItemsField - The field which points to the subitems collection of each data item.\n * @param {(value: any) => any} callback - The callback function.\n * @returns {any[]} - The new data tree.\n */\nexport var mapTreeItem = function (tree, level, subItemsField, callback) {\n    return mapTreeItemCommon(tree, level, subItemsField, callback);\n};\n/**\n * @hidden\n */\nexport function flatData(data, getChildren, itemMap) {\n    var stack = [];\n    var flatted = [];\n    // we start from end as push() improves performance by up to 50%\n    for (var i = data.length - 1; i >= 0; i--) {\n        var root = data[i];\n        stack.push({\n            root: root,\n            data: getChildren(root),\n            level: [i],\n            levelCount: data.length\n        });\n    }\n    while (stack.length > 0) {\n        var stackItem = stack.pop();\n        flatted.push(__assign(__assign({ dataItem: stackItem.root, level: __spreadArray([], stackItem.level, true) }, itemMap(stackItem.root)), { levelCount: stackItem.levelCount }));\n        if (stackItem.data.length) {\n            for (var i = stackItem.data.length - 1; i >= 0; i--) {\n                var root = stackItem.data[i];\n                stack.push({\n                    root: root,\n                    data: getChildren(root),\n                    level: __spreadArray(__spreadArray([], stackItem.level, true), [i], false),\n                    levelCount: stackItem.data.length\n                });\n            }\n        }\n    }\n    return flatted;\n}\n/**\n * Creates a flat data array from the passed tree dataset.\n *\n * @param {object[]} dataset - The source dataset of data items.\n * @param {string} expandField - The field which points to the expanded value of each data item.\n * @param {string} subItemsField - The field which points to the subitems collection of each data item.\n * @returns {object[]} - A collection of the generated data items that are in a flat structure.\n */\nexport var treeToFlat = function (data, expandField, subItemsField) {\n    var expanded = function (dataItem) { return Boolean(getNestedValue(expandField, dataItem)); };\n    var hasChildren = function (dataItem) { return Boolean(getNestedValue(subItemsField, dataItem)); };\n    var getChildren = function (dataItem) {\n        var items = [];\n        if (expanded(dataItem) && hasChildren(dataItem)) {\n            items.push.apply(items, getNestedValue(subItemsField, dataItem));\n        }\n        return items;\n    };\n    var flatItems = function (dataItem, flatted, level) {\n        flatted.push(__assign(__assign({}, dataItem), { level: level }));\n        getChildren(dataItem).forEach(function (root) { return flatItems(root, flatted, level + 1); });\n    };\n    var flattedData = [];\n    data.forEach(function (root) { return flatItems(root, flattedData, 0); });\n    return flattedData;\n};\n/**\n * Creates a tree from the passed dataset.\n *\n * @param {object[]} dataset - The source dataset of data items.\n * @param {(item: object) => any} getId - A function which will return the id of the data item.\n * @param {(item: object) => any} getParentId - A function which will return the data item id of its parent data item.\n * @param {string} subItemsField - The field which points to the subitems collection of each data item.\n * @returns {object[]} - A collection of the generated data items that are structured in a tree.\n */\nexport var createDataTree = function (dataset, getId, getParentId, subItemsField) {\n    var hashTable = {}, dataTree = [], parentItem;\n    dataset.forEach(function (dataItem) { return hashTable[getId(dataItem)] = __assign({}, dataItem); });\n    dataset.forEach(function (dataItem) {\n        parentItem = hashTable[getParentId(dataItem)];\n        if (parentItem) {\n            parentItem[subItemsField] = parentItem[subItemsField] || [];\n            parentItem[subItemsField].push(hashTable[getId(dataItem)]);\n        }\n        else {\n            dataTree.push(hashTable[getId(dataItem)]);\n        }\n    });\n    return dataTree;\n};\n/**\n * Similar to the `Object.assign` function. Additionally, creates a new array for the subitems.\n *\n * @param {object} item - The source data item.\n * @param {string} subItemsField - The field which points to the subitems collection of each data item.\n * @param {object} propsToExtend - The props with which the source data item will be extended.\n * @returns {object} - The target data item.\n */\nexport var extendDataItem = function (item, subItemsField, propsToExtend) {\n    return extendDataItemCommon(item, subItemsField, propsToExtend);\n};\n/**\n * Removes the items from the passed `data` which match the passed `condition`.\n *\n * @param {any[]} data - The data tree.\n * @param {string} subItemsField - The field which points to the subitems collection of each data item.\n * @param {(item: object) => Boolean} condition - A function that will be executed for each data item\n * in the tree data and the items for which returns true will be removed.\n * @returns {any[]} - The new data tree.\n */\nexport var removeItems = function (data, subItemsField, condition) {\n    var _a;\n    var newData = mapTree([(_a = {}, _a[subItemsField] = __spreadArray([], data, true), _a)], subItemsField, function (item) { return removeChild(item, condition, subItemsField); });\n    return __spreadArray([], newData[0][subItemsField], true);\n};\n/**\n * @hidden\n */\nvar removeChild = function (item, condition, subItemsField) {\n    var _a;\n    var subItems = item[subItemsField] || [];\n    var childIndex = subItems.findIndex(condition);\n    if (childIndex !== -1) {\n        var newChildren = __spreadArray([], subItems, true);\n        newChildren.splice(childIndex, 1);\n        return __assign(__assign({}, item), (_a = {}, _a[subItemsField] = newChildren, _a));\n    }\n    return item;\n};\n/**\n * Changes the `subItems` collection of each data item which matches the passed `condition`.\n *\n * @param {any[]} data - The data tree.\n * @param {string} subItemsField - The field which points to the subitems collection of each data item.\n * @param {(item: object) => Boolean} condition - A function that will be executed for each data item and\n * will return `true` for items that have to change the subitems collection.\n * @param {(subItems: object[]) => object[]} change - A function which\n * has as a parameter the subitems collection of the matched items and which will return the new subitems collection.\n * @returns {any[]} - The new data tree.\n */\nexport var modifySubItems = function (data, subItemsField, condition, change) {\n    return mapTree(data, subItemsField, function (item) {\n        var _a;\n        return condition(item) ? __assign(__assign({}, item), (_a = {}, _a[subItemsField] = change(item[subItemsField] || []), _a)) :\n            item;\n    });\n};\n/**\n * Returns the data item path in the tree based on the level parameter.\n *\n * @param {any[]} tree - The data tree.\n * @param {number[]} level - The level of the target tree item.\n * @param {string} subItemsField - The field which points to the subitems collection of each data item.\n * @returns {any[]} - The path of the data item.\n */\nexport var getItemPath = function (tree, level, subItemsField) {\n    return getItemPathCommon(tree, level, subItemsField);\n};\n/**\n * Moves the targeted item in the tree to another position.\n *\n * @param {any[]} data - The data tree.\n * @param {number[]} target - The level of the target tree item which will be moved.\n * @param {number[] | null} destination - The level of the destination tree item where the target item will be moved in.\n * If it is null, the target item will be added at the root level.\n * @param {string} subItemsField - The field which points to the subitems collection of each data item.\n * @returns {any[]} - The new data tree.\n */\nexport var moveTreeItem = function (data, target, destination, subItemsField) {\n    var tree = __spreadArray([], data, true);\n    var targetItemPath = getItemPath(tree, target, subItemsField);\n    var targetItem = targetItemPath.pop();\n    var targetParent = targetItemPath.pop();\n    var targetItemIndex = target[target.length - 1];\n    if (destination) {\n        var destinationItemPath = getItemPath(tree, destination, subItemsField);\n        var destinationItem = destinationItemPath.pop();\n        (targetParent ? targetParent[subItemsField] : tree).splice(targetItemIndex, 1);\n        destinationItem[subItemsField] = destinationItem[subItemsField] || [];\n        destinationItem[subItemsField].push(targetItem);\n    }\n    else {\n        (targetParent ? targetParent[subItemsField] : tree).splice(targetItemIndex, 1);\n        tree.push(targetItem);\n    }\n    return tree;\n};\n"]},"metadata":{},"sourceType":"module"}