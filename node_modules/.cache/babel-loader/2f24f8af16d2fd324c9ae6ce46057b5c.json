{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _typeof = require(\"@babel/runtime/helpers/typeof\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _immutable = _interopRequireDefault(require(\"immutable\"));\n\nvar _treeUtils = require(\"../utils/treeUtils\");\n\nvar _defaultUtils = require(\"../utils/defaultUtils\");\n\nvar constants = _interopRequireWildcard(require(\"../constants\"));\n\nvar _uuid = _interopRequireDefault(require(\"../utils/uuid\"));\n\nvar _configUtils = require(\"../utils/configUtils\");\n\nvar _ruleUtils = require(\"../utils/ruleUtils\");\n\nvar _stuff = require(\"../utils/stuff\");\n\nvar _validation = require(\"../utils/validation\");\n\nvar _omit = _interopRequireDefault(require(\"lodash/omit\"));\n\nvar _mapValues = _interopRequireDefault(require(\"lodash/mapValues\"));\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n    return {\n      \"default\": obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache(nodeInterop);\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj[\"default\"] = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n  if (!it) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2[\"default\"])(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n/**\n * @param {object} config\n * @param {Immutable.List} path\n * @param {Immutable.Map} properties\n */\n\n\nvar addNewGroup = function addNewGroup(state, path, groupUuid, properties, config) {\n  var children = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n  var rulesNumber = (0, _treeUtils.getTotalRulesCountInTree)(state);\n  var groupPath = path.push(groupUuid);\n  var _config$settings = config.settings,\n      maxNumberOfRules = _config$settings.maxNumberOfRules,\n      shouldCreateEmptyGroup = _config$settings.shouldCreateEmptyGroup;\n  var canAddNewRule = !(maxNumberOfRules && rulesNumber + 1 > maxNumberOfRules);\n  state = addItem(state, path, \"group\", groupUuid, (0, _defaultUtils.defaultGroupProperties)(config).merge(properties || {}), config, children);\n\n  if (!children) {\n    state = state.setIn((0, _treeUtils.expandTreePath)(groupPath, \"children1\"), new _immutable[\"default\"].OrderedMap()); // Add one empty rule into new group\n\n    if (canAddNewRule && !shouldCreateEmptyGroup) {\n      state = addItem(state, groupPath, \"rule\", (0, _uuid[\"default\"])(), (0, _defaultUtils.defaultRuleProperties)(config), config);\n    }\n  }\n\n  state = (0, _treeUtils.fixPathsInTree)(state);\n  return state;\n};\n/**\n * @param {object} config\n * @param {Immutable.List} path\n * @param {Immutable.Map} properties\n */\n\n\nvar removeGroup = function removeGroup(state, path, config) {\n  state = removeItem(state, path);\n  var canLeaveEmptyGroup = config.settings.canLeaveEmptyGroup;\n  var parentPath = path.slice(0, -1);\n  var isEmptyParentGroup = !(0, _treeUtils.hasChildren)(state, parentPath);\n\n  if (isEmptyParentGroup && !canLeaveEmptyGroup) {\n    // check ancestors for emptiness (and delete 'em if empty)\n    state = (0, _treeUtils.fixEmptyGroupsInTree)(state);\n\n    if ((0, _treeUtils.isEmptyTree)(state) && !canLeaveEmptyGroup) {\n      // if whole query is empty, add one empty rule to root\n      state = addItem(state, new _immutable[\"default\"].List(), \"rule\", (0, _uuid[\"default\"])(), (0, _defaultUtils.defaultRuleProperties)(config), config);\n    }\n  }\n\n  state = (0, _treeUtils.fixPathsInTree)(state);\n  return state;\n};\n/**\n * @param {object} config\n * @param {Immutable.List} path\n */\n\n\nvar removeRule = function removeRule(state, path, config) {\n  state = removeItem(state, path);\n  var canLeaveEmptyGroup = config.settings.canLeaveEmptyGroup;\n  var parentPath = path.pop();\n  var parent = state.getIn((0, _treeUtils.expandTreePath)(parentPath));\n  var parentField = parent.getIn([\"properties\", \"field\"]);\n  var parentOperator = parent.getIn([\"properties\", \"operator\"]);\n  var parentValue = parent.getIn([\"properties\", \"value\", 0]);\n  var parentFieldConfig = parentField ? (0, _configUtils.getFieldConfig)(config, parentField) : null;\n  var parentOperatorConfig = parentOperator ? (0, _configUtils.getOperatorConfig)(config, parentOperator, parentField) : null;\n  var hasGroupCountRule = parentField && parentOperator && parentOperatorConfig.cardinality != 0; // && parentValue != undefined;\n\n  var isParentRuleGroup = parent.get(\"type\") == \"rule_group\";\n  var isEmptyParentGroup = !(0, _treeUtils.hasChildren)(state, parentPath);\n  var canLeaveEmpty = isParentRuleGroup ? hasGroupCountRule && parentFieldConfig.initialEmptyWhere : canLeaveEmptyGroup;\n\n  if (isEmptyParentGroup && !canLeaveEmpty) {\n    if (isParentRuleGroup) {\n      // deleted last rule from rule_group, so delete whole rule_group\n      state = state.deleteIn((0, _treeUtils.expandTreePath)(parentPath));\n    } // check ancestors for emptiness (and delete 'em if empty)\n\n\n    state = (0, _treeUtils.fixEmptyGroupsInTree)(state);\n\n    if ((0, _treeUtils.isEmptyTree)(state) && !canLeaveEmptyGroup) {\n      // if whole query is empty, add one empty rule to root\n      state = addItem(state, new _immutable[\"default\"].List(), \"rule\", (0, _uuid[\"default\"])(), (0, _defaultUtils.defaultRuleProperties)(config), config);\n    }\n  }\n\n  state = (0, _treeUtils.fixPathsInTree)(state);\n  return state;\n};\n/**\n * @param {Immutable.Map} state\n * @param {Immutable.List} path\n * @param {bool} not\n */\n\n\nvar setNot = function setNot(state, path, not) {\n  return state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"not\"), not);\n};\n/**\n * @param {Immutable.Map} state\n * @param {Immutable.List} path\n * @param {string} conjunction\n */\n\n\nvar setConjunction = function setConjunction(state, path, conjunction) {\n  return state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"conjunction\"), conjunction);\n}; // convert children deeply from JS to Immutable\n\n\nvar _addChildren1 = function _addChildren1(config, item, children) {\n  if (children && Array.isArray(children)) {\n    item.children1 = new _immutable[\"default\"].OrderedMap(children.reduce(function (map, it) {\n      var id1 = (0, _uuid[\"default\"])();\n\n      var it1 = _objectSpread(_objectSpread({}, it), {}, {\n        properties: (0, _defaultUtils.defaultItemProperties)(config, it).merge(it.properties || {}),\n        id: id1\n      });\n\n      _addChildren1(config, it1, it1.children1); //todo: guarantee order\n\n\n      return _objectSpread(_objectSpread({}, map), {}, (0, _defineProperty2[\"default\"])({}, id1, new _immutable[\"default\"].Map(it1)));\n    }, {}));\n  }\n};\n/**\n * @param {Immutable.Map} state\n * @param {Immutable.List} path\n * @param {string} type\n * @param {string} id\n * @param {Immutable.OrderedMap} properties\n * @param {object} config\n */\n\n\nvar addItem = function addItem(state, path, type, id, properties, config) {\n  var children = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n  var rulesNumber = (0, _treeUtils.getTotalRulesCountInTree)(state);\n  var maxNumberOfRules = config.settings.maxNumberOfRules;\n  var canAddNewRule = !(type == \"rule\" && maxNumberOfRules && rulesNumber + 1 > maxNumberOfRules);\n  var item = {\n    type: type,\n    id: id,\n    properties: properties\n  };\n\n  _addChildren1(config, item, children);\n\n  if (canAddNewRule) {\n    var childrenPath = (0, _treeUtils.expandTreePath)(path, \"children1\");\n\n    var _hasChildren = !!state.getIn(childrenPath);\n\n    var newChildren = new _immutable[\"default\"].OrderedMap((0, _defineProperty2[\"default\"])({}, id, new _immutable[\"default\"].Map(item)));\n\n    if (!_hasChildren) {\n      state = state.setIn(childrenPath, newChildren);\n    } else {\n      state = state.mergeIn(childrenPath, newChildren);\n    }\n  }\n\n  state = (0, _treeUtils.fixPathsInTree)(state);\n  return state;\n};\n/**\n * @param {Immutable.Map} state\n * @param {Immutable.List} path\n */\n\n\nvar removeItem = function removeItem(state, path) {\n  state = state.deleteIn((0, _treeUtils.expandTreePath)(path));\n  state = (0, _treeUtils.fixPathsInTree)(state);\n  return state;\n};\n/**\n * @param {Immutable.Map} state\n * @param {Immutable.List} fromPath\n * @param {Immutable.List} toPath\n * @param {string} placement, see constants PLACEMENT_*: PLACEMENT_AFTER, PLACEMENT_BEFORE, PLACEMENT_APPEND, PLACEMENT_PREPEND\n * @param {object} config\n */\n\n\nvar moveItem = function moveItem(state, fromPath, toPath, placement, config) {\n  var from = (0, _treeUtils.getItemByPath)(state, fromPath);\n  var sourcePath = fromPath.pop();\n  var source = fromPath.size > 1 ? (0, _treeUtils.getItemByPath)(state, sourcePath) : null;\n  var sourceChildren = source ? source.get(\"children1\") : null;\n  var to = (0, _treeUtils.getItemByPath)(state, toPath);\n  var targetPath = placement == constants.PLACEMENT_APPEND || placement == constants.PLACEMENT_PREPEND ? toPath : toPath.pop();\n  var target = placement == constants.PLACEMENT_APPEND || placement == constants.PLACEMENT_PREPEND ? to : toPath.size > 1 ? (0, _treeUtils.getItemByPath)(state, targetPath) : null;\n  var targetChildren = target ? target.get(\"children1\") : null;\n  if (!source || !target) return state;\n  var isSameParent = source.get(\"id\") == target.get(\"id\");\n  var isSourceInsideTarget = targetPath.size < sourcePath.size && (0, _stuff.deepEqual)(targetPath.toArray(), sourcePath.toArray().slice(0, targetPath.size));\n  var isTargetInsideSource = targetPath.size > sourcePath.size && (0, _stuff.deepEqual)(sourcePath.toArray(), targetPath.toArray().slice(0, sourcePath.size));\n  var sourceSubpathFromTarget = null;\n  var targetSubpathFromSource = null;\n\n  if (isSourceInsideTarget) {\n    sourceSubpathFromTarget = _immutable[\"default\"].List(sourcePath.toArray().slice(targetPath.size));\n  } else if (isTargetInsideSource) {\n    targetSubpathFromSource = _immutable[\"default\"].List(targetPath.toArray().slice(sourcePath.size));\n  }\n\n  var newTargetChildren = targetChildren,\n      newSourceChildren = sourceChildren;\n  if (!isTargetInsideSource) newSourceChildren = newSourceChildren[\"delete\"](from.get(\"id\"));\n\n  if (isSameParent) {\n    newTargetChildren = newSourceChildren;\n  } else if (isSourceInsideTarget) {\n    newTargetChildren = newTargetChildren.updateIn((0, _treeUtils.expandTreeSubpath)(sourceSubpathFromTarget, \"children1\"), function (_oldChildren) {\n      return newSourceChildren;\n    });\n  }\n\n  if (placement == constants.PLACEMENT_BEFORE || placement == constants.PLACEMENT_AFTER) {\n    newTargetChildren = _immutable[\"default\"].OrderedMap().withMutations(function (r) {\n      var _iterator = _createForOfIteratorHelper(newTargetChildren.entries()),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _step$value = (0, _slicedToArray2[\"default\"])(_step.value, 2),\n              itemId = _step$value[0],\n              item = _step$value[1];\n\n          if (itemId == to.get(\"id\") && placement == constants.PLACEMENT_BEFORE) {\n            r.set(from.get(\"id\"), from);\n          }\n\n          r.set(itemId, item);\n\n          if (itemId == to.get(\"id\") && placement == constants.PLACEMENT_AFTER) {\n            r.set(from.get(\"id\"), from);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    });\n  } else if (placement == constants.PLACEMENT_APPEND) {\n    newTargetChildren = newTargetChildren.merge((0, _defineProperty2[\"default\"])({}, from.get(\"id\"), from));\n  } else if (placement == constants.PLACEMENT_PREPEND) {\n    newTargetChildren = _immutable[\"default\"].OrderedMap((0, _defineProperty2[\"default\"])({}, from.get(\"id\"), from)).merge(newTargetChildren);\n  }\n\n  if (isTargetInsideSource) {\n    newSourceChildren = newSourceChildren.updateIn((0, _treeUtils.expandTreeSubpath)(targetSubpathFromSource, \"children1\"), function (_oldChildren) {\n      return newTargetChildren;\n    });\n    newSourceChildren = newSourceChildren[\"delete\"](from.get(\"id\"));\n  }\n\n  if (!isSameParent && !isSourceInsideTarget) state = state.updateIn((0, _treeUtils.expandTreePath)(sourcePath, \"children1\"), function (_oldChildren) {\n    return newSourceChildren;\n  });\n  if (!isTargetInsideSource) state = state.updateIn((0, _treeUtils.expandTreePath)(targetPath, \"children1\"), function (_oldChildren) {\n    return newTargetChildren;\n  });\n  state = (0, _treeUtils.fixPathsInTree)(state);\n  return state;\n};\n/**\n * @param {Immutable.Map} state\n * @param {Immutable.List} path\n * @param {string} field\n */\n\n\nvar setField = function setField(state, path, newField, config) {\n  if (!newField) return removeItem(state, path);\n  var _config$settings2 = config.settings,\n      fieldSeparator = _config$settings2.fieldSeparator,\n      setOpOnChangeField = _config$settings2.setOpOnChangeField,\n      showErrorMessage = _config$settings2.showErrorMessage;\n  if (Array.isArray(newField)) newField = newField.join(fieldSeparator);\n  var currentType = state.getIn((0, _treeUtils.expandTreePath)(path, \"type\"));\n  var currentProperties = state.getIn((0, _treeUtils.expandTreePath)(path, \"properties\"));\n  var wasRuleGroup = currentType == \"rule_group\";\n  var newFieldConfig = (0, _configUtils.getFieldConfig)(config, newField);\n  var isRuleGroup = newFieldConfig.type == \"!group\";\n  var isRuleGroupExt = isRuleGroup && newFieldConfig.mode == \"array\";\n  var isChangeToAnotherType = wasRuleGroup != isRuleGroup;\n  var currentOperator = currentProperties.get(\"operator\");\n  var currentOperatorOptions = currentProperties.get(\"operatorOptions\");\n\n  var _currentField = currentProperties.get(\"field\");\n\n  var _currentValue = currentProperties.get(\"value\");\n\n  var _currentValueSrc = currentProperties.get(\"valueSrc\", new _immutable[\"default\"].List());\n\n  var _currentValueType = currentProperties.get(\"valueType\", new _immutable[\"default\"].List()); // If the newly selected field supports the same operator the rule currently\n  // uses, keep it selected.\n\n\n  var lastOp = newFieldConfig && newFieldConfig.operators.indexOf(currentOperator) !== -1 ? currentOperator : null;\n  var newOperator = null;\n  var availOps = (0, _ruleUtils.getOperatorsForField)(config, newField);\n  if (availOps && availOps.length == 1) newOperator = availOps[0];else if (availOps && availOps.length > 1) {\n    var _iterator2 = _createForOfIteratorHelper(setOpOnChangeField || []),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var strategy = _step2.value;\n        if (strategy == \"keep\" && !isChangeToAnotherType) newOperator = lastOp;else if (strategy == \"default\") newOperator = (0, _defaultUtils.defaultOperator)(config, newField, false);else if (strategy == \"first\") newOperator = (0, _ruleUtils.getFirstOperator)(config, newField);\n        if (newOperator) //found op for strategy\n          break;\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  }\n\n  if (!isRuleGroup && !newFieldConfig.operators) {\n    console.warn(\"Type \".concat(newFieldConfig.type, \" is not supported\"));\n    return state;\n  }\n\n  if (wasRuleGroup && !isRuleGroup) {\n    state = state.setIn((0, _treeUtils.expandTreePath)(path, \"type\"), \"rule\");\n    state = state.deleteIn((0, _treeUtils.expandTreePath)(path, \"children1\"));\n    state = state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\"), new _immutable[\"default\"].OrderedMap());\n  }\n\n  if (isRuleGroup) {\n    state = state.setIn((0, _treeUtils.expandTreePath)(path, \"type\"), \"rule_group\");\n\n    var _getNewValueForFieldO = (0, _ruleUtils.getNewValueForFieldOp)(config, config, currentProperties, newField, newOperator, \"field\", true),\n        canReuseValue = _getNewValueForFieldO.canReuseValue,\n        newValue = _getNewValueForFieldO.newValue,\n        newValueSrc = _getNewValueForFieldO.newValueSrc,\n        newValueType = _getNewValueForFieldO.newValueType,\n        operatorCardinality = _getNewValueForFieldO.operatorCardinality;\n\n    var groupProperties = (0, _defaultUtils.defaultGroupProperties)(config, newFieldConfig).merge({\n      field: newField,\n      mode: newFieldConfig.mode\n    });\n\n    if (isRuleGroupExt) {\n      groupProperties = groupProperties.merge({\n        operator: newOperator,\n        value: newValue,\n        valueSrc: newValueSrc,\n        valueType: newValueType\n      });\n    }\n\n    state = state.setIn((0, _treeUtils.expandTreePath)(path, \"children1\"), new _immutable[\"default\"].OrderedMap());\n    state = state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\"), groupProperties);\n\n    if (newFieldConfig.initialEmptyWhere && operatorCardinality == 1) {// just `COUNT(grp) > 1` without `HAVING ..`\n      // no childeren\n    } else {\n      state = addItem(state, path, \"rule\", (0, _uuid[\"default\"])(), (0, _defaultUtils.defaultRuleProperties)(config, newField), config);\n    }\n\n    state = (0, _treeUtils.fixPathsInTree)(state);\n    return state;\n  }\n\n  return state.updateIn((0, _treeUtils.expandTreePath)(path, \"properties\"), function (map) {\n    return map.withMutations(function (current) {\n      var _getNewValueForFieldO2 = (0, _ruleUtils.getNewValueForFieldOp)(config, config, current, newField, newOperator, \"field\", true),\n          canReuseValue = _getNewValueForFieldO2.canReuseValue,\n          newValue = _getNewValueForFieldO2.newValue,\n          newValueSrc = _getNewValueForFieldO2.newValueSrc,\n          newValueType = _getNewValueForFieldO2.newValueType,\n          newValueError = _getNewValueForFieldO2.newValueError;\n\n      if (showErrorMessage) {\n        current = current.set(\"valueError\", newValueError);\n      }\n\n      var newOperatorOptions = canReuseValue ? currentOperatorOptions : (0, _defaultUtils.defaultOperatorOptions)(config, newOperator, newField);\n      return current.set(\"field\", newField).set(\"operator\", newOperator).set(\"operatorOptions\", newOperatorOptions).set(\"value\", newValue).set(\"valueSrc\", newValueSrc).set(\"valueType\", newValueType)[\"delete\"](\"asyncListValues\");\n    });\n  });\n};\n/**\n * @param {Immutable.Map} state\n * @param {Immutable.List} path\n * @param {string} operator\n */\n\n\nvar setOperator = function setOperator(state, path, newOperator, config) {\n  var showErrorMessage = config.settings.showErrorMessage;\n  var properties = state.getIn((0, _treeUtils.expandTreePath)(path, \"properties\"));\n  var children = state.getIn((0, _treeUtils.expandTreePath)(path, \"children1\"));\n  var currentField = properties.get(\"field\");\n  var fieldConfig = (0, _configUtils.getFieldConfig)(config, currentField);\n  var isRuleGroup = fieldConfig.type == \"!group\";\n  var operatorConfig = (0, _configUtils.getOperatorConfig)(config, newOperator, currentField);\n  var operatorCardinality = operatorConfig ? (0, _stuff.defaultValue)(operatorConfig.cardinality, 1) : null;\n  state = state.updateIn((0, _treeUtils.expandTreePath)(path, \"properties\"), function (map) {\n    return map.withMutations(function (current) {\n      var currentField = current.get(\"field\");\n      var currentOperatorOptions = current.get(\"operatorOptions\");\n\n      var _currentValue = current.get(\"value\", new _immutable[\"default\"].List());\n\n      var _currentValueSrc = current.get(\"valueSrc\", new _immutable[\"default\"].List());\n\n      var _currentOperator = current.get(\"operator\");\n\n      var _getNewValueForFieldO3 = (0, _ruleUtils.getNewValueForFieldOp)(config, config, current, currentField, newOperator, \"operator\", true),\n          canReuseValue = _getNewValueForFieldO3.canReuseValue,\n          newValue = _getNewValueForFieldO3.newValue,\n          newValueSrc = _getNewValueForFieldO3.newValueSrc,\n          newValueType = _getNewValueForFieldO3.newValueType,\n          newValueError = _getNewValueForFieldO3.newValueError;\n\n      if (showErrorMessage) {\n        current = current.set(\"valueError\", newValueError);\n      }\n\n      var newOperatorOptions = canReuseValue ? currentOperatorOptions : (0, _defaultUtils.defaultOperatorOptions)(config, newOperator, currentField);\n\n      if (!canReuseValue) {\n        current = current[\"delete\"](\"asyncListValues\");\n      }\n\n      return current.set(\"operator\", newOperator).set(\"operatorOptions\", newOperatorOptions).set(\"value\", newValue).set(\"valueSrc\", newValueSrc).set(\"valueType\", newValueType);\n    });\n  });\n\n  if (isRuleGroup) {\n    if (operatorCardinality == 0 && children.size == 0) {\n      state = addItem(state, path, \"rule\", (0, _uuid[\"default\"])(), (0, _defaultUtils.defaultRuleProperties)(config, currentField), config);\n    }\n  }\n\n  return state;\n};\n/**\n * @param {Immutable.Map} state\n * @param {Immutable.List} path\n * @param {integer} delta\n * @param {*} value\n * @param {string} valueType\n * @param {*} asyncListValues\n * @param {boolean} __isInternal\n */\n\n\nvar setValue = function setValue(state, path, delta, value, valueType, config, asyncListValues, __isInternal) {\n  var _config$settings3 = config.settings,\n      fieldSeparator = _config$settings3.fieldSeparator,\n      showErrorMessage = _config$settings3.showErrorMessage;\n  var isInternalValueChange;\n  var valueSrc = state.getIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"valueSrc\", delta + \"\")) || null;\n  if (valueSrc === \"field\" && Array.isArray(value)) value = value.join(fieldSeparator);\n  var field = state.getIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"field\")) || null;\n  var operator = state.getIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"operator\")) || null;\n  var isEndValue = false;\n  var canFix = false;\n  var calculatedValueType = valueType || calculateValueType(value, valueSrc, config);\n\n  var _validateValue = (0, _validation.validateValue)(config, field, field, operator, value, calculatedValueType, valueSrc, asyncListValues, canFix, isEndValue),\n      _validateValue2 = (0, _slicedToArray2[\"default\"])(_validateValue, 2),\n      validateError = _validateValue2[0],\n      fixedValue = _validateValue2[1];\n\n  var isValid = !validateError;\n\n  if (isValid && fixedValue !== value) {\n    // eg, get exact value from listValues (not string)\n    value = fixedValue;\n  } // Additional validation for range values\n\n\n  if (showErrorMessage) {\n    var w = (0, _ruleUtils.getWidgetForFieldOp)(config, field, operator, valueSrc);\n    var fieldWidgetDefinition = (0, _configUtils.getFieldWidgetConfig)(config, field, operator, w, valueSrc);\n    var operatorConfig = (0, _configUtils.getOperatorConfig)(config, operator, field);\n    var operatorCardinality = operator ? (0, _stuff.defaultValue)(operatorConfig.cardinality, 1) : null;\n    var valueSrcs = Array.from({\n      length: operatorCardinality\n    }, function (_, i) {\n      return state.getIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"valueSrc\", i + \"\")) || null;\n    });\n\n    if (operatorConfig && operatorConfig.validateValues && valueSrcs.filter(function (vs) {\n      return vs == \"value\" || vs == null;\n    }).length == operatorCardinality) {\n      var values = Array.from({\n        length: operatorCardinality\n      }, function (_, i) {\n        return i == delta ? value : state.getIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"value\", i + \"\")) || null;\n      });\n      var jsValues = fieldWidgetDefinition && fieldWidgetDefinition.toJS ? values.map(function (v) {\n        return fieldWidgetDefinition.toJS(v, fieldWidgetDefinition);\n      }) : values;\n      var rangeValidateError = operatorConfig.validateValues(jsValues);\n      state = state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"valueError\", operatorCardinality), rangeValidateError);\n    }\n  }\n\n  var lastValue = state.getIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"value\", delta + \"\"));\n  var lastError = state.getIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"valueError\", delta));\n  var isLastEmpty = lastValue == undefined;\n  var isLastError = !!lastError;\n\n  if (isValid || showErrorMessage) {\n    state = state.deleteIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"asyncListValues\")); // set only good value\n\n    if (typeof value === \"undefined\") {\n      state = state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"value\", delta + \"\"), undefined);\n      state = state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"valueType\", delta + \"\"), null);\n    } else {\n      if (asyncListValues) {\n        state = state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"asyncListValues\"), asyncListValues);\n      }\n\n      state = state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"value\", delta + \"\"), value);\n      state = state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"valueType\", delta + \"\"), calculatedValueType);\n      isInternalValueChange = __isInternal && !isLastEmpty && !isLastError;\n    }\n  }\n\n  if (showErrorMessage) {\n    state = state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"valueError\", delta), validateError);\n  }\n\n  if (__isInternal && (isValid && isLastError || !isValid && !isLastError)) {\n    state = state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"valueError\", delta), validateError);\n    isInternalValueChange = false;\n  }\n\n  return {\n    tree: state,\n    isInternalValueChange: isInternalValueChange\n  };\n};\n/**\n * @param {Immutable.Map} state\n * @param {Immutable.List} path\n * @param {integer} delta\n * @param {*} srcKey\n */\n\n\nvar setValueSrc = function setValueSrc(state, path, delta, srcKey, config) {\n  var showErrorMessage = config.settings.showErrorMessage;\n  state = state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"value\", delta + \"\"), undefined);\n  state = state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"valueType\", delta + \"\"), null);\n  state = state.deleteIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"asyncListValues\"));\n\n  if (showErrorMessage) {\n    // clear value error\n    state = state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"valueError\", delta), null); // if current operator is range, clear possible range error\n\n    var field = state.getIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"field\")) || null;\n    var operator = state.getIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"operator\")) || null;\n    var operatorConfig = (0, _configUtils.getOperatorConfig)(config, operator, field);\n    var operatorCardinality = operator ? (0, _stuff.defaultValue)(operatorConfig.cardinality, 1) : null;\n\n    if (operatorConfig.validateValues) {\n      state = state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"valueError\", operatorCardinality), null);\n    }\n  }\n\n  if (typeof srcKey === \"undefined\") {\n    state = state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"valueSrc\", delta + \"\"), null);\n  } else {\n    state = state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"valueSrc\", delta + \"\"), srcKey);\n  }\n\n  return state;\n};\n/**\n * @param {Immutable.Map} state\n * @param {Immutable.List} path\n * @param {string} name\n * @param {*} value\n */\n\n\nvar setOperatorOption = function setOperatorOption(state, path, name, value) {\n  return state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"operatorOptions\", name), value);\n};\n/**\n * @param {Immutable.Map} state\n */\n\n\nvar checkEmptyGroups = function checkEmptyGroups(state, config) {\n  var canLeaveEmptyGroup = config.settings.canLeaveEmptyGroup;\n\n  if (!canLeaveEmptyGroup) {\n    state = (0, _treeUtils.fixEmptyGroupsInTree)(state);\n  }\n\n  return state;\n};\n/**\n * \n */\n\n\nvar calculateValueType = function calculateValueType(value, valueSrc, config) {\n  var calculatedValueType = null;\n\n  if (value) {\n    if (valueSrc === \"field\") {\n      var fieldConfig = (0, _configUtils.getFieldConfig)(config, value);\n\n      if (fieldConfig) {\n        calculatedValueType = fieldConfig.type;\n      }\n    } else if (valueSrc === \"func\") {\n      var funcKey = value.get(\"func\");\n\n      if (funcKey) {\n        var funcConfig = (0, _configUtils.getFuncConfig)(config, funcKey);\n\n        if (funcConfig) {\n          calculatedValueType = funcConfig.returnType;\n        }\n      }\n    }\n  }\n\n  return calculatedValueType;\n};\n\nvar getField = function getField(state, path) {\n  var field = state.getIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"field\")) || null;\n  return field;\n};\n\nvar emptyDrag = {\n  dragging: {\n    id: null,\n    x: null,\n    y: null,\n    w: null,\n    h: null\n  },\n  mousePos: {},\n  dragStart: {\n    id: null\n  }\n};\n\nvar getActionMeta = function getActionMeta(action, state) {\n  var actionKeysToOmit = [\"config\", \"asyncListValues\", \"__isInternal\"];\n  var actionTypesToIgnore = [constants.SET_TREE, constants.SET_DRAG_START, constants.SET_DRAG_PROGRESS, constants.SET_DRAG_END];\n  var meta = (0, _mapValues[\"default\"])((0, _omit[\"default\"])(action, actionKeysToOmit), _stuff.applyToJS);\n  var affectedField = action.path && getField(state.tree, action.path) || action.field;\n  if (affectedField) meta.affectedField = affectedField;\n  if (actionTypesToIgnore.includes(action.type) || action.type.indexOf(\"@@redux\") == 0) meta = null;\n  return meta;\n};\n/**\n * @param {Immutable.Map} state\n * @param {object} action\n */\n\n\nvar _default = function _default(config) {\n  var emptyTree = (0, _defaultUtils.defaultRoot)(config);\n  var emptyState = Object.assign({}, {\n    tree: emptyTree\n  }, emptyDrag);\n  return function () {\n    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : emptyState;\n    var action = arguments.length > 1 ? arguments[1] : undefined;\n    var unset = {\n      __isInternalValueChange: undefined,\n      __lastAction: undefined\n    };\n    var set = {};\n    var actionMeta = getActionMeta(action, state);\n\n    switch (action.type) {\n      case constants.SET_TREE:\n        {\n          set.tree = action.tree;\n          break;\n        }\n\n      case constants.ADD_GROUP:\n        {\n          set.tree = addNewGroup(state.tree, action.path, action.id, action.properties, action.config, action.children);\n          break;\n        }\n\n      case constants.REMOVE_GROUP:\n        {\n          set.tree = removeGroup(state.tree, action.path, action.config);\n          break;\n        }\n\n      case constants.ADD_RULE:\n        {\n          set.tree = addItem(state.tree, action.path, action.ruleType, action.id, action.properties, action.config, action.children);\n          break;\n        }\n\n      case constants.REMOVE_RULE:\n        {\n          set.tree = removeRule(state.tree, action.path, action.config);\n          break;\n        }\n\n      case constants.SET_CONJUNCTION:\n        {\n          set.tree = setConjunction(state.tree, action.path, action.conjunction);\n          break;\n        }\n\n      case constants.SET_NOT:\n        {\n          set.tree = setNot(state.tree, action.path, action.not);\n          break;\n        }\n\n      case constants.SET_FIELD:\n        {\n          set.tree = setField(state.tree, action.path, action.field, action.config);\n          break;\n        }\n\n      case constants.SET_OPERATOR:\n        {\n          set.tree = setOperator(state.tree, action.path, action.operator, action.config);\n          break;\n        }\n\n      case constants.SET_VALUE:\n        {\n          var _setValue = setValue(state.tree, action.path, action.delta, action.value, action.valueType, action.config, action.asyncListValues, action.__isInternal),\n              tree = _setValue.tree,\n              isInternalValueChange = _setValue.isInternalValueChange;\n\n          set.__isInternalValueChange = isInternalValueChange;\n          set.tree = tree;\n          break;\n        }\n\n      case constants.SET_VALUE_SRC:\n        {\n          set.tree = setValueSrc(state.tree, action.path, action.delta, action.srcKey, action.config);\n          break;\n        }\n\n      case constants.SET_OPERATOR_OPTION:\n        {\n          set.tree = setOperatorOption(state.tree, action.path, action.name, action.value);\n          break;\n        }\n\n      case constants.MOVE_ITEM:\n        {\n          set.tree = moveItem(state.tree, action.fromPath, action.toPath, action.placement, action.config);\n          break;\n        }\n\n      case constants.SET_DRAG_START:\n        {\n          set.dragStart = action.dragStart;\n          set.dragging = action.dragging;\n          set.mousePos = action.mousePos;\n          break;\n        }\n\n      case constants.SET_DRAG_PROGRESS:\n        {\n          set.mousePos = action.mousePos;\n          set.dragging = action.dragging;\n          break;\n        }\n\n      case constants.SET_DRAG_END:\n        {\n          set.tree = checkEmptyGroups(state.tree, config);\n          set = _objectSpread(_objectSpread({}, set), emptyDrag);\n          break;\n        }\n\n      default:\n        {\n          break;\n        }\n    }\n\n    if (actionMeta) {\n      set.__lastAction = actionMeta;\n    }\n\n    return _objectSpread(_objectSpread(_objectSpread({}, state), unset), set);\n  };\n};\n\nexports[\"default\"] = _default;","map":{"version":3,"sources":["D:/LIMSWFH/LIMSPOSTGRESQL/QuaLISWeb/node_modules/react-awesome-query-builder/lib/stores/tree.js"],"names":["_interopRequireDefault","require","_typeof","Object","defineProperty","exports","value","_slicedToArray2","_defineProperty2","_immutable","_treeUtils","_defaultUtils","constants","_interopRequireWildcard","_uuid","_configUtils","_ruleUtils","_stuff","_validation","_omit","_mapValues","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","obj","__esModule","cache","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","_createForOfIteratorHelper","o","allowArrayLike","it","Symbol","iterator","Array","isArray","_unsupportedIterableToArray","length","i","F","s","n","done","e","_e","f","TypeError","normalCompletion","didErr","err","step","next","_e2","minLen","_arrayLikeToArray","toString","slice","constructor","name","from","test","arr","len","arr2","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","enumerable","push","apply","_objectSpread","target","arguments","source","forEach","getOwnPropertyDescriptors","defineProperties","addNewGroup","state","path","groupUuid","properties","config","children","undefined","rulesNumber","getTotalRulesCountInTree","groupPath","_config$settings","settings","maxNumberOfRules","shouldCreateEmptyGroup","canAddNewRule","addItem","defaultGroupProperties","merge","setIn","expandTreePath","OrderedMap","defaultRuleProperties","fixPathsInTree","removeGroup","removeItem","canLeaveEmptyGroup","parentPath","isEmptyParentGroup","hasChildren","fixEmptyGroupsInTree","isEmptyTree","List","removeRule","pop","parent","getIn","parentField","parentOperator","parentValue","parentFieldConfig","getFieldConfig","parentOperatorConfig","getOperatorConfig","hasGroupCountRule","cardinality","isParentRuleGroup","canLeaveEmpty","initialEmptyWhere","deleteIn","setNot","not","setConjunction","conjunction","_addChildren1","item","children1","reduce","map","id1","it1","defaultItemProperties","id","Map","type","childrenPath","_hasChildren","newChildren","mergeIn","moveItem","fromPath","toPath","placement","getItemByPath","sourcePath","size","sourceChildren","to","targetPath","PLACEMENT_APPEND","PLACEMENT_PREPEND","targetChildren","isSameParent","isSourceInsideTarget","deepEqual","toArray","isTargetInsideSource","sourceSubpathFromTarget","targetSubpathFromSource","newTargetChildren","newSourceChildren","updateIn","expandTreeSubpath","_oldChildren","PLACEMENT_BEFORE","PLACEMENT_AFTER","withMutations","r","_iterator","entries","_step","_step$value","itemId","setField","newField","_config$settings2","fieldSeparator","setOpOnChangeField","showErrorMessage","join","currentType","currentProperties","wasRuleGroup","newFieldConfig","isRuleGroup","isRuleGroupExt","mode","isChangeToAnotherType","currentOperator","currentOperatorOptions","_currentField","_currentValue","_currentValueSrc","_currentValueType","lastOp","operators","indexOf","newOperator","availOps","getOperatorsForField","_iterator2","_step2","strategy","defaultOperator","getFirstOperator","console","warn","concat","_getNewValueForFieldO","getNewValueForFieldOp","canReuseValue","newValue","newValueSrc","newValueType","operatorCardinality","groupProperties","field","operator","valueSrc","valueType","current","_getNewValueForFieldO2","newValueError","newOperatorOptions","defaultOperatorOptions","setOperator","currentField","fieldConfig","operatorConfig","defaultValue","_currentOperator","_getNewValueForFieldO3","setValue","delta","asyncListValues","__isInternal","_config$settings3","isInternalValueChange","isEndValue","canFix","calculatedValueType","calculateValueType","_validateValue","validateValue","_validateValue2","validateError","fixedValue","isValid","w","getWidgetForFieldOp","fieldWidgetDefinition","getFieldWidgetConfig","valueSrcs","_","validateValues","vs","values","jsValues","toJS","v","rangeValidateError","lastValue","lastError","isLastEmpty","isLastError","tree","setValueSrc","srcKey","setOperatorOption","checkEmptyGroups","funcKey","funcConfig","getFuncConfig","returnType","getField","emptyDrag","dragging","x","y","h","mousePos","dragStart","getActionMeta","action","actionKeysToOmit","actionTypesToIgnore","SET_TREE","SET_DRAG_START","SET_DRAG_PROGRESS","SET_DRAG_END","meta","applyToJS","affectedField","includes","_default","emptyTree","defaultRoot","emptyState","assign","unset","__isInternalValueChange","__lastAction","actionMeta","ADD_GROUP","REMOVE_GROUP","ADD_RULE","ruleType","REMOVE_RULE","SET_CONJUNCTION","SET_NOT","SET_FIELD","SET_OPERATOR","SET_VALUE","_setValue","SET_VALUE_SRC","SET_OPERATOR_OPTION","MOVE_ITEM"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _typeof = require(\"@babel/runtime/helpers/typeof\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _immutable = _interopRequireDefault(require(\"immutable\"));\n\nvar _treeUtils = require(\"../utils/treeUtils\");\n\nvar _defaultUtils = require(\"../utils/defaultUtils\");\n\nvar constants = _interopRequireWildcard(require(\"../constants\"));\n\nvar _uuid = _interopRequireDefault(require(\"../utils/uuid\"));\n\nvar _configUtils = require(\"../utils/configUtils\");\n\nvar _ruleUtils = require(\"../utils/ruleUtils\");\n\nvar _stuff = require(\"../utils/stuff\");\n\nvar _validation = require(\"../utils/validation\");\n\nvar _omit = _interopRequireDefault(require(\"lodash/omit\"));\n\nvar _mapValues = _interopRequireDefault(require(\"lodash/mapValues\"));\n\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\n\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") { return { \"default\": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj[\"default\"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2[\"default\"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n/**\n * @param {object} config\n * @param {Immutable.List} path\n * @param {Immutable.Map} properties\n */\nvar addNewGroup = function addNewGroup(state, path, groupUuid, properties, config) {\n  var children = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n  var rulesNumber = (0, _treeUtils.getTotalRulesCountInTree)(state);\n  var groupPath = path.push(groupUuid);\n  var _config$settings = config.settings,\n      maxNumberOfRules = _config$settings.maxNumberOfRules,\n      shouldCreateEmptyGroup = _config$settings.shouldCreateEmptyGroup;\n  var canAddNewRule = !(maxNumberOfRules && rulesNumber + 1 > maxNumberOfRules);\n  state = addItem(state, path, \"group\", groupUuid, (0, _defaultUtils.defaultGroupProperties)(config).merge(properties || {}), config, children);\n\n  if (!children) {\n    state = state.setIn((0, _treeUtils.expandTreePath)(groupPath, \"children1\"), new _immutable[\"default\"].OrderedMap()); // Add one empty rule into new group\n\n    if (canAddNewRule && !shouldCreateEmptyGroup) {\n      state = addItem(state, groupPath, \"rule\", (0, _uuid[\"default\"])(), (0, _defaultUtils.defaultRuleProperties)(config), config);\n    }\n  }\n\n  state = (0, _treeUtils.fixPathsInTree)(state);\n  return state;\n};\n/**\n * @param {object} config\n * @param {Immutable.List} path\n * @param {Immutable.Map} properties\n */\n\n\nvar removeGroup = function removeGroup(state, path, config) {\n  state = removeItem(state, path);\n  var canLeaveEmptyGroup = config.settings.canLeaveEmptyGroup;\n  var parentPath = path.slice(0, -1);\n  var isEmptyParentGroup = !(0, _treeUtils.hasChildren)(state, parentPath);\n\n  if (isEmptyParentGroup && !canLeaveEmptyGroup) {\n    // check ancestors for emptiness (and delete 'em if empty)\n    state = (0, _treeUtils.fixEmptyGroupsInTree)(state);\n\n    if ((0, _treeUtils.isEmptyTree)(state) && !canLeaveEmptyGroup) {\n      // if whole query is empty, add one empty rule to root\n      state = addItem(state, new _immutable[\"default\"].List(), \"rule\", (0, _uuid[\"default\"])(), (0, _defaultUtils.defaultRuleProperties)(config), config);\n    }\n  }\n\n  state = (0, _treeUtils.fixPathsInTree)(state);\n  return state;\n};\n/**\n * @param {object} config\n * @param {Immutable.List} path\n */\n\n\nvar removeRule = function removeRule(state, path, config) {\n  state = removeItem(state, path);\n  var canLeaveEmptyGroup = config.settings.canLeaveEmptyGroup;\n  var parentPath = path.pop();\n  var parent = state.getIn((0, _treeUtils.expandTreePath)(parentPath));\n  var parentField = parent.getIn([\"properties\", \"field\"]);\n  var parentOperator = parent.getIn([\"properties\", \"operator\"]);\n  var parentValue = parent.getIn([\"properties\", \"value\", 0]);\n  var parentFieldConfig = parentField ? (0, _configUtils.getFieldConfig)(config, parentField) : null;\n  var parentOperatorConfig = parentOperator ? (0, _configUtils.getOperatorConfig)(config, parentOperator, parentField) : null;\n  var hasGroupCountRule = parentField && parentOperator && parentOperatorConfig.cardinality != 0; // && parentValue != undefined;\n\n  var isParentRuleGroup = parent.get(\"type\") == \"rule_group\";\n  var isEmptyParentGroup = !(0, _treeUtils.hasChildren)(state, parentPath);\n  var canLeaveEmpty = isParentRuleGroup ? hasGroupCountRule && parentFieldConfig.initialEmptyWhere : canLeaveEmptyGroup;\n\n  if (isEmptyParentGroup && !canLeaveEmpty) {\n    if (isParentRuleGroup) {\n      // deleted last rule from rule_group, so delete whole rule_group\n      state = state.deleteIn((0, _treeUtils.expandTreePath)(parentPath));\n    } // check ancestors for emptiness (and delete 'em if empty)\n\n\n    state = (0, _treeUtils.fixEmptyGroupsInTree)(state);\n\n    if ((0, _treeUtils.isEmptyTree)(state) && !canLeaveEmptyGroup) {\n      // if whole query is empty, add one empty rule to root\n      state = addItem(state, new _immutable[\"default\"].List(), \"rule\", (0, _uuid[\"default\"])(), (0, _defaultUtils.defaultRuleProperties)(config), config);\n    }\n  }\n\n  state = (0, _treeUtils.fixPathsInTree)(state);\n  return state;\n};\n/**\n * @param {Immutable.Map} state\n * @param {Immutable.List} path\n * @param {bool} not\n */\n\n\nvar setNot = function setNot(state, path, not) {\n  return state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"not\"), not);\n};\n/**\n * @param {Immutable.Map} state\n * @param {Immutable.List} path\n * @param {string} conjunction\n */\n\n\nvar setConjunction = function setConjunction(state, path, conjunction) {\n  return state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"conjunction\"), conjunction);\n}; // convert children deeply from JS to Immutable\n\n\nvar _addChildren1 = function _addChildren1(config, item, children) {\n  if (children && Array.isArray(children)) {\n    item.children1 = new _immutable[\"default\"].OrderedMap(children.reduce(function (map, it) {\n      var id1 = (0, _uuid[\"default\"])();\n\n      var it1 = _objectSpread(_objectSpread({}, it), {}, {\n        properties: (0, _defaultUtils.defaultItemProperties)(config, it).merge(it.properties || {}),\n        id: id1\n      });\n\n      _addChildren1(config, it1, it1.children1); //todo: guarantee order\n\n\n      return _objectSpread(_objectSpread({}, map), {}, (0, _defineProperty2[\"default\"])({}, id1, new _immutable[\"default\"].Map(it1)));\n    }, {}));\n  }\n};\n/**\n * @param {Immutable.Map} state\n * @param {Immutable.List} path\n * @param {string} type\n * @param {string} id\n * @param {Immutable.OrderedMap} properties\n * @param {object} config\n */\n\n\nvar addItem = function addItem(state, path, type, id, properties, config) {\n  var children = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n  var rulesNumber = (0, _treeUtils.getTotalRulesCountInTree)(state);\n  var maxNumberOfRules = config.settings.maxNumberOfRules;\n  var canAddNewRule = !(type == \"rule\" && maxNumberOfRules && rulesNumber + 1 > maxNumberOfRules);\n  var item = {\n    type: type,\n    id: id,\n    properties: properties\n  };\n\n  _addChildren1(config, item, children);\n\n  if (canAddNewRule) {\n    var childrenPath = (0, _treeUtils.expandTreePath)(path, \"children1\");\n\n    var _hasChildren = !!state.getIn(childrenPath);\n\n    var newChildren = new _immutable[\"default\"].OrderedMap((0, _defineProperty2[\"default\"])({}, id, new _immutable[\"default\"].Map(item)));\n\n    if (!_hasChildren) {\n      state = state.setIn(childrenPath, newChildren);\n    } else {\n      state = state.mergeIn(childrenPath, newChildren);\n    }\n  }\n\n  state = (0, _treeUtils.fixPathsInTree)(state);\n  return state;\n};\n/**\n * @param {Immutable.Map} state\n * @param {Immutable.List} path\n */\n\n\nvar removeItem = function removeItem(state, path) {\n  state = state.deleteIn((0, _treeUtils.expandTreePath)(path));\n  state = (0, _treeUtils.fixPathsInTree)(state);\n  return state;\n};\n/**\n * @param {Immutable.Map} state\n * @param {Immutable.List} fromPath\n * @param {Immutable.List} toPath\n * @param {string} placement, see constants PLACEMENT_*: PLACEMENT_AFTER, PLACEMENT_BEFORE, PLACEMENT_APPEND, PLACEMENT_PREPEND\n * @param {object} config\n */\n\n\nvar moveItem = function moveItem(state, fromPath, toPath, placement, config) {\n  var from = (0, _treeUtils.getItemByPath)(state, fromPath);\n  var sourcePath = fromPath.pop();\n  var source = fromPath.size > 1 ? (0, _treeUtils.getItemByPath)(state, sourcePath) : null;\n  var sourceChildren = source ? source.get(\"children1\") : null;\n  var to = (0, _treeUtils.getItemByPath)(state, toPath);\n  var targetPath = placement == constants.PLACEMENT_APPEND || placement == constants.PLACEMENT_PREPEND ? toPath : toPath.pop();\n  var target = placement == constants.PLACEMENT_APPEND || placement == constants.PLACEMENT_PREPEND ? to : toPath.size > 1 ? (0, _treeUtils.getItemByPath)(state, targetPath) : null;\n  var targetChildren = target ? target.get(\"children1\") : null;\n  if (!source || !target) return state;\n  var isSameParent = source.get(\"id\") == target.get(\"id\");\n  var isSourceInsideTarget = targetPath.size < sourcePath.size && (0, _stuff.deepEqual)(targetPath.toArray(), sourcePath.toArray().slice(0, targetPath.size));\n  var isTargetInsideSource = targetPath.size > sourcePath.size && (0, _stuff.deepEqual)(sourcePath.toArray(), targetPath.toArray().slice(0, sourcePath.size));\n  var sourceSubpathFromTarget = null;\n  var targetSubpathFromSource = null;\n\n  if (isSourceInsideTarget) {\n    sourceSubpathFromTarget = _immutable[\"default\"].List(sourcePath.toArray().slice(targetPath.size));\n  } else if (isTargetInsideSource) {\n    targetSubpathFromSource = _immutable[\"default\"].List(targetPath.toArray().slice(sourcePath.size));\n  }\n\n  var newTargetChildren = targetChildren,\n      newSourceChildren = sourceChildren;\n  if (!isTargetInsideSource) newSourceChildren = newSourceChildren[\"delete\"](from.get(\"id\"));\n\n  if (isSameParent) {\n    newTargetChildren = newSourceChildren;\n  } else if (isSourceInsideTarget) {\n    newTargetChildren = newTargetChildren.updateIn((0, _treeUtils.expandTreeSubpath)(sourceSubpathFromTarget, \"children1\"), function (_oldChildren) {\n      return newSourceChildren;\n    });\n  }\n\n  if (placement == constants.PLACEMENT_BEFORE || placement == constants.PLACEMENT_AFTER) {\n    newTargetChildren = _immutable[\"default\"].OrderedMap().withMutations(function (r) {\n      var _iterator = _createForOfIteratorHelper(newTargetChildren.entries()),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _step$value = (0, _slicedToArray2[\"default\"])(_step.value, 2),\n              itemId = _step$value[0],\n              item = _step$value[1];\n\n          if (itemId == to.get(\"id\") && placement == constants.PLACEMENT_BEFORE) {\n            r.set(from.get(\"id\"), from);\n          }\n\n          r.set(itemId, item);\n\n          if (itemId == to.get(\"id\") && placement == constants.PLACEMENT_AFTER) {\n            r.set(from.get(\"id\"), from);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    });\n  } else if (placement == constants.PLACEMENT_APPEND) {\n    newTargetChildren = newTargetChildren.merge((0, _defineProperty2[\"default\"])({}, from.get(\"id\"), from));\n  } else if (placement == constants.PLACEMENT_PREPEND) {\n    newTargetChildren = _immutable[\"default\"].OrderedMap((0, _defineProperty2[\"default\"])({}, from.get(\"id\"), from)).merge(newTargetChildren);\n  }\n\n  if (isTargetInsideSource) {\n    newSourceChildren = newSourceChildren.updateIn((0, _treeUtils.expandTreeSubpath)(targetSubpathFromSource, \"children1\"), function (_oldChildren) {\n      return newTargetChildren;\n    });\n    newSourceChildren = newSourceChildren[\"delete\"](from.get(\"id\"));\n  }\n\n  if (!isSameParent && !isSourceInsideTarget) state = state.updateIn((0, _treeUtils.expandTreePath)(sourcePath, \"children1\"), function (_oldChildren) {\n    return newSourceChildren;\n  });\n  if (!isTargetInsideSource) state = state.updateIn((0, _treeUtils.expandTreePath)(targetPath, \"children1\"), function (_oldChildren) {\n    return newTargetChildren;\n  });\n  state = (0, _treeUtils.fixPathsInTree)(state);\n  return state;\n};\n/**\n * @param {Immutable.Map} state\n * @param {Immutable.List} path\n * @param {string} field\n */\n\n\nvar setField = function setField(state, path, newField, config) {\n  if (!newField) return removeItem(state, path);\n  var _config$settings2 = config.settings,\n      fieldSeparator = _config$settings2.fieldSeparator,\n      setOpOnChangeField = _config$settings2.setOpOnChangeField,\n      showErrorMessage = _config$settings2.showErrorMessage;\n  if (Array.isArray(newField)) newField = newField.join(fieldSeparator);\n  var currentType = state.getIn((0, _treeUtils.expandTreePath)(path, \"type\"));\n  var currentProperties = state.getIn((0, _treeUtils.expandTreePath)(path, \"properties\"));\n  var wasRuleGroup = currentType == \"rule_group\";\n  var newFieldConfig = (0, _configUtils.getFieldConfig)(config, newField);\n  var isRuleGroup = newFieldConfig.type == \"!group\";\n  var isRuleGroupExt = isRuleGroup && newFieldConfig.mode == \"array\";\n  var isChangeToAnotherType = wasRuleGroup != isRuleGroup;\n  var currentOperator = currentProperties.get(\"operator\");\n  var currentOperatorOptions = currentProperties.get(\"operatorOptions\");\n\n  var _currentField = currentProperties.get(\"field\");\n\n  var _currentValue = currentProperties.get(\"value\");\n\n  var _currentValueSrc = currentProperties.get(\"valueSrc\", new _immutable[\"default\"].List());\n\n  var _currentValueType = currentProperties.get(\"valueType\", new _immutable[\"default\"].List()); // If the newly selected field supports the same operator the rule currently\n  // uses, keep it selected.\n\n\n  var lastOp = newFieldConfig && newFieldConfig.operators.indexOf(currentOperator) !== -1 ? currentOperator : null;\n  var newOperator = null;\n  var availOps = (0, _ruleUtils.getOperatorsForField)(config, newField);\n  if (availOps && availOps.length == 1) newOperator = availOps[0];else if (availOps && availOps.length > 1) {\n    var _iterator2 = _createForOfIteratorHelper(setOpOnChangeField || []),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var strategy = _step2.value;\n        if (strategy == \"keep\" && !isChangeToAnotherType) newOperator = lastOp;else if (strategy == \"default\") newOperator = (0, _defaultUtils.defaultOperator)(config, newField, false);else if (strategy == \"first\") newOperator = (0, _ruleUtils.getFirstOperator)(config, newField);\n        if (newOperator) //found op for strategy\n          break;\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  }\n\n  if (!isRuleGroup && !newFieldConfig.operators) {\n    console.warn(\"Type \".concat(newFieldConfig.type, \" is not supported\"));\n    return state;\n  }\n\n  if (wasRuleGroup && !isRuleGroup) {\n    state = state.setIn((0, _treeUtils.expandTreePath)(path, \"type\"), \"rule\");\n    state = state.deleteIn((0, _treeUtils.expandTreePath)(path, \"children1\"));\n    state = state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\"), new _immutable[\"default\"].OrderedMap());\n  }\n\n  if (isRuleGroup) {\n    state = state.setIn((0, _treeUtils.expandTreePath)(path, \"type\"), \"rule_group\");\n\n    var _getNewValueForFieldO = (0, _ruleUtils.getNewValueForFieldOp)(config, config, currentProperties, newField, newOperator, \"field\", true),\n        canReuseValue = _getNewValueForFieldO.canReuseValue,\n        newValue = _getNewValueForFieldO.newValue,\n        newValueSrc = _getNewValueForFieldO.newValueSrc,\n        newValueType = _getNewValueForFieldO.newValueType,\n        operatorCardinality = _getNewValueForFieldO.operatorCardinality;\n\n    var groupProperties = (0, _defaultUtils.defaultGroupProperties)(config, newFieldConfig).merge({\n      field: newField,\n      mode: newFieldConfig.mode\n    });\n\n    if (isRuleGroupExt) {\n      groupProperties = groupProperties.merge({\n        operator: newOperator,\n        value: newValue,\n        valueSrc: newValueSrc,\n        valueType: newValueType\n      });\n    }\n\n    state = state.setIn((0, _treeUtils.expandTreePath)(path, \"children1\"), new _immutable[\"default\"].OrderedMap());\n    state = state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\"), groupProperties);\n\n    if (newFieldConfig.initialEmptyWhere && operatorCardinality == 1) {// just `COUNT(grp) > 1` without `HAVING ..`\n      // no childeren\n    } else {\n      state = addItem(state, path, \"rule\", (0, _uuid[\"default\"])(), (0, _defaultUtils.defaultRuleProperties)(config, newField), config);\n    }\n\n    state = (0, _treeUtils.fixPathsInTree)(state);\n    return state;\n  }\n\n  return state.updateIn((0, _treeUtils.expandTreePath)(path, \"properties\"), function (map) {\n    return map.withMutations(function (current) {\n      var _getNewValueForFieldO2 = (0, _ruleUtils.getNewValueForFieldOp)(config, config, current, newField, newOperator, \"field\", true),\n          canReuseValue = _getNewValueForFieldO2.canReuseValue,\n          newValue = _getNewValueForFieldO2.newValue,\n          newValueSrc = _getNewValueForFieldO2.newValueSrc,\n          newValueType = _getNewValueForFieldO2.newValueType,\n          newValueError = _getNewValueForFieldO2.newValueError;\n\n      if (showErrorMessage) {\n        current = current.set(\"valueError\", newValueError);\n      }\n\n      var newOperatorOptions = canReuseValue ? currentOperatorOptions : (0, _defaultUtils.defaultOperatorOptions)(config, newOperator, newField);\n      return current.set(\"field\", newField).set(\"operator\", newOperator).set(\"operatorOptions\", newOperatorOptions).set(\"value\", newValue).set(\"valueSrc\", newValueSrc).set(\"valueType\", newValueType)[\"delete\"](\"asyncListValues\");\n    });\n  });\n};\n/**\n * @param {Immutable.Map} state\n * @param {Immutable.List} path\n * @param {string} operator\n */\n\n\nvar setOperator = function setOperator(state, path, newOperator, config) {\n  var showErrorMessage = config.settings.showErrorMessage;\n  var properties = state.getIn((0, _treeUtils.expandTreePath)(path, \"properties\"));\n  var children = state.getIn((0, _treeUtils.expandTreePath)(path, \"children1\"));\n  var currentField = properties.get(\"field\");\n  var fieldConfig = (0, _configUtils.getFieldConfig)(config, currentField);\n  var isRuleGroup = fieldConfig.type == \"!group\";\n  var operatorConfig = (0, _configUtils.getOperatorConfig)(config, newOperator, currentField);\n  var operatorCardinality = operatorConfig ? (0, _stuff.defaultValue)(operatorConfig.cardinality, 1) : null;\n  state = state.updateIn((0, _treeUtils.expandTreePath)(path, \"properties\"), function (map) {\n    return map.withMutations(function (current) {\n      var currentField = current.get(\"field\");\n      var currentOperatorOptions = current.get(\"operatorOptions\");\n\n      var _currentValue = current.get(\"value\", new _immutable[\"default\"].List());\n\n      var _currentValueSrc = current.get(\"valueSrc\", new _immutable[\"default\"].List());\n\n      var _currentOperator = current.get(\"operator\");\n\n      var _getNewValueForFieldO3 = (0, _ruleUtils.getNewValueForFieldOp)(config, config, current, currentField, newOperator, \"operator\", true),\n          canReuseValue = _getNewValueForFieldO3.canReuseValue,\n          newValue = _getNewValueForFieldO3.newValue,\n          newValueSrc = _getNewValueForFieldO3.newValueSrc,\n          newValueType = _getNewValueForFieldO3.newValueType,\n          newValueError = _getNewValueForFieldO3.newValueError;\n\n      if (showErrorMessage) {\n        current = current.set(\"valueError\", newValueError);\n      }\n\n      var newOperatorOptions = canReuseValue ? currentOperatorOptions : (0, _defaultUtils.defaultOperatorOptions)(config, newOperator, currentField);\n\n      if (!canReuseValue) {\n        current = current[\"delete\"](\"asyncListValues\");\n      }\n\n      return current.set(\"operator\", newOperator).set(\"operatorOptions\", newOperatorOptions).set(\"value\", newValue).set(\"valueSrc\", newValueSrc).set(\"valueType\", newValueType);\n    });\n  });\n\n  if (isRuleGroup) {\n    if (operatorCardinality == 0 && children.size == 0) {\n      state = addItem(state, path, \"rule\", (0, _uuid[\"default\"])(), (0, _defaultUtils.defaultRuleProperties)(config, currentField), config);\n    }\n  }\n\n  return state;\n};\n/**\n * @param {Immutable.Map} state\n * @param {Immutable.List} path\n * @param {integer} delta\n * @param {*} value\n * @param {string} valueType\n * @param {*} asyncListValues\n * @param {boolean} __isInternal\n */\n\n\nvar setValue = function setValue(state, path, delta, value, valueType, config, asyncListValues, __isInternal) {\n  var _config$settings3 = config.settings,\n      fieldSeparator = _config$settings3.fieldSeparator,\n      showErrorMessage = _config$settings3.showErrorMessage;\n  var isInternalValueChange;\n  var valueSrc = state.getIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"valueSrc\", delta + \"\")) || null;\n  if (valueSrc === \"field\" && Array.isArray(value)) value = value.join(fieldSeparator);\n  var field = state.getIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"field\")) || null;\n  var operator = state.getIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"operator\")) || null;\n  var isEndValue = false;\n  var canFix = false;\n  var calculatedValueType = valueType || calculateValueType(value, valueSrc, config);\n\n  var _validateValue = (0, _validation.validateValue)(config, field, field, operator, value, calculatedValueType, valueSrc, asyncListValues, canFix, isEndValue),\n      _validateValue2 = (0, _slicedToArray2[\"default\"])(_validateValue, 2),\n      validateError = _validateValue2[0],\n      fixedValue = _validateValue2[1];\n\n  var isValid = !validateError;\n\n  if (isValid && fixedValue !== value) {\n    // eg, get exact value from listValues (not string)\n    value = fixedValue;\n  } // Additional validation for range values\n\n\n  if (showErrorMessage) {\n    var w = (0, _ruleUtils.getWidgetForFieldOp)(config, field, operator, valueSrc);\n    var fieldWidgetDefinition = (0, _configUtils.getFieldWidgetConfig)(config, field, operator, w, valueSrc);\n    var operatorConfig = (0, _configUtils.getOperatorConfig)(config, operator, field);\n    var operatorCardinality = operator ? (0, _stuff.defaultValue)(operatorConfig.cardinality, 1) : null;\n    var valueSrcs = Array.from({\n      length: operatorCardinality\n    }, function (_, i) {\n      return state.getIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"valueSrc\", i + \"\")) || null;\n    });\n\n    if (operatorConfig && operatorConfig.validateValues && valueSrcs.filter(function (vs) {\n      return vs == \"value\" || vs == null;\n    }).length == operatorCardinality) {\n      var values = Array.from({\n        length: operatorCardinality\n      }, function (_, i) {\n        return i == delta ? value : state.getIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"value\", i + \"\")) || null;\n      });\n      var jsValues = fieldWidgetDefinition && fieldWidgetDefinition.toJS ? values.map(function (v) {\n        return fieldWidgetDefinition.toJS(v, fieldWidgetDefinition);\n      }) : values;\n      var rangeValidateError = operatorConfig.validateValues(jsValues);\n      state = state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"valueError\", operatorCardinality), rangeValidateError);\n    }\n  }\n\n  var lastValue = state.getIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"value\", delta + \"\"));\n  var lastError = state.getIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"valueError\", delta));\n  var isLastEmpty = lastValue == undefined;\n  var isLastError = !!lastError;\n\n  if (isValid || showErrorMessage) {\n    state = state.deleteIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"asyncListValues\")); // set only good value\n\n    if (typeof value === \"undefined\") {\n      state = state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"value\", delta + \"\"), undefined);\n      state = state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"valueType\", delta + \"\"), null);\n    } else {\n      if (asyncListValues) {\n        state = state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"asyncListValues\"), asyncListValues);\n      }\n\n      state = state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"value\", delta + \"\"), value);\n      state = state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"valueType\", delta + \"\"), calculatedValueType);\n      isInternalValueChange = __isInternal && !isLastEmpty && !isLastError;\n    }\n  }\n\n  if (showErrorMessage) {\n    state = state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"valueError\", delta), validateError);\n  }\n\n  if (__isInternal && (isValid && isLastError || !isValid && !isLastError)) {\n    state = state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"valueError\", delta), validateError);\n    isInternalValueChange = false;\n  }\n\n  return {\n    tree: state,\n    isInternalValueChange: isInternalValueChange\n  };\n};\n/**\n * @param {Immutable.Map} state\n * @param {Immutable.List} path\n * @param {integer} delta\n * @param {*} srcKey\n */\n\n\nvar setValueSrc = function setValueSrc(state, path, delta, srcKey, config) {\n  var showErrorMessage = config.settings.showErrorMessage;\n  state = state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"value\", delta + \"\"), undefined);\n  state = state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"valueType\", delta + \"\"), null);\n  state = state.deleteIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"asyncListValues\"));\n\n  if (showErrorMessage) {\n    // clear value error\n    state = state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"valueError\", delta), null); // if current operator is range, clear possible range error\n\n    var field = state.getIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"field\")) || null;\n    var operator = state.getIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"operator\")) || null;\n    var operatorConfig = (0, _configUtils.getOperatorConfig)(config, operator, field);\n    var operatorCardinality = operator ? (0, _stuff.defaultValue)(operatorConfig.cardinality, 1) : null;\n\n    if (operatorConfig.validateValues) {\n      state = state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"valueError\", operatorCardinality), null);\n    }\n  }\n\n  if (typeof srcKey === \"undefined\") {\n    state = state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"valueSrc\", delta + \"\"), null);\n  } else {\n    state = state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"valueSrc\", delta + \"\"), srcKey);\n  }\n\n  return state;\n};\n/**\n * @param {Immutable.Map} state\n * @param {Immutable.List} path\n * @param {string} name\n * @param {*} value\n */\n\n\nvar setOperatorOption = function setOperatorOption(state, path, name, value) {\n  return state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"operatorOptions\", name), value);\n};\n/**\n * @param {Immutable.Map} state\n */\n\n\nvar checkEmptyGroups = function checkEmptyGroups(state, config) {\n  var canLeaveEmptyGroup = config.settings.canLeaveEmptyGroup;\n\n  if (!canLeaveEmptyGroup) {\n    state = (0, _treeUtils.fixEmptyGroupsInTree)(state);\n  }\n\n  return state;\n};\n/**\n * \n */\n\n\nvar calculateValueType = function calculateValueType(value, valueSrc, config) {\n  var calculatedValueType = null;\n\n  if (value) {\n    if (valueSrc === \"field\") {\n      var fieldConfig = (0, _configUtils.getFieldConfig)(config, value);\n\n      if (fieldConfig) {\n        calculatedValueType = fieldConfig.type;\n      }\n    } else if (valueSrc === \"func\") {\n      var funcKey = value.get(\"func\");\n\n      if (funcKey) {\n        var funcConfig = (0, _configUtils.getFuncConfig)(config, funcKey);\n\n        if (funcConfig) {\n          calculatedValueType = funcConfig.returnType;\n        }\n      }\n    }\n  }\n\n  return calculatedValueType;\n};\n\nvar getField = function getField(state, path) {\n  var field = state.getIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"field\")) || null;\n  return field;\n};\n\nvar emptyDrag = {\n  dragging: {\n    id: null,\n    x: null,\n    y: null,\n    w: null,\n    h: null\n  },\n  mousePos: {},\n  dragStart: {\n    id: null\n  }\n};\n\nvar getActionMeta = function getActionMeta(action, state) {\n  var actionKeysToOmit = [\"config\", \"asyncListValues\", \"__isInternal\"];\n  var actionTypesToIgnore = [constants.SET_TREE, constants.SET_DRAG_START, constants.SET_DRAG_PROGRESS, constants.SET_DRAG_END];\n  var meta = (0, _mapValues[\"default\"])((0, _omit[\"default\"])(action, actionKeysToOmit), _stuff.applyToJS);\n  var affectedField = action.path && getField(state.tree, action.path) || action.field;\n  if (affectedField) meta.affectedField = affectedField;\n  if (actionTypesToIgnore.includes(action.type) || action.type.indexOf(\"@@redux\") == 0) meta = null;\n  return meta;\n};\n/**\n * @param {Immutable.Map} state\n * @param {object} action\n */\n\n\nvar _default = function _default(config) {\n  var emptyTree = (0, _defaultUtils.defaultRoot)(config);\n  var emptyState = Object.assign({}, {\n    tree: emptyTree\n  }, emptyDrag);\n  return function () {\n    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : emptyState;\n    var action = arguments.length > 1 ? arguments[1] : undefined;\n    var unset = {\n      __isInternalValueChange: undefined,\n      __lastAction: undefined\n    };\n    var set = {};\n    var actionMeta = getActionMeta(action, state);\n\n    switch (action.type) {\n      case constants.SET_TREE:\n        {\n          set.tree = action.tree;\n          break;\n        }\n\n      case constants.ADD_GROUP:\n        {\n          set.tree = addNewGroup(state.tree, action.path, action.id, action.properties, action.config, action.children);\n          break;\n        }\n\n      case constants.REMOVE_GROUP:\n        {\n          set.tree = removeGroup(state.tree, action.path, action.config);\n          break;\n        }\n\n      case constants.ADD_RULE:\n        {\n          set.tree = addItem(state.tree, action.path, action.ruleType, action.id, action.properties, action.config, action.children);\n          break;\n        }\n\n      case constants.REMOVE_RULE:\n        {\n          set.tree = removeRule(state.tree, action.path, action.config);\n          break;\n        }\n\n      case constants.SET_CONJUNCTION:\n        {\n          set.tree = setConjunction(state.tree, action.path, action.conjunction);\n          break;\n        }\n\n      case constants.SET_NOT:\n        {\n          set.tree = setNot(state.tree, action.path, action.not);\n          break;\n        }\n\n      case constants.SET_FIELD:\n        {\n          set.tree = setField(state.tree, action.path, action.field, action.config);\n          break;\n        }\n\n      case constants.SET_OPERATOR:\n        {\n          set.tree = setOperator(state.tree, action.path, action.operator, action.config);\n          break;\n        }\n\n      case constants.SET_VALUE:\n        {\n          var _setValue = setValue(state.tree, action.path, action.delta, action.value, action.valueType, action.config, action.asyncListValues, action.__isInternal),\n              tree = _setValue.tree,\n              isInternalValueChange = _setValue.isInternalValueChange;\n\n          set.__isInternalValueChange = isInternalValueChange;\n          set.tree = tree;\n          break;\n        }\n\n      case constants.SET_VALUE_SRC:\n        {\n          set.tree = setValueSrc(state.tree, action.path, action.delta, action.srcKey, action.config);\n          break;\n        }\n\n      case constants.SET_OPERATOR_OPTION:\n        {\n          set.tree = setOperatorOption(state.tree, action.path, action.name, action.value);\n          break;\n        }\n\n      case constants.MOVE_ITEM:\n        {\n          set.tree = moveItem(state.tree, action.fromPath, action.toPath, action.placement, action.config);\n          break;\n        }\n\n      case constants.SET_DRAG_START:\n        {\n          set.dragStart = action.dragStart;\n          set.dragging = action.dragging;\n          set.mousePos = action.mousePos;\n          break;\n        }\n\n      case constants.SET_DRAG_PROGRESS:\n        {\n          set.mousePos = action.mousePos;\n          set.dragging = action.dragging;\n          break;\n        }\n\n      case constants.SET_DRAG_END:\n        {\n          set.tree = checkEmptyGroups(state.tree, config);\n          set = _objectSpread(_objectSpread({}, set), emptyDrag);\n          break;\n        }\n\n      default:\n        {\n          break;\n        }\n    }\n\n    if (actionMeta) {\n      set.__lastAction = actionMeta;\n    }\n\n    return _objectSpread(_objectSpread(_objectSpread({}, state), unset), set);\n  };\n};\n\nexports[\"default\"] = _default;"]},"metadata":{},"sourceType":"script"}