{"ast":null,"code":"import { DOMSerializer, DOMParser as ProseMirrorDOMParser } from 'prosemirror-model';\nimport { AllSelection } from 'prosemirror-state';\nvar blockWrappers = ['div', 'ol', 'ul', 'li', 'table', 'tbody', 'thead', 'tfoot', 'td', 'th', 'p', 'tr', 'col', 'colgroup', 'article', 'main', 'nav', 'header', 'footer', 'aside', 'section'];\n/**\n * Trims the whitespace around the provided block nodes.\n *\n * @param html - Input HTML content\n * @param trimAroundTags - Block elements to which trimming will be applied.\n * Defaults to block nodes of the current default schema:\n * 'div', 'ol', 'ul', 'li', 'table', 'tbody', 'thead', 'tfoot', 'td', 'th', 'p'\n * and additional table and semantic nodes from the default Angular Editor schema:\n * 'tr', 'col', 'colgroup', 'article', 'main', 'nav', 'header', 'footer', 'aside', 'section'\n *\n * @returns The trimmed HTML content\n */\n\nexport var trimWhitespace = function trimWhitespace(html, trimAroundTags) {\n  if (trimAroundTags === void 0) {\n    trimAroundTags = blockWrappers;\n  }\n\n  var tags = trimAroundTags.join('|');\n  return html.replace(new RegExp('\\\\s*(<(?:' + tags + ')(?:\\\\s[^>]*?)?>)', 'g'), '$1').replace(new RegExp('(<\\\\/(?:' + tags + ')(?:\\\\s[^>]*?)?>)\\\\s*', 'g'), '$1');\n};\n/**\n * Creates a Node from the given content.\n *\n * @param content - The new HTML content.\n * @param schema - The document schema.\n * @param parseOptions - ProseMirror parse options recognized by the `parse` and `parseSlice` methods.\n * @returns - New Node instance.\n */\n\nexport var parseContent = function parseContent(content, schema, parseOptions) {\n  var template = document.createElement('template');\n  var dom;\n\n  if ('content' in template) {\n    template.innerHTML = content;\n    dom = template.content;\n  } else {\n    var parsedDocument = new DOMParser().parseFromString(content, 'text/html');\n    dom = parsedDocument.body || document.createDocumentFragment();\n  }\n\n  return ProseMirrorDOMParser.fromSchema(schema).parse(dom, parseOptions);\n};\n/**\n * A function that serializes the Editor State content as HTML string.\n *\n * @param state - The Editor State\n * @returns - The serialized content\n */\n\nexport var getHtml = function getHtml(state) {\n  var fragment = DOMSerializer.fromSchema(state.schema).serializeFragment(state.doc.content);\n  var container = document.createElement('div');\n  container.appendChild(fragment);\n  return container.innerHTML;\n};\n/**\n * Replaces the content of the editor with a new one.\n *\n * @param content - The new HTML content.\n * @param commandName - The name of the command.\n * @param parseOptions - ProseMirror parse options recognized by the `parse` and `parseSlice` methods.\n * @returns - Command function that takes an editor `state` and `dispatch` function.\n */\n\nexport var setHtml = function setHtml(content, command, parseOptions) {\n  if (command === void 0) {\n    command = 'setHTML';\n  }\n\n  if (parseOptions === void 0) {\n    parseOptions = {\n      preserveWhitespace: 'full'\n    };\n  }\n\n  return function (state, dispatch) {\n    return dispatch(state.tr.setSelection(new AllSelection(state.doc)).replaceSelectionWith(parseContent(content, state.schema, parseOptions)).setMeta('commandName', command));\n  };\n};","map":{"version":3,"sources":["D:/LIMSWFH/LIMSPOSTGRESQL/QuaLISWeb/node_modules/@progress/kendo-editor-common/dist/es/source.js"],"names":["DOMSerializer","DOMParser","ProseMirrorDOMParser","AllSelection","blockWrappers","trimWhitespace","html","trimAroundTags","tags","join","replace","RegExp","parseContent","content","schema","parseOptions","template","document","createElement","dom","innerHTML","parsedDocument","parseFromString","body","createDocumentFragment","fromSchema","parse","getHtml","state","fragment","serializeFragment","doc","container","appendChild","setHtml","command","preserveWhitespace","dispatch","tr","setSelection","replaceSelectionWith","setMeta"],"mappings":"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","sourcesContent":["import { DOMSerializer, DOMParser as ProseMirrorDOMParser } from 'prosemirror-model';\nimport { AllSelection } from 'prosemirror-state';\nvar blockWrappers = [\n    'div', 'ol', 'ul', 'li', 'table', 'tbody', 'thead', 'tfoot', 'td', 'th', 'p',\n    'tr', 'col', 'colgroup', 'article', 'main', 'nav', 'header', 'footer', 'aside', 'section'\n];\n/**\n * Trims the whitespace around the provided block nodes.\n *\n * @param html - Input HTML content\n * @param trimAroundTags - Block elements to which trimming will be applied.\n * Defaults to block nodes of the current default schema:\n * 'div', 'ol', 'ul', 'li', 'table', 'tbody', 'thead', 'tfoot', 'td', 'th', 'p'\n * and additional table and semantic nodes from the default Angular Editor schema:\n * 'tr', 'col', 'colgroup', 'article', 'main', 'nav', 'header', 'footer', 'aside', 'section'\n *\n * @returns The trimmed HTML content\n */\nexport var trimWhitespace = function (html, trimAroundTags) {\n    if (trimAroundTags === void 0) { trimAroundTags = blockWrappers; }\n    var tags = trimAroundTags.join('|');\n    return html.replace(new RegExp('\\\\s*(<(?:' + tags + ')(?:\\\\s[^>]*?)?>)', 'g'), '$1')\n        .replace(new RegExp('(<\\\\/(?:' + tags + ')(?:\\\\s[^>]*?)?>)\\\\s*', 'g'), '$1');\n};\n/**\n * Creates a Node from the given content.\n *\n * @param content - The new HTML content.\n * @param schema - The document schema.\n * @param parseOptions - ProseMirror parse options recognized by the `parse` and `parseSlice` methods.\n * @returns - New Node instance.\n */\nexport var parseContent = function (content, schema, parseOptions) {\n    var template = document.createElement('template');\n    var dom;\n    if ('content' in template) {\n        template.innerHTML = content;\n        dom = template.content;\n    }\n    else {\n        var parsedDocument = new DOMParser().parseFromString(content, 'text/html');\n        dom = parsedDocument.body || document.createDocumentFragment();\n    }\n    return ProseMirrorDOMParser.fromSchema(schema).parse(dom, parseOptions);\n};\n/**\n * A function that serializes the Editor State content as HTML string.\n *\n * @param state - The Editor State\n * @returns - The serialized content\n */\nexport var getHtml = function (state) {\n    var fragment = DOMSerializer.fromSchema(state.schema).serializeFragment(state.doc.content);\n    var container = document.createElement('div');\n    container.appendChild(fragment);\n    return container.innerHTML;\n};\n/**\n * Replaces the content of the editor with a new one.\n *\n * @param content - The new HTML content.\n * @param commandName - The name of the command.\n * @param parseOptions - ProseMirror parse options recognized by the `parse` and `parseSlice` methods.\n * @returns - Command function that takes an editor `state` and `dispatch` function.\n */\nexport var setHtml = function (content, command, parseOptions) {\n    if (command === void 0) { command = 'setHTML'; }\n    if (parseOptions === void 0) { parseOptions = { preserveWhitespace: 'full' }; }\n    return function (state, dispatch) {\n        return dispatch(state.tr\n            .setSelection(new AllSelection(state.doc))\n            .replaceSelectionWith(parseContent(content, state.schema, parseOptions))\n            .setMeta('commandName', command));\n    };\n};\n"]},"metadata":{},"sourceType":"module"}