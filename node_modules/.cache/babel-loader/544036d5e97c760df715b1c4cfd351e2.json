{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.queryString = void 0;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _configUtils = require(\"../utils/configUtils\");\n\nvar _ruleUtils = require(\"../utils/ruleUtils\");\n\nvar _omit = _interopRequireDefault(require(\"lodash/omit\"));\n\nvar _pick = _interopRequireDefault(require(\"lodash/pick\"));\n\nvar _stuff = require(\"../utils/stuff\");\n\nvar _defaultUtils = require(\"../utils/defaultUtils\");\n\nvar _default = require(\"../config/default\");\n\nvar _funcUtils = require(\"../utils/funcUtils\");\n\nvar _immutable = require(\"immutable\");\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      (0, _defineProperty2[\"default\"])(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nvar queryString = function queryString(item, config) {\n  var isForDisplay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false; //meta is mutable\n\n  var meta = {\n    errors: []\n  };\n  var res = formatItem(item, config, meta, isForDisplay, null);\n  if (meta.errors.length) console.warn(\"Errors while exporting to string:\", meta.errors);\n  return res;\n};\n\nexports.queryString = queryString;\n\nvar formatItem = function formatItem(item, config, meta) {\n  var isForDisplay = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var parentField = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  if (!item) return undefined;\n  var type = item.get(\"type\");\n  var children = item.get(\"children1\");\n\n  if (type === \"group\" || type === \"rule_group\") {\n    return formatGroup(item, config, meta, isForDisplay, parentField);\n  } else if (type === \"rule\") {\n    return formatRule(item, config, meta, isForDisplay, parentField);\n  }\n\n  return undefined;\n};\n\nvar formatGroup = function formatGroup(item, config, meta) {\n  var isForDisplay = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var parentField = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  var type = item.get(\"type\");\n  var properties = item.get(\"properties\") || new _immutable.Map();\n  var mode = properties.get(\"mode\");\n  var children = item.get(\"children1\");\n  if (!children) return undefined;\n  var isRuleGroup = type === \"rule_group\"; // TIP: don't cut group for mode == 'struct' and don't do aggr format (maybe later)\n\n  var groupField = isRuleGroup && mode == \"array\" ? properties.get(\"field\") : null;\n  var canHaveEmptyChildren = isRuleGroup && mode == \"array\";\n  var not = properties.get(\"not\");\n  var list = children.map(function (currentChild) {\n    return formatItem(currentChild, config, meta, isForDisplay, groupField);\n  }).filter(function (currentChild) {\n    return typeof currentChild !== \"undefined\";\n  });\n  if (!canHaveEmptyChildren && !list.size) return undefined;\n  var conjunction = properties.get(\"conjunction\");\n  if (!conjunction) conjunction = (0, _defaultUtils.defaultConjunction)(config);\n  var conjunctionDefinition = config.conjunctions[conjunction];\n  var conjStr = list.size ? conjunctionDefinition.formatConj(list, conjunction, not, isForDisplay) : null;\n  var ret;\n\n  if (groupField) {\n    var aggrArgs = formatRule(item, config, meta, isForDisplay, parentField, true);\n\n    if (aggrArgs) {\n      var _config$settings;\n\n      var isRev = aggrArgs.pop();\n      var args = [conjStr].concat((0, _toConsumableArray2[\"default\"])(aggrArgs));\n      ret = (_config$settings = config.settings).formatAggr.apply(_config$settings, (0, _toConsumableArray2[\"default\"])(args));\n\n      if (isRev) {\n        ret = config.settings.formatReverse(ret, null, null, null, null, isForDisplay);\n      }\n    }\n  } else {\n    ret = conjStr;\n  }\n\n  return ret;\n};\n\nvar formatItemValue = function formatItemValue(config, properties, meta, _operator, isForDisplay, parentField) {\n  var field = properties.get(\"field\");\n  var iValueSrc = properties.get(\"valueSrc\");\n  var iValueType = properties.get(\"valueType\");\n  var fieldDef = (0, _configUtils.getFieldConfig)(config, field) || {};\n\n  var operator = _operator || properties.get(\"operator\");\n\n  var operatorDef = (0, _configUtils.getOperatorConfig)(config, operator, field) || {};\n  var cardinality = (0, _stuff.defaultValue)(operatorDef.cardinality, 1);\n  var iValue = properties.get(\"value\");\n  var asyncListValues = properties.get(\"asyncListValues\");\n  var valueSrcs = [];\n  var valueTypes = [];\n  var formattedValue;\n\n  if (iValue != undefined) {\n    var fvalue = iValue.map(function (currentValue, ind) {\n      var valueSrc = iValueSrc ? iValueSrc.get(ind) : null;\n      var valueType = iValueType ? iValueType.get(ind) : null;\n      var cValue = (0, _funcUtils.completeValue)(currentValue, valueSrc, config);\n      var widget = (0, _ruleUtils.getWidgetForFieldOp)(config, field, operator, valueSrc);\n      var fieldWidgetDef = (0, _omit[\"default\"])((0, _configUtils.getFieldWidgetConfig)(config, field, operator, widget, valueSrc), [\"factory\"]);\n      var fv = formatValue(config, meta, cValue, valueSrc, valueType, fieldWidgetDef, fieldDef, operator, operatorDef, isForDisplay, parentField, asyncListValues);\n\n      if (fv !== undefined) {\n        valueSrcs.push(valueSrc);\n        valueTypes.push(valueType);\n      }\n\n      return fv;\n    });\n    var hasUndefinedValues = fvalue.filter(function (v) {\n      return v === undefined;\n    }).size > 0;\n\n    if (!(hasUndefinedValues || fvalue.size < cardinality)) {\n      formattedValue = cardinality == 1 ? fvalue.first() : fvalue;\n    }\n  }\n\n  return [formattedValue, valueSrcs.length > 1 ? valueSrcs : valueSrcs[0], valueTypes.length > 1 ? valueTypes : valueTypes[0]];\n};\n\nvar buildFnToFormatOp = function buildFnToFormatOp(operator, operatorDefinition) {\n  var fop = operatorDefinition.labelForFormat || operator;\n  var cardinality = (0, _stuff.defaultValue)(operatorDefinition.cardinality, 1);\n  var fn;\n\n  if (cardinality == 0) {\n    fn = function fn(field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {\n      return \"\".concat(field, \" \").concat(fop);\n    };\n  } else if (cardinality == 1) {\n    fn = function fn(field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {\n      return \"\".concat(field, \" \").concat(fop, \" \").concat(values);\n    };\n  } else if (cardinality == 2) {\n    // between\n    fn = function fn(field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {\n      var valFrom = values.first();\n      var valTo = values.get(1);\n      return \"\".concat(field, \" \").concat(fop, \" \").concat(valFrom, \" AND \").concat(valTo);\n    };\n  }\n\n  return fn;\n};\n\nvar formatRule = function formatRule(item, config, meta) {\n  var isForDisplay = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var parentField = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  var returnArgs = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  var properties = item.get(\"properties\") || new _immutable.Map();\n  var field = properties.get(\"field\");\n  var operator = properties.get(\"operator\");\n  var operatorOptions = properties.get(\"operatorOptions\");\n  if (field == null || operator == null) return undefined;\n  var fieldDef = (0, _configUtils.getFieldConfig)(config, field) || {};\n  var operatorDef = (0, _configUtils.getOperatorConfig)(config, operator, field) || {};\n  var reversedOp = operatorDef.reversedOp;\n  var revOperatorDef = (0, _configUtils.getOperatorConfig)(config, reversedOp, field) || {}; //check op\n\n  var isRev = false;\n  var fn = operatorDef.formatOp;\n\n  if (!fn && reversedOp) {\n    fn = revOperatorDef.formatOp;\n\n    if (fn) {\n      isRev = true;\n      var _ref = [reversedOp, operator];\n      operator = _ref[0];\n      reversedOp = _ref[1];\n      var _ref2 = [revOperatorDef, operatorDef];\n      operatorDef = _ref2[0];\n      revOperatorDef = _ref2[1];\n    }\n  } //find fn to format expr\n\n\n  if (!fn) fn = buildFnToFormatOp(operator, operatorDef);\n  if (!fn) return undefined; //format field\n\n  var formattedField = formatField(config, meta, field, isForDisplay, parentField); //format value\n\n  var _formatItemValue = formatItemValue(config, properties, meta, operator, isForDisplay, parentField),\n      _formatItemValue2 = (0, _slicedToArray2[\"default\"])(_formatItemValue, 3),\n      formattedValue = _formatItemValue2[0],\n      valueSrc = _formatItemValue2[1],\n      valueType = _formatItemValue2[2];\n\n  if (formattedValue === undefined) return undefined;\n  var args = [formattedField, operator, formattedValue, valueSrc, valueType, (0, _omit[\"default\"])(operatorDef, [\"formatOp\", \"mongoFormatOp\", \"sqlFormatOp\", \"jsonLogic\", \"spelFormatOp\"]), operatorOptions, isForDisplay, fieldDef, isRev];\n\n  if (returnArgs) {\n    return args;\n  } else {\n    //format expr\n    var ret = fn.apply(void 0, args); //rev\n\n    if (isRev) {\n      ret = config.settings.formatReverse(ret, operator, reversedOp, operatorDef, revOperatorDef, isForDisplay);\n    }\n\n    return ret;\n  }\n};\n\nvar formatValue = function formatValue(config, meta, value, valueSrc, valueType, fieldWidgetDef, fieldDef, operator, opDef, isForDisplay) {\n  var parentField = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : null;\n  var asyncListValues = arguments.length > 11 ? arguments[11] : undefined;\n  if (value === undefined) return undefined;\n  var ret;\n\n  if (valueSrc == \"field\") {\n    ret = formatField(config, meta, value, isForDisplay, parentField);\n  } else if (valueSrc == \"func\") {\n    ret = formatFunc(config, meta, value, isForDisplay, parentField);\n  } else {\n    if (typeof fieldWidgetDef.formatValue === \"function\") {\n      var fn = fieldWidgetDef.formatValue;\n      var args = [value, _objectSpread(_objectSpread({}, (0, _pick[\"default\"])(fieldDef, [\"fieldSettings\", \"listValues\"])), {}, {\n        asyncListValues: asyncListValues\n      }), //useful options: valueFormat for date/time\n      (0, _omit[\"default\"])(fieldWidgetDef, [\"formatValue\", \"mongoFormatValue\", \"sqlFormatValue\", \"jsonLogic\", \"elasticSearchFormatValue\", \"spelFormatValue\"]), isForDisplay];\n\n      if (operator) {\n        args.push(operator);\n        args.push(opDef);\n      }\n\n      if (valueSrc == \"field\") {\n        var valFieldDefinition = (0, _configUtils.getFieldConfig)(config, value) || {};\n        args.push(valFieldDefinition);\n      }\n\n      ret = fn.apply(void 0, args);\n    } else {\n      ret = value;\n    }\n  }\n\n  return ret;\n};\n\nvar formatField = function formatField(config, meta, field, isForDisplay) {\n  var parentField = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  var cutParentField = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n  var _config$settings2 = config.settings,\n      fieldSeparator = _config$settings2.fieldSeparator,\n      fieldSeparatorDisplay = _config$settings2.fieldSeparatorDisplay;\n  var ret = null;\n\n  if (field) {\n    var fieldDefinition = (0, _configUtils.getFieldConfig)(config, field) || {};\n    var fieldParts = Array.isArray(field) ? field : field.split(fieldSeparator);\n\n    var _fieldKeys = (0, _ruleUtils.getFieldPath)(field, config);\n\n    var fieldPartsLabels = (0, _ruleUtils.getFieldPathLabels)(field, config, cutParentField ? parentField : null);\n    var fieldFullLabel = fieldPartsLabels ? fieldPartsLabels.join(fieldSeparatorDisplay) : null;\n    var fieldLabel2 = fieldDefinition.label2 || fieldFullLabel;\n    var formatFieldFn = config.settings.formatField || _default.settings.formatField;\n    var fieldName = (0, _ruleUtils.formatFieldName)(field, config, meta, cutParentField ? parentField : null);\n    ret = formatFieldFn(fieldName, fieldParts, fieldLabel2, fieldDefinition, config, isForDisplay);\n  }\n\n  return ret;\n};\n\nvar formatFunc = function formatFunc(config, meta, funcValue, isForDisplay) {\n  var parentField = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  var funcKey = funcValue.get(\"func\");\n  var args = funcValue.get(\"args\");\n  var funcConfig = (0, _configUtils.getFuncConfig)(config, funcKey);\n  var funcName = isForDisplay && funcConfig.label || funcKey;\n  var formattedArgs = {};\n  var formattedArgsWithNames = {};\n\n  for (var argKey in funcConfig.args) {\n    var argConfig = funcConfig.args[argKey];\n    var fieldDef = (0, _configUtils.getFieldConfig)(config, argConfig);\n    var argVal = args ? args.get(argKey) : undefined;\n    var argValue = argVal ? argVal.get(\"value\") : undefined;\n    var argValueSrc = argVal ? argVal.get(\"valueSrc\") : undefined;\n    var argAsyncListValues = argVal ? argVal.get(\"asyncListValues\") : undefined;\n    var formattedArgVal = formatValue(config, meta, argValue, argValueSrc, argConfig.type, fieldDef, argConfig, null, null, isForDisplay, parentField, argAsyncListValues);\n    var argName = isForDisplay && argConfig.label || argKey;\n\n    if (formattedArgVal !== undefined) {\n      // skip optional in the end\n      formattedArgs[argKey] = formattedArgVal;\n      formattedArgsWithNames[argName] = formattedArgVal;\n    }\n  }\n\n  var ret = null;\n\n  if (typeof funcConfig.formatFunc === \"function\") {\n    var fn = funcConfig.formatFunc;\n    var _args = [formattedArgs, isForDisplay];\n    ret = fn.apply(void 0, _args);\n  } else {\n    var argsStr = Object.entries(formattedArgsWithNames).map(function (_ref3) {\n      var _ref4 = (0, _slicedToArray2[\"default\"])(_ref3, 2),\n          k = _ref4[0],\n          v = _ref4[1];\n\n      return isForDisplay ? \"\".concat(k, \": \").concat(v) : \"\".concat(v);\n    }).join(\", \");\n    ret = \"\".concat(funcName, \"(\").concat(argsStr, \")\");\n  }\n\n  return ret;\n};","map":{"version":3,"sources":["D:/LIMSWFH/LIMSPOSTGRESQL/QuaLISWeb/node_modules/react-awesome-query-builder/lib/export/queryString.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","queryString","_defineProperty2","_slicedToArray2","_toConsumableArray2","_configUtils","_ruleUtils","_omit","_pick","_stuff","_defaultUtils","_default","_funcUtils","_immutable","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","item","config","isForDisplay","undefined","meta","errors","res","formatItem","console","warn","parentField","type","get","children","formatGroup","formatRule","properties","Map","mode","isRuleGroup","groupField","canHaveEmptyChildren","not","list","map","currentChild","size","conjunction","defaultConjunction","conjunctionDefinition","conjunctions","conjStr","formatConj","ret","aggrArgs","_config$settings","isRev","pop","args","concat","settings","formatAggr","formatReverse","formatItemValue","_operator","field","iValueSrc","iValueType","fieldDef","getFieldConfig","operator","operatorDef","getOperatorConfig","cardinality","defaultValue","iValue","asyncListValues","valueSrcs","valueTypes","formattedValue","fvalue","currentValue","ind","valueSrc","valueType","cValue","completeValue","widget","getWidgetForFieldOp","fieldWidgetDef","getFieldWidgetConfig","fv","formatValue","hasUndefinedValues","v","first","buildFnToFormatOp","operatorDefinition","fop","labelForFormat","fn","op","values","opDef","operatorOptions","valFrom","valTo","returnArgs","reversedOp","revOperatorDef","formatOp","_ref","_ref2","formattedField","formatField","_formatItemValue","_formatItemValue2","formatFunc","valFieldDefinition","cutParentField","_config$settings2","fieldSeparator","fieldSeparatorDisplay","fieldDefinition","fieldParts","Array","isArray","split","_fieldKeys","getFieldPath","fieldPartsLabels","getFieldPathLabels","fieldFullLabel","join","fieldLabel2","label2","formatFieldFn","fieldName","formatFieldName","funcValue","funcKey","funcConfig","getFuncConfig","funcName","label","formattedArgs","formattedArgsWithNames","argKey","argConfig","argVal","argValue","argValueSrc","argAsyncListValues","formattedArgVal","argName","_args","argsStr","entries","_ref3","_ref4","k"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.queryString = void 0;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _configUtils = require(\"../utils/configUtils\");\n\nvar _ruleUtils = require(\"../utils/ruleUtils\");\n\nvar _omit = _interopRequireDefault(require(\"lodash/omit\"));\n\nvar _pick = _interopRequireDefault(require(\"lodash/pick\"));\n\nvar _stuff = require(\"../utils/stuff\");\n\nvar _defaultUtils = require(\"../utils/defaultUtils\");\n\nvar _default = require(\"../config/default\");\n\nvar _funcUtils = require(\"../utils/funcUtils\");\n\nvar _immutable = require(\"immutable\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2[\"default\"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nvar queryString = function queryString(item, config) {\n  var isForDisplay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  //meta is mutable\n  var meta = {\n    errors: []\n  };\n  var res = formatItem(item, config, meta, isForDisplay, null);\n  if (meta.errors.length) console.warn(\"Errors while exporting to string:\", meta.errors);\n  return res;\n};\n\nexports.queryString = queryString;\n\nvar formatItem = function formatItem(item, config, meta) {\n  var isForDisplay = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var parentField = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  if (!item) return undefined;\n  var type = item.get(\"type\");\n  var children = item.get(\"children1\");\n\n  if (type === \"group\" || type === \"rule_group\") {\n    return formatGroup(item, config, meta, isForDisplay, parentField);\n  } else if (type === \"rule\") {\n    return formatRule(item, config, meta, isForDisplay, parentField);\n  }\n\n  return undefined;\n};\n\nvar formatGroup = function formatGroup(item, config, meta) {\n  var isForDisplay = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var parentField = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  var type = item.get(\"type\");\n  var properties = item.get(\"properties\") || new _immutable.Map();\n  var mode = properties.get(\"mode\");\n  var children = item.get(\"children1\");\n  if (!children) return undefined;\n  var isRuleGroup = type === \"rule_group\"; // TIP: don't cut group for mode == 'struct' and don't do aggr format (maybe later)\n\n  var groupField = isRuleGroup && mode == \"array\" ? properties.get(\"field\") : null;\n  var canHaveEmptyChildren = isRuleGroup && mode == \"array\";\n  var not = properties.get(\"not\");\n  var list = children.map(function (currentChild) {\n    return formatItem(currentChild, config, meta, isForDisplay, groupField);\n  }).filter(function (currentChild) {\n    return typeof currentChild !== \"undefined\";\n  });\n  if (!canHaveEmptyChildren && !list.size) return undefined;\n  var conjunction = properties.get(\"conjunction\");\n  if (!conjunction) conjunction = (0, _defaultUtils.defaultConjunction)(config);\n  var conjunctionDefinition = config.conjunctions[conjunction];\n  var conjStr = list.size ? conjunctionDefinition.formatConj(list, conjunction, not, isForDisplay) : null;\n  var ret;\n\n  if (groupField) {\n    var aggrArgs = formatRule(item, config, meta, isForDisplay, parentField, true);\n\n    if (aggrArgs) {\n      var _config$settings;\n\n      var isRev = aggrArgs.pop();\n      var args = [conjStr].concat((0, _toConsumableArray2[\"default\"])(aggrArgs));\n      ret = (_config$settings = config.settings).formatAggr.apply(_config$settings, (0, _toConsumableArray2[\"default\"])(args));\n\n      if (isRev) {\n        ret = config.settings.formatReverse(ret, null, null, null, null, isForDisplay);\n      }\n    }\n  } else {\n    ret = conjStr;\n  }\n\n  return ret;\n};\n\nvar formatItemValue = function formatItemValue(config, properties, meta, _operator, isForDisplay, parentField) {\n  var field = properties.get(\"field\");\n  var iValueSrc = properties.get(\"valueSrc\");\n  var iValueType = properties.get(\"valueType\");\n  var fieldDef = (0, _configUtils.getFieldConfig)(config, field) || {};\n\n  var operator = _operator || properties.get(\"operator\");\n\n  var operatorDef = (0, _configUtils.getOperatorConfig)(config, operator, field) || {};\n  var cardinality = (0, _stuff.defaultValue)(operatorDef.cardinality, 1);\n  var iValue = properties.get(\"value\");\n  var asyncListValues = properties.get(\"asyncListValues\");\n  var valueSrcs = [];\n  var valueTypes = [];\n  var formattedValue;\n\n  if (iValue != undefined) {\n    var fvalue = iValue.map(function (currentValue, ind) {\n      var valueSrc = iValueSrc ? iValueSrc.get(ind) : null;\n      var valueType = iValueType ? iValueType.get(ind) : null;\n      var cValue = (0, _funcUtils.completeValue)(currentValue, valueSrc, config);\n      var widget = (0, _ruleUtils.getWidgetForFieldOp)(config, field, operator, valueSrc);\n      var fieldWidgetDef = (0, _omit[\"default\"])((0, _configUtils.getFieldWidgetConfig)(config, field, operator, widget, valueSrc), [\"factory\"]);\n      var fv = formatValue(config, meta, cValue, valueSrc, valueType, fieldWidgetDef, fieldDef, operator, operatorDef, isForDisplay, parentField, asyncListValues);\n\n      if (fv !== undefined) {\n        valueSrcs.push(valueSrc);\n        valueTypes.push(valueType);\n      }\n\n      return fv;\n    });\n    var hasUndefinedValues = fvalue.filter(function (v) {\n      return v === undefined;\n    }).size > 0;\n\n    if (!(hasUndefinedValues || fvalue.size < cardinality)) {\n      formattedValue = cardinality == 1 ? fvalue.first() : fvalue;\n    }\n  }\n\n  return [formattedValue, valueSrcs.length > 1 ? valueSrcs : valueSrcs[0], valueTypes.length > 1 ? valueTypes : valueTypes[0]];\n};\n\nvar buildFnToFormatOp = function buildFnToFormatOp(operator, operatorDefinition) {\n  var fop = operatorDefinition.labelForFormat || operator;\n  var cardinality = (0, _stuff.defaultValue)(operatorDefinition.cardinality, 1);\n  var fn;\n\n  if (cardinality == 0) {\n    fn = function fn(field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {\n      return \"\".concat(field, \" \").concat(fop);\n    };\n  } else if (cardinality == 1) {\n    fn = function fn(field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {\n      return \"\".concat(field, \" \").concat(fop, \" \").concat(values);\n    };\n  } else if (cardinality == 2) {\n    // between\n    fn = function fn(field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {\n      var valFrom = values.first();\n      var valTo = values.get(1);\n      return \"\".concat(field, \" \").concat(fop, \" \").concat(valFrom, \" AND \").concat(valTo);\n    };\n  }\n\n  return fn;\n};\n\nvar formatRule = function formatRule(item, config, meta) {\n  var isForDisplay = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var parentField = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  var returnArgs = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  var properties = item.get(\"properties\") || new _immutable.Map();\n  var field = properties.get(\"field\");\n  var operator = properties.get(\"operator\");\n  var operatorOptions = properties.get(\"operatorOptions\");\n  if (field == null || operator == null) return undefined;\n  var fieldDef = (0, _configUtils.getFieldConfig)(config, field) || {};\n  var operatorDef = (0, _configUtils.getOperatorConfig)(config, operator, field) || {};\n  var reversedOp = operatorDef.reversedOp;\n  var revOperatorDef = (0, _configUtils.getOperatorConfig)(config, reversedOp, field) || {}; //check op\n\n  var isRev = false;\n  var fn = operatorDef.formatOp;\n\n  if (!fn && reversedOp) {\n    fn = revOperatorDef.formatOp;\n\n    if (fn) {\n      isRev = true;\n      var _ref = [reversedOp, operator];\n      operator = _ref[0];\n      reversedOp = _ref[1];\n      var _ref2 = [revOperatorDef, operatorDef];\n      operatorDef = _ref2[0];\n      revOperatorDef = _ref2[1];\n    }\n  } //find fn to format expr\n\n\n  if (!fn) fn = buildFnToFormatOp(operator, operatorDef);\n  if (!fn) return undefined; //format field\n\n  var formattedField = formatField(config, meta, field, isForDisplay, parentField); //format value\n\n  var _formatItemValue = formatItemValue(config, properties, meta, operator, isForDisplay, parentField),\n      _formatItemValue2 = (0, _slicedToArray2[\"default\"])(_formatItemValue, 3),\n      formattedValue = _formatItemValue2[0],\n      valueSrc = _formatItemValue2[1],\n      valueType = _formatItemValue2[2];\n\n  if (formattedValue === undefined) return undefined;\n  var args = [formattedField, operator, formattedValue, valueSrc, valueType, (0, _omit[\"default\"])(operatorDef, [\"formatOp\", \"mongoFormatOp\", \"sqlFormatOp\", \"jsonLogic\", \"spelFormatOp\"]), operatorOptions, isForDisplay, fieldDef, isRev];\n\n  if (returnArgs) {\n    return args;\n  } else {\n    //format expr\n    var ret = fn.apply(void 0, args); //rev\n\n    if (isRev) {\n      ret = config.settings.formatReverse(ret, operator, reversedOp, operatorDef, revOperatorDef, isForDisplay);\n    }\n\n    return ret;\n  }\n};\n\nvar formatValue = function formatValue(config, meta, value, valueSrc, valueType, fieldWidgetDef, fieldDef, operator, opDef, isForDisplay) {\n  var parentField = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : null;\n  var asyncListValues = arguments.length > 11 ? arguments[11] : undefined;\n  if (value === undefined) return undefined;\n  var ret;\n\n  if (valueSrc == \"field\") {\n    ret = formatField(config, meta, value, isForDisplay, parentField);\n  } else if (valueSrc == \"func\") {\n    ret = formatFunc(config, meta, value, isForDisplay, parentField);\n  } else {\n    if (typeof fieldWidgetDef.formatValue === \"function\") {\n      var fn = fieldWidgetDef.formatValue;\n      var args = [value, _objectSpread(_objectSpread({}, (0, _pick[\"default\"])(fieldDef, [\"fieldSettings\", \"listValues\"])), {}, {\n        asyncListValues: asyncListValues\n      }), //useful options: valueFormat for date/time\n      (0, _omit[\"default\"])(fieldWidgetDef, [\"formatValue\", \"mongoFormatValue\", \"sqlFormatValue\", \"jsonLogic\", \"elasticSearchFormatValue\", \"spelFormatValue\"]), isForDisplay];\n\n      if (operator) {\n        args.push(operator);\n        args.push(opDef);\n      }\n\n      if (valueSrc == \"field\") {\n        var valFieldDefinition = (0, _configUtils.getFieldConfig)(config, value) || {};\n        args.push(valFieldDefinition);\n      }\n\n      ret = fn.apply(void 0, args);\n    } else {\n      ret = value;\n    }\n  }\n\n  return ret;\n};\n\nvar formatField = function formatField(config, meta, field, isForDisplay) {\n  var parentField = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  var cutParentField = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n  var _config$settings2 = config.settings,\n      fieldSeparator = _config$settings2.fieldSeparator,\n      fieldSeparatorDisplay = _config$settings2.fieldSeparatorDisplay;\n  var ret = null;\n\n  if (field) {\n    var fieldDefinition = (0, _configUtils.getFieldConfig)(config, field) || {};\n    var fieldParts = Array.isArray(field) ? field : field.split(fieldSeparator);\n\n    var _fieldKeys = (0, _ruleUtils.getFieldPath)(field, config);\n\n    var fieldPartsLabels = (0, _ruleUtils.getFieldPathLabels)(field, config, cutParentField ? parentField : null);\n    var fieldFullLabel = fieldPartsLabels ? fieldPartsLabels.join(fieldSeparatorDisplay) : null;\n    var fieldLabel2 = fieldDefinition.label2 || fieldFullLabel;\n    var formatFieldFn = config.settings.formatField || _default.settings.formatField;\n    var fieldName = (0, _ruleUtils.formatFieldName)(field, config, meta, cutParentField ? parentField : null);\n    ret = formatFieldFn(fieldName, fieldParts, fieldLabel2, fieldDefinition, config, isForDisplay);\n  }\n\n  return ret;\n};\n\nvar formatFunc = function formatFunc(config, meta, funcValue, isForDisplay) {\n  var parentField = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  var funcKey = funcValue.get(\"func\");\n  var args = funcValue.get(\"args\");\n  var funcConfig = (0, _configUtils.getFuncConfig)(config, funcKey);\n  var funcName = isForDisplay && funcConfig.label || funcKey;\n  var formattedArgs = {};\n  var formattedArgsWithNames = {};\n\n  for (var argKey in funcConfig.args) {\n    var argConfig = funcConfig.args[argKey];\n    var fieldDef = (0, _configUtils.getFieldConfig)(config, argConfig);\n    var argVal = args ? args.get(argKey) : undefined;\n    var argValue = argVal ? argVal.get(\"value\") : undefined;\n    var argValueSrc = argVal ? argVal.get(\"valueSrc\") : undefined;\n    var argAsyncListValues = argVal ? argVal.get(\"asyncListValues\") : undefined;\n    var formattedArgVal = formatValue(config, meta, argValue, argValueSrc, argConfig.type, fieldDef, argConfig, null, null, isForDisplay, parentField, argAsyncListValues);\n    var argName = isForDisplay && argConfig.label || argKey;\n\n    if (formattedArgVal !== undefined) {\n      // skip optional in the end\n      formattedArgs[argKey] = formattedArgVal;\n      formattedArgsWithNames[argName] = formattedArgVal;\n    }\n  }\n\n  var ret = null;\n\n  if (typeof funcConfig.formatFunc === \"function\") {\n    var fn = funcConfig.formatFunc;\n    var _args = [formattedArgs, isForDisplay];\n    ret = fn.apply(void 0, _args);\n  } else {\n    var argsStr = Object.entries(formattedArgsWithNames).map(function (_ref3) {\n      var _ref4 = (0, _slicedToArray2[\"default\"])(_ref3, 2),\n          k = _ref4[0],\n          v = _ref4[1];\n\n      return isForDisplay ? \"\".concat(k, \": \").concat(v) : \"\".concat(v);\n    }).join(\", \");\n    ret = \"\".concat(funcName, \"(\").concat(argsStr, \")\");\n  }\n\n  return ret;\n};"]},"metadata":{},"sourceType":"script"}