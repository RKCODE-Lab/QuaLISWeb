{"ast":null,"code":"import { Node, Fragment } from 'prosemirror-model';\nimport { TextSelection, AllSelection, NodeSelection } from 'prosemirror-state';\nimport { parseContent } from './source';\nexport var changeStylesString = function (styleText, newStyle) {\n  var styleToChange = newStyle.style;\n  var regExp = newStyle.value;\n  var newValue = newStyle.newValue;\n\n  if (!styleText) {\n    return {\n      changed: false,\n      style: null\n    };\n  }\n\n  var styles = styleText.split(/\\s*;\\s*/).filter(function (s) {\n    return Boolean(s);\n  });\n  var filtered = styles.filter(function (s) {\n    var nameValue = s.split(/\\s*:\\s*/);\n    return !(nameValue[0].toLowerCase() === styleToChange && regExp.test(nameValue[1]));\n  });\n\n  if (newValue) {\n    filtered.push(styleToChange + \": \" + newValue);\n  }\n\n  return {\n    style: filtered.join('; ') + (filtered.length ? ';' : ''),\n    changed: Boolean(newValue) || filtered.length !== styles.length\n  };\n};\n/**\n * Determines if a given node type can be inserted at the current cursor position.\n */\n\nexport var canInsert = function (state, nodeType) {\n  var $from = state.selection.$from;\n\n  for (var d = $from.depth; d >= 0; d--) {\n    var index = $from.index(d);\n\n    if ($from.node(d).canReplaceWith(index, index, nodeType)) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nvar getTypeName = function (n) {\n  return n instanceof Node ? n.type.name : n.name;\n};\n\nvar findNthParentNode = function (predicate, depth) {\n  if (depth === void 0) {\n    depth = 1;\n  }\n\n  return function (selection) {\n    var $from = selection.$from;\n\n    for (var i = $from.depth; i > 0; i--) {\n      var node = $from.node(i);\n\n      if (predicate(node)) {\n        depth = depth - 1;\n\n        if (depth === 0) {\n          return {\n            depth: i,\n            node: node\n          };\n        }\n      }\n    }\n  };\n};\n\nexport var findNthParentNodeOfType = function (nodeType, depth) {\n  if (depth === void 0) {\n    depth = 1;\n  }\n\n  return function (selection) {\n    return findNthParentNode(function (node) {\n      return getTypeName(node) === getTypeName(nodeType);\n    }, depth)(selection);\n  };\n};\n/**\n * Inserts the given node at the place of current selection.\n */\n\nexport var insertNode = function (node, scrollIntoView) {\n  return function (state, dispatch) {\n    var tr = state.tr.replaceSelectionWith(node);\n\n    if (scrollIntoView) {\n      tr.scrollIntoView();\n    }\n\n    dispatch(tr);\n  };\n};\nexport var hasSameMarkup = function (dom1, dom2, schema, parseOptions) {\n  var fragment1 = Fragment.from(parseContent(dom1, schema, parseOptions));\n  var fragment2 = Fragment.from(parseContent(dom2, schema, parseOptions));\n  return fragment1.eq(fragment2);\n};\nexport var getSelectionText = function (state) {\n  var sel = state.selection;\n\n  if (sel instanceof TextSelection || sel instanceof AllSelection) {\n    var fragment = sel.content().content;\n    return fragment.textBetween(0, fragment.size);\n  }\n\n  return '';\n};\nexport var getNodeFromSelection = function (state) {\n  if (state.selection instanceof NodeSelection) {\n    return state.selection.node;\n  }\n};\n/**\n * Returns the text from the selection if only text is selected on a single line.\n * If selection contains leaf nodes (br, image) between text elements or\n * text from multiple block nodes, the function will return empty string.\n *\n * Useful for values of the inputs of Link and Find&Replace dialogs where the inputs value has been retrieved from the selection and\n * should be single line text only.\n */\n\nexport var selectedLineTextOnly = function (state) {\n  var result = '',\n      hasLeafs = false;\n  var selection = state.selection,\n      doc = state.doc;\n  var $from = selection.$from,\n      $to = selection.$to,\n      from = selection.from,\n      to = selection.to;\n\n  if ($from.sameParent($to)) {\n    doc.nodesBetween(from, to, function (node) {\n      hasLeafs = hasLeafs || node.isLeaf && !node.isText;\n    });\n\n    if (!hasLeafs) {\n      result = getSelectionText(state);\n    }\n  }\n\n  return result;\n};\n/**\n * Used by ViewHtml/ViewSource dialogs for making the HTML more readable.\n */\n\nexport var indentHtml = function (content) {\n  return content.replace(/<\\/(p|li|ul|ol|h[1-6]|table|tr|td|th)>/ig, '</$1>\\n').replace(/<(ul|ol)([^>]*)><li/ig, '<$1$2>\\n<li').replace(/<br \\/>/ig, '<br />\\n').replace(/\\n$/, '');\n};\nexport var shallowEqual = function (object1, object2) {\n  var keys1 = Object.keys(object1);\n  var keys2 = Object.keys(object2);\n  return keys1.length === keys2.length && keys1.every(function (k) {\n    return object1[k] === object2[k];\n  });\n};","map":{"version":3,"sources":["D:/Postgres_workingFolder/QuaLISWeb/node_modules/@progress/kendo-editor-common/dist/es/utils.js"],"names":["Node","Fragment","TextSelection","AllSelection","NodeSelection","parseContent","changeStylesString","styleText","newStyle","styleToChange","style","regExp","value","newValue","changed","styles","split","filter","s","Boolean","filtered","nameValue","toLowerCase","test","push","join","length","canInsert","state","nodeType","$from","selection","d","depth","index","node","canReplaceWith","getTypeName","n","type","name","findNthParentNode","predicate","i","findNthParentNodeOfType","insertNode","scrollIntoView","dispatch","tr","replaceSelectionWith","hasSameMarkup","dom1","dom2","schema","parseOptions","fragment1","from","fragment2","eq","getSelectionText","sel","fragment","content","textBetween","size","getNodeFromSelection","selectedLineTextOnly","result","hasLeafs","doc","$to","to","sameParent","nodesBetween","isLeaf","isText","indentHtml","replace","shallowEqual","object1","object2","keys1","Object","keys","keys2","every","k"],"mappings":"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","sourcesContent":["import { Node, Fragment } from 'prosemirror-model';\nimport { TextSelection, AllSelection, NodeSelection } from 'prosemirror-state';\nimport { parseContent } from './source';\nexport var changeStylesString = function (styleText, newStyle) {\n    var styleToChange = newStyle.style;\n    var regExp = newStyle.value;\n    var newValue = newStyle.newValue;\n    if (!styleText) {\n        return { changed: false, style: null };\n    }\n    var styles = styleText.split(/\\s*;\\s*/).filter(function (s) { return Boolean(s); });\n    var filtered = styles.filter(function (s) {\n        var nameValue = s.split(/\\s*:\\s*/);\n        return !(nameValue[0].toLowerCase() === styleToChange && regExp.test(nameValue[1]));\n    });\n    if (newValue) {\n        filtered.push(styleToChange + \": \" + newValue);\n    }\n    return {\n        style: filtered.join('; ') + (filtered.length ? ';' : ''),\n        changed: Boolean(newValue) || filtered.length !== styles.length\n    };\n};\n/**\n * Determines if a given node type can be inserted at the current cursor position.\n */\nexport var canInsert = function (state, nodeType) {\n    var $from = state.selection.$from;\n    for (var d = $from.depth; d >= 0; d--) {\n        var index = $from.index(d);\n        if ($from.node(d).canReplaceWith(index, index, nodeType)) {\n            return true;\n        }\n    }\n    return false;\n};\nvar getTypeName = function (n) {\n    return n instanceof Node ? n.type.name : n.name;\n};\nvar findNthParentNode = function (predicate, depth) {\n    if (depth === void 0) { depth = 1; }\n    return function (selection) {\n        var $from = selection.$from;\n        for (var i = $from.depth; i > 0; i--) {\n            var node = $from.node(i);\n            if (predicate(node)) {\n                depth = depth - 1;\n                if (depth === 0) {\n                    return { depth: i, node: node };\n                }\n            }\n        }\n    };\n};\nexport var findNthParentNodeOfType = function (nodeType, depth) {\n    if (depth === void 0) { depth = 1; }\n    return function (selection) {\n        return findNthParentNode(function (node) { return getTypeName(node) === getTypeName(nodeType); }, depth)(selection);\n    };\n};\n/**\n * Inserts the given node at the place of current selection.\n */\nexport var insertNode = function (node, scrollIntoView) { return function (state, dispatch) {\n    var tr = state.tr.replaceSelectionWith(node);\n    if (scrollIntoView) {\n        tr.scrollIntoView();\n    }\n    dispatch(tr);\n}; };\nexport var hasSameMarkup = function (dom1, dom2, schema, parseOptions) {\n    var fragment1 = Fragment.from(parseContent(dom1, schema, parseOptions));\n    var fragment2 = Fragment.from(parseContent(dom2, schema, parseOptions));\n    return fragment1.eq(fragment2);\n};\nexport var getSelectionText = function (state) {\n    var sel = state.selection;\n    if (sel instanceof TextSelection || sel instanceof AllSelection) {\n        var fragment = sel.content().content;\n        return fragment.textBetween(0, fragment.size);\n    }\n    return '';\n};\nexport var getNodeFromSelection = function (state) {\n    if (state.selection instanceof NodeSelection) {\n        return state.selection.node;\n    }\n};\n/**\n * Returns the text from the selection if only text is selected on a single line.\n * If selection contains leaf nodes (br, image) between text elements or\n * text from multiple block nodes, the function will return empty string.\n *\n * Useful for values of the inputs of Link and Find&Replace dialogs where the inputs value has been retrieved from the selection and\n * should be single line text only.\n */\nexport var selectedLineTextOnly = function (state) {\n    var result = '', hasLeafs = false;\n    var selection = state.selection, doc = state.doc;\n    var $from = selection.$from, $to = selection.$to, from = selection.from, to = selection.to;\n    if ($from.sameParent($to)) {\n        doc.nodesBetween(from, to, function (node) {\n            hasLeafs = hasLeafs || (node.isLeaf && !node.isText);\n        });\n        if (!hasLeafs) {\n            result = getSelectionText(state);\n        }\n    }\n    return result;\n};\n/**\n * Used by ViewHtml/ViewSource dialogs for making the HTML more readable.\n */\nexport var indentHtml = function (content) {\n    return content.replace(/<\\/(p|li|ul|ol|h[1-6]|table|tr|td|th)>/ig, '</$1>\\n')\n        .replace(/<(ul|ol)([^>]*)><li/ig, '<$1$2>\\n<li')\n        .replace(/<br \\/>/ig, '<br />\\n')\n        .replace(/\\n$/, '');\n};\nexport var shallowEqual = function (object1, object2) {\n    var keys1 = Object.keys(object1);\n    var keys2 = Object.keys(object2);\n    return keys1.length === keys2.length &&\n        keys1.every(function (k) { return object1[k] === object2[k]; });\n};\n"]},"metadata":{},"sourceType":"module"}