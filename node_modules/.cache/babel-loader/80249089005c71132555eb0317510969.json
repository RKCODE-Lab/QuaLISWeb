{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.removePathsInTree = exports.removeIsLockedInTree = exports.isEmptyTree = exports.hasChildren = exports.getTreeBadFields = exports.getTotalRulesCountInTree = exports.getTotalReordableNodesCountInTree = exports.getLightTree = exports.getItemByPath = exports.getFlatTree = exports.fixPathsInTree = exports.fixEmptyGroupsInTree = exports.expandTreeSubpath = exports.expandTreePath = void 0;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _immutable = _interopRequireDefault(require(\"immutable\"));\n/**\n * @param {Immutable.List} path\n * @param {...string} suffix\n * @return {Immutable.List}\n */\n\n\nvar expandTreePath = function expandTreePath(path) {\n  for (var _len = arguments.length, suffix = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    suffix[_key - 1] = arguments[_key];\n  }\n\n  return path.interpose(\"children1\").withMutations(function (list) {\n    list.skip(1);\n    list.push.apply(list, suffix);\n    return list;\n  });\n};\n/**\n * @param {Immutable.List} path\n * @param {...string} suffix\n * @return {Immutable.List}\n */\n\n\nexports.expandTreePath = expandTreePath;\n\nvar expandTreeSubpath = function expandTreeSubpath(path) {\n  for (var _len2 = arguments.length, suffix = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    suffix[_key2 - 1] = arguments[_key2];\n  }\n\n  return path.interpose(\"children1\").withMutations(function (list) {\n    list.push.apply(list, suffix);\n    return list;\n  });\n};\n/**\n * @param {Immutable.Map} path\n * @param {Immutable.List} path\n * @return {Immutable.Map}\n */\n\n\nexports.expandTreeSubpath = expandTreeSubpath;\n\nvar getItemByPath = function getItemByPath(tree, path) {\n  var children = new _immutable[\"default\"].OrderedMap((0, _defineProperty2[\"default\"])({}, tree.get(\"id\"), tree));\n  var res = tree;\n  path.forEach(function (id) {\n    res = children.get(id);\n    children = res.get(\"children1\");\n  });\n  return res;\n};\n/**\n * Remove `path` in every item\n * @param {Immutable.Map} tree\n * @return {Immutable.Map} tree\n */\n\n\nexports.getItemByPath = getItemByPath;\n\nvar removePathsInTree = function removePathsInTree(tree) {\n  var newTree = tree;\n\n  function _processNode(item, path) {\n    var itemPath = path.push(item.get(\"id\"));\n\n    if (item.get(\"path\")) {\n      newTree = newTree.removeIn(expandTreePath(itemPath, \"path\"));\n    }\n\n    var children = item.get(\"children1\");\n\n    if (children) {\n      children.map(function (child, _childId) {\n        _processNode(child, itemPath);\n      });\n    }\n  }\n\n  _processNode(tree, new _immutable[\"default\"].List());\n\n  return newTree;\n};\n/**\n * Remove `isLocked` in items that inherit parent's `isLocked`\n * @param {Immutable.Map} tree\n * @return {Immutable.Map} tree\n */\n\n\nexports.removePathsInTree = removePathsInTree;\n\nvar removeIsLockedInTree = function removeIsLockedInTree(tree) {\n  var newTree = tree;\n\n  function _processNode(item, path) {\n    var isParentLocked = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var itemPath = path.push(item.get(\"id\"));\n    var isLocked = item.getIn([\"properties\", \"isLocked\"]);\n\n    if (isParentLocked && isLocked) {\n      newTree = newTree.deleteIn(expandTreePath(itemPath, \"properties\", \"isLocked\"));\n    }\n\n    var children = item.get(\"children1\");\n\n    if (children) {\n      children.map(function (child, _childId) {\n        _processNode(child, itemPath, isLocked || isParentLocked);\n      });\n    }\n  }\n\n  _processNode(tree, new _immutable[\"default\"].List());\n\n  return newTree;\n};\n/**\n * Set correct `path` in every item\n * @param {Immutable.Map} tree\n * @return {Immutable.Map} tree\n */\n\n\nexports.removeIsLockedInTree = removeIsLockedInTree;\n\nvar fixPathsInTree = function fixPathsInTree(tree) {\n  var newTree = tree;\n\n  function _processNode(item, path, lev) {\n    if (!item) return;\n\n    var _id = item.get(\"id\");\n\n    var itemPath = path.push(item.get(\"id\"));\n    var currItemPath = item.get(\"path\");\n\n    if (!currItemPath || !currItemPath.equals(itemPath)) {\n      newTree = newTree.setIn(expandTreePath(itemPath, \"path\"), itemPath);\n    }\n\n    var children = item.get(\"children1\");\n\n    if (children) {\n      if (children.constructor.name == \"Map\") {\n        // protect: should me OrderedMap, not Map (issue #501)\n        newTree = newTree.setIn(expandTreePath(itemPath, \"children1\"), new _immutable[\"default\"].OrderedMap(children));\n      }\n\n      children.map(function (child, _childId) {\n        _processNode(child, itemPath, lev + 1);\n      });\n    }\n  }\n\n  _processNode(tree, new _immutable[\"default\"].List(), 0);\n\n  return newTree;\n};\n\nexports.fixPathsInTree = fixPathsInTree;\n\nvar fixEmptyGroupsInTree = function fixEmptyGroupsInTree(tree) {\n  var newTree = tree;\n\n  function _processNode(item, path, lev) {\n    if (!item) return false;\n    var id = item.get(\"id\");\n    var itemPath = path.push(item.get(\"id\"));\n    var children = item.get(\"children1\");\n\n    if (children) {\n      var allChildrenGone = children.map(function (child, _childId) {\n        return _processNode(child, itemPath, lev + 1);\n      }).reduce(function (curr, v) {\n        return curr && v;\n      }, true);\n\n      if ((children.size == 0 || allChildrenGone) && lev > 0) {\n        newTree = newTree.deleteIn(expandTreePath(itemPath));\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  _processNode(tree, new _immutable[\"default\"].List(), 0);\n\n  return newTree;\n};\n/**\n * @param {Immutable.Map} tree\n * @return {Object} {flat, items}\n */\n\n\nexports.fixEmptyGroupsInTree = fixEmptyGroupsInTree;\n\nvar getFlatTree = function getFlatTree(tree) {\n  var flat = [];\n  var items = {};\n  var realHeight = 0;\n\n  function _flatizeTree(item, path, insideCollapsed, insideLocked, lev, info, parentType) {\n    var type = item.get(\"type\");\n    var collapsed = item.get(\"collapsed\");\n    var id = item.get(\"id\");\n    var children = item.get(\"children1\");\n    var isLocked = item.getIn([\"properties\", \"isLocked\"]);\n    var childrenIds = children ? children.map(function (_child, childId) {\n      return childId;\n    }) : null;\n    var itemsBefore = flat.length;\n    var top = realHeight;\n    flat.push(id);\n    if (!insideCollapsed) realHeight += 1;\n    info.height = (info.height || 0) + 1;\n\n    if (children) {\n      var subinfo = {};\n      children.map(function (child, _childId) {\n        _flatizeTree(child, path.concat(id), insideCollapsed || collapsed, insideLocked || isLocked, lev + 1, subinfo, type);\n      });\n\n      if (!collapsed) {\n        info.height = (info.height || 0) + (subinfo.height || 0);\n      }\n    }\n\n    var itemsAfter = flat.length;\n    var _bottom = realHeight;\n    var height = info.height;\n    items[id] = {\n      type: type,\n      parent: path.length ? path[path.length - 1] : null,\n      parentType: parentType,\n      path: path.concat(id),\n      lev: lev,\n      leaf: !children,\n      index: itemsBefore,\n      id: id,\n      children: childrenIds,\n      _top: itemsBefore,\n      _height: itemsAfter - itemsBefore,\n      top: insideCollapsed ? null : top,\n      height: height,\n      bottom: (insideCollapsed ? null : top) + height,\n      collapsed: collapsed,\n      node: item,\n      isLocked: isLocked || insideLocked\n    };\n  }\n\n  _flatizeTree(tree, [], false, false, 0, {}, null);\n\n  for (var i = 0; i < flat.length; i++) {\n    var prevId = i > 0 ? flat[i - 1] : null;\n    var nextId = i < flat.length - 1 ? flat[i + 1] : null;\n    var item = items[flat[i]];\n    item.prev = prevId;\n    item.next = nextId;\n  }\n\n  return {\n    flat: flat,\n    items: items\n  };\n};\n/**\n * Returns count of reorderable(!) nodes\n * @param {Immutable.Map} tree\n * @return {Integer}\n */\n\n\nexports.getFlatTree = getFlatTree;\n\nvar getTotalReordableNodesCountInTree = function getTotalReordableNodesCountInTree(tree) {\n  if (!tree) return -1;\n  var cnt = 0;\n\n  function _processNode(item, path, lev) {\n    var id = item.get(\"id\");\n    var children = item.get(\"children1\");\n    var isRuleGroup = item.get(\"type\") == \"rule_group\";\n    cnt++; //tip: rules in rule-group can be reordered only inside\n\n    if (children && !isRuleGroup) {\n      children.map(function (child, _childId) {\n        _processNode(child, path.concat(id), lev + 1);\n      });\n    }\n  }\n\n  _processNode(tree, [], 0);\n\n  return cnt - 1; // -1 for root\n};\n/**\n * Returns count of rules (leafs, i.e. don't count groups)\n * @param {Immutable.Map} tree\n * @return {Integer}\n */\n\n\nexports.getTotalReordableNodesCountInTree = getTotalReordableNodesCountInTree;\n\nvar getTotalRulesCountInTree = function getTotalRulesCountInTree(tree) {\n  if (!tree) return -1;\n  var cnt = 0;\n\n  function _processNode(item, path, lev) {\n    var id = item.get(\"id\");\n    var children = item.get(\"children1\");\n    var isGroup = item.get(\"type\") == \"group\"; //const isRuleGroup = item.get(\"type\") == \"rule_group\";\n\n    if (children && isGroup) {\n      children.map(function (child, _childId) {\n        _processNode(child, path.concat(id), lev + 1);\n      });\n    } else {\n      // tip: count rule_group as 1 rule\n      cnt++;\n    }\n  }\n\n  _processNode(tree, [], 0);\n\n  return cnt;\n};\n\nexports.getTotalRulesCountInTree = getTotalRulesCountInTree;\n\nvar getTreeBadFields = function getTreeBadFields(tree) {\n  var badFields = [];\n\n  function _processNode(item, path, lev) {\n    var id = item.get(\"id\");\n    var children = item.get(\"children1\");\n    var valueError = item.getIn([\"properties\", \"valueError\"]);\n    var field = item.getIn([\"properties\", \"field\"]);\n\n    if (valueError && valueError.size > 0 && valueError.filter(function (v) {\n      return v != null;\n    }).size > 0) {\n      badFields.push(field);\n    }\n\n    if (children) {\n      children.map(function (child, _childId) {\n        _processNode(child, path.concat(id), lev + 1);\n      });\n    }\n  }\n\n  if (tree) _processNode(tree, [], 0);\n  return Array.from(new Set(badFields));\n}; // Remove fields that can be calced: \"id\", \"path\"\n// Remove empty fields: \"operatorOptions\"\n\n\nexports.getTreeBadFields = getTreeBadFields;\n\nvar getLightTree = function getLightTree(tree) {\n  var newTree = tree;\n\n  function _processNode(item, itemId) {\n    if (item.path) delete item.path;\n    if (itemId) delete item.id;\n    var properties = item.properties;\n\n    if (properties) {\n      if (properties.operatorOptions == null) delete properties.operatorOptions;\n    }\n\n    var children = item.children1;\n\n    if (children) {\n      for (var id in children) {\n        _processNode(children[id], id);\n      }\n    }\n  }\n\n  _processNode(tree, null);\n\n  return newTree;\n};\n\nexports.getLightTree = getLightTree;\n\nvar isEmptyTree = function isEmptyTree(tree) {\n  return !tree.get(\"children1\") || tree.get(\"children1\").size == 0;\n};\n\nexports.isEmptyTree = isEmptyTree;\n\nvar hasChildren = function hasChildren(tree, path) {\n  return tree.getIn(expandTreePath(path, \"children1\")).size > 0;\n};\n\nexports.hasChildren = hasChildren;","map":{"version":3,"sources":["D:/LIMSWFH/LIMSPOSTGRESQL/QuaLISWeb/node_modules/react-awesome-query-builder/lib/utils/treeUtils.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","removePathsInTree","removeIsLockedInTree","isEmptyTree","hasChildren","getTreeBadFields","getTotalRulesCountInTree","getTotalReordableNodesCountInTree","getLightTree","getItemByPath","getFlatTree","fixPathsInTree","fixEmptyGroupsInTree","expandTreeSubpath","expandTreePath","_defineProperty2","_immutable","path","_len","arguments","length","suffix","Array","_key","interpose","withMutations","list","skip","push","apply","_len2","_key2","tree","children","OrderedMap","get","res","forEach","id","newTree","_processNode","item","itemPath","removeIn","map","child","_childId","List","isParentLocked","undefined","isLocked","getIn","deleteIn","lev","_id","currItemPath","equals","setIn","constructor","name","allChildrenGone","reduce","curr","v","size","flat","items","realHeight","_flatizeTree","insideCollapsed","insideLocked","info","parentType","type","collapsed","childrenIds","_child","childId","itemsBefore","top","height","subinfo","concat","itemsAfter","_bottom","parent","leaf","index","_top","_height","bottom","node","i","prevId","nextId","prev","next","cnt","isRuleGroup","isGroup","badFields","valueError","field","filter","from","Set","itemId","properties","operatorOptions","children1"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.removePathsInTree = exports.removeIsLockedInTree = exports.isEmptyTree = exports.hasChildren = exports.getTreeBadFields = exports.getTotalRulesCountInTree = exports.getTotalReordableNodesCountInTree = exports.getLightTree = exports.getItemByPath = exports.getFlatTree = exports.fixPathsInTree = exports.fixEmptyGroupsInTree = exports.expandTreeSubpath = exports.expandTreePath = void 0;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _immutable = _interopRequireDefault(require(\"immutable\"));\n\n/**\n * @param {Immutable.List} path\n * @param {...string} suffix\n * @return {Immutable.List}\n */\nvar expandTreePath = function expandTreePath(path) {\n  for (var _len = arguments.length, suffix = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    suffix[_key - 1] = arguments[_key];\n  }\n\n  return path.interpose(\"children1\").withMutations(function (list) {\n    list.skip(1);\n    list.push.apply(list, suffix);\n    return list;\n  });\n};\n/**\n * @param {Immutable.List} path\n * @param {...string} suffix\n * @return {Immutable.List}\n */\n\n\nexports.expandTreePath = expandTreePath;\n\nvar expandTreeSubpath = function expandTreeSubpath(path) {\n  for (var _len2 = arguments.length, suffix = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    suffix[_key2 - 1] = arguments[_key2];\n  }\n\n  return path.interpose(\"children1\").withMutations(function (list) {\n    list.push.apply(list, suffix);\n    return list;\n  });\n};\n/**\n * @param {Immutable.Map} path\n * @param {Immutable.List} path\n * @return {Immutable.Map}\n */\n\n\nexports.expandTreeSubpath = expandTreeSubpath;\n\nvar getItemByPath = function getItemByPath(tree, path) {\n  var children = new _immutable[\"default\"].OrderedMap((0, _defineProperty2[\"default\"])({}, tree.get(\"id\"), tree));\n  var res = tree;\n  path.forEach(function (id) {\n    res = children.get(id);\n    children = res.get(\"children1\");\n  });\n  return res;\n};\n/**\n * Remove `path` in every item\n * @param {Immutable.Map} tree\n * @return {Immutable.Map} tree\n */\n\n\nexports.getItemByPath = getItemByPath;\n\nvar removePathsInTree = function removePathsInTree(tree) {\n  var newTree = tree;\n\n  function _processNode(item, path) {\n    var itemPath = path.push(item.get(\"id\"));\n\n    if (item.get(\"path\")) {\n      newTree = newTree.removeIn(expandTreePath(itemPath, \"path\"));\n    }\n\n    var children = item.get(\"children1\");\n\n    if (children) {\n      children.map(function (child, _childId) {\n        _processNode(child, itemPath);\n      });\n    }\n  }\n\n  _processNode(tree, new _immutable[\"default\"].List());\n\n  return newTree;\n};\n/**\n * Remove `isLocked` in items that inherit parent's `isLocked`\n * @param {Immutable.Map} tree\n * @return {Immutable.Map} tree\n */\n\n\nexports.removePathsInTree = removePathsInTree;\n\nvar removeIsLockedInTree = function removeIsLockedInTree(tree) {\n  var newTree = tree;\n\n  function _processNode(item, path) {\n    var isParentLocked = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var itemPath = path.push(item.get(\"id\"));\n    var isLocked = item.getIn([\"properties\", \"isLocked\"]);\n\n    if (isParentLocked && isLocked) {\n      newTree = newTree.deleteIn(expandTreePath(itemPath, \"properties\", \"isLocked\"));\n    }\n\n    var children = item.get(\"children1\");\n\n    if (children) {\n      children.map(function (child, _childId) {\n        _processNode(child, itemPath, isLocked || isParentLocked);\n      });\n    }\n  }\n\n  _processNode(tree, new _immutable[\"default\"].List());\n\n  return newTree;\n};\n/**\n * Set correct `path` in every item\n * @param {Immutable.Map} tree\n * @return {Immutable.Map} tree\n */\n\n\nexports.removeIsLockedInTree = removeIsLockedInTree;\n\nvar fixPathsInTree = function fixPathsInTree(tree) {\n  var newTree = tree;\n\n  function _processNode(item, path, lev) {\n    if (!item) return;\n\n    var _id = item.get(\"id\");\n\n    var itemPath = path.push(item.get(\"id\"));\n    var currItemPath = item.get(\"path\");\n\n    if (!currItemPath || !currItemPath.equals(itemPath)) {\n      newTree = newTree.setIn(expandTreePath(itemPath, \"path\"), itemPath);\n    }\n\n    var children = item.get(\"children1\");\n\n    if (children) {\n      if (children.constructor.name == \"Map\") {\n        // protect: should me OrderedMap, not Map (issue #501)\n        newTree = newTree.setIn(expandTreePath(itemPath, \"children1\"), new _immutable[\"default\"].OrderedMap(children));\n      }\n\n      children.map(function (child, _childId) {\n        _processNode(child, itemPath, lev + 1);\n      });\n    }\n  }\n\n  _processNode(tree, new _immutable[\"default\"].List(), 0);\n\n  return newTree;\n};\n\nexports.fixPathsInTree = fixPathsInTree;\n\nvar fixEmptyGroupsInTree = function fixEmptyGroupsInTree(tree) {\n  var newTree = tree;\n\n  function _processNode(item, path, lev) {\n    if (!item) return false;\n    var id = item.get(\"id\");\n    var itemPath = path.push(item.get(\"id\"));\n    var children = item.get(\"children1\");\n\n    if (children) {\n      var allChildrenGone = children.map(function (child, _childId) {\n        return _processNode(child, itemPath, lev + 1);\n      }).reduce(function (curr, v) {\n        return curr && v;\n      }, true);\n\n      if ((children.size == 0 || allChildrenGone) && lev > 0) {\n        newTree = newTree.deleteIn(expandTreePath(itemPath));\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  _processNode(tree, new _immutable[\"default\"].List(), 0);\n\n  return newTree;\n};\n/**\n * @param {Immutable.Map} tree\n * @return {Object} {flat, items}\n */\n\n\nexports.fixEmptyGroupsInTree = fixEmptyGroupsInTree;\n\nvar getFlatTree = function getFlatTree(tree) {\n  var flat = [];\n  var items = {};\n  var realHeight = 0;\n\n  function _flatizeTree(item, path, insideCollapsed, insideLocked, lev, info, parentType) {\n    var type = item.get(\"type\");\n    var collapsed = item.get(\"collapsed\");\n    var id = item.get(\"id\");\n    var children = item.get(\"children1\");\n    var isLocked = item.getIn([\"properties\", \"isLocked\"]);\n    var childrenIds = children ? children.map(function (_child, childId) {\n      return childId;\n    }) : null;\n    var itemsBefore = flat.length;\n    var top = realHeight;\n    flat.push(id);\n    if (!insideCollapsed) realHeight += 1;\n    info.height = (info.height || 0) + 1;\n\n    if (children) {\n      var subinfo = {};\n      children.map(function (child, _childId) {\n        _flatizeTree(child, path.concat(id), insideCollapsed || collapsed, insideLocked || isLocked, lev + 1, subinfo, type);\n      });\n\n      if (!collapsed) {\n        info.height = (info.height || 0) + (subinfo.height || 0);\n      }\n    }\n\n    var itemsAfter = flat.length;\n    var _bottom = realHeight;\n    var height = info.height;\n    items[id] = {\n      type: type,\n      parent: path.length ? path[path.length - 1] : null,\n      parentType: parentType,\n      path: path.concat(id),\n      lev: lev,\n      leaf: !children,\n      index: itemsBefore,\n      id: id,\n      children: childrenIds,\n      _top: itemsBefore,\n      _height: itemsAfter - itemsBefore,\n      top: insideCollapsed ? null : top,\n      height: height,\n      bottom: (insideCollapsed ? null : top) + height,\n      collapsed: collapsed,\n      node: item,\n      isLocked: isLocked || insideLocked\n    };\n  }\n\n  _flatizeTree(tree, [], false, false, 0, {}, null);\n\n  for (var i = 0; i < flat.length; i++) {\n    var prevId = i > 0 ? flat[i - 1] : null;\n    var nextId = i < flat.length - 1 ? flat[i + 1] : null;\n    var item = items[flat[i]];\n    item.prev = prevId;\n    item.next = nextId;\n  }\n\n  return {\n    flat: flat,\n    items: items\n  };\n};\n/**\n * Returns count of reorderable(!) nodes\n * @param {Immutable.Map} tree\n * @return {Integer}\n */\n\n\nexports.getFlatTree = getFlatTree;\n\nvar getTotalReordableNodesCountInTree = function getTotalReordableNodesCountInTree(tree) {\n  if (!tree) return -1;\n  var cnt = 0;\n\n  function _processNode(item, path, lev) {\n    var id = item.get(\"id\");\n    var children = item.get(\"children1\");\n    var isRuleGroup = item.get(\"type\") == \"rule_group\";\n    cnt++; //tip: rules in rule-group can be reordered only inside\n\n    if (children && !isRuleGroup) {\n      children.map(function (child, _childId) {\n        _processNode(child, path.concat(id), lev + 1);\n      });\n    }\n  }\n\n  _processNode(tree, [], 0);\n\n  return cnt - 1; // -1 for root\n};\n/**\n * Returns count of rules (leafs, i.e. don't count groups)\n * @param {Immutable.Map} tree\n * @return {Integer}\n */\n\n\nexports.getTotalReordableNodesCountInTree = getTotalReordableNodesCountInTree;\n\nvar getTotalRulesCountInTree = function getTotalRulesCountInTree(tree) {\n  if (!tree) return -1;\n  var cnt = 0;\n\n  function _processNode(item, path, lev) {\n    var id = item.get(\"id\");\n    var children = item.get(\"children1\");\n    var isGroup = item.get(\"type\") == \"group\"; //const isRuleGroup = item.get(\"type\") == \"rule_group\";\n\n    if (children && isGroup) {\n      children.map(function (child, _childId) {\n        _processNode(child, path.concat(id), lev + 1);\n      });\n    } else {\n      // tip: count rule_group as 1 rule\n      cnt++;\n    }\n  }\n\n  _processNode(tree, [], 0);\n\n  return cnt;\n};\n\nexports.getTotalRulesCountInTree = getTotalRulesCountInTree;\n\nvar getTreeBadFields = function getTreeBadFields(tree) {\n  var badFields = [];\n\n  function _processNode(item, path, lev) {\n    var id = item.get(\"id\");\n    var children = item.get(\"children1\");\n    var valueError = item.getIn([\"properties\", \"valueError\"]);\n    var field = item.getIn([\"properties\", \"field\"]);\n\n    if (valueError && valueError.size > 0 && valueError.filter(function (v) {\n      return v != null;\n    }).size > 0) {\n      badFields.push(field);\n    }\n\n    if (children) {\n      children.map(function (child, _childId) {\n        _processNode(child, path.concat(id), lev + 1);\n      });\n    }\n  }\n\n  if (tree) _processNode(tree, [], 0);\n  return Array.from(new Set(badFields));\n}; // Remove fields that can be calced: \"id\", \"path\"\n// Remove empty fields: \"operatorOptions\"\n\n\nexports.getTreeBadFields = getTreeBadFields;\n\nvar getLightTree = function getLightTree(tree) {\n  var newTree = tree;\n\n  function _processNode(item, itemId) {\n    if (item.path) delete item.path;\n    if (itemId) delete item.id;\n    var properties = item.properties;\n\n    if (properties) {\n      if (properties.operatorOptions == null) delete properties.operatorOptions;\n    }\n\n    var children = item.children1;\n\n    if (children) {\n      for (var id in children) {\n        _processNode(children[id], id);\n      }\n    }\n  }\n\n  _processNode(tree, null);\n\n  return newTree;\n};\n\nexports.getLightTree = getLightTree;\n\nvar isEmptyTree = function isEmptyTree(tree) {\n  return !tree.get(\"children1\") || tree.get(\"children1\").size == 0;\n};\n\nexports.isEmptyTree = isEmptyTree;\n\nvar hasChildren = function hasChildren(tree, path) {\n  return tree.getIn(expandTreePath(path, \"children1\")).size > 0;\n};\n\nexports.hasChildren = hasChildren;"]},"metadata":{},"sourceType":"script"}