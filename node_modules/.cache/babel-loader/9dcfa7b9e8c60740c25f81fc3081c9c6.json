{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nimport { getFieldConfig, getOperatorConfig, getFieldWidgetConfig, getFuncConfig } from \"../utils/configUtils\";\nimport { getFieldPath, getFieldPathLabels, getWidgetForFieldOp, formatFieldName } from \"../utils/ruleUtils\";\nimport omit from \"lodash/omit\";\nimport pick from \"lodash/pick\";\nimport { defaultValue } from \"../utils/stuff\";\nimport { defaultConjunction } from \"../utils/defaultUtils\";\nimport { completeValue } from \"../utils/funcUtils\";\nimport { List, Map } from \"immutable\";\nimport { SqlString } from \"../utils/export\";\nexport var sqlFormat = function sqlFormat(tree, config) {\n  return _sqlFormat(tree, config, false);\n};\nexport var _sqlFormat = function _sqlFormat(tree, config) {\n  var returnErrors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true; //meta is mutable\n\n  var meta = {\n    errors: []\n  };\n  var res = formatItem(tree, config, meta);\n\n  if (returnErrors) {\n    return [res, meta.errors];\n  } else {\n    if (meta.errors.length) console.warn(\"Errors while exporting to SQL:\", meta.errors);\n    return res;\n  }\n};\n\nvar formatItem = function formatItem(item, config, meta) {\n  if (!item) return undefined;\n  var type = item.get(\"type\");\n  var children = item.get(\"children1\");\n\n  if (type === \"group\" || type === \"rule_group\") {\n    return formatGroup(item, config, meta);\n  } else if (type === \"rule\") {\n    return formatRule(item, config, meta);\n  }\n\n  return undefined;\n};\n\nvar formatGroup = function formatGroup(item, config, meta) {\n  var type = item.get(\"type\");\n  var properties = item.get(\"properties\") || new Map();\n  var children = item.get(\"children1\") || new List();\n  var isRuleGroup = type === \"rule_group\";\n  var groupField = isRuleGroup ? properties.get(\"field\") : null;\n  var groupFieldDef = getFieldConfig(config, groupField) || {};\n  var mode = groupFieldDef.mode;\n\n  if (mode == \"array\") {\n    meta.errors.push(\"Aggregation is not supported for \".concat(groupField));\n  }\n\n  var not = properties.get(\"not\");\n  var canHaveEmptyChildren = false; //isRuleGroup && mode == \"array\";\n\n  var list = children.map(function (currentChild) {\n    return formatItem(currentChild, config, meta);\n  }).filter(function (currentChild) {\n    return typeof currentChild !== \"undefined\";\n  });\n  if (!canHaveEmptyChildren && !list.size) return undefined;\n  var conjunction = properties.get(\"conjunction\");\n  if (!conjunction) conjunction = defaultConjunction(config);\n  var conjunctionDefinition = config.conjunctions[conjunction];\n  return conjunctionDefinition.sqlFormatConj(list, conjunction, not);\n};\n\nvar buildFnToFormatOp = function buildFnToFormatOp(operator, operatorDefinition) {\n  var sqlOp = operatorDefinition.sqlOp || operator;\n  var cardinality = defaultValue(operatorDefinition.cardinality, 1);\n  var fn;\n\n  if (cardinality == 0) {\n    fn = function fn(field, op, values, valueSrc, valueType, opDef, operatorOptions, fieldDef) {\n      return \"\".concat(field, \" \").concat(sqlOp);\n    };\n  } else if (cardinality == 1) {\n    fn = function fn(field, op, value, valueSrc, valueType, opDef, operatorOptions, fieldDef) {\n      return \"\".concat(field, \" \").concat(sqlOp, \" \").concat(value);\n    };\n  } else if (cardinality == 2) {\n    // between\n    fn = function fn(field, op, values, valueSrc, valueType, opDef, operatorOptions, fieldDef) {\n      var valFrom = values.first();\n      var valTo = values.get(1);\n      return \"\".concat(field, \" \").concat(sqlOp, \" \").concat(valFrom, \" AND \").concat(valTo);\n    };\n  }\n\n  return fn;\n};\n\nvar formatRule = function formatRule(item, config, meta) {\n  var properties = item.get(\"properties\") || new Map();\n  var field = properties.get(\"field\");\n  var operator = properties.get(\"operator\");\n  var operatorOptions = properties.get(\"operatorOptions\");\n  var iValueSrc = properties.get(\"valueSrc\");\n  var iValueType = properties.get(\"valueType\");\n  var iValue = properties.get(\"value\");\n  var asyncListValues = properties.get(\"asyncListValues\");\n  if (field == null || operator == null) return undefined;\n  var fieldDefinition = getFieldConfig(config, field) || {};\n  var opDef = getOperatorConfig(config, operator, field) || {};\n  var reversedOp = opDef.reversedOp;\n  var revOpDef = getOperatorConfig(config, reversedOp, field) || {};\n  var cardinality = defaultValue(opDef.cardinality, 1); // check op\n\n  var isRev = false;\n  var canFormatOp = opDef.sqlOp || opDef.sqlFormatOp;\n  var canFormatRevOp = revOpDef.sqlOp || revOpDef.sqlFormatOp;\n\n  if (!canFormatOp && !canFormatRevOp) {\n    meta.errors.push(\"Operator \".concat(operator, \" is not supported\"));\n    return undefined;\n  }\n\n  if (!canFormatRevOp && canFormatRevOp) {\n    isRev = true;\n    var _ref = [reversedOp, operator];\n    operator = _ref[0];\n    reversedOp = _ref[1];\n    var _ref2 = [revOpDef, opDef];\n    opDef = _ref2[0];\n    revOpDef = _ref2[1];\n  } //format value\n\n\n  var valueSrcs = [];\n  var valueTypes = [];\n  var fvalue = iValue.map(function (currentValue, ind) {\n    var valueSrc = iValueSrc ? iValueSrc.get(ind) : null;\n    var valueType = iValueType ? iValueType.get(ind) : null;\n    var cValue = completeValue(currentValue, valueSrc, config);\n    var widget = getWidgetForFieldOp(config, field, operator, valueSrc);\n    var fieldWidgetDefinition = omit(getFieldWidgetConfig(config, field, operator, widget, valueSrc), [\"factory\"]);\n    var fv = formatValue(meta, config, cValue, valueSrc, valueType, fieldWidgetDefinition, fieldDefinition, operator, opDef, asyncListValues);\n\n    if (fv !== undefined) {\n      valueSrcs.push(valueSrc);\n      valueTypes.push(valueType);\n    }\n\n    return fv;\n  });\n  var hasUndefinedValues = fvalue.filter(function (v) {\n    return v === undefined;\n  }).size > 0;\n  if (hasUndefinedValues || fvalue.size < cardinality) return undefined;\n  var formattedValue = cardinality == 1 ? fvalue.first() : fvalue; //find fn to format expr\n\n  var fn = opDef.sqlFormatOp || buildFnToFormatOp(operator, opDef);\n\n  if (!fn) {\n    meta.errors.push(\"Operator \".concat(operator, \" is not supported\"));\n    return undefined;\n  } //format field\n\n\n  var formattedField = formatField(meta, config, field); //format expr\n\n  var args = [formattedField, operator, formattedValue, valueSrcs.length > 1 ? valueSrcs : valueSrcs[0], valueTypes.length > 1 ? valueTypes : valueTypes[0], omit(opDef, [\"formatOp\", \"mongoFormatOp\", \"sqlFormatOp\", \"jsonLogic\", \"spelFormatOp\"]), operatorOptions, fieldDefinition];\n  var ret;\n  ret = fn.apply(void 0, args);\n\n  if (isRev) {\n    ret = config.settings.sqlFormatReverse(ret);\n  }\n\n  if (ret === undefined) {\n    meta.errors.push(\"Operator \".concat(operator, \" is not supported for value source \").concat(valueSrcs.join(\", \")));\n    return undefined;\n  }\n\n  return ret;\n};\n\nvar formatValue = function formatValue(meta, config, currentValue, valueSrc, valueType, fieldWidgetDef, fieldDef, operator, operatorDef, asyncListValues) {\n  if (currentValue === undefined) return undefined;\n  var ret;\n\n  if (valueSrc == \"field\") {\n    ret = formatField(meta, config, currentValue);\n  } else if (valueSrc == \"func\") {\n    ret = formatFunc(meta, config, currentValue);\n  } else {\n    if (typeof fieldWidgetDef.sqlFormatValue === \"function\") {\n      var fn = fieldWidgetDef.sqlFormatValue;\n      var args = [currentValue, _objectSpread(_objectSpread({}, pick(fieldDef, [\"fieldSettings\", \"listValues\"])), {}, {\n        asyncListValues: asyncListValues\n      }), //useful options: valueFormat for date/time\n      omit(fieldWidgetDef, [\"formatValue\", \"mongoFormatValue\", \"sqlFormatValue\", \"jsonLogic\", \"elasticSearchFormatValue\", \"spelFormatValue\"])];\n\n      if (operator) {\n        args.push(operator);\n        args.push(operatorDef);\n      }\n\n      if (valueSrc == \"field\") {\n        var valFieldDefinition = getFieldConfig(config, currentValue) || {};\n        args.push(valFieldDefinition);\n      }\n\n      ret = fn.apply(void 0, args);\n    } else {\n      if (Array.isArray(currentValue)) {\n        ret = currentValue.map(function (v) {\n          return SqlString.escape(v);\n        });\n      } else {\n        ret = SqlString.escape(currentValue);\n      }\n    }\n  }\n\n  return ret;\n};\n\nvar formatField = function formatField(meta, config, field) {\n  if (!field) return;\n  var fieldSeparator = config.settings.fieldSeparator;\n  var fieldDefinition = getFieldConfig(config, field) || {};\n  var fieldParts = Array.isArray(field) ? field : field.split(fieldSeparator);\n\n  var _fieldKeys = getFieldPath(field, config);\n\n  var fieldPartsLabels = getFieldPathLabels(field, config);\n  var fieldFullLabel = fieldPartsLabels ? fieldPartsLabels.join(fieldSeparator) : null;\n  var formatFieldFn = config.settings.formatField;\n  var fieldName = formatFieldName(field, config, meta);\n  var formattedField = formatFieldFn(fieldName, fieldParts, fieldFullLabel, fieldDefinition, config);\n  return formattedField;\n};\n\nvar formatFunc = function formatFunc(meta, config, currentValue) {\n  var funcKey = currentValue.get(\"func\");\n  var args = currentValue.get(\"args\");\n  var funcConfig = getFuncConfig(config, funcKey);\n  var funcName = funcConfig.sqlFunc || funcKey;\n  var formattedArgs = {};\n\n  for (var argKey in funcConfig.args) {\n    var argConfig = funcConfig.args[argKey];\n    var fieldDef = getFieldConfig(config, argConfig);\n    var argVal = args ? args.get(argKey) : undefined;\n    var argValue = argVal ? argVal.get(\"value\") : undefined;\n    var argValueSrc = argVal ? argVal.get(\"valueSrc\") : undefined;\n    var argAsyncListValues = argVal ? argVal.get(\"asyncListValues\") : undefined;\n    var formattedArgVal = formatValue(meta, config, argValue, argValueSrc, argConfig.type, fieldDef, argConfig, null, null, argAsyncListValues);\n\n    if (argValue != undefined && formattedArgVal === undefined) {\n      meta.errors.push(\"Can't format value of arg \".concat(argKey, \" for func \").concat(funcKey));\n      return undefined;\n    }\n\n    if (formattedArgVal !== undefined) {\n      // skip optional in the end\n      formattedArgs[argKey] = formattedArgVal;\n    }\n  }\n\n  var ret;\n\n  if (typeof funcConfig.sqlFormatFunc === \"function\") {\n    var fn = funcConfig.sqlFormatFunc;\n    var _args = [formattedArgs];\n    ret = fn.apply(void 0, _args);\n  } else {\n    var argsStr = Object.entries(formattedArgs).map(function (_ref3) {\n      var _ref4 = _slicedToArray(_ref3, 2),\n          k = _ref4[0],\n          v = _ref4[1];\n\n      return v;\n    }).join(\", \");\n    ret = \"\".concat(funcName, \"(\").concat(argsStr, \")\");\n  }\n\n  return ret;\n};","map":{"version":3,"sources":["D:/LIMSWFH/LIMSPOSTGRESQL/QuaLISWeb/node_modules/@react-awesome-query-builder/core/esm/export/sql.js"],"names":["_slicedToArray","_defineProperty","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","getFieldConfig","getOperatorConfig","getFieldWidgetConfig","getFuncConfig","getFieldPath","getFieldPathLabels","getWidgetForFieldOp","formatFieldName","omit","pick","defaultValue","defaultConjunction","completeValue","List","Map","SqlString","sqlFormat","tree","config","_sqlFormat","returnErrors","undefined","meta","errors","res","formatItem","console","warn","item","type","get","children","formatGroup","formatRule","properties","isRuleGroup","groupField","groupFieldDef","mode","concat","not","canHaveEmptyChildren","list","map","currentChild","size","conjunction","conjunctionDefinition","conjunctions","sqlFormatConj","buildFnToFormatOp","operator","operatorDefinition","sqlOp","cardinality","fn","field","op","values","valueSrc","valueType","opDef","operatorOptions","fieldDef","value","valFrom","first","valTo","iValueSrc","iValueType","iValue","asyncListValues","fieldDefinition","reversedOp","revOpDef","isRev","canFormatOp","sqlFormatOp","canFormatRevOp","_ref","_ref2","valueSrcs","valueTypes","fvalue","currentValue","ind","cValue","widget","fieldWidgetDefinition","fv","formatValue","hasUndefinedValues","v","formattedValue","formattedField","formatField","args","ret","settings","sqlFormatReverse","join","fieldWidgetDef","operatorDef","formatFunc","sqlFormatValue","valFieldDefinition","Array","isArray","escape","fieldSeparator","fieldParts","split","_fieldKeys","fieldPartsLabels","fieldFullLabel","formatFieldFn","fieldName","funcKey","funcConfig","funcName","sqlFunc","formattedArgs","argKey","argConfig","argVal","argValue","argValueSrc","argAsyncListValues","formattedArgVal","sqlFormatFunc","_args","argsStr","entries","_ref3","_ref4","k"],"mappings":"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","sourcesContent":["import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nimport { getFieldConfig, getOperatorConfig, getFieldWidgetConfig, getFuncConfig } from \"../utils/configUtils\";\nimport { getFieldPath, getFieldPathLabels, getWidgetForFieldOp, formatFieldName } from \"../utils/ruleUtils\";\nimport omit from \"lodash/omit\";\nimport pick from \"lodash/pick\";\nimport { defaultValue } from \"../utils/stuff\";\nimport { defaultConjunction } from \"../utils/defaultUtils\";\nimport { completeValue } from \"../utils/funcUtils\";\nimport { List, Map } from \"immutable\";\nimport { SqlString } from \"../utils/export\";\nexport var sqlFormat = function sqlFormat(tree, config) {\n  return _sqlFormat(tree, config, false);\n};\nexport var _sqlFormat = function _sqlFormat(tree, config) {\n  var returnErrors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  //meta is mutable\n  var meta = {\n    errors: []\n  };\n  var res = formatItem(tree, config, meta);\n  if (returnErrors) {\n    return [res, meta.errors];\n  } else {\n    if (meta.errors.length) console.warn(\"Errors while exporting to SQL:\", meta.errors);\n    return res;\n  }\n};\nvar formatItem = function formatItem(item, config, meta) {\n  if (!item) return undefined;\n  var type = item.get(\"type\");\n  var children = item.get(\"children1\");\n  if (type === \"group\" || type === \"rule_group\") {\n    return formatGroup(item, config, meta);\n  } else if (type === \"rule\") {\n    return formatRule(item, config, meta);\n  }\n  return undefined;\n};\nvar formatGroup = function formatGroup(item, config, meta) {\n  var type = item.get(\"type\");\n  var properties = item.get(\"properties\") || new Map();\n  var children = item.get(\"children1\") || new List();\n  var isRuleGroup = type === \"rule_group\";\n  var groupField = isRuleGroup ? properties.get(\"field\") : null;\n  var groupFieldDef = getFieldConfig(config, groupField) || {};\n  var mode = groupFieldDef.mode;\n  if (mode == \"array\") {\n    meta.errors.push(\"Aggregation is not supported for \".concat(groupField));\n  }\n  var not = properties.get(\"not\");\n  var canHaveEmptyChildren = false; //isRuleGroup && mode == \"array\";\n  var list = children.map(function (currentChild) {\n    return formatItem(currentChild, config, meta);\n  }).filter(function (currentChild) {\n    return typeof currentChild !== \"undefined\";\n  });\n  if (!canHaveEmptyChildren && !list.size) return undefined;\n  var conjunction = properties.get(\"conjunction\");\n  if (!conjunction) conjunction = defaultConjunction(config);\n  var conjunctionDefinition = config.conjunctions[conjunction];\n  return conjunctionDefinition.sqlFormatConj(list, conjunction, not);\n};\nvar buildFnToFormatOp = function buildFnToFormatOp(operator, operatorDefinition) {\n  var sqlOp = operatorDefinition.sqlOp || operator;\n  var cardinality = defaultValue(operatorDefinition.cardinality, 1);\n  var fn;\n  if (cardinality == 0) {\n    fn = function fn(field, op, values, valueSrc, valueType, opDef, operatorOptions, fieldDef) {\n      return \"\".concat(field, \" \").concat(sqlOp);\n    };\n  } else if (cardinality == 1) {\n    fn = function fn(field, op, value, valueSrc, valueType, opDef, operatorOptions, fieldDef) {\n      return \"\".concat(field, \" \").concat(sqlOp, \" \").concat(value);\n    };\n  } else if (cardinality == 2) {\n    // between\n    fn = function fn(field, op, values, valueSrc, valueType, opDef, operatorOptions, fieldDef) {\n      var valFrom = values.first();\n      var valTo = values.get(1);\n      return \"\".concat(field, \" \").concat(sqlOp, \" \").concat(valFrom, \" AND \").concat(valTo);\n    };\n  }\n  return fn;\n};\nvar formatRule = function formatRule(item, config, meta) {\n  var properties = item.get(\"properties\") || new Map();\n  var field = properties.get(\"field\");\n  var operator = properties.get(\"operator\");\n  var operatorOptions = properties.get(\"operatorOptions\");\n  var iValueSrc = properties.get(\"valueSrc\");\n  var iValueType = properties.get(\"valueType\");\n  var iValue = properties.get(\"value\");\n  var asyncListValues = properties.get(\"asyncListValues\");\n  if (field == null || operator == null) return undefined;\n  var fieldDefinition = getFieldConfig(config, field) || {};\n  var opDef = getOperatorConfig(config, operator, field) || {};\n  var reversedOp = opDef.reversedOp;\n  var revOpDef = getOperatorConfig(config, reversedOp, field) || {};\n  var cardinality = defaultValue(opDef.cardinality, 1);\n\n  // check op\n  var isRev = false;\n  var canFormatOp = opDef.sqlOp || opDef.sqlFormatOp;\n  var canFormatRevOp = revOpDef.sqlOp || revOpDef.sqlFormatOp;\n  if (!canFormatOp && !canFormatRevOp) {\n    meta.errors.push(\"Operator \".concat(operator, \" is not supported\"));\n    return undefined;\n  }\n  if (!canFormatRevOp && canFormatRevOp) {\n    isRev = true;\n    var _ref = [reversedOp, operator];\n    operator = _ref[0];\n    reversedOp = _ref[1];\n    var _ref2 = [revOpDef, opDef];\n    opDef = _ref2[0];\n    revOpDef = _ref2[1];\n  }\n\n  //format value\n  var valueSrcs = [];\n  var valueTypes = [];\n  var fvalue = iValue.map(function (currentValue, ind) {\n    var valueSrc = iValueSrc ? iValueSrc.get(ind) : null;\n    var valueType = iValueType ? iValueType.get(ind) : null;\n    var cValue = completeValue(currentValue, valueSrc, config);\n    var widget = getWidgetForFieldOp(config, field, operator, valueSrc);\n    var fieldWidgetDefinition = omit(getFieldWidgetConfig(config, field, operator, widget, valueSrc), [\"factory\"]);\n    var fv = formatValue(meta, config, cValue, valueSrc, valueType, fieldWidgetDefinition, fieldDefinition, operator, opDef, asyncListValues);\n    if (fv !== undefined) {\n      valueSrcs.push(valueSrc);\n      valueTypes.push(valueType);\n    }\n    return fv;\n  });\n  var hasUndefinedValues = fvalue.filter(function (v) {\n    return v === undefined;\n  }).size > 0;\n  if (hasUndefinedValues || fvalue.size < cardinality) return undefined;\n  var formattedValue = cardinality == 1 ? fvalue.first() : fvalue;\n\n  //find fn to format expr\n  var fn = opDef.sqlFormatOp || buildFnToFormatOp(operator, opDef);\n  if (!fn) {\n    meta.errors.push(\"Operator \".concat(operator, \" is not supported\"));\n    return undefined;\n  }\n\n  //format field\n  var formattedField = formatField(meta, config, field);\n\n  //format expr\n  var args = [formattedField, operator, formattedValue, valueSrcs.length > 1 ? valueSrcs : valueSrcs[0], valueTypes.length > 1 ? valueTypes : valueTypes[0], omit(opDef, [\"formatOp\", \"mongoFormatOp\", \"sqlFormatOp\", \"jsonLogic\", \"spelFormatOp\"]), operatorOptions, fieldDefinition];\n  var ret;\n  ret = fn.apply(void 0, args);\n  if (isRev) {\n    ret = config.settings.sqlFormatReverse(ret);\n  }\n  if (ret === undefined) {\n    meta.errors.push(\"Operator \".concat(operator, \" is not supported for value source \").concat(valueSrcs.join(\", \")));\n    return undefined;\n  }\n  return ret;\n};\nvar formatValue = function formatValue(meta, config, currentValue, valueSrc, valueType, fieldWidgetDef, fieldDef, operator, operatorDef, asyncListValues) {\n  if (currentValue === undefined) return undefined;\n  var ret;\n  if (valueSrc == \"field\") {\n    ret = formatField(meta, config, currentValue);\n  } else if (valueSrc == \"func\") {\n    ret = formatFunc(meta, config, currentValue);\n  } else {\n    if (typeof fieldWidgetDef.sqlFormatValue === \"function\") {\n      var fn = fieldWidgetDef.sqlFormatValue;\n      var args = [currentValue, _objectSpread(_objectSpread({}, pick(fieldDef, [\"fieldSettings\", \"listValues\"])), {}, {\n        asyncListValues: asyncListValues\n      }),\n      //useful options: valueFormat for date/time\n      omit(fieldWidgetDef, [\"formatValue\", \"mongoFormatValue\", \"sqlFormatValue\", \"jsonLogic\", \"elasticSearchFormatValue\", \"spelFormatValue\"])];\n      if (operator) {\n        args.push(operator);\n        args.push(operatorDef);\n      }\n      if (valueSrc == \"field\") {\n        var valFieldDefinition = getFieldConfig(config, currentValue) || {};\n        args.push(valFieldDefinition);\n      }\n      ret = fn.apply(void 0, args);\n    } else {\n      if (Array.isArray(currentValue)) {\n        ret = currentValue.map(function (v) {\n          return SqlString.escape(v);\n        });\n      } else {\n        ret = SqlString.escape(currentValue);\n      }\n    }\n  }\n  return ret;\n};\nvar formatField = function formatField(meta, config, field) {\n  if (!field) return;\n  var fieldSeparator = config.settings.fieldSeparator;\n  var fieldDefinition = getFieldConfig(config, field) || {};\n  var fieldParts = Array.isArray(field) ? field : field.split(fieldSeparator);\n  var _fieldKeys = getFieldPath(field, config);\n  var fieldPartsLabels = getFieldPathLabels(field, config);\n  var fieldFullLabel = fieldPartsLabels ? fieldPartsLabels.join(fieldSeparator) : null;\n  var formatFieldFn = config.settings.formatField;\n  var fieldName = formatFieldName(field, config, meta);\n  var formattedField = formatFieldFn(fieldName, fieldParts, fieldFullLabel, fieldDefinition, config);\n  return formattedField;\n};\nvar formatFunc = function formatFunc(meta, config, currentValue) {\n  var funcKey = currentValue.get(\"func\");\n  var args = currentValue.get(\"args\");\n  var funcConfig = getFuncConfig(config, funcKey);\n  var funcName = funcConfig.sqlFunc || funcKey;\n  var formattedArgs = {};\n  for (var argKey in funcConfig.args) {\n    var argConfig = funcConfig.args[argKey];\n    var fieldDef = getFieldConfig(config, argConfig);\n    var argVal = args ? args.get(argKey) : undefined;\n    var argValue = argVal ? argVal.get(\"value\") : undefined;\n    var argValueSrc = argVal ? argVal.get(\"valueSrc\") : undefined;\n    var argAsyncListValues = argVal ? argVal.get(\"asyncListValues\") : undefined;\n    var formattedArgVal = formatValue(meta, config, argValue, argValueSrc, argConfig.type, fieldDef, argConfig, null, null, argAsyncListValues);\n    if (argValue != undefined && formattedArgVal === undefined) {\n      meta.errors.push(\"Can't format value of arg \".concat(argKey, \" for func \").concat(funcKey));\n      return undefined;\n    }\n    if (formattedArgVal !== undefined) {\n      // skip optional in the end\n      formattedArgs[argKey] = formattedArgVal;\n    }\n  }\n  var ret;\n  if (typeof funcConfig.sqlFormatFunc === \"function\") {\n    var fn = funcConfig.sqlFormatFunc;\n    var _args = [formattedArgs];\n    ret = fn.apply(void 0, _args);\n  } else {\n    var argsStr = Object.entries(formattedArgs).map(function (_ref3) {\n      var _ref4 = _slicedToArray(_ref3, 2),\n        k = _ref4[0],\n        v = _ref4[1];\n      return v;\n    }).join(\", \");\n    ret = \"\".concat(funcName, \"(\").concat(argsStr, \")\");\n  }\n  return ret;\n};"]},"metadata":{},"sourceType":"module"}