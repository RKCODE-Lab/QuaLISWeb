{"ast":null,"code":"import { sinkListItem, liftListItem } from 'prosemirror-schema-list';\nimport { indentRules, outdentRules } from './config/indent-rules';\nimport { blockNodes, addStyles, changeBlockNode, hasNode } from './blockNode';\nimport { findNthParentNodeOfType } from './utils';\n/**\n * Indenting block elements in the selection.\n *\n * @returns {boolean} - Returns true if any indentation is applied.\n */\n\nexport var indentBlocks = function (actions, command, dir) {\n  return function (state, dispatch) {\n    var blocks = blockNodes(state);\n    var tr = state.tr;\n    var result = false;\n    tr.setMeta('commandName', command);\n    blocks.forEach(function (node) {\n      if (node.type.isTextblock) {\n        var newAttrs = void 0;\n        var action = actions.find(function (a) {\n          return a.node === node.type.name;\n        });\n\n        if (action) {\n          var style = dir === 'rtl' ? action.rtlStyle : action.style;\n          var newStyle = {\n            name: style,\n            value: action.step > 0 ? \"\" + action.step + action.unit : ''\n          };\n\n          if (node.attrs.style) {\n            var re = new RegExp(style + \":\\\\s?(\\\\d+)\" + action.unit, 'i');\n            var match = node.attrs.style.match(re);\n\n            if (match) {\n              var newMargin = parseFloat(match[1]) + action.step;\n              newMargin = newMargin <= 0 ? '' : newMargin;\n              newStyle.value = \"\" + newMargin + (newMargin ? action.unit : '');\n            }\n          }\n\n          newAttrs = addStyles(node, [newStyle]);\n        }\n\n        if (newAttrs) {\n          result = changeBlockNode(state, dispatch, tr, node, node.type, newAttrs) || result;\n        }\n      }\n    });\n\n    if (result) {\n      dispatch(tr.scrollIntoView());\n    }\n\n    return result;\n  };\n};\nexport var isIndented = function (state, rules, dir) {\n  var blocks = blockNodes(state);\n  var result = false;\n  blocks.forEach(function (node) {\n    if (!result && node.type.isTextblock && node.attrs.style) {\n      var action = rules.find(function (a) {\n        return a.node === node.type.name;\n      });\n\n      if (action) {\n        var style = dir === 'rtl' ? action.rtlStyle : action.style;\n        var reIndent = new RegExp(style + \":\\\\s?\\\\d+\" + action.unit, 'i');\n        result = reIndent.test(node.attrs.style);\n      }\n    }\n  });\n  return result;\n};\nexport var canIndentAsListItem = function (state, nodeType) {\n  return sinkListItem(nodeType)(state);\n};\nexport var canOutdentAsListItem = function (state, rules) {\n  var listItem = state.schema.nodes[rules.listsTypes.listItem];\n  var orderedList = state.schema.nodes[rules.listsTypes.orderedList];\n  var bulletList = state.schema.nodes[rules.listsTypes.bulletList];\n  var isNestedInOL = !!findNthParentNodeOfType(orderedList, 2)(state.selection);\n  var isNestedInUL = !!findNthParentNodeOfType(bulletList, 2)(state.selection);\n  return (isNestedInOL || isNestedInUL) && liftListItem(listItem)(state);\n};\nexport var canBeIndented = function (state, rules) {\n  var nodes = state.schema.nodes;\n  var listItem = nodes[indentRules.listsTypes.listItem];\n  return (isIndented(state, rules.nodes) || indentRules.nodes.some(function (rule) {\n    return nodes[rule.node] && hasNode(state, nodes[rule.node]);\n  })) && !hasNode(state, listItem);\n};\nexport var indent = function (state, dispatch) {\n  var listItem = state.schema.nodes[indentRules.listsTypes.listItem];\n  var isIndentableBlock = canBeIndented(state, indentRules);\n\n  if (canIndentAsListItem(state, listItem)) {\n    sinkListItem(listItem)(state, dispatch);\n  } else if (isIndentableBlock) {\n    indentBlocks(indentRules.nodes)(state, dispatch);\n  }\n};\nexport var outdent = function (state, dispatch) {\n  var listItem = state.schema.nodes[outdentRules.listsTypes.listItem];\n  var isIndentableBlock = canBeIndented(state, outdentRules);\n\n  if (canOutdentAsListItem(state, outdentRules)) {\n    liftListItem(listItem)(state, dispatch);\n  } else if (isIndentableBlock) {\n    indentBlocks(outdentRules.nodes)(state, dispatch);\n  }\n};","map":{"version":3,"sources":["D:/Postgres_workingFolder/QuaLISWeb/node_modules/@progress/kendo-editor-common/dist/es/indent.js"],"names":["sinkListItem","liftListItem","indentRules","outdentRules","blockNodes","addStyles","changeBlockNode","hasNode","findNthParentNodeOfType","indentBlocks","actions","command","dir","state","dispatch","blocks","tr","result","setMeta","forEach","node","type","isTextblock","newAttrs","action","find","a","name","style","rtlStyle","newStyle","value","step","unit","attrs","re","RegExp","match","newMargin","parseFloat","scrollIntoView","isIndented","rules","reIndent","test","canIndentAsListItem","nodeType","canOutdentAsListItem","listItem","schema","nodes","listsTypes","orderedList","bulletList","isNestedInOL","selection","isNestedInUL","canBeIndented","some","rule","indent","isIndentableBlock","outdent"],"mappings":"AAAA,SAASA,YAAT,EAAuBC,YAAvB,QAA2C,yBAA3C;AACA,SAASC,WAAT,EAAsBC,YAAtB,QAA0C,uBAA1C;AACA,SAASC,UAAT,EAAqBC,SAArB,EAAgCC,eAAhC,EAAiDC,OAAjD,QAAgE,aAAhE;AACA,SAASC,uBAAT,QAAwC,SAAxC;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAIC,YAAY,GAAG,UAAUC,OAAV,EAAmBC,OAAnB,EAA4BC,GAA5B,EAAiC;AAAE,SAAO,UAAUC,KAAV,EAAiBC,QAAjB,EAA2B;AAC3F,QAAIC,MAAM,GAAGX,UAAU,CAACS,KAAD,CAAvB;AACA,QAAIG,EAAE,GAAGH,KAAK,CAACG,EAAf;AACA,QAAIC,MAAM,GAAG,KAAb;AACAD,IAAAA,EAAE,CAACE,OAAH,CAAW,aAAX,EAA0BP,OAA1B;AACAI,IAAAA,MAAM,CAACI,OAAP,CAAe,UAAUC,IAAV,EAAgB;AAC3B,UAAIA,IAAI,CAACC,IAAL,CAAUC,WAAd,EAA2B;AACvB,YAAIC,QAAQ,GAAG,KAAK,CAApB;AACA,YAAIC,MAAM,GAAGd,OAAO,CAACe,IAAR,CAAa,UAAUC,CAAV,EAAa;AAAE,iBAAOA,CAAC,CAACN,IAAF,KAAWA,IAAI,CAACC,IAAL,CAAUM,IAA5B;AAAmC,SAA/D,CAAb;;AACA,YAAIH,MAAJ,EAAY;AACR,cAAII,KAAK,GAAGhB,GAAG,KAAK,KAAR,GAAgBY,MAAM,CAACK,QAAvB,GAAkCL,MAAM,CAACI,KAArD;AACA,cAAIE,QAAQ,GAAG;AACXH,YAAAA,IAAI,EAAEC,KADK;AAEXG,YAAAA,KAAK,EAAEP,MAAM,CAACQ,IAAP,GAAc,CAAd,GAAkB,KAAKR,MAAM,CAACQ,IAAZ,GAAmBR,MAAM,CAACS,IAA5C,GAAmD;AAF/C,WAAf;;AAIA,cAAIb,IAAI,CAACc,KAAL,CAAWN,KAAf,EAAsB;AAClB,gBAAIO,EAAE,GAAG,IAAIC,MAAJ,CAAWR,KAAK,GAAG,aAAR,GAAwBJ,MAAM,CAACS,IAA1C,EAAgD,GAAhD,CAAT;AACA,gBAAII,KAAK,GAAGjB,IAAI,CAACc,KAAL,CAAWN,KAAX,CAAiBS,KAAjB,CAAuBF,EAAvB,CAAZ;;AACA,gBAAIE,KAAJ,EAAW;AACP,kBAAIC,SAAS,GAAGC,UAAU,CAACF,KAAK,CAAC,CAAD,CAAN,CAAV,GAAuBb,MAAM,CAACQ,IAA9C;AACAM,cAAAA,SAAS,GAAGA,SAAS,IAAI,CAAb,GAAiB,EAAjB,GAAsBA,SAAlC;AACAR,cAAAA,QAAQ,CAACC,KAAT,GAAiB,KAAKO,SAAL,IAAkBA,SAAS,GAAGd,MAAM,CAACS,IAAV,GAAiB,EAA5C,CAAjB;AACH;AACJ;;AACDV,UAAAA,QAAQ,GAAGlB,SAAS,CAACe,IAAD,EAAO,CAACU,QAAD,CAAP,CAApB;AACH;;AACD,YAAIP,QAAJ,EAAc;AACVN,UAAAA,MAAM,GAAGX,eAAe,CAACO,KAAD,EAAQC,QAAR,EAAkBE,EAAlB,EAAsBI,IAAtB,EAA4BA,IAAI,CAACC,IAAjC,EAAuCE,QAAvC,CAAf,IAAmEN,MAA5E;AACH;AACJ;AACJ,KAzBD;;AA0BA,QAAIA,MAAJ,EAAY;AACRH,MAAAA,QAAQ,CAACE,EAAE,CAACwB,cAAH,EAAD,CAAR;AACH;;AACD,WAAOvB,MAAP;AACH,GAnC4D;AAmCzD,CAnCG;AAoCP,OAAO,IAAIwB,UAAU,GAAG,UAAU5B,KAAV,EAAiB6B,KAAjB,EAAwB9B,GAAxB,EAA6B;AACjD,MAAIG,MAAM,GAAGX,UAAU,CAACS,KAAD,CAAvB;AACA,MAAII,MAAM,GAAG,KAAb;AACAF,EAAAA,MAAM,CAACI,OAAP,CAAe,UAAUC,IAAV,EAAgB;AAC3B,QAAI,CAACH,MAAD,IAAWG,IAAI,CAACC,IAAL,CAAUC,WAArB,IAAoCF,IAAI,CAACc,KAAL,CAAWN,KAAnD,EAA0D;AACtD,UAAIJ,MAAM,GAAGkB,KAAK,CAACjB,IAAN,CAAW,UAAUC,CAAV,EAAa;AAAE,eAAOA,CAAC,CAACN,IAAF,KAAWA,IAAI,CAACC,IAAL,CAAUM,IAA5B;AAAmC,OAA7D,CAAb;;AACA,UAAIH,MAAJ,EAAY;AACR,YAAII,KAAK,GAAGhB,GAAG,KAAK,KAAR,GAAgBY,MAAM,CAACK,QAAvB,GAAkCL,MAAM,CAACI,KAArD;AACA,YAAIe,QAAQ,GAAG,IAAIP,MAAJ,CAAWR,KAAK,GAAG,WAAR,GAAsBJ,MAAM,CAACS,IAAxC,EAA8C,GAA9C,CAAf;AACAhB,QAAAA,MAAM,GAAG0B,QAAQ,CAACC,IAAT,CAAcxB,IAAI,CAACc,KAAL,CAAWN,KAAzB,CAAT;AACH;AACJ;AACJ,GATD;AAUA,SAAOX,MAAP;AACH,CAdM;AAeP,OAAO,IAAI4B,mBAAmB,GAAG,UAAUhC,KAAV,EAAiBiC,QAAjB,EAA2B;AACxD,SAAO9C,YAAY,CAAC8C,QAAD,CAAZ,CAAuBjC,KAAvB,CAAP;AACH,CAFM;AAGP,OAAO,IAAIkC,oBAAoB,GAAG,UAAUlC,KAAV,EAAiB6B,KAAjB,EAAwB;AACtD,MAAIM,QAAQ,GAAGnC,KAAK,CAACoC,MAAN,CAAaC,KAAb,CAAmBR,KAAK,CAACS,UAAN,CAAiBH,QAApC,CAAf;AACA,MAAII,WAAW,GAAGvC,KAAK,CAACoC,MAAN,CAAaC,KAAb,CAAmBR,KAAK,CAACS,UAAN,CAAiBC,WAApC,CAAlB;AACA,MAAIC,UAAU,GAAGxC,KAAK,CAACoC,MAAN,CAAaC,KAAb,CAAmBR,KAAK,CAACS,UAAN,CAAiBE,UAApC,CAAjB;AACA,MAAIC,YAAY,GAAG,CAAC,CAAC9C,uBAAuB,CAAC4C,WAAD,EAAc,CAAd,CAAvB,CAAwCvC,KAAK,CAAC0C,SAA9C,CAArB;AACA,MAAIC,YAAY,GAAG,CAAC,CAAChD,uBAAuB,CAAC6C,UAAD,EAAa,CAAb,CAAvB,CAAuCxC,KAAK,CAAC0C,SAA7C,CAArB;AACA,SAAO,CAACD,YAAY,IAAIE,YAAjB,KAAkCvD,YAAY,CAAC+C,QAAD,CAAZ,CAAuBnC,KAAvB,CAAzC;AACH,CAPM;AAQP,OAAO,IAAI4C,aAAa,GAAG,UAAU5C,KAAV,EAAiB6B,KAAjB,EAAwB;AAC/C,MAAIQ,KAAK,GAAGrC,KAAK,CAACoC,MAAN,CAAaC,KAAzB;AACA,MAAIF,QAAQ,GAAGE,KAAK,CAAChD,WAAW,CAACiD,UAAZ,CAAuBH,QAAxB,CAApB;AACA,SAAQ,CAACP,UAAU,CAAC5B,KAAD,EAAQ6B,KAAK,CAACQ,KAAd,CAAV,IAAkChD,WAAW,CAACgD,KAAZ,CAAkBQ,IAAlB,CAAuB,UAAUC,IAAV,EAAgB;AAAE,WAAOT,KAAK,CAACS,IAAI,CAACvC,IAAN,CAAL,IAAoBb,OAAO,CAACM,KAAD,EAAQqC,KAAK,CAACS,IAAI,CAACvC,IAAN,CAAb,CAAlC;AAA8D,GAAvG,CAAnC,KACJ,CAACb,OAAO,CAACM,KAAD,EAAQmC,QAAR,CADZ;AAEH,CALM;AAMP,OAAO,IAAIY,MAAM,GAAG,UAAU/C,KAAV,EAAiBC,QAAjB,EAA2B;AAC3C,MAAIkC,QAAQ,GAAGnC,KAAK,CAACoC,MAAN,CAAaC,KAAb,CAAmBhD,WAAW,CAACiD,UAAZ,CAAuBH,QAA1C,CAAf;AACA,MAAIa,iBAAiB,GAAGJ,aAAa,CAAC5C,KAAD,EAAQX,WAAR,CAArC;;AACA,MAAI2C,mBAAmB,CAAChC,KAAD,EAAQmC,QAAR,CAAvB,EAA0C;AACtChD,IAAAA,YAAY,CAACgD,QAAD,CAAZ,CAAuBnC,KAAvB,EAA8BC,QAA9B;AACH,GAFD,MAGK,IAAI+C,iBAAJ,EAAuB;AACxBpD,IAAAA,YAAY,CAACP,WAAW,CAACgD,KAAb,CAAZ,CAAgCrC,KAAhC,EAAuCC,QAAvC;AACH;AACJ,CATM;AAUP,OAAO,IAAIgD,OAAO,GAAG,UAAUjD,KAAV,EAAiBC,QAAjB,EAA2B;AAC5C,MAAIkC,QAAQ,GAAGnC,KAAK,CAACoC,MAAN,CAAaC,KAAb,CAAmB/C,YAAY,CAACgD,UAAb,CAAwBH,QAA3C,CAAf;AACA,MAAIa,iBAAiB,GAAGJ,aAAa,CAAC5C,KAAD,EAAQV,YAAR,CAArC;;AACA,MAAI4C,oBAAoB,CAAClC,KAAD,EAAQV,YAAR,CAAxB,EAA+C;AAC3CF,IAAAA,YAAY,CAAC+C,QAAD,CAAZ,CAAuBnC,KAAvB,EAA8BC,QAA9B;AACH,GAFD,MAGK,IAAI+C,iBAAJ,EAAuB;AACxBpD,IAAAA,YAAY,CAACN,YAAY,CAAC+C,KAAd,CAAZ,CAAiCrC,KAAjC,EAAwCC,QAAxC;AACH;AACJ,CATM","sourcesContent":["import { sinkListItem, liftListItem } from 'prosemirror-schema-list';\nimport { indentRules, outdentRules } from './config/indent-rules';\nimport { blockNodes, addStyles, changeBlockNode, hasNode } from './blockNode';\nimport { findNthParentNodeOfType } from './utils';\n/**\n * Indenting block elements in the selection.\n *\n * @returns {boolean} - Returns true if any indentation is applied.\n */\nexport var indentBlocks = function (actions, command, dir) { return function (state, dispatch) {\n    var blocks = blockNodes(state);\n    var tr = state.tr;\n    var result = false;\n    tr.setMeta('commandName', command);\n    blocks.forEach(function (node) {\n        if (node.type.isTextblock) {\n            var newAttrs = void 0;\n            var action = actions.find(function (a) { return a.node === node.type.name; });\n            if (action) {\n                var style = dir === 'rtl' ? action.rtlStyle : action.style;\n                var newStyle = {\n                    name: style,\n                    value: action.step > 0 ? \"\" + action.step + action.unit : ''\n                };\n                if (node.attrs.style) {\n                    var re = new RegExp(style + \":\\\\s?(\\\\d+)\" + action.unit, 'i');\n                    var match = node.attrs.style.match(re);\n                    if (match) {\n                        var newMargin = parseFloat(match[1]) + action.step;\n                        newMargin = newMargin <= 0 ? '' : newMargin;\n                        newStyle.value = \"\" + newMargin + (newMargin ? action.unit : '');\n                    }\n                }\n                newAttrs = addStyles(node, [newStyle]);\n            }\n            if (newAttrs) {\n                result = changeBlockNode(state, dispatch, tr, node, node.type, newAttrs) || result;\n            }\n        }\n    });\n    if (result) {\n        dispatch(tr.scrollIntoView());\n    }\n    return result;\n}; };\nexport var isIndented = function (state, rules, dir) {\n    var blocks = blockNodes(state);\n    var result = false;\n    blocks.forEach(function (node) {\n        if (!result && node.type.isTextblock && node.attrs.style) {\n            var action = rules.find(function (a) { return a.node === node.type.name; });\n            if (action) {\n                var style = dir === 'rtl' ? action.rtlStyle : action.style;\n                var reIndent = new RegExp(style + \":\\\\s?\\\\d+\" + action.unit, 'i');\n                result = reIndent.test(node.attrs.style);\n            }\n        }\n    });\n    return result;\n};\nexport var canIndentAsListItem = function (state, nodeType) {\n    return sinkListItem(nodeType)(state);\n};\nexport var canOutdentAsListItem = function (state, rules) {\n    var listItem = state.schema.nodes[rules.listsTypes.listItem];\n    var orderedList = state.schema.nodes[rules.listsTypes.orderedList];\n    var bulletList = state.schema.nodes[rules.listsTypes.bulletList];\n    var isNestedInOL = !!findNthParentNodeOfType(orderedList, 2)(state.selection);\n    var isNestedInUL = !!findNthParentNodeOfType(bulletList, 2)(state.selection);\n    return (isNestedInOL || isNestedInUL) && liftListItem(listItem)(state);\n};\nexport var canBeIndented = function (state, rules) {\n    var nodes = state.schema.nodes;\n    var listItem = nodes[indentRules.listsTypes.listItem];\n    return ((isIndented(state, rules.nodes) || indentRules.nodes.some(function (rule) { return nodes[rule.node] && hasNode(state, nodes[rule.node]); })) &&\n        !hasNode(state, listItem));\n};\nexport var indent = function (state, dispatch) {\n    var listItem = state.schema.nodes[indentRules.listsTypes.listItem];\n    var isIndentableBlock = canBeIndented(state, indentRules);\n    if (canIndentAsListItem(state, listItem)) {\n        sinkListItem(listItem)(state, dispatch);\n    }\n    else if (isIndentableBlock) {\n        indentBlocks(indentRules.nodes)(state, dispatch);\n    }\n};\nexport var outdent = function (state, dispatch) {\n    var listItem = state.schema.nodes[outdentRules.listsTypes.listItem];\n    var isIndentableBlock = canBeIndented(state, outdentRules);\n    if (canOutdentAsListItem(state, outdentRules)) {\n        liftListItem(listItem)(state, dispatch);\n    }\n    else if (isIndentableBlock) {\n        indentBlocks(outdentRules.nodes)(state, dispatch);\n    }\n};\n"]},"metadata":{},"sourceType":"module"}