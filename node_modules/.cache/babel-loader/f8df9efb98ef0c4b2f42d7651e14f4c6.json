{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _typeof from \"@babel/runtime/helpers/typeof\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nimport { defaultValue } from \"../utils/stuff\";\nimport { getFieldConfig, getOperatorConfig, getFieldWidgetConfig, getFuncConfig } from \"../utils/configUtils\";\nimport { getFieldPath, getFieldPathLabels, getWidgetForFieldOp } from \"../utils/ruleUtils\";\nimport { defaultConjunction } from \"../utils/defaultUtils\";\nimport { completeValue } from \"../utils/funcUtils\";\nimport omit from \"lodash/omit\";\nimport pick from \"lodash/pick\";\nimport { List, Map } from \"immutable\"; // helpers\n\nvar isObject = function isObject(v) {\n  return _typeof(v) == \"object\" && v !== null && !Array.isArray(v);\n};\n\nexport var mongodbFormat = function mongodbFormat(tree, config) {\n  return _mongodbFormat(tree, config, false);\n};\nexport var _mongodbFormat = function _mongodbFormat(tree, config) {\n  var returnErrors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true; //meta is mutable\n\n  var meta = {\n    errors: []\n  };\n  var res = formatItem([], tree, config, meta);\n\n  if (returnErrors) {\n    return [res, meta.errors];\n  } else {\n    if (meta.errors.length) console.warn(\"Errors while exporting to MongoDb:\", meta.errors);\n    return res;\n  }\n};\n\nvar formatItem = function formatItem(parents, item, config, meta) {\n  var _not = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n  var _canWrapExpr = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n\n  var _fieldName = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : undefined;\n\n  var _value = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : undefined;\n\n  if (!item) return undefined;\n  var type = item.get(\"type\");\n\n  if (type === \"group\" || type === \"rule_group\") {\n    return formatGroup(parents, item, config, meta, _not, _canWrapExpr, _fieldName, _value);\n  } else if (type === \"rule\") {\n    return formatRule(parents, item, config, meta, _not, _canWrapExpr, _fieldName, _value);\n  }\n\n  return undefined;\n};\n\nvar formatGroup = function formatGroup(parents, item, config, meta) {\n  var _not = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n  var _canWrapExpr = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n\n  var _fieldName = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : undefined;\n\n  var _value = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : undefined;\n\n  var type = item.get(\"type\");\n  var properties = item.get(\"properties\") || new Map();\n  var children = item.get(\"children1\") || new List();\n  var canShortMongoQuery = config.settings.canShortMongoQuery;\n  var hasParentRuleGroup = parents.filter(function (it) {\n    return it.get(\"type\") == \"rule_group\";\n  }).length > 0;\n  var parentPath = parents.filter(function (it) {\n    return it.get(\"type\") == \"rule_group\";\n  }).map(function (it) {\n    return it.get(\"properties\").get(\"field\");\n  }).slice(-1).pop();\n  var realParentPath = hasParentRuleGroup && parentPath;\n  var groupField = type === \"rule_group\" ? properties.get(\"field\") : null;\n  var groupFieldName = formatFieldName(groupField, config, meta, realParentPath);\n  var groupFieldDef = getFieldConfig(config, groupField) || {};\n  var mode = groupFieldDef.mode; //properties.get(\"mode\");\n\n  var canHaveEmptyChildren = groupField && mode == \"array\";\n  var not = _not ? !properties.get(\"not\") : properties.get(\"not\");\n  var list = children.map(function (currentChild) {\n    return formatItem([].concat(_toConsumableArray(parents), [item]), currentChild, config, meta, not, true, mode == \"array\" ? function (f) {\n      return \"$$el.\".concat(f);\n    } : undefined);\n  }).filter(function (currentChild) {\n    return typeof currentChild !== \"undefined\";\n  });\n  if (!canHaveEmptyChildren && !list.size) return undefined;\n  var conjunction = properties.get(\"conjunction\");\n  if (!conjunction) conjunction = defaultConjunction(config);\n  var conjunctionDefinition = config.conjunctions[conjunction];\n  var reversedConj = conjunctionDefinition.reversedConj;\n\n  if (not && reversedConj) {\n    conjunction = reversedConj;\n    conjunctionDefinition = config.conjunctions[conjunction];\n  }\n\n  var mongoConj = conjunctionDefinition.mongoConj;\n  var resultQuery;\n\n  if (list.size == 1) {\n    resultQuery = list.first();\n  } else if (list.size > 1) {\n    var rules = list.toList().toJS();\n    var canShort = canShortMongoQuery && mongoConj == \"$and\";\n\n    if (canShort) {\n      resultQuery = rules.reduce(function (acc, rule) {\n        if (!acc) return undefined;\n\n        for (var k in rule) {\n          if (k[0] == \"$\") {\n            acc = undefined;\n            break;\n          }\n\n          if (acc[k] == undefined) {\n            acc[k] = rule[k];\n          } else {\n            // https://github.com/ukrbublik/react-awesome-query-builder/issues/182\n            var prev = acc[k],\n                next = rule[k];\n\n            if (!isObject(prev)) {\n              prev = {\n                \"$eq\": prev\n              };\n            }\n\n            if (!isObject(next)) {\n              next = {\n                \"$eq\": next\n              };\n            }\n\n            var prevOp = Object.keys(prev)[0],\n                nextOp = Object.keys(next)[0];\n\n            if (prevOp == nextOp) {\n              acc = undefined;\n              break;\n            }\n\n            acc[k] = Object.assign({}, prev, next);\n          }\n        }\n\n        return acc;\n      }, {});\n    }\n\n    if (!resultQuery) // can't be shorten\n      resultQuery = _defineProperty({}, mongoConj, rules);\n  }\n\n  if (groupField) {\n    if (mode == \"array\") {\n      var totalQuery = {\n        \"$size\": groupFieldName\n      };\n      var filterQuery = resultQuery ? {\n        \"$size\": {\n          \"$filter\": {\n            input: \"$\" + groupFieldName,\n            as: \"el\",\n            cond: resultQuery\n          }\n        }\n      } : totalQuery;\n      resultQuery = formatItem(parents, item.set(\"type\", \"rule\"), config, meta, false, false, function (_f) {\n        return filterQuery;\n      }, totalQuery);\n      resultQuery = {\n        \"$expr\": resultQuery\n      };\n    } else {\n      resultQuery = _defineProperty({}, groupFieldName, {\n        \"$elemMatch\": resultQuery\n      });\n    }\n  }\n\n  return resultQuery;\n};\n\nvar formatRule = function formatRule(parents, item, config, meta) {\n  var _not = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n  var _canWrapExpr = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n\n  var _fieldName = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : undefined;\n\n  var _value = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : undefined;\n\n  var properties = item.get(\"properties\") || new Map();\n  var hasParentRuleGroup = parents.filter(function (it) {\n    return it.get(\"type\") == \"rule_group\";\n  }).length > 0;\n  var parentPath = parents.filter(function (it) {\n    return it.get(\"type\") == \"rule_group\";\n  }).map(function (it) {\n    return it.get(\"properties\").get(\"field\");\n  }).slice(-1).pop();\n  var realParentPath = hasParentRuleGroup && parentPath;\n  var operator = properties.get(\"operator\");\n  var operatorOptions = properties.get(\"operatorOptions\");\n  var field = properties.get(\"field\");\n  var iValue = properties.get(\"value\");\n  var iValueSrc = properties.get(\"valueSrc\");\n  var iValueType = properties.get(\"valueType\");\n  var asyncListValues = properties.get(\"asyncListValues\");\n  if (field == null || operator == null || iValue === undefined) return undefined;\n  var fieldDef = getFieldConfig(config, field) || {};\n  var operatorDefinition = getOperatorConfig(config, operator, field) || {};\n  var reversedOp = operatorDefinition.reversedOp;\n  var revOperatorDefinition = getOperatorConfig(config, reversedOp, field) || {};\n  var cardinality = defaultValue(operatorDefinition.cardinality, 1);\n  var not = _not;\n\n  if (not && reversedOp) {\n    var _ref = [reversedOp, operator];\n    operator = _ref[0];\n    reversedOp = _ref[1];\n    var _ref2 = [revOperatorDefinition, operatorDefinition];\n    operatorDefinition = _ref2[0];\n    revOperatorDefinition = _ref2[1];\n    not = false;\n  }\n\n  var fieldName = formatFieldName(field, config, meta, realParentPath); //format value\n\n  var valueSrcs = [];\n  var valueTypes = [];\n  var useExpr = false;\n  var fvalue = iValue.map(function (currentValue, ind) {\n    var valueSrc = iValueSrc ? iValueSrc.get(ind) : null;\n    var valueType = iValueType ? iValueType.get(ind) : null;\n    var cValue = completeValue(currentValue, valueSrc, config);\n    var widget = getWidgetForFieldOp(config, field, operator, valueSrc);\n    var fieldWidgetDef = omit(getFieldWidgetConfig(config, field, operator, widget, valueSrc), [\"factory\"]);\n\n    var _formatValue = formatValue(meta, config, cValue, valueSrc, valueType, fieldWidgetDef, fieldDef, realParentPath, operator, operatorDefinition, asyncListValues),\n        _formatValue2 = _slicedToArray(_formatValue, 2),\n        fv = _formatValue2[0],\n        fvUseExpr = _formatValue2[1];\n\n    if (fv !== undefined) {\n      useExpr = useExpr || fvUseExpr;\n      valueSrcs.push(valueSrc);\n      valueTypes.push(valueType);\n    }\n\n    return fv;\n  });\n  if (_fieldName) useExpr = true;\n  var wrapExpr = useExpr && _canWrapExpr;\n  var hasUndefinedValues = fvalue.filter(function (v) {\n    return v === undefined;\n  }).size > 0;\n  if (fvalue.size < cardinality || hasUndefinedValues) return undefined;\n  var formattedValue = cardinality > 1 ? fvalue.toArray() : cardinality == 1 ? fvalue.first() : null; //build rule\n\n  var fn = operatorDefinition.mongoFormatOp;\n\n  if (!fn) {\n    meta.errors.push(\"Operator \".concat(operator, \" is not supported\"));\n    return undefined;\n  }\n\n  var args = [_fieldName ? _fieldName(fieldName) : fieldName, operator, _value !== undefined && formattedValue == null ? _value : formattedValue, useExpr, valueSrcs.length > 1 ? valueSrcs : valueSrcs[0], valueTypes.length > 1 ? valueTypes : valueTypes[0], omit(operatorDefinition, [\"formatOp\", \"mongoFormatOp\", \"sqlFormatOp\", \"jsonLogic\", \"spelFormatOp\"]), operatorOptions, fieldDef];\n  var ruleQuery = fn.apply(void 0, args);\n\n  if (wrapExpr) {\n    ruleQuery = {\n      \"$expr\": ruleQuery\n    };\n  }\n\n  if (not) {\n    ruleQuery = {\n      \"$not\": ruleQuery\n    };\n  }\n\n  return ruleQuery;\n};\n\nvar formatValue = function formatValue(meta, config, currentValue, valueSrc, valueType, fieldWidgetDef, fieldDef, parentPath, operator, operatorDef, asyncListValues) {\n  if (currentValue === undefined) return [undefined, false];\n  var ret;\n  var useExpr = false;\n\n  if (valueSrc == \"field\") {\n    var _formatRightField = formatRightField(meta, config, currentValue, parentPath);\n\n    var _formatRightField2 = _slicedToArray(_formatRightField, 2);\n\n    ret = _formatRightField2[0];\n    useExpr = _formatRightField2[1];\n  } else if (valueSrc == \"func\") {\n    var _formatFunc = formatFunc(meta, config, currentValue, parentPath);\n\n    var _formatFunc2 = _slicedToArray(_formatFunc, 2);\n\n    ret = _formatFunc2[0];\n    useExpr = _formatFunc2[1];\n  } else {\n    if (typeof fieldWidgetDef.mongoFormatValue === \"function\") {\n      var fn = fieldWidgetDef.mongoFormatValue;\n      var args = [currentValue, _objectSpread(_objectSpread({}, pick(fieldDef, [\"fieldSettings\", \"listValues\"])), {}, {\n        asyncListValues: asyncListValues\n      }), //useful options: valueFormat for date/time\n      omit(fieldWidgetDef, [\"formatValue\", \"mongoFormatValue\", \"sqlFormatValue\", \"jsonLogic\", \"elasticSearchFormatValue\", \"spelFormatValue\"])];\n\n      if (operator) {\n        args.push(operator);\n        args.push(operatorDef);\n      }\n\n      ret = fn.apply(void 0, args);\n    } else {\n      ret = currentValue;\n    }\n  }\n\n  return [ret, useExpr];\n};\n\nvar formatFieldName = function formatFieldName(field, config, meta, parentPath) {\n  if (!field) return;\n  var fieldDef = getFieldConfig(config, field) || {};\n  var fieldSeparator = config.settings.fieldSeparator;\n  var fieldParts = Array.isArray(field) ? field : field.split(fieldSeparator);\n  var fieldName = Array.isArray(field) ? field.join(fieldSeparator) : field; // if (fieldDef.tableName) { // legacy\n  //     const fieldPartsCopy = [...fieldParts];\n  //     fieldPartsCopy[0] = fieldDef.tableName;\n  //     fieldName = fieldPartsCopy.join(fieldSeparator);\n  // }\n\n  if (fieldDef.fieldName) {\n    fieldName = fieldDef.fieldName;\n  }\n\n  if (parentPath) {\n    var parentFieldDef = getFieldConfig(config, parentPath) || {};\n    var parentFieldName = parentPath;\n\n    if (parentFieldDef.fieldName) {\n      parentFieldName = parentFieldDef.fieldName;\n    }\n\n    if (fieldName.indexOf(parentFieldName + \".\") == 0) {\n      fieldName = fieldName.slice((parentFieldName + \".\").length);\n    } else {\n      meta.errors.push(\"Can't cut group \".concat(parentFieldName, \" from field \").concat(fieldName));\n    }\n  }\n\n  return fieldName;\n};\n\nvar formatRightField = function formatRightField(meta, config, rightField, parentPath) {\n  var fieldSeparator = config.settings.fieldSeparator;\n  var ret;\n  var useExpr = true;\n\n  if (rightField) {\n    var rightFieldDefinition = getFieldConfig(config, rightField) || {};\n    var fieldParts = Array.isArray(rightField) ? rightField : rightField.split(fieldSeparator);\n\n    var _fieldKeys = getFieldPath(rightField, config);\n\n    var fieldPartsLabels = getFieldPathLabels(rightField, config);\n    var fieldFullLabel = fieldPartsLabels ? fieldPartsLabels.join(fieldSeparator) : null;\n    var formatFieldFn = config.settings.formatField;\n    var rightFieldName = formatFieldName(rightField, config, meta, parentPath);\n    var formattedField = formatFieldFn(rightFieldName, fieldParts, fieldFullLabel, rightFieldDefinition, config, false);\n    ret = \"$\" + formattedField;\n  }\n\n  return [ret, useExpr];\n};\n\nvar formatFunc = function formatFunc(meta, config, currentValue, parentPath) {\n  var useExpr = true;\n  var ret;\n  var funcKey = currentValue.get(\"func\");\n  var args = currentValue.get(\"args\");\n  var funcConfig = getFuncConfig(config, funcKey);\n  var funcName = funcConfig.mongoFunc || funcKey;\n  var mongoArgsAsObject = funcConfig.mongoArgsAsObject;\n  var formattedArgs = {};\n  var argsCnt = 0;\n  var lastArg = undefined;\n\n  for (var argKey in funcConfig.args) {\n    var argConfig = funcConfig.args[argKey];\n    var fieldDef = getFieldConfig(config, argConfig);\n    var argVal = args ? args.get(argKey) : undefined;\n    var argValue = argVal ? argVal.get(\"value\") : undefined;\n    var argValueSrc = argVal ? argVal.get(\"valueSrc\") : undefined;\n    var argAsyncListValues = argVal ? argVal.get(\"asyncListValues\") : undefined;\n    var widget = getWidgetForFieldOp(config, fieldDef, null, argValueSrc);\n    var fieldWidgetDef = omit(getFieldWidgetConfig(config, fieldDef, null, widget, argValueSrc), [\"factory\"]);\n\n    var _formatValue3 = formatValue(meta, config, argValue, argValueSrc, argConfig.type, fieldWidgetDef, fieldDef, parentPath, null, null, argAsyncListValues),\n        _formatValue4 = _slicedToArray(_formatValue3, 2),\n        formattedArgVal = _formatValue4[0],\n        _argUseExpr = _formatValue4[1];\n\n    if (argValue != undefined && formattedArgVal === undefined) {\n      meta.errors.push(\"Can't format value of arg \".concat(argKey, \" for func \").concat(funcKey));\n      return [undefined, false];\n    }\n\n    argsCnt++;\n\n    if (formattedArgVal !== undefined) {\n      // skip optional in the end\n      formattedArgs[argKey] = formattedArgVal;\n      lastArg = formattedArgVal;\n    }\n  }\n\n  if (typeof funcConfig.mongoFormatFunc === \"function\") {\n    var fn = funcConfig.mongoFormatFunc;\n    var _args = [formattedArgs];\n    ret = fn.apply(void 0, _args);\n  } else if (funcConfig.mongoFormatFunc === null) {\n    meta.errors.push(\"Functon \".concat(funcName, \" is not supported\"));\n    return [undefined, false];\n  } else {\n    if (mongoArgsAsObject) ret = _defineProperty({}, funcName, formattedArgs);else if (argsCnt == 1 && lastArg !== undefined) ret = _defineProperty({}, funcName, lastArg);else ret = _defineProperty({}, funcName, Object.values(formattedArgs));\n  }\n\n  return [ret, useExpr];\n};","map":{"version":3,"sources":["D:/LIMSWFH/LIMSPOSTGRESQL/QuaLISWeb/node_modules/@react-awesome-query-builder/core/esm/export/mongoDb.js"],"names":["_slicedToArray","_defineProperty","_toConsumableArray","_typeof","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","defaultValue","getFieldConfig","getOperatorConfig","getFieldWidgetConfig","getFuncConfig","getFieldPath","getFieldPathLabels","getWidgetForFieldOp","defaultConjunction","completeValue","omit","pick","List","Map","isObject","v","Array","isArray","mongodbFormat","tree","config","_mongodbFormat","returnErrors","undefined","meta","errors","res","formatItem","console","warn","parents","item","_not","_canWrapExpr","_fieldName","_value","type","get","formatGroup","formatRule","properties","children","canShortMongoQuery","settings","hasParentRuleGroup","it","parentPath","map","slice","pop","realParentPath","groupField","groupFieldName","formatFieldName","groupFieldDef","mode","canHaveEmptyChildren","not","list","currentChild","concat","f","size","conjunction","conjunctionDefinition","conjunctions","reversedConj","mongoConj","resultQuery","first","rules","toList","toJS","canShort","reduce","acc","rule","k","prev","next","prevOp","nextOp","assign","totalQuery","filterQuery","input","as","cond","set","_f","operator","operatorOptions","field","iValue","iValueSrc","iValueType","asyncListValues","fieldDef","operatorDefinition","reversedOp","revOperatorDefinition","cardinality","_ref","_ref2","fieldName","valueSrcs","valueTypes","useExpr","fvalue","currentValue","ind","valueSrc","valueType","cValue","widget","fieldWidgetDef","_formatValue","formatValue","_formatValue2","fv","fvUseExpr","wrapExpr","hasUndefinedValues","formattedValue","toArray","fn","mongoFormatOp","args","ruleQuery","operatorDef","ret","_formatRightField","formatRightField","_formatRightField2","_formatFunc","formatFunc","_formatFunc2","mongoFormatValue","fieldSeparator","fieldParts","split","join","parentFieldDef","parentFieldName","indexOf","rightField","rightFieldDefinition","_fieldKeys","fieldPartsLabels","fieldFullLabel","formatFieldFn","formatField","rightFieldName","formattedField","funcKey","funcConfig","funcName","mongoFunc","mongoArgsAsObject","formattedArgs","argsCnt","lastArg","argKey","argConfig","argVal","argValue","argValueSrc","argAsyncListValues","_formatValue3","_formatValue4","formattedArgVal","_argUseExpr","mongoFormatFunc","_args","values"],"mappings":"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","sourcesContent":["import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _typeof from \"@babel/runtime/helpers/typeof\";\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nimport { defaultValue } from \"../utils/stuff\";\nimport { getFieldConfig, getOperatorConfig, getFieldWidgetConfig, getFuncConfig } from \"../utils/configUtils\";\nimport { getFieldPath, getFieldPathLabels, getWidgetForFieldOp } from \"../utils/ruleUtils\";\nimport { defaultConjunction } from \"../utils/defaultUtils\";\nimport { completeValue } from \"../utils/funcUtils\";\nimport omit from \"lodash/omit\";\nimport pick from \"lodash/pick\";\nimport { List, Map } from \"immutable\";\n\n// helpers\nvar isObject = function isObject(v) {\n  return _typeof(v) == \"object\" && v !== null && !Array.isArray(v);\n};\nexport var mongodbFormat = function mongodbFormat(tree, config) {\n  return _mongodbFormat(tree, config, false);\n};\nexport var _mongodbFormat = function _mongodbFormat(tree, config) {\n  var returnErrors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  //meta is mutable\n  var meta = {\n    errors: []\n  };\n  var res = formatItem([], tree, config, meta);\n  if (returnErrors) {\n    return [res, meta.errors];\n  } else {\n    if (meta.errors.length) console.warn(\"Errors while exporting to MongoDb:\", meta.errors);\n    return res;\n  }\n};\nvar formatItem = function formatItem(parents, item, config, meta) {\n  var _not = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  var _canWrapExpr = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n  var _fieldName = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : undefined;\n  var _value = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : undefined;\n  if (!item) return undefined;\n  var type = item.get(\"type\");\n  if (type === \"group\" || type === \"rule_group\") {\n    return formatGroup(parents, item, config, meta, _not, _canWrapExpr, _fieldName, _value);\n  } else if (type === \"rule\") {\n    return formatRule(parents, item, config, meta, _not, _canWrapExpr, _fieldName, _value);\n  }\n  return undefined;\n};\nvar formatGroup = function formatGroup(parents, item, config, meta) {\n  var _not = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  var _canWrapExpr = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n  var _fieldName = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : undefined;\n  var _value = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : undefined;\n  var type = item.get(\"type\");\n  var properties = item.get(\"properties\") || new Map();\n  var children = item.get(\"children1\") || new List();\n  var canShortMongoQuery = config.settings.canShortMongoQuery;\n  var hasParentRuleGroup = parents.filter(function (it) {\n    return it.get(\"type\") == \"rule_group\";\n  }).length > 0;\n  var parentPath = parents.filter(function (it) {\n    return it.get(\"type\") == \"rule_group\";\n  }).map(function (it) {\n    return it.get(\"properties\").get(\"field\");\n  }).slice(-1).pop();\n  var realParentPath = hasParentRuleGroup && parentPath;\n  var groupField = type === \"rule_group\" ? properties.get(\"field\") : null;\n  var groupFieldName = formatFieldName(groupField, config, meta, realParentPath);\n  var groupFieldDef = getFieldConfig(config, groupField) || {};\n  var mode = groupFieldDef.mode; //properties.get(\"mode\");\n  var canHaveEmptyChildren = groupField && mode == \"array\";\n  var not = _not ? !properties.get(\"not\") : properties.get(\"not\");\n  var list = children.map(function (currentChild) {\n    return formatItem([].concat(_toConsumableArray(parents), [item]), currentChild, config, meta, not, true, mode == \"array\" ? function (f) {\n      return \"$$el.\".concat(f);\n    } : undefined);\n  }).filter(function (currentChild) {\n    return typeof currentChild !== \"undefined\";\n  });\n  if (!canHaveEmptyChildren && !list.size) return undefined;\n  var conjunction = properties.get(\"conjunction\");\n  if (!conjunction) conjunction = defaultConjunction(config);\n  var conjunctionDefinition = config.conjunctions[conjunction];\n  var reversedConj = conjunctionDefinition.reversedConj;\n  if (not && reversedConj) {\n    conjunction = reversedConj;\n    conjunctionDefinition = config.conjunctions[conjunction];\n  }\n  var mongoConj = conjunctionDefinition.mongoConj;\n  var resultQuery;\n  if (list.size == 1) {\n    resultQuery = list.first();\n  } else if (list.size > 1) {\n    var rules = list.toList().toJS();\n    var canShort = canShortMongoQuery && mongoConj == \"$and\";\n    if (canShort) {\n      resultQuery = rules.reduce(function (acc, rule) {\n        if (!acc) return undefined;\n        for (var k in rule) {\n          if (k[0] == \"$\") {\n            acc = undefined;\n            break;\n          }\n          if (acc[k] == undefined) {\n            acc[k] = rule[k];\n          } else {\n            // https://github.com/ukrbublik/react-awesome-query-builder/issues/182\n            var prev = acc[k],\n              next = rule[k];\n            if (!isObject(prev)) {\n              prev = {\n                \"$eq\": prev\n              };\n            }\n            if (!isObject(next)) {\n              next = {\n                \"$eq\": next\n              };\n            }\n            var prevOp = Object.keys(prev)[0],\n              nextOp = Object.keys(next)[0];\n            if (prevOp == nextOp) {\n              acc = undefined;\n              break;\n            }\n            acc[k] = Object.assign({}, prev, next);\n          }\n        }\n        return acc;\n      }, {});\n    }\n    if (!resultQuery)\n      // can't be shorten\n      resultQuery = _defineProperty({}, mongoConj, rules);\n  }\n  if (groupField) {\n    if (mode == \"array\") {\n      var totalQuery = {\n        \"$size\": groupFieldName\n      };\n      var filterQuery = resultQuery ? {\n        \"$size\": {\n          \"$filter\": {\n            input: \"$\" + groupFieldName,\n            as: \"el\",\n            cond: resultQuery\n          }\n        }\n      } : totalQuery;\n      resultQuery = formatItem(parents, item.set(\"type\", \"rule\"), config, meta, false, false, function (_f) {\n        return filterQuery;\n      }, totalQuery);\n      resultQuery = {\n        \"$expr\": resultQuery\n      };\n    } else {\n      resultQuery = _defineProperty({}, groupFieldName, {\n        \"$elemMatch\": resultQuery\n      });\n    }\n  }\n  return resultQuery;\n};\nvar formatRule = function formatRule(parents, item, config, meta) {\n  var _not = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  var _canWrapExpr = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n  var _fieldName = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : undefined;\n  var _value = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : undefined;\n  var properties = item.get(\"properties\") || new Map();\n  var hasParentRuleGroup = parents.filter(function (it) {\n    return it.get(\"type\") == \"rule_group\";\n  }).length > 0;\n  var parentPath = parents.filter(function (it) {\n    return it.get(\"type\") == \"rule_group\";\n  }).map(function (it) {\n    return it.get(\"properties\").get(\"field\");\n  }).slice(-1).pop();\n  var realParentPath = hasParentRuleGroup && parentPath;\n  var operator = properties.get(\"operator\");\n  var operatorOptions = properties.get(\"operatorOptions\");\n  var field = properties.get(\"field\");\n  var iValue = properties.get(\"value\");\n  var iValueSrc = properties.get(\"valueSrc\");\n  var iValueType = properties.get(\"valueType\");\n  var asyncListValues = properties.get(\"asyncListValues\");\n  if (field == null || operator == null || iValue === undefined) return undefined;\n  var fieldDef = getFieldConfig(config, field) || {};\n  var operatorDefinition = getOperatorConfig(config, operator, field) || {};\n  var reversedOp = operatorDefinition.reversedOp;\n  var revOperatorDefinition = getOperatorConfig(config, reversedOp, field) || {};\n  var cardinality = defaultValue(operatorDefinition.cardinality, 1);\n  var not = _not;\n  if (not && reversedOp) {\n    var _ref = [reversedOp, operator];\n    operator = _ref[0];\n    reversedOp = _ref[1];\n    var _ref2 = [revOperatorDefinition, operatorDefinition];\n    operatorDefinition = _ref2[0];\n    revOperatorDefinition = _ref2[1];\n    not = false;\n  }\n  var fieldName = formatFieldName(field, config, meta, realParentPath);\n\n  //format value\n  var valueSrcs = [];\n  var valueTypes = [];\n  var useExpr = false;\n  var fvalue = iValue.map(function (currentValue, ind) {\n    var valueSrc = iValueSrc ? iValueSrc.get(ind) : null;\n    var valueType = iValueType ? iValueType.get(ind) : null;\n    var cValue = completeValue(currentValue, valueSrc, config);\n    var widget = getWidgetForFieldOp(config, field, operator, valueSrc);\n    var fieldWidgetDef = omit(getFieldWidgetConfig(config, field, operator, widget, valueSrc), [\"factory\"]);\n    var _formatValue = formatValue(meta, config, cValue, valueSrc, valueType, fieldWidgetDef, fieldDef, realParentPath, operator, operatorDefinition, asyncListValues),\n      _formatValue2 = _slicedToArray(_formatValue, 2),\n      fv = _formatValue2[0],\n      fvUseExpr = _formatValue2[1];\n    if (fv !== undefined) {\n      useExpr = useExpr || fvUseExpr;\n      valueSrcs.push(valueSrc);\n      valueTypes.push(valueType);\n    }\n    return fv;\n  });\n  if (_fieldName) useExpr = true;\n  var wrapExpr = useExpr && _canWrapExpr;\n  var hasUndefinedValues = fvalue.filter(function (v) {\n    return v === undefined;\n  }).size > 0;\n  if (fvalue.size < cardinality || hasUndefinedValues) return undefined;\n  var formattedValue = cardinality > 1 ? fvalue.toArray() : cardinality == 1 ? fvalue.first() : null;\n\n  //build rule\n  var fn = operatorDefinition.mongoFormatOp;\n  if (!fn) {\n    meta.errors.push(\"Operator \".concat(operator, \" is not supported\"));\n    return undefined;\n  }\n  var args = [_fieldName ? _fieldName(fieldName) : fieldName, operator, _value !== undefined && formattedValue == null ? _value : formattedValue, useExpr, valueSrcs.length > 1 ? valueSrcs : valueSrcs[0], valueTypes.length > 1 ? valueTypes : valueTypes[0], omit(operatorDefinition, [\"formatOp\", \"mongoFormatOp\", \"sqlFormatOp\", \"jsonLogic\", \"spelFormatOp\"]), operatorOptions, fieldDef];\n  var ruleQuery = fn.apply(void 0, args);\n  if (wrapExpr) {\n    ruleQuery = {\n      \"$expr\": ruleQuery\n    };\n  }\n  if (not) {\n    ruleQuery = {\n      \"$not\": ruleQuery\n    };\n  }\n  return ruleQuery;\n};\nvar formatValue = function formatValue(meta, config, currentValue, valueSrc, valueType, fieldWidgetDef, fieldDef, parentPath, operator, operatorDef, asyncListValues) {\n  if (currentValue === undefined) return [undefined, false];\n  var ret;\n  var useExpr = false;\n  if (valueSrc == \"field\") {\n    var _formatRightField = formatRightField(meta, config, currentValue, parentPath);\n    var _formatRightField2 = _slicedToArray(_formatRightField, 2);\n    ret = _formatRightField2[0];\n    useExpr = _formatRightField2[1];\n  } else if (valueSrc == \"func\") {\n    var _formatFunc = formatFunc(meta, config, currentValue, parentPath);\n    var _formatFunc2 = _slicedToArray(_formatFunc, 2);\n    ret = _formatFunc2[0];\n    useExpr = _formatFunc2[1];\n  } else {\n    if (typeof fieldWidgetDef.mongoFormatValue === \"function\") {\n      var fn = fieldWidgetDef.mongoFormatValue;\n      var args = [currentValue, _objectSpread(_objectSpread({}, pick(fieldDef, [\"fieldSettings\", \"listValues\"])), {}, {\n        asyncListValues: asyncListValues\n      }),\n      //useful options: valueFormat for date/time\n      omit(fieldWidgetDef, [\"formatValue\", \"mongoFormatValue\", \"sqlFormatValue\", \"jsonLogic\", \"elasticSearchFormatValue\", \"spelFormatValue\"])];\n      if (operator) {\n        args.push(operator);\n        args.push(operatorDef);\n      }\n      ret = fn.apply(void 0, args);\n    } else {\n      ret = currentValue;\n    }\n  }\n  return [ret, useExpr];\n};\nvar formatFieldName = function formatFieldName(field, config, meta, parentPath) {\n  if (!field) return;\n  var fieldDef = getFieldConfig(config, field) || {};\n  var fieldSeparator = config.settings.fieldSeparator;\n  var fieldParts = Array.isArray(field) ? field : field.split(fieldSeparator);\n  var fieldName = Array.isArray(field) ? field.join(fieldSeparator) : field;\n  // if (fieldDef.tableName) { // legacy\n  //     const fieldPartsCopy = [...fieldParts];\n  //     fieldPartsCopy[0] = fieldDef.tableName;\n  //     fieldName = fieldPartsCopy.join(fieldSeparator);\n  // }\n  if (fieldDef.fieldName) {\n    fieldName = fieldDef.fieldName;\n  }\n  if (parentPath) {\n    var parentFieldDef = getFieldConfig(config, parentPath) || {};\n    var parentFieldName = parentPath;\n    if (parentFieldDef.fieldName) {\n      parentFieldName = parentFieldDef.fieldName;\n    }\n    if (fieldName.indexOf(parentFieldName + \".\") == 0) {\n      fieldName = fieldName.slice((parentFieldName + \".\").length);\n    } else {\n      meta.errors.push(\"Can't cut group \".concat(parentFieldName, \" from field \").concat(fieldName));\n    }\n  }\n  return fieldName;\n};\nvar formatRightField = function formatRightField(meta, config, rightField, parentPath) {\n  var fieldSeparator = config.settings.fieldSeparator;\n  var ret;\n  var useExpr = true;\n  if (rightField) {\n    var rightFieldDefinition = getFieldConfig(config, rightField) || {};\n    var fieldParts = Array.isArray(rightField) ? rightField : rightField.split(fieldSeparator);\n    var _fieldKeys = getFieldPath(rightField, config);\n    var fieldPartsLabels = getFieldPathLabels(rightField, config);\n    var fieldFullLabel = fieldPartsLabels ? fieldPartsLabels.join(fieldSeparator) : null;\n    var formatFieldFn = config.settings.formatField;\n    var rightFieldName = formatFieldName(rightField, config, meta, parentPath);\n    var formattedField = formatFieldFn(rightFieldName, fieldParts, fieldFullLabel, rightFieldDefinition, config, false);\n    ret = \"$\" + formattedField;\n  }\n  return [ret, useExpr];\n};\nvar formatFunc = function formatFunc(meta, config, currentValue, parentPath) {\n  var useExpr = true;\n  var ret;\n  var funcKey = currentValue.get(\"func\");\n  var args = currentValue.get(\"args\");\n  var funcConfig = getFuncConfig(config, funcKey);\n  var funcName = funcConfig.mongoFunc || funcKey;\n  var mongoArgsAsObject = funcConfig.mongoArgsAsObject;\n  var formattedArgs = {};\n  var argsCnt = 0;\n  var lastArg = undefined;\n  for (var argKey in funcConfig.args) {\n    var argConfig = funcConfig.args[argKey];\n    var fieldDef = getFieldConfig(config, argConfig);\n    var argVal = args ? args.get(argKey) : undefined;\n    var argValue = argVal ? argVal.get(\"value\") : undefined;\n    var argValueSrc = argVal ? argVal.get(\"valueSrc\") : undefined;\n    var argAsyncListValues = argVal ? argVal.get(\"asyncListValues\") : undefined;\n    var widget = getWidgetForFieldOp(config, fieldDef, null, argValueSrc);\n    var fieldWidgetDef = omit(getFieldWidgetConfig(config, fieldDef, null, widget, argValueSrc), [\"factory\"]);\n    var _formatValue3 = formatValue(meta, config, argValue, argValueSrc, argConfig.type, fieldWidgetDef, fieldDef, parentPath, null, null, argAsyncListValues),\n      _formatValue4 = _slicedToArray(_formatValue3, 2),\n      formattedArgVal = _formatValue4[0],\n      _argUseExpr = _formatValue4[1];\n    if (argValue != undefined && formattedArgVal === undefined) {\n      meta.errors.push(\"Can't format value of arg \".concat(argKey, \" for func \").concat(funcKey));\n      return [undefined, false];\n    }\n    argsCnt++;\n    if (formattedArgVal !== undefined) {\n      // skip optional in the end\n      formattedArgs[argKey] = formattedArgVal;\n      lastArg = formattedArgVal;\n    }\n  }\n  if (typeof funcConfig.mongoFormatFunc === \"function\") {\n    var fn = funcConfig.mongoFormatFunc;\n    var _args = [formattedArgs];\n    ret = fn.apply(void 0, _args);\n  } else if (funcConfig.mongoFormatFunc === null) {\n    meta.errors.push(\"Functon \".concat(funcName, \" is not supported\"));\n    return [undefined, false];\n  } else {\n    if (mongoArgsAsObject) ret = _defineProperty({}, funcName, formattedArgs);else if (argsCnt == 1 && lastArg !== undefined) ret = _defineProperty({}, funcName, lastArg);else ret = _defineProperty({}, funcName, Object.values(formattedArgs));\n  }\n  return [ret, useExpr];\n};"]},"metadata":{},"sourceType":"module"}