{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.removePathsInTree = exports.isEmptyTree = exports.hasChildren = exports.getTreeBadFields = exports.getTotalRulesCountInTree = exports.getTotalReordableNodesCountInTree = exports.getLightTree = exports.getItemByPath = exports.getFlatTree = exports.fixPathsInTree = exports.fixEmptyGroupsInTree = exports.expandTreeSubpath = exports.expandTreePath = void 0;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _immutable = _interopRequireDefault(require(\"immutable\"));\n/**\n * @param {Immutable.List} path\n * @param {...string} suffix\n * @return {Immutable.List}\n */\n\n\nvar expandTreePath = function expandTreePath(path) {\n  for (var _len = arguments.length, suffix = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    suffix[_key - 1] = arguments[_key];\n  }\n\n  return path.interpose(\"children1\").withMutations(function (list) {\n    list.skip(1);\n    list.push.apply(list, suffix);\n    return list;\n  });\n};\n/**\n * @param {Immutable.List} path\n * @param {...string} suffix\n * @return {Immutable.List}\n */\n\n\nexports.expandTreePath = expandTreePath;\n\nvar expandTreeSubpath = function expandTreeSubpath(path) {\n  for (var _len2 = arguments.length, suffix = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    suffix[_key2 - 1] = arguments[_key2];\n  }\n\n  return path.interpose(\"children1\").withMutations(function (list) {\n    list.push.apply(list, suffix);\n    return list;\n  });\n};\n/**\n * @param {Immutable.Map} path\n * @param {Immutable.List} path\n * @return {Immutable.Map}\n */\n\n\nexports.expandTreeSubpath = expandTreeSubpath;\n\nvar getItemByPath = function getItemByPath(tree, path) {\n  var children = new _immutable[\"default\"].OrderedMap((0, _defineProperty2[\"default\"])({}, tree.get(\"id\"), tree));\n  var res = tree;\n  path.forEach(function (id) {\n    res = children.get(id);\n    children = res.get(\"children1\");\n  });\n  return res;\n};\n/**\n * Remove `path` in every item\n * @param {Immutable.Map} tree\n * @return {Immutable.Map} tree\n */\n\n\nexports.getItemByPath = getItemByPath;\n\nvar removePathsInTree = function removePathsInTree(tree) {\n  var newTree = tree;\n\n  function _processNode(item, path) {\n    var itemPath = path.push(item.get(\"id\"));\n\n    if (item.get(\"path\")) {\n      newTree = newTree.removeIn(expandTreePath(itemPath, \"path\"));\n    }\n\n    var children = item.get(\"children1\");\n\n    if (children) {\n      children.map(function (child, _childId) {\n        _processNode(child, itemPath);\n      });\n    }\n  }\n\n  _processNode(tree, new _immutable[\"default\"].List());\n\n  return newTree;\n};\n/**\n * Set correct `path` in every item\n * @param {Immutable.Map} tree\n * @return {Immutable.Map} tree\n */\n\n\nexports.removePathsInTree = removePathsInTree;\n\nvar fixPathsInTree = function fixPathsInTree(tree) {\n  var newTree = tree;\n\n  function _processNode(item, path, lev) {\n    if (!item) return;\n\n    var _id = item.get(\"id\");\n\n    var itemPath = path.push(item.get(\"id\"));\n    var currItemPath = item.get(\"path\");\n\n    if (!currItemPath || !currItemPath.equals(itemPath)) {\n      newTree = newTree.setIn(expandTreePath(itemPath, \"path\"), itemPath);\n    }\n\n    var children = item.get(\"children1\");\n\n    if (children) {\n      if (children.constructor.name == \"Map\") {\n        // protect: should me OrderedMap, not Map (issue #501)\n        newTree = newTree.setIn(expandTreePath(itemPath, \"children1\"), new _immutable[\"default\"].OrderedMap(children));\n      }\n\n      children.map(function (child, _childId) {\n        _processNode(child, itemPath, lev + 1);\n      });\n    }\n  }\n\n  _processNode(tree, new _immutable[\"default\"].List(), 0);\n\n  return newTree;\n};\n\nexports.fixPathsInTree = fixPathsInTree;\n\nvar fixEmptyGroupsInTree = function fixEmptyGroupsInTree(tree) {\n  var newTree = tree;\n\n  function _processNode(item, path, lev) {\n    if (!item) return false;\n    var id = item.get(\"id\");\n    var itemPath = path.push(item.get(\"id\"));\n    var children = item.get(\"children1\");\n\n    if (children) {\n      var allChildrenGone = children.map(function (child, _childId) {\n        return _processNode(child, itemPath, lev + 1);\n      }).reduce(function (curr, v) {\n        return curr && v;\n      }, true);\n\n      if ((children.size == 0 || allChildrenGone) && lev > 0) {\n        newTree = newTree.deleteIn(expandTreePath(itemPath));\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  _processNode(tree, new _immutable[\"default\"].List(), 0);\n\n  return newTree;\n};\n/**\n * @param {Immutable.Map} tree\n * @return {Object} {flat, items}\n */\n\n\nexports.fixEmptyGroupsInTree = fixEmptyGroupsInTree;\n\nvar getFlatTree = function getFlatTree(tree) {\n  var flat = [];\n  var items = {};\n  var realHeight = 0;\n\n  function _flatizeTree(item, path, insideCollapsed, lev, info, parentType) {\n    var type = item.get(\"type\");\n    var collapsed = item.get(\"collapsed\");\n    var id = item.get(\"id\");\n    var children = item.get(\"children1\");\n    var childrenIds = children ? children.map(function (_child, childId) {\n      return childId;\n    }) : null;\n    var itemsBefore = flat.length;\n    var top = realHeight;\n    flat.push(id);\n    if (!insideCollapsed) realHeight += 1;\n    info.height = (info.height || 0) + 1;\n\n    if (children) {\n      var subinfo = {};\n      children.map(function (child, _childId) {\n        _flatizeTree(child, path.concat(id), insideCollapsed || collapsed, lev + 1, subinfo, type);\n      });\n\n      if (!collapsed) {\n        info.height = (info.height || 0) + (subinfo.height || 0);\n      }\n    }\n\n    var itemsAfter = flat.length;\n    var _bottom = realHeight;\n    var height = info.height;\n    items[id] = {\n      type: type,\n      parent: path.length ? path[path.length - 1] : null,\n      parentType: parentType,\n      path: path.concat(id),\n      lev: lev,\n      leaf: !children,\n      index: itemsBefore,\n      id: id,\n      children: childrenIds,\n      _top: itemsBefore,\n      _height: itemsAfter - itemsBefore,\n      top: insideCollapsed ? null : top,\n      height: height,\n      bottom: (insideCollapsed ? null : top) + height,\n      collapsed: collapsed,\n      node: item\n    };\n  }\n\n  _flatizeTree(tree, [], false, 0, {}, null);\n\n  for (var i = 0; i < flat.length; i++) {\n    var prevId = i > 0 ? flat[i - 1] : null;\n    var nextId = i < flat.length - 1 ? flat[i + 1] : null;\n    var item = items[flat[i]];\n    item.prev = prevId;\n    item.next = nextId;\n  }\n\n  return {\n    flat: flat,\n    items: items\n  };\n};\n/**\n * Returns count of reorderable(!) nodes\n * @param {Immutable.Map} tree\n * @return {Integer}\n */\n\n\nexports.getFlatTree = getFlatTree;\n\nvar getTotalReordableNodesCountInTree = function getTotalReordableNodesCountInTree(tree) {\n  if (!tree) return -1;\n  var cnt = 0;\n\n  function _processNode(item, path, lev) {\n    var id = item.get(\"id\");\n    var children = item.get(\"children1\");\n    var isRuleGroup = item.get(\"type\") == \"rule_group\";\n    cnt++; //tip: rules in rule-group can be reordered only inside\n\n    if (children && !isRuleGroup) {\n      children.map(function (child, _childId) {\n        _processNode(child, path.concat(id), lev + 1);\n      });\n    }\n  }\n\n  _processNode(tree, [], 0);\n\n  return cnt - 1; // -1 for root\n};\n/**\n * Returns count of rules (leafs, i.e. don't count groups)\n * @param {Immutable.Map} tree\n * @return {Integer}\n */\n\n\nexports.getTotalReordableNodesCountInTree = getTotalReordableNodesCountInTree;\n\nvar getTotalRulesCountInTree = function getTotalRulesCountInTree(tree) {\n  if (!tree) return -1;\n  var cnt = 0;\n\n  function _processNode(item, path, lev) {\n    var id = item.get(\"id\");\n    var children = item.get(\"children1\");\n    var isGroup = item.get(\"type\") == \"group\"; //const isRuleGroup = item.get(\"type\") == \"rule_group\";\n\n    if (children && isGroup) {\n      children.map(function (child, _childId) {\n        _processNode(child, path.concat(id), lev + 1);\n      });\n    } else {\n      // tip: count rule_group as 1 rule\n      cnt++;\n    }\n  }\n\n  _processNode(tree, [], 0);\n\n  return cnt;\n};\n\nexports.getTotalRulesCountInTree = getTotalRulesCountInTree;\n\nvar getTreeBadFields = function getTreeBadFields(tree) {\n  var badFields = [];\n\n  function _processNode(item, path, lev) {\n    var id = item.get(\"id\");\n    var children = item.get(\"children1\");\n    var valueError = item.getIn([\"properties\", \"valueError\"]);\n    var field = item.getIn([\"properties\", \"field\"]);\n\n    if (valueError && valueError.size > 0 && valueError.filter(function (v) {\n      return v != null;\n    }).size > 0) {\n      badFields.push(field);\n    }\n\n    if (children) {\n      children.map(function (child, _childId) {\n        _processNode(child, path.concat(id), lev + 1);\n      });\n    }\n  }\n\n  if (tree) _processNode(tree, [], 0);\n  return Array.from(new Set(badFields));\n}; // Remove fields that can be calced: \"id\", \"path\"\n// Remove empty fields: \"operatorOptions\"\n\n\nexports.getTreeBadFields = getTreeBadFields;\n\nvar getLightTree = function getLightTree(tree) {\n  var newTree = tree;\n\n  function _processNode(item, itemId) {\n    if (item.path) delete item.path;\n    if (itemId) delete item.id;\n    var properties = item.properties;\n\n    if (properties) {\n      if (properties.operatorOptions == null) delete properties.operatorOptions;\n    }\n\n    var children = item.children1;\n\n    if (children) {\n      for (var id in children) {\n        _processNode(children[id], id);\n      }\n    }\n  }\n\n  _processNode(tree, null);\n\n  return newTree;\n};\n\nexports.getLightTree = getLightTree;\n\nvar isEmptyTree = function isEmptyTree(tree) {\n  return !tree.get(\"children1\") || tree.get(\"children1\").size == 0;\n};\n\nexports.isEmptyTree = isEmptyTree;\n\nvar hasChildren = function hasChildren(tree, path) {\n  return tree.getIn(expandTreePath(path, \"children1\")).size > 0;\n};\n\nexports.hasChildren = hasChildren;","map":{"version":3,"sources":["D:/LIMSWFH/LIMSPOSTGRESQL/QuaLISWeb/node_modules/react-awesome-query-builder/lib/utils/treeUtils.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","removePathsInTree","isEmptyTree","hasChildren","getTreeBadFields","getTotalRulesCountInTree","getTotalReordableNodesCountInTree","getLightTree","getItemByPath","getFlatTree","fixPathsInTree","fixEmptyGroupsInTree","expandTreeSubpath","expandTreePath","_defineProperty2","_immutable","path","_len","arguments","length","suffix","Array","_key","interpose","withMutations","list","skip","push","apply","_len2","_key2","tree","children","OrderedMap","get","res","forEach","id","newTree","_processNode","item","itemPath","removeIn","map","child","_childId","List","lev","_id","currItemPath","equals","setIn","constructor","name","allChildrenGone","reduce","curr","v","size","deleteIn","flat","items","realHeight","_flatizeTree","insideCollapsed","info","parentType","type","collapsed","childrenIds","_child","childId","itemsBefore","top","height","subinfo","concat","itemsAfter","_bottom","parent","leaf","index","_top","_height","bottom","node","i","prevId","nextId","prev","next","cnt","isRuleGroup","isGroup","badFields","valueError","getIn","field","filter","from","Set","itemId","properties","operatorOptions","children1"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.removePathsInTree = exports.isEmptyTree = exports.hasChildren = exports.getTreeBadFields = exports.getTotalRulesCountInTree = exports.getTotalReordableNodesCountInTree = exports.getLightTree = exports.getItemByPath = exports.getFlatTree = exports.fixPathsInTree = exports.fixEmptyGroupsInTree = exports.expandTreeSubpath = exports.expandTreePath = void 0;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _immutable = _interopRequireDefault(require(\"immutable\"));\n\n/**\n * @param {Immutable.List} path\n * @param {...string} suffix\n * @return {Immutable.List}\n */\nvar expandTreePath = function expandTreePath(path) {\n  for (var _len = arguments.length, suffix = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    suffix[_key - 1] = arguments[_key];\n  }\n\n  return path.interpose(\"children1\").withMutations(function (list) {\n    list.skip(1);\n    list.push.apply(list, suffix);\n    return list;\n  });\n};\n/**\n * @param {Immutable.List} path\n * @param {...string} suffix\n * @return {Immutable.List}\n */\n\n\nexports.expandTreePath = expandTreePath;\n\nvar expandTreeSubpath = function expandTreeSubpath(path) {\n  for (var _len2 = arguments.length, suffix = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    suffix[_key2 - 1] = arguments[_key2];\n  }\n\n  return path.interpose(\"children1\").withMutations(function (list) {\n    list.push.apply(list, suffix);\n    return list;\n  });\n};\n/**\n * @param {Immutable.Map} path\n * @param {Immutable.List} path\n * @return {Immutable.Map}\n */\n\n\nexports.expandTreeSubpath = expandTreeSubpath;\n\nvar getItemByPath = function getItemByPath(tree, path) {\n  var children = new _immutable[\"default\"].OrderedMap((0, _defineProperty2[\"default\"])({}, tree.get(\"id\"), tree));\n  var res = tree;\n  path.forEach(function (id) {\n    res = children.get(id);\n    children = res.get(\"children1\");\n  });\n  return res;\n};\n/**\n * Remove `path` in every item\n * @param {Immutable.Map} tree\n * @return {Immutable.Map} tree\n */\n\n\nexports.getItemByPath = getItemByPath;\n\nvar removePathsInTree = function removePathsInTree(tree) {\n  var newTree = tree;\n\n  function _processNode(item, path) {\n    var itemPath = path.push(item.get(\"id\"));\n\n    if (item.get(\"path\")) {\n      newTree = newTree.removeIn(expandTreePath(itemPath, \"path\"));\n    }\n\n    var children = item.get(\"children1\");\n\n    if (children) {\n      children.map(function (child, _childId) {\n        _processNode(child, itemPath);\n      });\n    }\n  }\n\n  _processNode(tree, new _immutable[\"default\"].List());\n\n  return newTree;\n};\n/**\n * Set correct `path` in every item\n * @param {Immutable.Map} tree\n * @return {Immutable.Map} tree\n */\n\n\nexports.removePathsInTree = removePathsInTree;\n\nvar fixPathsInTree = function fixPathsInTree(tree) {\n  var newTree = tree;\n\n  function _processNode(item, path, lev) {\n    if (!item) return;\n\n    var _id = item.get(\"id\");\n\n    var itemPath = path.push(item.get(\"id\"));\n    var currItemPath = item.get(\"path\");\n\n    if (!currItemPath || !currItemPath.equals(itemPath)) {\n      newTree = newTree.setIn(expandTreePath(itemPath, \"path\"), itemPath);\n    }\n\n    var children = item.get(\"children1\");\n\n    if (children) {\n      if (children.constructor.name == \"Map\") {\n        // protect: should me OrderedMap, not Map (issue #501)\n        newTree = newTree.setIn(expandTreePath(itemPath, \"children1\"), new _immutable[\"default\"].OrderedMap(children));\n      }\n\n      children.map(function (child, _childId) {\n        _processNode(child, itemPath, lev + 1);\n      });\n    }\n  }\n\n  _processNode(tree, new _immutable[\"default\"].List(), 0);\n\n  return newTree;\n};\n\nexports.fixPathsInTree = fixPathsInTree;\n\nvar fixEmptyGroupsInTree = function fixEmptyGroupsInTree(tree) {\n  var newTree = tree;\n\n  function _processNode(item, path, lev) {\n    if (!item) return false;\n    var id = item.get(\"id\");\n    var itemPath = path.push(item.get(\"id\"));\n    var children = item.get(\"children1\");\n\n    if (children) {\n      var allChildrenGone = children.map(function (child, _childId) {\n        return _processNode(child, itemPath, lev + 1);\n      }).reduce(function (curr, v) {\n        return curr && v;\n      }, true);\n\n      if ((children.size == 0 || allChildrenGone) && lev > 0) {\n        newTree = newTree.deleteIn(expandTreePath(itemPath));\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  _processNode(tree, new _immutable[\"default\"].List(), 0);\n\n  return newTree;\n};\n/**\n * @param {Immutable.Map} tree\n * @return {Object} {flat, items}\n */\n\n\nexports.fixEmptyGroupsInTree = fixEmptyGroupsInTree;\n\nvar getFlatTree = function getFlatTree(tree) {\n  var flat = [];\n  var items = {};\n  var realHeight = 0;\n\n  function _flatizeTree(item, path, insideCollapsed, lev, info, parentType) {\n    var type = item.get(\"type\");\n    var collapsed = item.get(\"collapsed\");\n    var id = item.get(\"id\");\n    var children = item.get(\"children1\");\n    var childrenIds = children ? children.map(function (_child, childId) {\n      return childId;\n    }) : null;\n    var itemsBefore = flat.length;\n    var top = realHeight;\n    flat.push(id);\n    if (!insideCollapsed) realHeight += 1;\n    info.height = (info.height || 0) + 1;\n\n    if (children) {\n      var subinfo = {};\n      children.map(function (child, _childId) {\n        _flatizeTree(child, path.concat(id), insideCollapsed || collapsed, lev + 1, subinfo, type);\n      });\n\n      if (!collapsed) {\n        info.height = (info.height || 0) + (subinfo.height || 0);\n      }\n    }\n\n    var itemsAfter = flat.length;\n    var _bottom = realHeight;\n    var height = info.height;\n    items[id] = {\n      type: type,\n      parent: path.length ? path[path.length - 1] : null,\n      parentType: parentType,\n      path: path.concat(id),\n      lev: lev,\n      leaf: !children,\n      index: itemsBefore,\n      id: id,\n      children: childrenIds,\n      _top: itemsBefore,\n      _height: itemsAfter - itemsBefore,\n      top: insideCollapsed ? null : top,\n      height: height,\n      bottom: (insideCollapsed ? null : top) + height,\n      collapsed: collapsed,\n      node: item\n    };\n  }\n\n  _flatizeTree(tree, [], false, 0, {}, null);\n\n  for (var i = 0; i < flat.length; i++) {\n    var prevId = i > 0 ? flat[i - 1] : null;\n    var nextId = i < flat.length - 1 ? flat[i + 1] : null;\n    var item = items[flat[i]];\n    item.prev = prevId;\n    item.next = nextId;\n  }\n\n  return {\n    flat: flat,\n    items: items\n  };\n};\n/**\n * Returns count of reorderable(!) nodes\n * @param {Immutable.Map} tree\n * @return {Integer}\n */\n\n\nexports.getFlatTree = getFlatTree;\n\nvar getTotalReordableNodesCountInTree = function getTotalReordableNodesCountInTree(tree) {\n  if (!tree) return -1;\n  var cnt = 0;\n\n  function _processNode(item, path, lev) {\n    var id = item.get(\"id\");\n    var children = item.get(\"children1\");\n    var isRuleGroup = item.get(\"type\") == \"rule_group\";\n    cnt++; //tip: rules in rule-group can be reordered only inside\n\n    if (children && !isRuleGroup) {\n      children.map(function (child, _childId) {\n        _processNode(child, path.concat(id), lev + 1);\n      });\n    }\n  }\n\n  _processNode(tree, [], 0);\n\n  return cnt - 1; // -1 for root\n};\n/**\n * Returns count of rules (leafs, i.e. don't count groups)\n * @param {Immutable.Map} tree\n * @return {Integer}\n */\n\n\nexports.getTotalReordableNodesCountInTree = getTotalReordableNodesCountInTree;\n\nvar getTotalRulesCountInTree = function getTotalRulesCountInTree(tree) {\n  if (!tree) return -1;\n  var cnt = 0;\n\n  function _processNode(item, path, lev) {\n    var id = item.get(\"id\");\n    var children = item.get(\"children1\");\n    var isGroup = item.get(\"type\") == \"group\"; //const isRuleGroup = item.get(\"type\") == \"rule_group\";\n\n    if (children && isGroup) {\n      children.map(function (child, _childId) {\n        _processNode(child, path.concat(id), lev + 1);\n      });\n    } else {\n      // tip: count rule_group as 1 rule\n      cnt++;\n    }\n  }\n\n  _processNode(tree, [], 0);\n\n  return cnt;\n};\n\nexports.getTotalRulesCountInTree = getTotalRulesCountInTree;\n\nvar getTreeBadFields = function getTreeBadFields(tree) {\n  var badFields = [];\n\n  function _processNode(item, path, lev) {\n    var id = item.get(\"id\");\n    var children = item.get(\"children1\");\n    var valueError = item.getIn([\"properties\", \"valueError\"]);\n    var field = item.getIn([\"properties\", \"field\"]);\n\n    if (valueError && valueError.size > 0 && valueError.filter(function (v) {\n      return v != null;\n    }).size > 0) {\n      badFields.push(field);\n    }\n\n    if (children) {\n      children.map(function (child, _childId) {\n        _processNode(child, path.concat(id), lev + 1);\n      });\n    }\n  }\n\n  if (tree) _processNode(tree, [], 0);\n  return Array.from(new Set(badFields));\n}; // Remove fields that can be calced: \"id\", \"path\"\n// Remove empty fields: \"operatorOptions\"\n\n\nexports.getTreeBadFields = getTreeBadFields;\n\nvar getLightTree = function getLightTree(tree) {\n  var newTree = tree;\n\n  function _processNode(item, itemId) {\n    if (item.path) delete item.path;\n    if (itemId) delete item.id;\n    var properties = item.properties;\n\n    if (properties) {\n      if (properties.operatorOptions == null) delete properties.operatorOptions;\n    }\n\n    var children = item.children1;\n\n    if (children) {\n      for (var id in children) {\n        _processNode(children[id], id);\n      }\n    }\n  }\n\n  _processNode(tree, null);\n\n  return newTree;\n};\n\nexports.getLightTree = getLightTree;\n\nvar isEmptyTree = function isEmptyTree(tree) {\n  return !tree.get(\"children1\") || tree.get(\"children1\").size == 0;\n};\n\nexports.isEmptyTree = isEmptyTree;\n\nvar hasChildren = function hasChildren(tree, path) {\n  return tree.getIn(expandTreePath(path, \"children1\")).size > 0;\n};\n\nexports.hasChildren = hasChildren;"]},"metadata":{},"sourceType":"script"}