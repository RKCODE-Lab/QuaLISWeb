{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport { changeStylesString } from './utils';\nimport { ReplaceAroundStep } from 'prosemirror-transform';\nimport { Fragment, Slice } from 'prosemirror-model';\n/**\n * @hidden\n */\n\nvar canChangeType = function canChangeType(stateDoc, pos, type) {\n  var $pos = stateDoc.resolve(pos),\n      index = $pos.index();\n  return $pos.parent.canReplaceWith(index, index + 1, type);\n};\n\nexport var changeBlockNode = function changeBlockNode(state, dispatch, tr, node, nodeType, attrs) {\n  var _a = state.selection,\n      from = _a.from,\n      to = _a.to;\n  var applicable = false;\n  state.doc.nodesBetween(from, to, function (currNode, pos) {\n    if (applicable) {\n      return false;\n    }\n\n    if (!currNode.isTextblock || currNode.hasMarkup(nodeType, attrs)) {\n      return;\n    }\n\n    if (currNode.type === nodeType) {\n      applicable = true;\n    } else {\n      var $pos = state.doc.resolve(pos),\n          index = $pos.index();\n      applicable = $pos.parent.canReplaceWith(index, index + 1, nodeType);\n    }\n  });\n\n  if (!applicable) {\n    return false;\n  }\n\n  if (dispatch) {\n    if (!nodeType.isTextblock) {\n      throw new RangeError('Type given to setBlockType should be a textblock');\n    }\n\n    var mapFrom_1 = tr.steps.length;\n    tr.doc.nodesBetween(from, to, function (currNode, pos) {\n      if (currNode.eq(node) && currNode.isTextblock && !currNode.hasMarkup(nodeType, attrs) && canChangeType(tr.doc, tr.mapping.slice(mapFrom_1).map(pos), nodeType)) {\n        // Ensure all markup that isn't allowed in the new node type is cleared\n        tr.clearIncompatible(tr.mapping.slice(mapFrom_1).map(pos, 1), nodeType);\n        var mapping = tr.mapping.slice(mapFrom_1);\n        var startM = mapping.map(pos, 1),\n            endM = mapping.map(pos + currNode.nodeSize, 1);\n        var slice = new Slice(Fragment.from(nodeType.create(attrs, null, currNode.marks)), 0, 0);\n        tr.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1, slice, 1, true));\n        return false; // this will skip the node children\n      }\n    });\n  }\n\n  return true;\n};\nexport var blockNodes = function blockNodes(state) {\n  var selection = state.selection;\n  var from = selection.from,\n      to = selection.to,\n      $from = selection.$from;\n  var result = [];\n\n  if (selection.node) {\n    if (selection.node.isBlock) {\n      result.push(selection.node);\n    } else if ($from.parent && $from.parent.isBlock) {\n      result.push($from.parent);\n    }\n  } else {\n    state.doc.nodesBetween(from, to, function (node) {\n      if (node.isBlock) {\n        result.push(node);\n      }\n    });\n  }\n\n  return result;\n};\nexport var formatBlockElements = function formatBlockElements(value, commandName) {\n  return function (state, dispatch) {\n    var blocks = blockNodes(state);\n    var nodes = state.schema.nodes;\n    var result = false;\n    var tr = state.tr;\n    tr.setMeta('commandName', commandName);\n    tr.setMeta('args', {\n      value: value\n    });\n    blocks.forEach(function (node) {\n      if (node.type.isTextblock) {\n        if (value === 'p') {\n          var _a = node.attrs,\n              level = _a.level,\n              attrs = tslib_1.__rest(_a, [\"level\"]);\n\n          result = changeBlockNode(state, dispatch, tr, node, nodes.paragraph, attrs) || result;\n        } else if (/^h[1-6]$/i.test(value)) {\n          var level = parseInt(value.substr(1), 10);\n          result = changeBlockNode(state, dispatch, tr, node, nodes.heading, tslib_1.__assign({}, node.attrs, {\n            level: level\n          })) || result;\n        } else if (value === 'blockquote') {\n          var _b = node.attrs,\n              level = _b.level,\n              attrs = tslib_1.__rest(_b, [\"level\"]);\n\n          result = changeBlockNode(state, dispatch, tr, node, nodes.blockquote, attrs) || result;\n        }\n      }\n    });\n\n    if (result) {\n      dispatch(tr.scrollIntoView());\n    }\n\n    return result;\n  };\n};\nexport var getBlockFormats = function getBlockFormats(state) {\n  var blocks = blockNodes(state);\n  var nodes = state.schema.nodes;\n  var result = [];\n  blocks.forEach(function (node) {\n    if (node.type === nodes.paragraph) {\n      result.push('p');\n    } else if (node.type === nodes.heading) {\n      result.push(\"h\" + node.attrs.level);\n    } else if (node.type === nodes.blockquote) {\n      // In case the blockquote can have inline content.\n      // Will be removed once a blockquote command is implemented.\n      result.push('blockquote');\n    }\n  });\n  return result;\n};\nexport var addStyles = function addStyles(node, stylesToApply) {\n  var currentStyles = node.attrs.style,\n      changedStyleResult,\n      toChange;\n\n  if (currentStyles) {\n    stylesToApply.forEach(function (style) {\n      toChange = {\n        style: style.name,\n        value: /^.+$/,\n        newValue: style.value\n      };\n      changedStyleResult = changeStylesString(currentStyles, toChange);\n      currentStyles = changedStyleResult.changed ? changedStyleResult.style : currentStyles;\n    });\n  }\n\n  var reducer = function reducer(acc, curr) {\n    return (acc && curr.value ? acc + ' ' : '') + curr.value ? curr.name + \": \" + curr.value + \";\" : '';\n  };\n\n  currentStyles = currentStyles || stylesToApply.reduce(reducer, '');\n  return Object.assign({}, node.attrs, {\n    style: currentStyles || null\n  });\n};\nexport var hasNode = function hasNode(state, nodeType) {\n  var _a = state.selection,\n      from = _a.from,\n      to = _a.to;\n  var result = false;\n  state.doc.nodesBetween(from, to, function (node) {\n    result = result || node.type === nodeType;\n    return !result;\n  });\n  return result;\n};\nexport var parentBlockFormat = function parentBlockFormat(state) {\n  var formats = getBlockFormats(state);\n  return new Set(formats).size === 1 ? formats[0] : null;\n};\n/**\n * **Deprecated.** Use `parentBlockFormat` function instead.\n */\n\nexport var activeNode = function activeNode(state) {\n  return {\n    tag: parentBlockFormat(state) || ''\n  };\n};","map":{"version":3,"sources":["D:/LIMSWFH/LIMSPOSTGRESQL/QuaLISWeb/node_modules/@progress/kendo-editor-common/dist/es/blockNode.js"],"names":["tslib_1","changeStylesString","ReplaceAroundStep","Fragment","Slice","canChangeType","stateDoc","pos","type","$pos","resolve","index","parent","canReplaceWith","changeBlockNode","state","dispatch","tr","node","nodeType","attrs","_a","selection","from","to","applicable","doc","nodesBetween","currNode","isTextblock","hasMarkup","RangeError","mapFrom_1","steps","length","eq","mapping","slice","map","clearIncompatible","startM","endM","nodeSize","create","marks","step","blockNodes","$from","result","isBlock","push","formatBlockElements","value","commandName","blocks","nodes","schema","setMeta","forEach","level","__rest","paragraph","test","parseInt","substr","heading","__assign","_b","blockquote","scrollIntoView","getBlockFormats","addStyles","stylesToApply","currentStyles","style","changedStyleResult","toChange","name","newValue","changed","reducer","acc","curr","reduce","Object","assign","hasNode","parentBlockFormat","formats","Set","size","activeNode","tag"],"mappings":"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","sourcesContent":["import * as tslib_1 from \"tslib\";\nimport { changeStylesString } from './utils';\nimport { ReplaceAroundStep } from 'prosemirror-transform';\nimport { Fragment, Slice } from 'prosemirror-model';\n/**\n * @hidden\n */\nvar canChangeType = function (stateDoc, pos, type) {\n    var $pos = stateDoc.resolve(pos), index = $pos.index();\n    return $pos.parent.canReplaceWith(index, index + 1, type);\n};\nexport var changeBlockNode = function (state, dispatch, tr, node, nodeType, attrs) {\n    var _a = state.selection, from = _a.from, to = _a.to;\n    var applicable = false;\n    state.doc.nodesBetween(from, to, function (currNode, pos) {\n        if (applicable) {\n            return false;\n        }\n        if (!currNode.isTextblock || currNode.hasMarkup(nodeType, attrs)) {\n            return;\n        }\n        if (currNode.type === nodeType) {\n            applicable = true;\n        }\n        else {\n            var $pos = state.doc.resolve(pos), index = $pos.index();\n            applicable = $pos.parent.canReplaceWith(index, index + 1, nodeType);\n        }\n    });\n    if (!applicable) {\n        return false;\n    }\n    if (dispatch) {\n        if (!nodeType.isTextblock) {\n            throw new RangeError('Type given to setBlockType should be a textblock');\n        }\n        var mapFrom_1 = tr.steps.length;\n        tr.doc.nodesBetween(from, to, function (currNode, pos) {\n            if (currNode.eq(node) &&\n                currNode.isTextblock &&\n                !currNode.hasMarkup(nodeType, attrs) &&\n                canChangeType(tr.doc, tr.mapping.slice(mapFrom_1).map(pos), nodeType)) {\n                // Ensure all markup that isn't allowed in the new node type is cleared\n                tr.clearIncompatible(tr.mapping.slice(mapFrom_1).map(pos, 1), nodeType);\n                var mapping = tr.mapping.slice(mapFrom_1);\n                var startM = mapping.map(pos, 1), endM = mapping.map(pos + currNode.nodeSize, 1);\n                var slice = new Slice(Fragment.from(nodeType.create(attrs, null, currNode.marks)), 0, 0);\n                tr.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1, slice, 1, true));\n                return false; // this will skip the node children\n            }\n        });\n    }\n    return true;\n};\nexport var blockNodes = function (state) {\n    var selection = state.selection;\n    var from = selection.from, to = selection.to, $from = selection.$from;\n    var result = [];\n    if (selection.node) {\n        if (selection.node.isBlock) {\n            result.push(selection.node);\n        }\n        else if ($from.parent && $from.parent.isBlock) {\n            result.push($from.parent);\n        }\n    }\n    else {\n        state.doc.nodesBetween(from, to, function (node) {\n            if (node.isBlock) {\n                result.push(node);\n            }\n        });\n    }\n    return result;\n};\nexport var formatBlockElements = function (value, commandName) {\n    return function (state, dispatch) {\n        var blocks = blockNodes(state);\n        var nodes = state.schema.nodes;\n        var result = false;\n        var tr = state.tr;\n        tr.setMeta('commandName', commandName);\n        tr.setMeta('args', { value: value });\n        blocks.forEach(function (node) {\n            if (node.type.isTextblock) {\n                if (value === 'p') {\n                    var _a = node.attrs, level = _a.level, attrs = tslib_1.__rest(_a, [\"level\"]);\n                    result = changeBlockNode(state, dispatch, tr, node, nodes.paragraph, attrs) || result;\n                }\n                else if (/^h[1-6]$/i.test(value)) {\n                    var level = parseInt(value.substr(1), 10);\n                    result = changeBlockNode(state, dispatch, tr, node, nodes.heading, tslib_1.__assign({}, node.attrs, { level: level })) || result;\n                }\n                else if (value === 'blockquote') {\n                    var _b = node.attrs, level = _b.level, attrs = tslib_1.__rest(_b, [\"level\"]);\n                    result = changeBlockNode(state, dispatch, tr, node, nodes.blockquote, attrs) || result;\n                }\n            }\n        });\n        if (result) {\n            dispatch(tr.scrollIntoView());\n        }\n        return result;\n    };\n};\nexport var getBlockFormats = function (state) {\n    var blocks = blockNodes(state);\n    var nodes = state.schema.nodes;\n    var result = [];\n    blocks.forEach(function (node) {\n        if (node.type === nodes.paragraph) {\n            result.push('p');\n        }\n        else if (node.type === nodes.heading) {\n            result.push(\"h\" + node.attrs.level);\n        }\n        else if (node.type === nodes.blockquote) {\n            // In case the blockquote can have inline content.\n            // Will be removed once a blockquote command is implemented.\n            result.push('blockquote');\n        }\n    });\n    return result;\n};\nexport var addStyles = function (node, stylesToApply) {\n    var currentStyles = node.attrs.style, changedStyleResult, toChange;\n    if (currentStyles) {\n        stylesToApply.forEach(function (style) {\n            toChange = { style: style.name, value: /^.+$/, newValue: style.value };\n            changedStyleResult = changeStylesString(currentStyles, toChange);\n            currentStyles = changedStyleResult.changed ? changedStyleResult.style : currentStyles;\n        });\n    }\n    var reducer = function (acc, curr) { return ((acc && curr.value ? acc + ' ' : '') + curr.value ? curr.name + \": \" + curr.value + \";\" : ''); };\n    currentStyles = currentStyles || stylesToApply.reduce(reducer, '');\n    return Object.assign({}, node.attrs, { style: currentStyles || null });\n};\nexport var hasNode = function (state, nodeType) {\n    var _a = state.selection, from = _a.from, to = _a.to;\n    var result = false;\n    state.doc.nodesBetween(from, to, function (node) {\n        result = result || node.type === nodeType;\n        return !result;\n    });\n    return result;\n};\nexport var parentBlockFormat = function (state) {\n    var formats = getBlockFormats(state);\n    return new Set(formats).size === 1 ? formats[0] : null;\n};\n/**\n * **Deprecated.** Use `parentBlockFormat` function instead.\n */\nexport var activeNode = function (state) {\n    return { tag: parentBlockFormat(state) || '' };\n};\n"]},"metadata":{},"sourceType":"module"}