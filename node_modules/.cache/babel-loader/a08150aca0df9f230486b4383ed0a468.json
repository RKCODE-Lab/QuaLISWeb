{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport { Fragment, Slice, NodeRange } from 'prosemirror-model';\nimport { TextSelection, NodeSelection } from 'prosemirror-state';\nimport { liftTarget, ReplaceAroundStep } from 'prosemirror-transform';\nimport { autoJoin } from 'prosemirror-commands';\nimport { wrapInList as pmWrapInList, splitListItem } from 'prosemirror-schema-list';\nimport { bulletList as bulletListSettings, orderedList as orderedListSettings } from './config/list-settings';\n\nvar rootListDepth = function (pos, nodes) {\n  // Get the depth of the nearest ancestor list\n  var bulletList = nodes.bulletList,\n      orderedList = nodes.orderedList,\n      listItem = nodes.listItem;\n  var depth;\n\n  for (var i = pos.depth - 1; i > 0; i--) {\n    var node = pos.node(i);\n\n    if (node.type === bulletList || node.type === orderedList) {\n      depth = i;\n    }\n\n    if (node.type !== bulletList && node.type !== orderedList && node.type !== listItem) {\n      break;\n    }\n  }\n\n  return depth;\n};\n\nvar getListLiftTarget = function (schema, resPos, listNodeNames) {\n  // This will return (depth - 1) for root list parent of a list.\n  var target = resPos.depth;\n  var bulletList = schema.nodes[listNodeNames.bulletList];\n  var orderedList = schema.nodes[listNodeNames.orderedList];\n  var listItem = schema.nodes[listNodeNames.listItem];\n\n  for (var i = resPos.depth; i > 0; i--) {\n    var node = resPos.node(i);\n\n    if (node.type === bulletList || node.type === orderedList) {\n      target = i;\n    }\n\n    if (node.type !== bulletList && node.type !== orderedList && node.type !== listItem) {\n      break;\n    }\n  }\n\n  return target - 1;\n};\n\nfunction liftSelectionList(state, tr, listNodeNames) {\n  // The function will list paragraphs in selection out to level 1 below root list.\n  var _a = state.selection,\n      from = _a.from,\n      to = _a.to;\n  var _b = state.schema.nodes,\n      paragraph = _b.paragraph,\n      heading = _b.heading;\n  var listCol = [];\n  tr.doc.nodesBetween(from, to, function (node, pos) {\n    if (node.type === paragraph || node.type === heading) {\n      listCol.push({\n        node: node,\n        pos: pos\n      });\n    }\n  });\n\n  for (var i = listCol.length - 1; i >= 0; i--) {\n    var block = listCol[i];\n    var start = tr.doc.resolve(tr.mapping.map(block.pos));\n\n    if (start.depth > 0) {\n      var end = void 0;\n\n      if (block.node.textContent && block.node.textContent.length > 0) {\n        end = tr.doc.resolve(tr.mapping.map(block.pos + block.node.textContent.length));\n      } else {\n        end = tr.doc.resolve(tr.mapping.map(block.pos + 1));\n      }\n\n      var range = start.blockRange(end);\n\n      if (range) {\n        tr.lift(range, getListLiftTarget(state.schema, start, listNodeNames));\n      }\n    }\n  }\n\n  return tr;\n}\n\nfunction toggleListCommand(listNodeNames) {\n  return function (state, dispatch, view) {\n    if (!view) {\n      return false;\n    }\n\n    state = view.state;\n    var listNode = state.schema.nodes[listNodeNames.listType];\n    var _a = state.selection,\n        $from = _a.$from,\n        $to = _a.$to;\n    var parent = $from.node(-2);\n    var grandgrandParent = $from.node(-3);\n    var isRangeOfSingleType = isRangeOfType(state.doc, $from, $to, listNode);\n\n    if ((parent && parent.type === listNode || grandgrandParent && grandgrandParent.type === listNode) && isRangeOfSingleType) {\n      // Untoggles list\n      return liftListItems(listNodeNames)(state, dispatch);\n    } else {\n      // Wraps selection in list and converts list type e.g. bullet_list -> ordered_list if needed\n      if (!isRangeOfSingleType) {\n        liftListItems(listNodeNames)(state, dispatch);\n        state = view.state;\n      }\n\n      return wrapInList(listNode)(state, dispatch);\n    }\n  };\n}\n\nfunction liftListItem(state, selection, tr, nodeType) {\n  if (!nodeType) {\n    nodeType = state.schema.nodes.listItem;\n  }\n\n  var $from = selection.$from,\n      $to = selection.$to;\n  var range = $from.blockRange($to, function (node) {\n    return node.childCount && node.firstChild.type === nodeType;\n  });\n\n  if (!range || range.depth < 2 || $from.node(range.depth - 1).type !== nodeType) {\n    return tr;\n  }\n\n  var end = range.end;\n  var endOfList = $to.end(range.depth);\n\n  if (end < endOfList) {\n    tr.step(new ReplaceAroundStep(end - 1, endOfList, end, endOfList, new Slice(Fragment.from(nodeType.create(undefined, range.parent.copy())), 1, 0), 1, true));\n    range = new NodeRange(tr.doc.resolve($from.pos), tr.doc.resolve(endOfList), range.depth);\n  }\n\n  return tr.lift(range, liftTarget(range)).scrollIntoView();\n}\n\nfunction liftFollowingList(state, from, to, rootListDepthNum, tr, listItem) {\n  // Function will lift list item following selection to level-1.\n  if (!listItem) {\n    listItem = state.schema.nodes.listItem;\n  }\n\n  var lifted = false;\n  tr.doc.nodesBetween(from, to, function (node, pos) {\n    if (!lifted && node.type === listItem && pos > from) {\n      lifted = true;\n      var listDepth = rootListDepthNum + 3;\n\n      while (listDepth > rootListDepthNum + 2) {\n        var start = tr.doc.resolve(tr.mapping.map(pos));\n        listDepth = start.depth;\n        var end = tr.doc.resolve(tr.mapping.map(pos + node.textContent.length));\n        var sel = new TextSelection(start, end);\n        tr = liftListItem(state, sel, tr, listItem);\n      }\n    }\n  });\n  return tr;\n}\n\nfunction isRangeOfType(doc, $from, $to, nodeType) {\n  // Step through block-nodes between $from and $to and returns false if a node is\n  // found that isn't of the specified type\n  return getAncestorNodesBetween(doc, $from, $to).filter(function (node) {\n    return node.type !== nodeType;\n  }).length === 0;\n}\n\nfunction getAncestorNodesBetween(doc, $from, $to) {\n  // Returns all top-level ancestor-nodes between $from and $to\n  var nodes = Array();\n  var maxDepth = findAncestorPosition(doc, $from).depth;\n  var current = doc.resolve($from.start(maxDepth));\n\n  while (current.pos <= $to.start($to.depth)) {\n    var depth = Math.min(current.depth, maxDepth);\n    var node = current.node(depth);\n\n    if (node) {\n      nodes.push(node);\n    }\n\n    if (depth === 0) {\n      break;\n    }\n\n    var next = doc.resolve(current.after(depth));\n\n    if (next.start(depth) >= doc.nodeSize - 2) {\n      break;\n    }\n\n    if (next.depth !== current.depth) {\n      next = doc.resolve(next.pos + 2);\n    }\n\n    if (next.depth) {\n      current = doc.resolve(next.start(next.depth));\n    } else {\n      current = doc.resolve(next.end(next.depth));\n    }\n  }\n\n  return nodes;\n}\n\nfunction findAncestorPosition(doc, pos) {\n  // Traverse the document until an \"ancestor\" is found. Any nestable block can be an ancestor.\n  var nestableBlocks = ['blockquote', 'bulletList', 'orderedList'];\n\n  if (pos.depth === 1) {\n    return pos;\n  }\n\n  var node = pos.node(pos.depth);\n  var newPos = pos;\n\n  while (pos.depth >= 1) {\n    pos = doc.resolve(pos.before(pos.depth));\n    node = pos.node(pos.depth);\n\n    if (node && nestableBlocks.indexOf(node.type.name) !== -1) {\n      newPos = pos;\n    }\n  }\n\n  return newPos;\n}\n\nfunction liftListItems(listNodeNames) {\n  return function (state, dispatch) {\n    var tr = state.tr;\n    var _a = state.selection,\n        $from = _a.$from,\n        $to = _a.$to;\n    tr.doc.nodesBetween($from.pos, $to.pos, function (node, pos) {\n      // Following condition will ensure that block types `paragraph`, `heading`, `codeBlock`, `blockquote`, `div` are lifted.\n      // isTextblock is true for paragraph, heading, codeBlock.\n      if (node.isTextblock || node.type.name === 'blockquote' || node.type.name === 'div') {\n        var sel = new NodeSelection(tr.doc.resolve(tr.mapping.map(pos)));\n        var range = sel.$from.blockRange(sel.$to);\n\n        if (!range || sel.$from.parent.type !== state.schema.nodes[listNodeNames.listItem]) {\n          return false;\n        }\n\n        var target = range && liftTarget(range);\n\n        if (target === undefined || target === null) {\n          return false;\n        }\n\n        tr.lift(range, target);\n      }\n    });\n\n    if (dispatch) {\n      dispatch(tr);\n    }\n\n    return true;\n  };\n}\n\nfunction wrapInList(nodeType) {\n  return autoJoin(pmWrapInList(nodeType), function (before, after) {\n    return before.type === after.type && before.type === nodeType;\n  });\n}\n\nexport var toggleList = function (state, dispatch, view, listNodeNames, command) {\n  var listType = listNodeNames.listType;\n  var selection = state.selection;\n  var fromNode = selection.$from.node(selection.$from.depth - 2);\n  var endNode = selection.$to.node(selection.$to.depth - 2);\n\n  if (!fromNode || fromNode.type.name !== listType || !endNode || endNode.type.name !== listType) {\n    return toggleListCommand(listNodeNames)(state, dispatch, view);\n  } else {\n    var nodes = view.state.schema.nodes;\n    var listNodes = {\n      bulletList: nodes[listNodeNames.bulletList],\n      orderedList: nodes[listNodeNames.orderedList],\n      listItem: nodes[listNodeNames.listItem]\n    };\n    var depth = rootListDepth(selection.$to, listNodes);\n    var tr = liftFollowingList(state, selection.$to.pos, selection.$to.end(depth), depth, view.state.tr, listNodes.listItem);\n    tr = liftSelectionList(state, tr, listNodeNames);\n    tr.setMeta('commandName', command);\n    dispatch(tr);\n    return true;\n  }\n};\nexport function toggleUnorderedList(state, dispatch, view) {\n  return toggleList(state, dispatch, view, tslib_1.__assign({\n    listType: bulletListSettings.listType\n  }, bulletListSettings.types));\n}\nexport function toggleOrderedList(state, dispatch, view) {\n  return toggleList(state, dispatch, view, tslib_1.__assign({\n    listType: orderedListSettings.listType\n  }, orderedListSettings.types));\n}\nexport var splitListItemKeepMarks = function (itemType) {\n  return function (state, dispatch) {\n    // see https://github.com/ProseMirror/prosemirror-commands/blob/master/src/commands.js#L321-L327\n    return splitListItem(itemType)(state, function (tr) {\n      var marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();\n\n      if (marks) {\n        tr.ensureMarks(marks);\n      }\n\n      dispatch(tr);\n    });\n  };\n};","map":{"version":3,"sources":["D:/LIMSWFH/LIMSPOSTGRESQL/QuaLISWeb/node_modules/@progress/kendo-editor-common/dist/es/lists.js"],"names":["tslib_1","Fragment","Slice","NodeRange","TextSelection","NodeSelection","liftTarget","ReplaceAroundStep","autoJoin","wrapInList","pmWrapInList","splitListItem","bulletList","bulletListSettings","orderedList","orderedListSettings","rootListDepth","pos","nodes","listItem","depth","i","node","type","getListLiftTarget","schema","resPos","listNodeNames","target","liftSelectionList","state","tr","_a","selection","from","to","_b","paragraph","heading","listCol","doc","nodesBetween","push","length","block","start","resolve","mapping","map","end","textContent","range","blockRange","lift","toggleListCommand","dispatch","view","listNode","listType","$from","$to","parent","grandgrandParent","isRangeOfSingleType","isRangeOfType","liftListItems","liftListItem","nodeType","childCount","firstChild","endOfList","step","create","undefined","copy","scrollIntoView","liftFollowingList","rootListDepthNum","lifted","listDepth","sel","getAncestorNodesBetween","filter","Array","maxDepth","findAncestorPosition","current","Math","min","next","after","nodeSize","nestableBlocks","newPos","before","indexOf","name","isTextblock","toggleList","command","fromNode","endNode","listNodes","setMeta","toggleUnorderedList","__assign","types","toggleOrderedList","splitListItemKeepMarks","itemType","marks","storedMarks","parentOffset","ensureMarks"],"mappings":"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","sourcesContent":["import * as tslib_1 from \"tslib\";\nimport { Fragment, Slice, NodeRange } from 'prosemirror-model';\nimport { TextSelection, NodeSelection } from 'prosemirror-state';\nimport { liftTarget, ReplaceAroundStep } from 'prosemirror-transform';\nimport { autoJoin } from 'prosemirror-commands';\nimport { wrapInList as pmWrapInList, splitListItem } from 'prosemirror-schema-list';\nimport { bulletList as bulletListSettings, orderedList as orderedListSettings } from './config/list-settings';\nvar rootListDepth = function (pos, nodes) {\n    // Get the depth of the nearest ancestor list\n    var bulletList = nodes.bulletList, orderedList = nodes.orderedList, listItem = nodes.listItem;\n    var depth;\n    for (var i = pos.depth - 1; i > 0; i--) {\n        var node = pos.node(i);\n        if (node.type === bulletList || node.type === orderedList) {\n            depth = i;\n        }\n        if (node.type !== bulletList && node.type !== orderedList && node.type !== listItem) {\n            break;\n        }\n    }\n    return depth;\n};\nvar getListLiftTarget = function (schema, resPos, listNodeNames) {\n    // This will return (depth - 1) for root list parent of a list.\n    var target = resPos.depth;\n    var bulletList = schema.nodes[listNodeNames.bulletList];\n    var orderedList = schema.nodes[listNodeNames.orderedList];\n    var listItem = schema.nodes[listNodeNames.listItem];\n    for (var i = resPos.depth; i > 0; i--) {\n        var node = resPos.node(i);\n        if (node.type === bulletList || node.type === orderedList) {\n            target = i;\n        }\n        if (node.type !== bulletList && node.type !== orderedList && node.type !== listItem) {\n            break;\n        }\n    }\n    return target - 1;\n};\nfunction liftSelectionList(state, tr, listNodeNames) {\n    // The function will list paragraphs in selection out to level 1 below root list.\n    var _a = state.selection, from = _a.from, to = _a.to;\n    var _b = state.schema.nodes, paragraph = _b.paragraph, heading = _b.heading;\n    var listCol = [];\n    tr.doc.nodesBetween(from, to, function (node, pos) {\n        if (node.type === paragraph || node.type === heading) {\n            listCol.push({ node: node, pos: pos });\n        }\n    });\n    for (var i = listCol.length - 1; i >= 0; i--) {\n        var block = listCol[i];\n        var start = tr.doc.resolve(tr.mapping.map(block.pos));\n        if (start.depth > 0) {\n            var end = void 0;\n            if (block.node.textContent && block.node.textContent.length > 0) {\n                end = tr.doc.resolve(tr.mapping.map(block.pos + block.node.textContent.length));\n            }\n            else {\n                end = tr.doc.resolve(tr.mapping.map(block.pos + 1));\n            }\n            var range = start.blockRange(end);\n            if (range) {\n                tr.lift(range, getListLiftTarget(state.schema, start, listNodeNames));\n            }\n        }\n    }\n    return tr;\n}\nfunction toggleListCommand(listNodeNames) {\n    return function (state, dispatch, view) {\n        if (!view) {\n            return false;\n        }\n        state = view.state;\n        var listNode = state.schema.nodes[listNodeNames.listType];\n        var _a = state.selection, $from = _a.$from, $to = _a.$to;\n        var parent = $from.node(-2);\n        var grandgrandParent = $from.node(-3);\n        var isRangeOfSingleType = isRangeOfType(state.doc, $from, $to, listNode);\n        if (((parent && parent.type === listNode) ||\n            (grandgrandParent && grandgrandParent.type === listNode)) &&\n            isRangeOfSingleType) {\n            // Untoggles list\n            return liftListItems(listNodeNames)(state, dispatch);\n        }\n        else {\n            // Wraps selection in list and converts list type e.g. bullet_list -> ordered_list if needed\n            if (!isRangeOfSingleType) {\n                liftListItems(listNodeNames)(state, dispatch);\n                state = view.state;\n            }\n            return wrapInList(listNode)(state, dispatch);\n        }\n    };\n}\nfunction liftListItem(state, selection, tr, nodeType) {\n    if (!nodeType) {\n        nodeType = state.schema.nodes.listItem;\n    }\n    var $from = selection.$from, $to = selection.$to;\n    var range = $from.blockRange($to, function (node) { return node.childCount && node.firstChild.type === nodeType; });\n    if (!range || range.depth < 2 || $from.node(range.depth - 1).type !== nodeType) {\n        return tr;\n    }\n    var end = range.end;\n    var endOfList = $to.end(range.depth);\n    if (end < endOfList) {\n        tr.step(new ReplaceAroundStep(end - 1, endOfList, end, endOfList, new Slice(Fragment.from(nodeType.create(undefined, range.parent.copy())), 1, 0), 1, true));\n        range = new NodeRange(tr.doc.resolve($from.pos), tr.doc.resolve(endOfList), range.depth);\n    }\n    return tr.lift(range, liftTarget(range)).scrollIntoView();\n}\nfunction liftFollowingList(state, from, to, rootListDepthNum, tr, listItem) {\n    // Function will lift list item following selection to level-1.\n    if (!listItem) {\n        listItem = state.schema.nodes.listItem;\n    }\n    var lifted = false;\n    tr.doc.nodesBetween(from, to, function (node, pos) {\n        if (!lifted && node.type === listItem && pos > from) {\n            lifted = true;\n            var listDepth = rootListDepthNum + 3;\n            while (listDepth > rootListDepthNum + 2) {\n                var start = tr.doc.resolve(tr.mapping.map(pos));\n                listDepth = start.depth;\n                var end = tr.doc.resolve(tr.mapping.map(pos + node.textContent.length));\n                var sel = new TextSelection(start, end);\n                tr = liftListItem(state, sel, tr, listItem);\n            }\n        }\n    });\n    return tr;\n}\nfunction isRangeOfType(doc, $from, $to, nodeType) {\n    // Step through block-nodes between $from and $to and returns false if a node is\n    // found that isn't of the specified type\n    return getAncestorNodesBetween(doc, $from, $to).filter(function (node) { return node.type !== nodeType; }).length === 0;\n}\nfunction getAncestorNodesBetween(doc, $from, $to) {\n    // Returns all top-level ancestor-nodes between $from and $to\n    var nodes = Array();\n    var maxDepth = findAncestorPosition(doc, $from).depth;\n    var current = doc.resolve($from.start(maxDepth));\n    while (current.pos <= $to.start($to.depth)) {\n        var depth = Math.min(current.depth, maxDepth);\n        var node = current.node(depth);\n        if (node) {\n            nodes.push(node);\n        }\n        if (depth === 0) {\n            break;\n        }\n        var next = doc.resolve(current.after(depth));\n        if (next.start(depth) >= doc.nodeSize - 2) {\n            break;\n        }\n        if (next.depth !== current.depth) {\n            next = doc.resolve(next.pos + 2);\n        }\n        if (next.depth) {\n            current = doc.resolve(next.start(next.depth));\n        }\n        else {\n            current = doc.resolve(next.end(next.depth));\n        }\n    }\n    return nodes;\n}\nfunction findAncestorPosition(doc, pos) {\n    // Traverse the document until an \"ancestor\" is found. Any nestable block can be an ancestor.\n    var nestableBlocks = ['blockquote', 'bulletList', 'orderedList'];\n    if (pos.depth === 1) {\n        return pos;\n    }\n    var node = pos.node(pos.depth);\n    var newPos = pos;\n    while (pos.depth >= 1) {\n        pos = doc.resolve(pos.before(pos.depth));\n        node = pos.node(pos.depth);\n        if (node && nestableBlocks.indexOf(node.type.name) !== -1) {\n            newPos = pos;\n        }\n    }\n    return newPos;\n}\nfunction liftListItems(listNodeNames) {\n    return function (state, dispatch) {\n        var tr = state.tr;\n        var _a = state.selection, $from = _a.$from, $to = _a.$to;\n        tr.doc.nodesBetween($from.pos, $to.pos, function (node, pos) {\n            // Following condition will ensure that block types `paragraph`, `heading`, `codeBlock`, `blockquote`, `div` are lifted.\n            // isTextblock is true for paragraph, heading, codeBlock.\n            if (node.isTextblock || node.type.name === 'blockquote' || node.type.name === 'div') {\n                var sel = new NodeSelection(tr.doc.resolve(tr.mapping.map(pos)));\n                var range = sel.$from.blockRange(sel.$to);\n                if (!range || sel.$from.parent.type !== state.schema.nodes[listNodeNames.listItem]) {\n                    return false;\n                }\n                var target = range && liftTarget(range);\n                if (target === undefined || target === null) {\n                    return false;\n                }\n                tr.lift(range, target);\n            }\n        });\n        if (dispatch) {\n            dispatch(tr);\n        }\n        return true;\n    };\n}\nfunction wrapInList(nodeType) {\n    return autoJoin(pmWrapInList(nodeType), function (before, after) { return before.type === after.type && before.type === nodeType; });\n}\nexport var toggleList = function (state, dispatch, view, listNodeNames, command) {\n    var listType = listNodeNames.listType;\n    var selection = state.selection;\n    var fromNode = selection.$from.node(selection.$from.depth - 2);\n    var endNode = selection.$to.node(selection.$to.depth - 2);\n    if (!fromNode || fromNode.type.name !== listType || (!endNode || endNode.type.name !== listType)) {\n        return toggleListCommand(listNodeNames)(state, dispatch, view);\n    }\n    else {\n        var nodes = view.state.schema.nodes;\n        var listNodes = {\n            bulletList: nodes[listNodeNames.bulletList],\n            orderedList: nodes[listNodeNames.orderedList],\n            listItem: nodes[listNodeNames.listItem]\n        };\n        var depth = rootListDepth(selection.$to, listNodes);\n        var tr = liftFollowingList(state, selection.$to.pos, selection.$to.end(depth), depth, view.state.tr, listNodes.listItem);\n        tr = liftSelectionList(state, tr, listNodeNames);\n        tr.setMeta('commandName', command);\n        dispatch(tr);\n        return true;\n    }\n};\nexport function toggleUnorderedList(state, dispatch, view) {\n    return toggleList(state, dispatch, view, tslib_1.__assign({ listType: bulletListSettings.listType }, bulletListSettings.types));\n}\nexport function toggleOrderedList(state, dispatch, view) {\n    return toggleList(state, dispatch, view, tslib_1.__assign({ listType: orderedListSettings.listType }, orderedListSettings.types));\n}\nexport var splitListItemKeepMarks = function (itemType) { return function (state, dispatch) {\n    // see https://github.com/ProseMirror/prosemirror-commands/blob/master/src/commands.js#L321-L327\n    return splitListItem(itemType)(state, function (tr) {\n        var marks = state.storedMarks || (state.selection.$to.parentOffset && state.selection.$from.marks());\n        if (marks) {\n            tr.ensureMarks(marks);\n        }\n        dispatch(tr);\n    });\n}; };\n"]},"metadata":{},"sourceType":"module"}