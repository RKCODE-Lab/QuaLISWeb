{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.loadFromJsonLogic = void 0;\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _toArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toArray\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _uuid = _interopRequireDefault(require(\"../utils/uuid\"));\n\nvar _stuff = require(\"../utils/stuff\");\n\nvar _configUtils = require(\"../utils/configUtils\");\n\nvar _ruleUtils = require(\"../utils/ruleUtils\");\n\nvar _tree = require(\"./tree\");\n\nvar _defaultUtils = require(\"../utils/defaultUtils\");\n\nvar _moment = _interopRequireDefault(require(\"moment\"));\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2[\"default\"])(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // http://jsonlogic.com/\n// helpers\n\n\nvar arrayUniq = function arrayUniq(arr) {\n  return Array.from(new Set(arr));\n};\n\nvar arrayToObject = function arrayToObject(arr) {\n  return arr.reduce(function (acc, _ref) {\n    var _ref2 = (0, _slicedToArray2[\"default\"])(_ref, 2),\n        f = _ref2[0],\n        fc = _ref2[1];\n\n    return _objectSpread(_objectSpread({}, acc), {}, (0, _defineProperty2[\"default\"])({}, f, fc));\n  }, {});\n};\n\nvar loadFromJsonLogic = function loadFromJsonLogic(logicTree, config) {\n  //meta is mutable\n  var meta = {\n    errors: []\n  };\n  var extendedConfig = (0, _configUtils.extendConfig)(config);\n  var conv = buildConv(extendedConfig);\n  var jsTree = logicTree ? convertFromLogic(logicTree, conv, extendedConfig, \"rule\", meta) : undefined;\n\n  if (jsTree && jsTree.type != \"group\") {\n    jsTree = wrapInDefaultConj(jsTree, extendedConfig);\n  }\n\n  var immTree = jsTree ? (0, _tree.loadTree)(jsTree) : undefined;\n  if (meta.errors.length) console.warn(\"Errors while importing from JsonLogic:\", meta.errors);\n  return immTree;\n};\n\nexports.loadFromJsonLogic = loadFromJsonLogic;\n\nvar buildConv = function buildConv(config) {\n  var operators = {};\n\n  for (var opKey in config.operators) {\n    var opConfig = config.operators[opKey];\n\n    if (typeof opConfig.jsonLogic == \"string\") {\n      // example: \"</2\", \"#in/1\"\n      var opk = (opConfig._jsonLogicIsRevArgs ? \"#\" : \"\") + opConfig.jsonLogic + \"/\" + (0, _stuff.defaultValue)(opConfig.cardinality, 1);\n      if (!operators[opk]) operators[opk] = [];\n      operators[opk].push(opKey);\n    } else if (typeof opConfig.jsonLogic2 == \"string\") {\n      // example: all-in/1\"\n      var _opk = opConfig.jsonLogic2 + \"/\" + (0, _stuff.defaultValue)(opConfig.cardinality, 1);\n\n      if (!operators[_opk]) operators[_opk] = [];\n\n      operators[_opk].push(opKey);\n    }\n  }\n\n  var conjunctions = {};\n\n  for (var conjKey in config.conjunctions) {\n    var ck = conjKey.toLowerCase();\n    conjunctions[ck] = conjKey;\n  }\n\n  var funcs = {};\n\n  for (var funcKey in config.funcs) {\n    var funcConfig = config.funcs[funcKey];\n    var fk = void 0;\n\n    if (funcConfig.jsonLogicIsMethod) {\n      fk = \"#\" + funcConfig.jsonLogic;\n    } else if (typeof funcConfig.jsonLogic == \"string\") {\n      fk = funcConfig.jsonLogic;\n    }\n\n    if (fk) {\n      if (!funcs[fk]) funcs[fk] = [];\n      funcs[fk].push(funcKey);\n    }\n  }\n\n  return {\n    operators: operators,\n    conjunctions: conjunctions,\n    funcs: funcs,\n    varKeys: [\"var\", config.settings.jsonLogic.groupVarKey, config.settings.jsonLogic.altVarKey]\n  };\n};\n\nvar convertFromLogic = function convertFromLogic(logic, conv, config, expectedType, meta) {\n  var not = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  var fieldConfig = arguments.length > 6 ? arguments[6] : undefined;\n  var widget = arguments.length > 7 ? arguments[7] : undefined;\n  var parentField = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : null;\n  var op, vals;\n\n  if ((0, _stuff.isJsonLogic)(logic)) {\n    op = Object.keys(logic)[0];\n    vals = logic[op];\n    if (!Array.isArray(vals)) vals = [vals];\n  }\n\n  var ret;\n  var beforeErrorsCnt = meta.errors.length;\n  var isEmptyOp = op == \"!\" && vals.length == 1 && vals[0] && (0, _stuff.isJsonLogic)(vals[0]) && conv.varKeys.includes(Object.keys(vals[0])[0]);\n  var isRev = op == \"!\" && !isEmptyOp;\n\n  if (isRev) {\n    // reverse with not\n    ret = convertFromLogic(vals[0], conv, config, expectedType, meta, !not, fieldConfig, widget, parentField);\n  } else if (expectedType == \"val\") {\n    // not is not used here\n    ret = convertField(op, vals, conv, config, not, meta, parentField) || convertFunc(op, vals, conv, config, not, fieldConfig, meta, parentField) || convertVal(logic, fieldConfig, widget, config, meta);\n  } else if (expectedType == \"rule\") {\n    ret = convertConj(op, vals, conv, config, not, meta, parentField, false) || convertOp(op, vals, conv, config, not, meta, parentField);\n  }\n\n  var afterErrorsCnt = meta.errors.length;\n\n  if (op != \"!\" && ret === undefined && afterErrorsCnt == beforeErrorsCnt) {\n    meta.errors.push(\"Can't parse logic \".concat(JSON.stringify(logic)));\n  }\n\n  return ret;\n};\n\nvar convertVal = function convertVal(val, fieldConfig, widget, config, meta) {\n  if (val === undefined) return undefined;\n  var widgetConfig = config.widgets[widget || fieldConfig.mainWidget];\n\n  if (!widgetConfig) {\n    meta.errors.push(\"No widget for type \".concat(fieldConfig.type));\n    return undefined;\n  }\n\n  if ((0, _stuff.isJsonLogic)(val)) {\n    meta.errors.push(\"Unexpected logic in value: \".concat(JSON.stringify(val)));\n    return undefined;\n  } // number of seconds -> time string\n\n\n  if (fieldConfig && fieldConfig.type == \"time\" && typeof val == \"number\") {\n    var h = Math.floor(val / 60 / 60) % 24,\n        m = Math.floor(val / 60) % 60,\n        s = val % 60;\n    var valueFormat = widgetConfig.valueFormat;\n\n    if (valueFormat) {\n      var dateVal = new Date(val);\n      dateVal.setMilliseconds(0);\n      dateVal.setHours(h);\n      dateVal.setMinutes(m);\n      dateVal.setSeconds(s);\n      val = (0, _moment[\"default\"])(dateVal).format(valueFormat);\n    } else {\n      val = \"\".concat(h, \":\").concat(m, \":\").concat(s);\n    }\n  } // \"2020-01-08T22:00:00.000Z\" -> Date object\n\n\n  if (fieldConfig && [\"date\", \"datetime\"].includes(fieldConfig.type) && val && !(val instanceof Date)) {\n    try {\n      var _dateVal = new Date(val);\n\n      if (_dateVal instanceof Date && _dateVal.toISOString() === val) {\n        val = _dateVal;\n      }\n    } catch (e) {\n      meta.errors.push(\"Can't convert value \".concat(val, \" as Date\"));\n      val = undefined;\n    }\n  } // Date object -> formatted string\n\n\n  if (val instanceof Date && fieldConfig) {\n    var _valueFormat = widgetConfig.valueFormat;\n\n    if (_valueFormat) {\n      val = (0, _moment[\"default\"])(val).format(_valueFormat);\n    }\n  }\n\n  var asyncListValues;\n\n  if (val && fieldConfig.fieldSettings && fieldConfig.fieldSettings.asyncFetch) {\n    var vals = Array.isArray(val) ? val : [val];\n    asyncListValues = vals;\n  }\n\n  return {\n    valueSrc: \"value\",\n    value: val,\n    valueType: widgetConfig.type,\n    asyncListValues: asyncListValues\n  };\n};\n\nvar convertField = function convertField(op, vals, conv, config, not, meta) {\n  var parentField = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n  var fieldSeparator = config.settings.fieldSeparator;\n\n  if (conv.varKeys.includes(op) && typeof vals[0] == \"string\") {\n    var field = vals[0];\n    if (parentField) field = [parentField, field].join(fieldSeparator);\n    field = (0, _configUtils.normalizeField)(config, field);\n    var fieldConfig = (0, _configUtils.getFieldConfig)(config, field);\n\n    if (!fieldConfig) {\n      meta.errors.push(\"No config for field \".concat(field));\n      return undefined;\n    }\n\n    return {\n      valueSrc: \"field\",\n      value: field,\n      valueType: fieldConfig.type\n    };\n  }\n\n  return undefined;\n};\n\nvar convertFunc = function convertFunc(op, vals, conv, config, not, fieldConfig, meta) {\n  var parentField = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;\n  if (!op) return undefined;\n  var func, argsArr, funcKey;\n  var jsonLogicIsMethod = op == \"method\";\n\n  if (jsonLogicIsMethod) {\n    var obj, opts;\n\n    var _vals = (0, _toArray2[\"default\"])(vals);\n\n    obj = _vals[0];\n    func = _vals[1];\n    opts = _vals.slice(2);\n    argsArr = [obj].concat((0, _toConsumableArray2[\"default\"])(opts));\n  } else {\n    func = op;\n    argsArr = vals;\n  }\n\n  var fk = (jsonLogicIsMethod ? \"#\" : \"\") + func;\n  var funcKeys = (conv.funcs[fk] || []).filter(function (k) {\n    return fieldConfig ? config.funcs[k].returnType == fieldConfig.type : true;\n  });\n\n  if (funcKeys.length) {\n    funcKey = funcKeys[0];\n  } else {\n    var v = (0, _defineProperty2[\"default\"])({}, op, vals);\n\n    for (var _i = 0, _Object$entries = Object.entries(config.funcs || {}); _i < _Object$entries.length; _i++) {\n      var _Object$entries$_i = (0, _slicedToArray2[\"default\"])(_Object$entries[_i], 2),\n          f = _Object$entries$_i[0],\n          fc = _Object$entries$_i[1];\n\n      if (fc.jsonLogicImport && fc.returnType == fieldConfig.type) {\n        var parsed = void 0;\n\n        try {\n          parsed = fc.jsonLogicImport(v);\n        } catch (_e) {// given expression `v` can't be parsed into function\n        }\n\n        if (parsed) {\n          funcKey = f;\n          argsArr = parsed;\n        }\n      }\n    }\n  }\n\n  if (!funcKey) return undefined;\n\n  if (funcKey) {\n    var funcConfig = config.funcs[funcKey];\n    var argKeys = Object.keys(funcConfig.args || {});\n    var args = argsArr.reduce(function (acc, val, ind) {\n      var argKey = argKeys[ind];\n      var argConfig = funcConfig.args[argKey];\n      var argVal = convertFromLogic(val, conv, config, \"val\", meta, false, argConfig, null, parentField);\n\n      if (argVal === undefined) {\n        argVal = argConfig.defaultValue;\n\n        if (argVal === undefined) {\n          meta.errors.push(\"No value for arg \".concat(argKey, \" of func \").concat(funcKey));\n          return undefined;\n        }\n      }\n\n      return _objectSpread(_objectSpread({}, acc), {}, (0, _defineProperty2[\"default\"])({}, argKey, argVal));\n    }, {});\n    return {\n      valueSrc: \"func\",\n      value: {\n        func: funcKey,\n        args: args\n      },\n      valueType: funcConfig.returnType\n    };\n  }\n\n  return undefined;\n};\n\nvar convertConj = function convertConj(op, vals, conv, config, not, meta) {\n  var parentField = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n  var isRuleGroup = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;\n  var conjKey = conv.conjunctions[op];\n  var fieldSeparator = config.settings.fieldSeparator;\n  var parentFieldConfig = parentField ? (0, _configUtils.getFieldConfig)(config, parentField) : null;\n  var isParentGroup = (parentFieldConfig === null || parentFieldConfig === void 0 ? void 0 : parentFieldConfig.type) == \"!group\";\n\n  if (conjKey) {\n    var type = \"group\";\n    var children = vals.map(function (v) {\n      return convertFromLogic(v, conv, config, \"rule\", meta, false, null, null, parentField);\n    }).filter(function (r) {\n      return r !== undefined;\n    }).reduce(function (acc, r) {\n      return _objectSpread(_objectSpread({}, acc), {}, (0, _defineProperty2[\"default\"])({}, r.id, r));\n    }, {});\n    var complexFields = Object.values(children).map(function (v) {\n      var _v$properties;\n\n      return v === null || v === void 0 ? void 0 : (_v$properties = v.properties) === null || _v$properties === void 0 ? void 0 : _v$properties.field;\n    }).filter(function (f) {\n      return f && f.includes(fieldSeparator);\n    });\n    var complexFieldsGroupAncestors = Object.fromEntries(arrayUniq(complexFields).map(function (f) {\n      var parts = f.split(fieldSeparator);\n      var ancs = Object.fromEntries(parts.slice(0, -1).map(function (f, i, parts) {\n        return [].concat((0, _toConsumableArray2[\"default\"])(parts.slice(0, i)), [f]);\n      }).map(function (fp) {\n        return [fp.join(fieldSeparator), (0, _configUtils.getFieldConfig)(config, fp)];\n      }).filter(function (_ref3) {\n        var _ref4 = (0, _slicedToArray2[\"default\"])(_ref3, 2),\n            _f = _ref4[0],\n            fc = _ref4[1];\n\n        return fc.type == \"!group\";\n      }));\n      return [f, Object.keys(ancs)];\n    }));\n    var childrenInRuleGroup = Object.values(children).map(function (v) {\n      var _v$properties2;\n\n      return v === null || v === void 0 ? void 0 : (_v$properties2 = v.properties) === null || _v$properties2 === void 0 ? void 0 : _v$properties2.field;\n    }).map(function (f) {\n      return complexFieldsGroupAncestors[f];\n    }).filter(function (ancs) {\n      return ancs && ancs.length;\n    });\n    var usedRuleGroups = arrayUniq(Object.values(complexFieldsGroupAncestors).flat());\n    var usedTopRuleGroups = topLevelFieldsFilter(usedRuleGroups);\n    var properties = {\n      conjunction: conjKey,\n      not: not\n    };\n    var id = (0, _uuid[\"default\"])();\n    var children1 = {};\n    var groupToId = {};\n    Object.entries(children).map(function (_ref5) {\n      var _ref6 = (0, _slicedToArray2[\"default\"])(_ref5, 2),\n          k = _ref6[0],\n          v = _ref6[1];\n\n      if (v.type == \"group\" || v.type == \"rule_group\") {\n        // put as-is\n        children1[k] = v;\n      } else {\n        var _v$properties3;\n\n        var field = v === null || v === void 0 ? void 0 : (_v$properties3 = v.properties) === null || _v$properties3 === void 0 ? void 0 : _v$properties3.field;\n        var groupAncestors = complexFieldsGroupAncestors[field];\n        var groupField = groupAncestors === null || groupAncestors === void 0 ? void 0 : groupAncestors.at(-1);\n\n        if (!groupField) {\n          // not in rule_group (can be simple field or in struct) - put as-is\n          children1[k] = v;\n        } else {\n          // wrap field in rule_group (with creating hierarchy if need)\n          var ch = children1;\n          var parentFieldParts = parentField ? parentField.split(fieldSeparator) : [];\n          var isInParent = (0, _stuff.shallowEqual)(parentFieldParts, groupField.split(fieldSeparator).slice(0, parentFieldParts.length));\n          if (!isInParent) parentFieldParts = []; // should not be\n\n          var traverseGroupFields = groupField.split(fieldSeparator).slice(parentFieldParts.length).map(function (f, i, parts) {\n            return [].concat((0, _toConsumableArray2[\"default\"])(parentFieldParts), (0, _toConsumableArray2[\"default\"])(parts.slice(0, i)), [f]).join(fieldSeparator);\n          }).map(function (f) {\n            return (0, _configUtils.normalizeField)(config, f);\n          }).map(function (f) {\n            return {\n              f: f,\n              fc: (0, _configUtils.getFieldConfig)(config, f) || {}\n            };\n          }).filter(function (_ref7) {\n            var fc = _ref7.fc;\n            return fc.type != \"!struct\";\n          });\n          traverseGroupFields.map(function (_ref8, i) {\n            var gf = _ref8.f,\n                gfc = _ref8.fc;\n            var groupId = groupToId[gf];\n\n            if (!groupId) {\n              groupId = (0, _uuid[\"default\"])();\n              groupToId[gf] = groupId;\n              ch[groupId] = {\n                type: \"rule_group\",\n                id: groupId,\n                children1: {},\n                properties: {\n                  conjunction: conjKey,\n                  not: false,\n                  field: gf,\n                  mode: gfc.mode\n                }\n              };\n            }\n\n            ch = ch[groupId].children1;\n          });\n          ch[k] = v;\n        }\n      }\n    }); // tip: for isRuleGroup=true correct type and properties will be set out of this func\n\n    return {\n      type: type,\n      id: id,\n      children1: children1,\n      properties: properties\n    };\n  }\n\n  return undefined;\n};\n\nvar topLevelFieldsFilter = function topLevelFieldsFilter(fields) {\n  var arr = (0, _toConsumableArray2[\"default\"])(fields).sort(function (a, b) {\n    return a.length - b.length;\n  });\n\n  for (var i = 0; i < arr.length; i++) {\n    for (var j = i + 1; j < arr.length; j++) {\n      if (arr[j].indexOf(arr[i]) == 0) {\n        // arr[j] is inside arr[i] (eg. \"a.b\" inside \"a\")\n        arr.splice(j, 1);\n        j--;\n      }\n    }\n  }\n\n  return arr;\n};\n\nvar wrapInDefaultConjRuleGroup = function wrapInDefaultConjRuleGroup(rule, parentField, parentFieldConfig, config, conj) {\n  if (!rule) return undefined;\n  return {\n    type: \"rule_group\",\n    id: (0, _uuid[\"default\"])(),\n    children1: (0, _defineProperty2[\"default\"])({}, rule.id, rule),\n    properties: {\n      conjunction: conj || (0, _defaultUtils.defaultGroupConjunction)(config, parentFieldConfig),\n      not: false,\n      field: parentField\n    }\n  };\n};\n\nvar wrapInDefaultConj = function wrapInDefaultConj(rule, config) {\n  var not = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  return {\n    type: \"group\",\n    id: (0, _uuid[\"default\"])(),\n    children1: (0, _defineProperty2[\"default\"])({}, rule.id, rule),\n    properties: {\n      conjunction: (0, _defaultUtils.defaultConjunction)(config),\n      not: not\n    }\n  };\n};\n\nvar parseRule = function parseRule(op, arity, vals, parentField, conv, config, meta) {\n  var errors = [];\n\n  var res = _parseRule(op, arity, vals, parentField, conv, config, errors, false) || _parseRule(op, arity, vals, parentField, conv, config, errors, true);\n\n  if (!res) {\n    meta.errors.push(errors.join(\"; \") || \"Unknown op \".concat(op, \"/\").concat(arity));\n    return undefined;\n  }\n\n  return res;\n};\n\nvar _parseRule = function _parseRule(op, arity, vals, parentField, conv, config, errors, isRevArgs) {\n  // config.settings.groupOperators are used for group count (cardinality = 0 is exception)\n  // but don't confuse with \"all-in\" for multiselect\n  var isAllInForMultiselect = op == \"all\" && (0, _stuff.isJsonLogic)(vals[1]) && Object.keys(vals[1])[0] == \"in\";\n  var isGroup0 = !isAllInForMultiselect && config.settings.groupOperators.includes(op);\n  var cardinality = isGroup0 ? 0 : arity - 1;\n  var opk = op + \"/\" + cardinality;\n  var fieldSeparator = config.settings.fieldSeparator;\n  var opKeys = conv.operators[(isRevArgs ? \"#\" : \"\") + opk];\n\n  if (opKeys) {\n    var jlField,\n        args = [];\n    var rangeOps = [\"<\", \"<=\", \">\", \">=\"];\n\n    if (rangeOps.includes(op) && arity == 3) {\n      jlField = vals[1];\n      args = [vals[0], vals[2]];\n    } else if (isRevArgs) {\n      jlField = vals[1];\n      args = [vals[0]];\n    } else {\n      var _vals2 = (0, _toArray2[\"default\"])(vals);\n\n      jlField = _vals2[0];\n      args = _vals2.slice(1);\n    }\n\n    if (!(0, _stuff.isJsonLogic)(jlField)) {\n      errors.push(\"Incorrect operands for \".concat(op, \": \").concat(JSON.stringify(vals)));\n      return;\n    }\n\n    var k = Object.keys(jlField)[0];\n    var v = Object.values(jlField)[0];\n    var field, having, isGroup;\n\n    if (conv.varKeys.includes(k) && typeof v == \"string\") {\n      field = v;\n    }\n\n    if (isGroup0) {\n      isGroup = true;\n      having = args[0];\n      args = [];\n    } // reduce/filter for group ext\n\n\n    if (k == \"reduce\" && Array.isArray(v) && v.length == 3) {\n      var _v2 = v,\n          _v3 = (0, _slicedToArray2[\"default\"])(_v2, 3),\n          filter = _v3[0],\n          acc = _v3[1],\n          init = _v3[2];\n\n      if ((0, _stuff.isJsonLogic)(filter) && init == 0 && (0, _stuff.isJsonLogic)(acc) && Array.isArray(acc[\"+\"]) && acc[\"+\"][0] == 1 && (0, _stuff.isJsonLogic)(acc[\"+\"][1]) && acc[\"+\"][1][\"var\"] == \"accumulator\") {\n        k = Object.keys(filter)[0];\n        v = Object.values(filter)[0];\n\n        if (k == \"filter\") {\n          var _v4 = v,\n              _v5 = (0, _slicedToArray2[\"default\"])(_v4, 2),\n              group = _v5[0],\n              _filter = _v5[1];\n\n          if ((0, _stuff.isJsonLogic)(group)) {\n            k = Object.keys(group)[0];\n            v = Object.values(group)[0];\n\n            if (conv.varKeys.includes(k) && typeof v == \"string\") {\n              field = v;\n              having = _filter;\n              isGroup = true;\n            }\n          }\n        } else if (conv.varKeys.includes(k) && typeof v == \"string\") {\n          field = v;\n          isGroup = true;\n        }\n      }\n    }\n\n    if (!field) {\n      errors.push(\"Unknown field \".concat(JSON.stringify(jlField)));\n      return;\n    }\n\n    if (parentField) field = [parentField, field].join(fieldSeparator);\n    field = (0, _configUtils.normalizeField)(config, field);\n    var fieldConfig = (0, _configUtils.getFieldConfig)(config, field);\n\n    if (!fieldConfig) {\n      errors.push(\"No config for field \".concat(field));\n      return;\n    }\n\n    var opKey = opKeys[0];\n\n    if (opKeys.length > 1 && fieldConfig && fieldConfig.operators) {\n      // eg. for \"equal\" and \"select_equals\"\n      opKeys = opKeys.filter(function (k) {\n        return fieldConfig.operators.includes(k);\n      });\n\n      if (opKeys.length == 0) {\n        errors.push(\"No corresponding ops for field \".concat(field));\n        return;\n      }\n\n      opKey = opKeys[0];\n    }\n\n    return {\n      field: field,\n      fieldConfig: fieldConfig,\n      opKey: opKey,\n      args: args,\n      having: having\n    };\n  }\n};\n\nvar convertOp = function convertOp(op, vals, conv, config, not, meta) {\n  var parentField = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n  if (!op) return undefined;\n  var arity = vals.length;\n\n  if (op == \"all\" && (0, _stuff.isJsonLogic)(vals[1])) {\n    // special case for \"all-in\"\n    var op2 = Object.keys(vals[1])[0];\n\n    if (op2 == \"in\") {\n      vals = [vals[0], vals[1][op2][1]];\n      op = op + \"-\" + op2; // \"all-in\"\n    }\n  }\n\n  var parseRes = parseRule(op, arity, vals, parentField, conv, config, meta);\n  if (!parseRes) return undefined;\n  var field = parseRes.field,\n      fieldConfig = parseRes.fieldConfig,\n      opKey = parseRes.opKey,\n      args = parseRes.args,\n      having = parseRes.having;\n  var opConfig = config.operators[opKey]; // Group component in array mode can show NOT checkbox, so do nothing in this case\n  // Otherwise try to revert\n\n  var showNot = fieldConfig.showNot !== undefined ? fieldConfig.showNot : config.settings.showNot;\n  var canRev = true;\n  if (fieldConfig.type == \"!group\" && fieldConfig.mode == \"array\" && showNot) canRev = false; // Fix \"some ! in\"\n\n  if (fieldConfig.type == \"!group\" && having && Object.keys(having)[0] == \"!\") {\n    not = !not;\n    having = having[\"!\"];\n  } // Use reversed op\n\n\n  if (not && canRev && opConfig.reversedOp) {\n    not = false;\n    opKey = opConfig.reversedOp;\n    opConfig = config.operators[opKey];\n  }\n\n  var widget = (0, _ruleUtils.getWidgetForFieldOp)(config, field, opKey);\n  var convertedArgs = args.map(function (v) {\n    return convertFromLogic(v, conv, config, \"val\", meta, false, fieldConfig, widget, parentField);\n  });\n\n  if (convertedArgs.filter(function (v) {\n    return v === undefined;\n  }).length) {\n    //meta.errors.push(`Undefined arg for field ${field} and op ${opKey}`);\n    return undefined;\n  }\n\n  var res;\n\n  if (fieldConfig.type == \"!group\" && having) {\n    var conj = Object.keys(having)[0];\n    var havingVals = having[conj];\n    var _not = false;\n\n    if (conv.conjunctions[conj] !== undefined) {\n      res = convertConj(conj, havingVals, conv, config, _not, meta, field, true);\n    } else {\n      // need to be wrapped in `rule_group`\n      var rule = convertOp(conj, havingVals, conv, config, _not, meta, field);\n      res = wrapInDefaultConjRuleGroup(rule, field, fieldConfig, config, conv.conjunctions[\"and\"]);\n    }\n\n    res.type = \"rule_group\";\n    Object.assign(res.properties, {\n      field: field,\n      mode: fieldConfig.mode,\n      not: canRev ? false : not,\n      operator: opKey\n    });\n\n    if (fieldConfig.mode == \"array\") {\n      Object.assign(res.properties, {\n        value: convertedArgs.map(function (v) {\n          return v.value;\n        }),\n        valueSrc: convertedArgs.map(function (v) {\n          return v.valueSrc;\n        }),\n        valueType: convertedArgs.map(function (v) {\n          return v.valueType;\n        })\n      });\n    }\n  } else if (fieldConfig.type == \"!group\" && !having) {\n    res = {\n      type: \"rule_group\",\n      id: (0, _uuid[\"default\"])(),\n      children1: {},\n      properties: {\n        conjunction: (0, _defaultUtils.defaultGroupConjunction)(config, fieldConfig),\n        not: canRev ? false : not,\n        mode: fieldConfig.mode,\n        field: field,\n        operator: opKey\n      }\n    };\n\n    if (fieldConfig.mode == \"array\") {\n      Object.assign(res.properties, {\n        value: convertedArgs.map(function (v) {\n          return v.value;\n        }),\n        valueSrc: convertedArgs.map(function (v) {\n          return v.valueSrc;\n        }),\n        valueType: convertedArgs.map(function (v) {\n          return v.valueType;\n        })\n      });\n    }\n  } else {\n    var asyncListValuesArr = convertedArgs.map(function (v) {\n      return v.asyncListValues;\n    }).filter(function (v) {\n      return v != undefined;\n    });\n    var asyncListValues = asyncListValuesArr.length ? asyncListValuesArr[0] : undefined;\n    res = {\n      type: \"rule\",\n      id: (0, _uuid[\"default\"])(),\n      properties: {\n        field: field,\n        operator: opKey,\n        value: convertedArgs.map(function (v) {\n          return v.value;\n        }),\n        valueSrc: convertedArgs.map(function (v) {\n          return v.valueSrc;\n        }),\n        valueType: convertedArgs.map(function (v) {\n          return v.valueType;\n        }),\n        asyncListValues: asyncListValues\n      }\n    };\n  }\n\n  if (not && canRev) {\n    //meta.errors.push(`No rev op for ${opKey}`);\n    res = wrapInDefaultConj(res, config, not);\n  }\n\n  return res;\n};","map":{"version":3,"sources":["D:/LIMSWFH/LIMSPOSTGRESQL/QuaLISWeb/node_modules/react-awesome-query-builder/lib/import/jsonLogic.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","loadFromJsonLogic","_toConsumableArray2","_toArray2","_defineProperty2","_slicedToArray2","_uuid","_stuff","_configUtils","_ruleUtils","_tree","_defaultUtils","_moment","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","arrayUniq","arr","Array","from","Set","arrayToObject","reduce","acc","_ref","_ref2","f","fc","logicTree","config","meta","errors","extendedConfig","extendConfig","conv","buildConv","jsTree","convertFromLogic","undefined","type","wrapInDefaultConj","immTree","loadTree","console","warn","operators","opKey","opConfig","jsonLogic","opk","_jsonLogicIsRevArgs","defaultValue","cardinality","jsonLogic2","_opk","conjunctions","conjKey","ck","toLowerCase","funcs","funcKey","funcConfig","fk","jsonLogicIsMethod","varKeys","settings","groupVarKey","altVarKey","logic","expectedType","not","fieldConfig","widget","parentField","op","vals","isJsonLogic","isArray","ret","beforeErrorsCnt","isEmptyOp","includes","isRev","convertField","convertFunc","convertVal","convertConj","convertOp","afterErrorsCnt","concat","JSON","stringify","val","widgetConfig","widgets","mainWidget","h","Math","floor","m","s","valueFormat","dateVal","Date","setMilliseconds","setHours","setMinutes","setSeconds","format","_dateVal","toISOString","e","_valueFormat","asyncListValues","fieldSettings","asyncFetch","valueSrc","valueType","fieldSeparator","field","join","normalizeField","getFieldConfig","func","argsArr","obj","opts","_vals","slice","funcKeys","k","returnType","v","_i","_Object$entries","entries","_Object$entries$_i","jsonLogicImport","parsed","_e","argKeys","args","ind","argKey","argConfig","argVal","isRuleGroup","parentFieldConfig","isParentGroup","children","map","r","id","complexFields","values","_v$properties","properties","complexFieldsGroupAncestors","fromEntries","parts","split","ancs","fp","_ref3","_ref4","_f","childrenInRuleGroup","_v$properties2","usedRuleGroups","flat","usedTopRuleGroups","topLevelFieldsFilter","conjunction","children1","groupToId","_ref5","_ref6","_v$properties3","groupAncestors","groupField","at","ch","parentFieldParts","isInParent","shallowEqual","traverseGroupFields","_ref7","_ref8","gf","gfc","groupId","mode","fields","sort","a","b","j","indexOf","splice","wrapInDefaultConjRuleGroup","rule","conj","defaultGroupConjunction","defaultConjunction","parseRule","arity","res","_parseRule","isRevArgs","isAllInForMultiselect","isGroup0","groupOperators","opKeys","jlField","rangeOps","_vals2","having","isGroup","_v2","_v3","init","_v4","_v5","group","_filter","op2","parseRes","showNot","canRev","reversedOp","getWidgetForFieldOp","convertedArgs","havingVals","_not","assign","operator","asyncListValuesArr"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.loadFromJsonLogic = void 0;\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _toArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toArray\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _uuid = _interopRequireDefault(require(\"../utils/uuid\"));\n\nvar _stuff = require(\"../utils/stuff\");\n\nvar _configUtils = require(\"../utils/configUtils\");\n\nvar _ruleUtils = require(\"../utils/ruleUtils\");\n\nvar _tree = require(\"./tree\");\n\nvar _defaultUtils = require(\"../utils/defaultUtils\");\n\nvar _moment = _interopRequireDefault(require(\"moment\"));\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2[\"default\"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n// http://jsonlogic.com/\n// helpers\nvar arrayUniq = function arrayUniq(arr) {\n  return Array.from(new Set(arr));\n};\n\nvar arrayToObject = function arrayToObject(arr) {\n  return arr.reduce(function (acc, _ref) {\n    var _ref2 = (0, _slicedToArray2[\"default\"])(_ref, 2),\n        f = _ref2[0],\n        fc = _ref2[1];\n\n    return _objectSpread(_objectSpread({}, acc), {}, (0, _defineProperty2[\"default\"])({}, f, fc));\n  }, {});\n};\n\nvar loadFromJsonLogic = function loadFromJsonLogic(logicTree, config) {\n  //meta is mutable\n  var meta = {\n    errors: []\n  };\n  var extendedConfig = (0, _configUtils.extendConfig)(config);\n  var conv = buildConv(extendedConfig);\n  var jsTree = logicTree ? convertFromLogic(logicTree, conv, extendedConfig, \"rule\", meta) : undefined;\n\n  if (jsTree && jsTree.type != \"group\") {\n    jsTree = wrapInDefaultConj(jsTree, extendedConfig);\n  }\n\n  var immTree = jsTree ? (0, _tree.loadTree)(jsTree) : undefined;\n  if (meta.errors.length) console.warn(\"Errors while importing from JsonLogic:\", meta.errors);\n  return immTree;\n};\n\nexports.loadFromJsonLogic = loadFromJsonLogic;\n\nvar buildConv = function buildConv(config) {\n  var operators = {};\n\n  for (var opKey in config.operators) {\n    var opConfig = config.operators[opKey];\n\n    if (typeof opConfig.jsonLogic == \"string\") {\n      // example: \"</2\", \"#in/1\"\n      var opk = (opConfig._jsonLogicIsRevArgs ? \"#\" : \"\") + opConfig.jsonLogic + \"/\" + (0, _stuff.defaultValue)(opConfig.cardinality, 1);\n      if (!operators[opk]) operators[opk] = [];\n      operators[opk].push(opKey);\n    } else if (typeof opConfig.jsonLogic2 == \"string\") {\n      // example: all-in/1\"\n      var _opk = opConfig.jsonLogic2 + \"/\" + (0, _stuff.defaultValue)(opConfig.cardinality, 1);\n\n      if (!operators[_opk]) operators[_opk] = [];\n\n      operators[_opk].push(opKey);\n    }\n  }\n\n  var conjunctions = {};\n\n  for (var conjKey in config.conjunctions) {\n    var ck = conjKey.toLowerCase();\n    conjunctions[ck] = conjKey;\n  }\n\n  var funcs = {};\n\n  for (var funcKey in config.funcs) {\n    var funcConfig = config.funcs[funcKey];\n    var fk = void 0;\n\n    if (funcConfig.jsonLogicIsMethod) {\n      fk = \"#\" + funcConfig.jsonLogic;\n    } else if (typeof funcConfig.jsonLogic == \"string\") {\n      fk = funcConfig.jsonLogic;\n    }\n\n    if (fk) {\n      if (!funcs[fk]) funcs[fk] = [];\n      funcs[fk].push(funcKey);\n    }\n  }\n\n  return {\n    operators: operators,\n    conjunctions: conjunctions,\n    funcs: funcs,\n    varKeys: [\"var\", config.settings.jsonLogic.groupVarKey, config.settings.jsonLogic.altVarKey]\n  };\n};\n\nvar convertFromLogic = function convertFromLogic(logic, conv, config, expectedType, meta) {\n  var not = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  var fieldConfig = arguments.length > 6 ? arguments[6] : undefined;\n  var widget = arguments.length > 7 ? arguments[7] : undefined;\n  var parentField = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : null;\n  var op, vals;\n\n  if ((0, _stuff.isJsonLogic)(logic)) {\n    op = Object.keys(logic)[0];\n    vals = logic[op];\n    if (!Array.isArray(vals)) vals = [vals];\n  }\n\n  var ret;\n  var beforeErrorsCnt = meta.errors.length;\n  var isEmptyOp = op == \"!\" && vals.length == 1 && vals[0] && (0, _stuff.isJsonLogic)(vals[0]) && conv.varKeys.includes(Object.keys(vals[0])[0]);\n  var isRev = op == \"!\" && !isEmptyOp;\n\n  if (isRev) {\n    // reverse with not\n    ret = convertFromLogic(vals[0], conv, config, expectedType, meta, !not, fieldConfig, widget, parentField);\n  } else if (expectedType == \"val\") {\n    // not is not used here\n    ret = convertField(op, vals, conv, config, not, meta, parentField) || convertFunc(op, vals, conv, config, not, fieldConfig, meta, parentField) || convertVal(logic, fieldConfig, widget, config, meta);\n  } else if (expectedType == \"rule\") {\n    ret = convertConj(op, vals, conv, config, not, meta, parentField, false) || convertOp(op, vals, conv, config, not, meta, parentField);\n  }\n\n  var afterErrorsCnt = meta.errors.length;\n\n  if (op != \"!\" && ret === undefined && afterErrorsCnt == beforeErrorsCnt) {\n    meta.errors.push(\"Can't parse logic \".concat(JSON.stringify(logic)));\n  }\n\n  return ret;\n};\n\nvar convertVal = function convertVal(val, fieldConfig, widget, config, meta) {\n  if (val === undefined) return undefined;\n  var widgetConfig = config.widgets[widget || fieldConfig.mainWidget];\n\n  if (!widgetConfig) {\n    meta.errors.push(\"No widget for type \".concat(fieldConfig.type));\n    return undefined;\n  }\n\n  if ((0, _stuff.isJsonLogic)(val)) {\n    meta.errors.push(\"Unexpected logic in value: \".concat(JSON.stringify(val)));\n    return undefined;\n  } // number of seconds -> time string\n\n\n  if (fieldConfig && fieldConfig.type == \"time\" && typeof val == \"number\") {\n    var h = Math.floor(val / 60 / 60) % 24,\n        m = Math.floor(val / 60) % 60,\n        s = val % 60;\n    var valueFormat = widgetConfig.valueFormat;\n\n    if (valueFormat) {\n      var dateVal = new Date(val);\n      dateVal.setMilliseconds(0);\n      dateVal.setHours(h);\n      dateVal.setMinutes(m);\n      dateVal.setSeconds(s);\n      val = (0, _moment[\"default\"])(dateVal).format(valueFormat);\n    } else {\n      val = \"\".concat(h, \":\").concat(m, \":\").concat(s);\n    }\n  } // \"2020-01-08T22:00:00.000Z\" -> Date object\n\n\n  if (fieldConfig && [\"date\", \"datetime\"].includes(fieldConfig.type) && val && !(val instanceof Date)) {\n    try {\n      var _dateVal = new Date(val);\n\n      if (_dateVal instanceof Date && _dateVal.toISOString() === val) {\n        val = _dateVal;\n      }\n    } catch (e) {\n      meta.errors.push(\"Can't convert value \".concat(val, \" as Date\"));\n      val = undefined;\n    }\n  } // Date object -> formatted string\n\n\n  if (val instanceof Date && fieldConfig) {\n    var _valueFormat = widgetConfig.valueFormat;\n\n    if (_valueFormat) {\n      val = (0, _moment[\"default\"])(val).format(_valueFormat);\n    }\n  }\n\n  var asyncListValues;\n\n  if (val && fieldConfig.fieldSettings && fieldConfig.fieldSettings.asyncFetch) {\n    var vals = Array.isArray(val) ? val : [val];\n    asyncListValues = vals;\n  }\n\n  return {\n    valueSrc: \"value\",\n    value: val,\n    valueType: widgetConfig.type,\n    asyncListValues: asyncListValues\n  };\n};\n\nvar convertField = function convertField(op, vals, conv, config, not, meta) {\n  var parentField = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n  var fieldSeparator = config.settings.fieldSeparator;\n\n  if (conv.varKeys.includes(op) && typeof vals[0] == \"string\") {\n    var field = vals[0];\n    if (parentField) field = [parentField, field].join(fieldSeparator);\n    field = (0, _configUtils.normalizeField)(config, field);\n    var fieldConfig = (0, _configUtils.getFieldConfig)(config, field);\n\n    if (!fieldConfig) {\n      meta.errors.push(\"No config for field \".concat(field));\n      return undefined;\n    }\n\n    return {\n      valueSrc: \"field\",\n      value: field,\n      valueType: fieldConfig.type\n    };\n  }\n\n  return undefined;\n};\n\nvar convertFunc = function convertFunc(op, vals, conv, config, not, fieldConfig, meta) {\n  var parentField = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;\n  if (!op) return undefined;\n  var func, argsArr, funcKey;\n  var jsonLogicIsMethod = op == \"method\";\n\n  if (jsonLogicIsMethod) {\n    var obj, opts;\n\n    var _vals = (0, _toArray2[\"default\"])(vals);\n\n    obj = _vals[0];\n    func = _vals[1];\n    opts = _vals.slice(2);\n    argsArr = [obj].concat((0, _toConsumableArray2[\"default\"])(opts));\n  } else {\n    func = op;\n    argsArr = vals;\n  }\n\n  var fk = (jsonLogicIsMethod ? \"#\" : \"\") + func;\n  var funcKeys = (conv.funcs[fk] || []).filter(function (k) {\n    return fieldConfig ? config.funcs[k].returnType == fieldConfig.type : true;\n  });\n\n  if (funcKeys.length) {\n    funcKey = funcKeys[0];\n  } else {\n    var v = (0, _defineProperty2[\"default\"])({}, op, vals);\n\n    for (var _i = 0, _Object$entries = Object.entries(config.funcs || {}); _i < _Object$entries.length; _i++) {\n      var _Object$entries$_i = (0, _slicedToArray2[\"default\"])(_Object$entries[_i], 2),\n          f = _Object$entries$_i[0],\n          fc = _Object$entries$_i[1];\n\n      if (fc.jsonLogicImport && fc.returnType == fieldConfig.type) {\n        var parsed = void 0;\n\n        try {\n          parsed = fc.jsonLogicImport(v);\n        } catch (_e) {// given expression `v` can't be parsed into function\n        }\n\n        if (parsed) {\n          funcKey = f;\n          argsArr = parsed;\n        }\n      }\n    }\n  }\n\n  if (!funcKey) return undefined;\n\n  if (funcKey) {\n    var funcConfig = config.funcs[funcKey];\n    var argKeys = Object.keys(funcConfig.args || {});\n    var args = argsArr.reduce(function (acc, val, ind) {\n      var argKey = argKeys[ind];\n      var argConfig = funcConfig.args[argKey];\n      var argVal = convertFromLogic(val, conv, config, \"val\", meta, false, argConfig, null, parentField);\n\n      if (argVal === undefined) {\n        argVal = argConfig.defaultValue;\n\n        if (argVal === undefined) {\n          meta.errors.push(\"No value for arg \".concat(argKey, \" of func \").concat(funcKey));\n          return undefined;\n        }\n      }\n\n      return _objectSpread(_objectSpread({}, acc), {}, (0, _defineProperty2[\"default\"])({}, argKey, argVal));\n    }, {});\n    return {\n      valueSrc: \"func\",\n      value: {\n        func: funcKey,\n        args: args\n      },\n      valueType: funcConfig.returnType\n    };\n  }\n\n  return undefined;\n};\n\nvar convertConj = function convertConj(op, vals, conv, config, not, meta) {\n  var parentField = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n  var isRuleGroup = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;\n  var conjKey = conv.conjunctions[op];\n  var fieldSeparator = config.settings.fieldSeparator;\n  var parentFieldConfig = parentField ? (0, _configUtils.getFieldConfig)(config, parentField) : null;\n  var isParentGroup = (parentFieldConfig === null || parentFieldConfig === void 0 ? void 0 : parentFieldConfig.type) == \"!group\";\n\n  if (conjKey) {\n    var type = \"group\";\n    var children = vals.map(function (v) {\n      return convertFromLogic(v, conv, config, \"rule\", meta, false, null, null, parentField);\n    }).filter(function (r) {\n      return r !== undefined;\n    }).reduce(function (acc, r) {\n      return _objectSpread(_objectSpread({}, acc), {}, (0, _defineProperty2[\"default\"])({}, r.id, r));\n    }, {});\n    var complexFields = Object.values(children).map(function (v) {\n      var _v$properties;\n\n      return v === null || v === void 0 ? void 0 : (_v$properties = v.properties) === null || _v$properties === void 0 ? void 0 : _v$properties.field;\n    }).filter(function (f) {\n      return f && f.includes(fieldSeparator);\n    });\n    var complexFieldsGroupAncestors = Object.fromEntries(arrayUniq(complexFields).map(function (f) {\n      var parts = f.split(fieldSeparator);\n      var ancs = Object.fromEntries(parts.slice(0, -1).map(function (f, i, parts) {\n        return [].concat((0, _toConsumableArray2[\"default\"])(parts.slice(0, i)), [f]);\n      }).map(function (fp) {\n        return [fp.join(fieldSeparator), (0, _configUtils.getFieldConfig)(config, fp)];\n      }).filter(function (_ref3) {\n        var _ref4 = (0, _slicedToArray2[\"default\"])(_ref3, 2),\n            _f = _ref4[0],\n            fc = _ref4[1];\n\n        return fc.type == \"!group\";\n      }));\n      return [f, Object.keys(ancs)];\n    }));\n    var childrenInRuleGroup = Object.values(children).map(function (v) {\n      var _v$properties2;\n\n      return v === null || v === void 0 ? void 0 : (_v$properties2 = v.properties) === null || _v$properties2 === void 0 ? void 0 : _v$properties2.field;\n    }).map(function (f) {\n      return complexFieldsGroupAncestors[f];\n    }).filter(function (ancs) {\n      return ancs && ancs.length;\n    });\n    var usedRuleGroups = arrayUniq(Object.values(complexFieldsGroupAncestors).flat());\n    var usedTopRuleGroups = topLevelFieldsFilter(usedRuleGroups);\n    var properties = {\n      conjunction: conjKey,\n      not: not\n    };\n    var id = (0, _uuid[\"default\"])();\n    var children1 = {};\n    var groupToId = {};\n    Object.entries(children).map(function (_ref5) {\n      var _ref6 = (0, _slicedToArray2[\"default\"])(_ref5, 2),\n          k = _ref6[0],\n          v = _ref6[1];\n\n      if (v.type == \"group\" || v.type == \"rule_group\") {\n        // put as-is\n        children1[k] = v;\n      } else {\n        var _v$properties3;\n\n        var field = v === null || v === void 0 ? void 0 : (_v$properties3 = v.properties) === null || _v$properties3 === void 0 ? void 0 : _v$properties3.field;\n        var groupAncestors = complexFieldsGroupAncestors[field];\n        var groupField = groupAncestors === null || groupAncestors === void 0 ? void 0 : groupAncestors.at(-1);\n\n        if (!groupField) {\n          // not in rule_group (can be simple field or in struct) - put as-is\n          children1[k] = v;\n        } else {\n          // wrap field in rule_group (with creating hierarchy if need)\n          var ch = children1;\n          var parentFieldParts = parentField ? parentField.split(fieldSeparator) : [];\n          var isInParent = (0, _stuff.shallowEqual)(parentFieldParts, groupField.split(fieldSeparator).slice(0, parentFieldParts.length));\n          if (!isInParent) parentFieldParts = []; // should not be\n\n          var traverseGroupFields = groupField.split(fieldSeparator).slice(parentFieldParts.length).map(function (f, i, parts) {\n            return [].concat((0, _toConsumableArray2[\"default\"])(parentFieldParts), (0, _toConsumableArray2[\"default\"])(parts.slice(0, i)), [f]).join(fieldSeparator);\n          }).map(function (f) {\n            return (0, _configUtils.normalizeField)(config, f);\n          }).map(function (f) {\n            return {\n              f: f,\n              fc: (0, _configUtils.getFieldConfig)(config, f) || {}\n            };\n          }).filter(function (_ref7) {\n            var fc = _ref7.fc;\n            return fc.type != \"!struct\";\n          });\n          traverseGroupFields.map(function (_ref8, i) {\n            var gf = _ref8.f,\n                gfc = _ref8.fc;\n            var groupId = groupToId[gf];\n\n            if (!groupId) {\n              groupId = (0, _uuid[\"default\"])();\n              groupToId[gf] = groupId;\n              ch[groupId] = {\n                type: \"rule_group\",\n                id: groupId,\n                children1: {},\n                properties: {\n                  conjunction: conjKey,\n                  not: false,\n                  field: gf,\n                  mode: gfc.mode\n                }\n              };\n            }\n\n            ch = ch[groupId].children1;\n          });\n          ch[k] = v;\n        }\n      }\n    }); // tip: for isRuleGroup=true correct type and properties will be set out of this func\n\n    return {\n      type: type,\n      id: id,\n      children1: children1,\n      properties: properties\n    };\n  }\n\n  return undefined;\n};\n\nvar topLevelFieldsFilter = function topLevelFieldsFilter(fields) {\n  var arr = (0, _toConsumableArray2[\"default\"])(fields).sort(function (a, b) {\n    return a.length - b.length;\n  });\n\n  for (var i = 0; i < arr.length; i++) {\n    for (var j = i + 1; j < arr.length; j++) {\n      if (arr[j].indexOf(arr[i]) == 0) {\n        // arr[j] is inside arr[i] (eg. \"a.b\" inside \"a\")\n        arr.splice(j, 1);\n        j--;\n      }\n    }\n  }\n\n  return arr;\n};\n\nvar wrapInDefaultConjRuleGroup = function wrapInDefaultConjRuleGroup(rule, parentField, parentFieldConfig, config, conj) {\n  if (!rule) return undefined;\n  return {\n    type: \"rule_group\",\n    id: (0, _uuid[\"default\"])(),\n    children1: (0, _defineProperty2[\"default\"])({}, rule.id, rule),\n    properties: {\n      conjunction: conj || (0, _defaultUtils.defaultGroupConjunction)(config, parentFieldConfig),\n      not: false,\n      field: parentField\n    }\n  };\n};\n\nvar wrapInDefaultConj = function wrapInDefaultConj(rule, config) {\n  var not = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  return {\n    type: \"group\",\n    id: (0, _uuid[\"default\"])(),\n    children1: (0, _defineProperty2[\"default\"])({}, rule.id, rule),\n    properties: {\n      conjunction: (0, _defaultUtils.defaultConjunction)(config),\n      not: not\n    }\n  };\n};\n\nvar parseRule = function parseRule(op, arity, vals, parentField, conv, config, meta) {\n  var errors = [];\n\n  var res = _parseRule(op, arity, vals, parentField, conv, config, errors, false) || _parseRule(op, arity, vals, parentField, conv, config, errors, true);\n\n  if (!res) {\n    meta.errors.push(errors.join(\"; \") || \"Unknown op \".concat(op, \"/\").concat(arity));\n    return undefined;\n  }\n\n  return res;\n};\n\nvar _parseRule = function _parseRule(op, arity, vals, parentField, conv, config, errors, isRevArgs) {\n  // config.settings.groupOperators are used for group count (cardinality = 0 is exception)\n  // but don't confuse with \"all-in\" for multiselect\n  var isAllInForMultiselect = op == \"all\" && (0, _stuff.isJsonLogic)(vals[1]) && Object.keys(vals[1])[0] == \"in\";\n  var isGroup0 = !isAllInForMultiselect && config.settings.groupOperators.includes(op);\n  var cardinality = isGroup0 ? 0 : arity - 1;\n  var opk = op + \"/\" + cardinality;\n  var fieldSeparator = config.settings.fieldSeparator;\n  var opKeys = conv.operators[(isRevArgs ? \"#\" : \"\") + opk];\n\n  if (opKeys) {\n    var jlField,\n        args = [];\n    var rangeOps = [\"<\", \"<=\", \">\", \">=\"];\n\n    if (rangeOps.includes(op) && arity == 3) {\n      jlField = vals[1];\n      args = [vals[0], vals[2]];\n    } else if (isRevArgs) {\n      jlField = vals[1];\n      args = [vals[0]];\n    } else {\n      var _vals2 = (0, _toArray2[\"default\"])(vals);\n\n      jlField = _vals2[0];\n      args = _vals2.slice(1);\n    }\n\n    if (!(0, _stuff.isJsonLogic)(jlField)) {\n      errors.push(\"Incorrect operands for \".concat(op, \": \").concat(JSON.stringify(vals)));\n      return;\n    }\n\n    var k = Object.keys(jlField)[0];\n    var v = Object.values(jlField)[0];\n    var field, having, isGroup;\n\n    if (conv.varKeys.includes(k) && typeof v == \"string\") {\n      field = v;\n    }\n\n    if (isGroup0) {\n      isGroup = true;\n      having = args[0];\n      args = [];\n    } // reduce/filter for group ext\n\n\n    if (k == \"reduce\" && Array.isArray(v) && v.length == 3) {\n      var _v2 = v,\n          _v3 = (0, _slicedToArray2[\"default\"])(_v2, 3),\n          filter = _v3[0],\n          acc = _v3[1],\n          init = _v3[2];\n\n      if ((0, _stuff.isJsonLogic)(filter) && init == 0 && (0, _stuff.isJsonLogic)(acc) && Array.isArray(acc[\"+\"]) && acc[\"+\"][0] == 1 && (0, _stuff.isJsonLogic)(acc[\"+\"][1]) && acc[\"+\"][1][\"var\"] == \"accumulator\") {\n        k = Object.keys(filter)[0];\n        v = Object.values(filter)[0];\n\n        if (k == \"filter\") {\n          var _v4 = v,\n              _v5 = (0, _slicedToArray2[\"default\"])(_v4, 2),\n              group = _v5[0],\n              _filter = _v5[1];\n\n          if ((0, _stuff.isJsonLogic)(group)) {\n            k = Object.keys(group)[0];\n            v = Object.values(group)[0];\n\n            if (conv.varKeys.includes(k) && typeof v == \"string\") {\n              field = v;\n              having = _filter;\n              isGroup = true;\n            }\n          }\n        } else if (conv.varKeys.includes(k) && typeof v == \"string\") {\n          field = v;\n          isGroup = true;\n        }\n      }\n    }\n\n    if (!field) {\n      errors.push(\"Unknown field \".concat(JSON.stringify(jlField)));\n      return;\n    }\n\n    if (parentField) field = [parentField, field].join(fieldSeparator);\n    field = (0, _configUtils.normalizeField)(config, field);\n    var fieldConfig = (0, _configUtils.getFieldConfig)(config, field);\n\n    if (!fieldConfig) {\n      errors.push(\"No config for field \".concat(field));\n      return;\n    }\n\n    var opKey = opKeys[0];\n\n    if (opKeys.length > 1 && fieldConfig && fieldConfig.operators) {\n      // eg. for \"equal\" and \"select_equals\"\n      opKeys = opKeys.filter(function (k) {\n        return fieldConfig.operators.includes(k);\n      });\n\n      if (opKeys.length == 0) {\n        errors.push(\"No corresponding ops for field \".concat(field));\n        return;\n      }\n\n      opKey = opKeys[0];\n    }\n\n    return {\n      field: field,\n      fieldConfig: fieldConfig,\n      opKey: opKey,\n      args: args,\n      having: having\n    };\n  }\n};\n\nvar convertOp = function convertOp(op, vals, conv, config, not, meta) {\n  var parentField = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n  if (!op) return undefined;\n  var arity = vals.length;\n\n  if (op == \"all\" && (0, _stuff.isJsonLogic)(vals[1])) {\n    // special case for \"all-in\"\n    var op2 = Object.keys(vals[1])[0];\n\n    if (op2 == \"in\") {\n      vals = [vals[0], vals[1][op2][1]];\n      op = op + \"-\" + op2; // \"all-in\"\n    }\n  }\n\n  var parseRes = parseRule(op, arity, vals, parentField, conv, config, meta);\n  if (!parseRes) return undefined;\n  var field = parseRes.field,\n      fieldConfig = parseRes.fieldConfig,\n      opKey = parseRes.opKey,\n      args = parseRes.args,\n      having = parseRes.having;\n  var opConfig = config.operators[opKey]; // Group component in array mode can show NOT checkbox, so do nothing in this case\n  // Otherwise try to revert\n\n  var showNot = fieldConfig.showNot !== undefined ? fieldConfig.showNot : config.settings.showNot;\n  var canRev = true;\n  if (fieldConfig.type == \"!group\" && fieldConfig.mode == \"array\" && showNot) canRev = false; // Fix \"some ! in\"\n\n  if (fieldConfig.type == \"!group\" && having && Object.keys(having)[0] == \"!\") {\n    not = !not;\n    having = having[\"!\"];\n  } // Use reversed op\n\n\n  if (not && canRev && opConfig.reversedOp) {\n    not = false;\n    opKey = opConfig.reversedOp;\n    opConfig = config.operators[opKey];\n  }\n\n  var widget = (0, _ruleUtils.getWidgetForFieldOp)(config, field, opKey);\n  var convertedArgs = args.map(function (v) {\n    return convertFromLogic(v, conv, config, \"val\", meta, false, fieldConfig, widget, parentField);\n  });\n\n  if (convertedArgs.filter(function (v) {\n    return v === undefined;\n  }).length) {\n    //meta.errors.push(`Undefined arg for field ${field} and op ${opKey}`);\n    return undefined;\n  }\n\n  var res;\n\n  if (fieldConfig.type == \"!group\" && having) {\n    var conj = Object.keys(having)[0];\n    var havingVals = having[conj];\n    var _not = false;\n\n    if (conv.conjunctions[conj] !== undefined) {\n      res = convertConj(conj, havingVals, conv, config, _not, meta, field, true);\n    } else {\n      // need to be wrapped in `rule_group`\n      var rule = convertOp(conj, havingVals, conv, config, _not, meta, field);\n      res = wrapInDefaultConjRuleGroup(rule, field, fieldConfig, config, conv.conjunctions[\"and\"]);\n    }\n\n    res.type = \"rule_group\";\n    Object.assign(res.properties, {\n      field: field,\n      mode: fieldConfig.mode,\n      not: canRev ? false : not,\n      operator: opKey\n    });\n\n    if (fieldConfig.mode == \"array\") {\n      Object.assign(res.properties, {\n        value: convertedArgs.map(function (v) {\n          return v.value;\n        }),\n        valueSrc: convertedArgs.map(function (v) {\n          return v.valueSrc;\n        }),\n        valueType: convertedArgs.map(function (v) {\n          return v.valueType;\n        })\n      });\n    }\n  } else if (fieldConfig.type == \"!group\" && !having) {\n    res = {\n      type: \"rule_group\",\n      id: (0, _uuid[\"default\"])(),\n      children1: {},\n      properties: {\n        conjunction: (0, _defaultUtils.defaultGroupConjunction)(config, fieldConfig),\n        not: canRev ? false : not,\n        mode: fieldConfig.mode,\n        field: field,\n        operator: opKey\n      }\n    };\n\n    if (fieldConfig.mode == \"array\") {\n      Object.assign(res.properties, {\n        value: convertedArgs.map(function (v) {\n          return v.value;\n        }),\n        valueSrc: convertedArgs.map(function (v) {\n          return v.valueSrc;\n        }),\n        valueType: convertedArgs.map(function (v) {\n          return v.valueType;\n        })\n      });\n    }\n  } else {\n    var asyncListValuesArr = convertedArgs.map(function (v) {\n      return v.asyncListValues;\n    }).filter(function (v) {\n      return v != undefined;\n    });\n    var asyncListValues = asyncListValuesArr.length ? asyncListValuesArr[0] : undefined;\n    res = {\n      type: \"rule\",\n      id: (0, _uuid[\"default\"])(),\n      properties: {\n        field: field,\n        operator: opKey,\n        value: convertedArgs.map(function (v) {\n          return v.value;\n        }),\n        valueSrc: convertedArgs.map(function (v) {\n          return v.valueSrc;\n        }),\n        valueType: convertedArgs.map(function (v) {\n          return v.valueType;\n        }),\n        asyncListValues: asyncListValues\n      }\n    };\n  }\n\n  if (not && canRev) {\n    //meta.errors.push(`No rev op for ${opKey}`);\n    res = wrapInDefaultConj(res, config, not);\n  }\n\n  return res;\n};"]},"metadata":{},"sourceType":"script"}