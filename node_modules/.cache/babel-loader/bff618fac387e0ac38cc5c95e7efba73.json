{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.mongodbFormat = exports._mongodbFormat = void 0;\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nvar _stuff = require(\"../utils/stuff\");\n\nvar _configUtils = require(\"../utils/configUtils\");\n\nvar _ruleUtils = require(\"../utils/ruleUtils\");\n\nvar _defaultUtils = require(\"../utils/defaultUtils\");\n\nvar _funcUtils = require(\"../utils/funcUtils\");\n\nvar _omit = _interopRequireDefault(require(\"lodash/omit\"));\n\nvar _pick = _interopRequireDefault(require(\"lodash/pick\"));\n\nvar _immutable = require(\"immutable\");\n\nvar _default = require(\"../config/default\");\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      (0, _defineProperty2[\"default\"])(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n} // helpers\n\n\nvar isObject = function isObject(v) {\n  return (0, _typeof2[\"default\"])(v) == \"object\" && v !== null && !Array.isArray(v);\n};\n\nvar mongodbFormat = function mongodbFormat(tree, config) {\n  return _mongodbFormat(tree, config, false);\n};\n\nexports.mongodbFormat = mongodbFormat;\n\nvar _mongodbFormat = function _mongodbFormat(tree, config) {\n  var returnErrors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true; //meta is mutable\n\n  var meta = {\n    errors: []\n  };\n  var res = formatItem([], tree, config, meta);\n\n  if (returnErrors) {\n    return [res, meta.errors];\n  } else {\n    if (meta.errors.length) console.warn(\"Errors while exporting to MongoDb:\", meta.errors);\n    return res;\n  }\n};\n\nexports._mongodbFormat = _mongodbFormat;\n\nvar formatItem = function formatItem(parents, item, config, meta) {\n  var _not = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n  var _canWrapExpr = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n\n  var _fieldName = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : undefined;\n\n  var _value = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : undefined;\n\n  if (!item) return undefined;\n  var type = item.get(\"type\");\n\n  if (type === \"group\" || type === \"rule_group\") {\n    return formatGroup(parents, item, config, meta, _not, _canWrapExpr, _fieldName, _value);\n  } else if (type === \"rule\") {\n    return formatRule(parents, item, config, meta, _not, _canWrapExpr, _fieldName, _value);\n  }\n\n  return undefined;\n};\n\nvar formatGroup = function formatGroup(parents, item, config, meta) {\n  var _not = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n  var _canWrapExpr = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n\n  var _fieldName = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : undefined;\n\n  var _value = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : undefined;\n\n  var type = item.get(\"type\");\n  var properties = item.get(\"properties\") || new _immutable.Map();\n  var children = item.get(\"children1\");\n  var canShortMongoQuery = config.settings.canShortMongoQuery;\n  if (!children) return undefined;\n  var hasParentRuleGroup = parents.filter(function (it) {\n    return it.get(\"type\") == \"rule_group\";\n  }).length > 0;\n  var parentPath = parents.filter(function (it) {\n    return it.get(\"type\") == \"rule_group\";\n  }).map(function (it) {\n    return it.get(\"properties\").get(\"field\");\n  }).slice(-1).pop();\n  var realParentPath = hasParentRuleGroup && parentPath;\n  var groupField = type === \"rule_group\" ? properties.get(\"field\") : null;\n  var groupFieldName = formatFieldName(groupField, config, meta, realParentPath);\n  var groupFieldDef = (0, _configUtils.getFieldConfig)(config, groupField) || {};\n  var mode = groupFieldDef.mode; //properties.get(\"mode\");\n\n  var canHaveEmptyChildren = groupField && mode == \"array\";\n  var not = _not ? !properties.get(\"not\") : properties.get(\"not\");\n  var list = children.map(function (currentChild) {\n    return formatItem([].concat((0, _toConsumableArray2[\"default\"])(parents), [item]), currentChild, config, meta, not, true, mode == \"array\" ? function (f) {\n      return \"$$el.\".concat(f);\n    } : undefined);\n  }).filter(function (currentChild) {\n    return typeof currentChild !== \"undefined\";\n  });\n  if (!canHaveEmptyChildren && !list.size) return undefined;\n  var conjunction = properties.get(\"conjunction\");\n  if (!conjunction) conjunction = (0, _defaultUtils.defaultConjunction)(config);\n  var conjunctionDefinition = config.conjunctions[conjunction];\n  var reversedConj = conjunctionDefinition.reversedConj;\n\n  if (not && reversedConj) {\n    conjunction = reversedConj;\n    conjunctionDefinition = config.conjunctions[conjunction];\n  }\n\n  var mongoConj = conjunctionDefinition.mongoConj;\n  var resultQuery;\n\n  if (list.size == 1) {\n    resultQuery = list.first();\n  } else if (list.size > 1) {\n    var rules = list.toList().toJS();\n    var canShort = canShortMongoQuery && mongoConj == \"$and\";\n\n    if (canShort) {\n      resultQuery = rules.reduce(function (acc, rule) {\n        if (!acc) return undefined;\n\n        for (var k in rule) {\n          if (k[0] == \"$\") {\n            acc = undefined;\n            break;\n          }\n\n          if (acc[k] == undefined) {\n            acc[k] = rule[k];\n          } else {\n            // https://github.com/ukrbublik/react-awesome-query-builder/issues/182\n            var prev = acc[k],\n                next = rule[k];\n\n            if (!isObject(prev)) {\n              prev = {\n                \"$eq\": prev\n              };\n            }\n\n            if (!isObject(next)) {\n              next = {\n                \"$eq\": next\n              };\n            }\n\n            var prevOp = Object.keys(prev)[0],\n                nextOp = Object.keys(next)[0];\n\n            if (prevOp == nextOp) {\n              acc = undefined;\n              break;\n            }\n\n            acc[k] = Object.assign({}, prev, next);\n          }\n        }\n\n        return acc;\n      }, {});\n    }\n\n    if (!resultQuery) // can't be shorten\n      resultQuery = (0, _defineProperty2[\"default\"])({}, mongoConj, rules);\n  }\n\n  if (groupField) {\n    if (mode == \"array\") {\n      var totalQuery = {\n        \"$size\": groupFieldName\n      };\n      var filterQuery = resultQuery ? {\n        \"$size\": {\n          \"$filter\": {\n            input: \"$\" + groupFieldName,\n            as: \"el\",\n            cond: resultQuery\n          }\n        }\n      } : totalQuery;\n      resultQuery = formatItem(parents, item.set(\"type\", \"rule\"), config, meta, false, false, function (_f) {\n        return filterQuery;\n      }, totalQuery);\n      resultQuery = {\n        \"$expr\": resultQuery\n      };\n    } else {\n      resultQuery = (0, _defineProperty2[\"default\"])({}, groupFieldName, {\n        \"$elemMatch\": resultQuery\n      });\n    }\n  }\n\n  return resultQuery;\n};\n\nvar formatRule = function formatRule(parents, item, config, meta) {\n  var _not = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n  var _canWrapExpr = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n\n  var _fieldName = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : undefined;\n\n  var _value = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : undefined;\n\n  var properties = item.get(\"properties\") || new _immutable.Map();\n  var hasParentRuleGroup = parents.filter(function (it) {\n    return it.get(\"type\") == \"rule_group\";\n  }).length > 0;\n  var parentPath = parents.filter(function (it) {\n    return it.get(\"type\") == \"rule_group\";\n  }).map(function (it) {\n    return it.get(\"properties\").get(\"field\");\n  }).slice(-1).pop();\n  var realParentPath = hasParentRuleGroup && parentPath;\n  var operator = properties.get(\"operator\");\n  var operatorOptions = properties.get(\"operatorOptions\");\n  var field = properties.get(\"field\");\n  var iValue = properties.get(\"value\");\n  var iValueSrc = properties.get(\"valueSrc\");\n  var iValueType = properties.get(\"valueType\");\n  var asyncListValues = properties.get(\"asyncListValues\");\n  if (field == null || operator == null || iValue === undefined) return undefined;\n  var fieldDef = (0, _configUtils.getFieldConfig)(config, field) || {};\n  var operatorDefinition = (0, _configUtils.getOperatorConfig)(config, operator, field) || {};\n  var reversedOp = operatorDefinition.reversedOp;\n  var revOperatorDefinition = (0, _configUtils.getOperatorConfig)(config, reversedOp, field) || {};\n  var cardinality = (0, _stuff.defaultValue)(operatorDefinition.cardinality, 1);\n  var not = _not;\n\n  if (not && reversedOp) {\n    var _ref = [reversedOp, operator];\n    operator = _ref[0];\n    reversedOp = _ref[1];\n    var _ref2 = [revOperatorDefinition, operatorDefinition];\n    operatorDefinition = _ref2[0];\n    revOperatorDefinition = _ref2[1];\n    not = false;\n  }\n\n  var fieldName = formatFieldName(field, config, meta, realParentPath); //format value\n\n  var valueSrcs = [];\n  var valueTypes = [];\n  var useExpr = false;\n  var fvalue = iValue.map(function (currentValue, ind) {\n    var valueSrc = iValueSrc ? iValueSrc.get(ind) : null;\n    var valueType = iValueType ? iValueType.get(ind) : null;\n    var cValue = (0, _funcUtils.completeValue)(currentValue, valueSrc, config);\n    var widget = (0, _ruleUtils.getWidgetForFieldOp)(config, field, operator, valueSrc);\n    var fieldWidgetDef = (0, _omit[\"default\"])((0, _configUtils.getFieldWidgetConfig)(config, field, operator, widget, valueSrc), [\"factory\"]);\n\n    var _formatValue = formatValue(meta, config, cValue, valueSrc, valueType, fieldWidgetDef, fieldDef, realParentPath, operator, operatorDefinition, asyncListValues),\n        _formatValue2 = (0, _slicedToArray2[\"default\"])(_formatValue, 2),\n        fv = _formatValue2[0],\n        fvUseExpr = _formatValue2[1];\n\n    if (fv !== undefined) {\n      useExpr = useExpr || fvUseExpr;\n      valueSrcs.push(valueSrc);\n      valueTypes.push(valueType);\n    }\n\n    return fv;\n  });\n  if (_fieldName) useExpr = true;\n  var wrapExpr = useExpr && _canWrapExpr;\n  var hasUndefinedValues = fvalue.filter(function (v) {\n    return v === undefined;\n  }).size > 0;\n  if (fvalue.size < cardinality || hasUndefinedValues) return undefined;\n  var formattedValue = cardinality > 1 ? fvalue.toArray() : cardinality == 1 ? fvalue.first() : null; //build rule\n\n  var fn = operatorDefinition.mongoFormatOp;\n\n  if (!fn) {\n    meta.errors.push(\"Operator \".concat(operator, \" is not supported\"));\n    return undefined;\n  }\n\n  var args = [_fieldName ? _fieldName(fieldName) : fieldName, operator, _value !== undefined && formattedValue == null ? _value : formattedValue, useExpr, valueSrcs.length > 1 ? valueSrcs : valueSrcs[0], valueTypes.length > 1 ? valueTypes : valueTypes[0], (0, _omit[\"default\"])(operatorDefinition, [\"formatOp\", \"mongoFormatOp\", \"sqlFormatOp\", \"jsonLogic\", \"spelFormatOp\"]), operatorOptions, fieldDef];\n  var ruleQuery = fn.apply(void 0, args);\n\n  if (wrapExpr) {\n    ruleQuery = {\n      \"$expr\": ruleQuery\n    };\n  }\n\n  if (not) {\n    ruleQuery = {\n      \"$not\": ruleQuery\n    };\n  }\n\n  return ruleQuery;\n};\n\nvar formatValue = function formatValue(meta, config, currentValue, valueSrc, valueType, fieldWidgetDef, fieldDef, parentPath, operator, operatorDef, asyncListValues) {\n  if (currentValue === undefined) return [undefined, false];\n  var ret;\n  var useExpr = false;\n\n  if (valueSrc == \"field\") {\n    var _formatRightField = formatRightField(meta, config, currentValue, parentPath);\n\n    var _formatRightField2 = (0, _slicedToArray2[\"default\"])(_formatRightField, 2);\n\n    ret = _formatRightField2[0];\n    useExpr = _formatRightField2[1];\n  } else if (valueSrc == \"func\") {\n    var _formatFunc = formatFunc(meta, config, currentValue, parentPath);\n\n    var _formatFunc2 = (0, _slicedToArray2[\"default\"])(_formatFunc, 2);\n\n    ret = _formatFunc2[0];\n    useExpr = _formatFunc2[1];\n  } else {\n    if (typeof fieldWidgetDef.mongoFormatValue === \"function\") {\n      var fn = fieldWidgetDef.mongoFormatValue;\n      var args = [currentValue, _objectSpread(_objectSpread({}, (0, _pick[\"default\"])(fieldDef, [\"fieldSettings\", \"listValues\"])), {}, {\n        asyncListValues: asyncListValues\n      }), //useful options: valueFormat for date/time\n      (0, _omit[\"default\"])(fieldWidgetDef, [\"formatValue\", \"mongoFormatValue\", \"sqlFormatValue\", \"jsonLogic\", \"elasticSearchFormatValue\", \"spelFormatValue\"])];\n\n      if (operator) {\n        args.push(operator);\n        args.push(operatorDef);\n      }\n\n      ret = fn.apply(void 0, args);\n    } else {\n      ret = currentValue;\n    }\n  }\n\n  return [ret, useExpr];\n};\n\nvar formatFieldName = function formatFieldName(field, config, meta, parentPath) {\n  if (!field) return;\n  var fieldDef = (0, _configUtils.getFieldConfig)(config, field) || {};\n  var fieldSeparator = config.settings.fieldSeparator;\n  var fieldParts = Array.isArray(field) ? field : field.split(fieldSeparator);\n  var fieldName = Array.isArray(field) ? field.join(fieldSeparator) : field; // if (fieldDef.tableName) { // legacy\n  //     const fieldPartsCopy = [...fieldParts];\n  //     fieldPartsCopy[0] = fieldDef.tableName;\n  //     fieldName = fieldPartsCopy.join(fieldSeparator);\n  // }\n\n  if (fieldDef.fieldName) {\n    fieldName = fieldDef.fieldName;\n  }\n\n  if (parentPath) {\n    var parentFieldDef = (0, _configUtils.getFieldConfig)(config, parentPath) || {};\n    var parentFieldName = parentPath;\n\n    if (parentFieldDef.fieldName) {\n      parentFieldName = parentFieldDef.fieldName;\n    }\n\n    if (fieldName.indexOf(parentFieldName + \".\") == 0) {\n      fieldName = fieldName.slice((parentFieldName + \".\").length);\n    } else {\n      meta.errors.push(\"Can't cut group \".concat(parentFieldName, \" from field \").concat(fieldName));\n    }\n  }\n\n  return fieldName;\n};\n\nvar formatRightField = function formatRightField(meta, config, rightField, parentPath) {\n  var fieldSeparator = config.settings.fieldSeparator;\n  var ret;\n  var useExpr = true;\n\n  if (rightField) {\n    var rightFieldDefinition = (0, _configUtils.getFieldConfig)(config, rightField) || {};\n    var fieldParts = Array.isArray(rightField) ? rightField : rightField.split(fieldSeparator);\n\n    var _fieldKeys = (0, _ruleUtils.getFieldPath)(rightField, config);\n\n    var fieldPartsLabels = (0, _ruleUtils.getFieldPathLabels)(rightField, config);\n    var fieldFullLabel = fieldPartsLabels ? fieldPartsLabels.join(fieldSeparator) : null;\n    var formatFieldFn = config.settings.formatField || _default.settings.formatField;\n    var rightFieldName = formatFieldName(rightField, config, meta, parentPath);\n    var formattedField = formatFieldFn(rightFieldName, fieldParts, fieldFullLabel, rightFieldDefinition, config, false);\n    ret = \"$\" + formattedField;\n  }\n\n  return [ret, useExpr];\n};\n\nvar formatFunc = function formatFunc(meta, config, currentValue, parentPath) {\n  var useExpr = true;\n  var ret;\n  var funcKey = currentValue.get(\"func\");\n  var args = currentValue.get(\"args\");\n  var funcConfig = (0, _configUtils.getFuncConfig)(config, funcKey);\n  var funcName = funcConfig.mongoFunc || funcKey;\n  var mongoArgsAsObject = funcConfig.mongoArgsAsObject;\n  var formattedArgs = {};\n  var argsCnt = 0;\n  var lastArg = undefined;\n\n  for (var argKey in funcConfig.args) {\n    var argConfig = funcConfig.args[argKey];\n    var fieldDef = (0, _configUtils.getFieldConfig)(config, argConfig);\n    var argVal = args ? args.get(argKey) : undefined;\n    var argValue = argVal ? argVal.get(\"value\") : undefined;\n    var argValueSrc = argVal ? argVal.get(\"valueSrc\") : undefined;\n    var argAsyncListValues = argVal ? argVal.get(\"asyncListValues\") : undefined;\n    var widget = (0, _ruleUtils.getWidgetForFieldOp)(config, fieldDef, null, argValueSrc);\n    var fieldWidgetDef = (0, _omit[\"default\"])((0, _configUtils.getFieldWidgetConfig)(config, fieldDef, null, widget, argValueSrc), [\"factory\"]);\n\n    var _formatValue3 = formatValue(meta, config, argValue, argValueSrc, argConfig.type, fieldWidgetDef, fieldDef, parentPath, null, null, argAsyncListValues),\n        _formatValue4 = (0, _slicedToArray2[\"default\"])(_formatValue3, 2),\n        formattedArgVal = _formatValue4[0],\n        _argUseExpr = _formatValue4[1];\n\n    if (argValue != undefined && formattedArgVal === undefined) {\n      meta.errors.push(\"Can't format value of arg \".concat(argKey, \" for func \").concat(funcKey));\n      return [undefined, false];\n    }\n\n    argsCnt++;\n\n    if (formattedArgVal !== undefined) {\n      // skip optional in the end\n      formattedArgs[argKey] = formattedArgVal;\n      lastArg = formattedArgVal;\n    }\n  }\n\n  if (typeof funcConfig.mongoFormatFunc === \"function\") {\n    var fn = funcConfig.mongoFormatFunc;\n    var _args = [formattedArgs];\n    ret = fn.apply(void 0, _args);\n  } else if (funcConfig.mongoFormatFunc === null) {\n    meta.errors.push(\"Functon \".concat(funcName, \" is not supported\"));\n    return [undefined, false];\n  } else {\n    if (mongoArgsAsObject) ret = (0, _defineProperty2[\"default\"])({}, funcName, formattedArgs);else if (argsCnt == 1 && lastArg !== undefined) ret = (0, _defineProperty2[\"default\"])({}, funcName, lastArg);else ret = (0, _defineProperty2[\"default\"])({}, funcName, Object.values(formattedArgs));\n  }\n\n  return [ret, useExpr];\n};","map":{"version":3,"sources":["D:/LIMSWFH/LIMSPOSTGRESQL/QuaLISWeb/node_modules/react-awesome-query-builder/lib/export/mongoDb.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","mongodbFormat","_mongodbFormat","_slicedToArray2","_defineProperty2","_toConsumableArray2","_typeof2","_stuff","_configUtils","_ruleUtils","_defaultUtils","_funcUtils","_omit","_pick","_immutable","_default","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","isObject","v","Array","isArray","tree","config","returnErrors","undefined","meta","errors","res","formatItem","console","warn","parents","item","_not","_canWrapExpr","_fieldName","_value","type","get","formatGroup","formatRule","properties","Map","children","canShortMongoQuery","settings","hasParentRuleGroup","it","parentPath","map","slice","pop","realParentPath","groupField","groupFieldName","formatFieldName","groupFieldDef","getFieldConfig","mode","canHaveEmptyChildren","not","list","currentChild","concat","f","size","conjunction","defaultConjunction","conjunctionDefinition","conjunctions","reversedConj","mongoConj","resultQuery","first","rules","toList","toJS","canShort","reduce","acc","rule","k","prev","next","prevOp","nextOp","assign","totalQuery","filterQuery","input","as","cond","set","_f","operator","operatorOptions","field","iValue","iValueSrc","iValueType","asyncListValues","fieldDef","operatorDefinition","getOperatorConfig","reversedOp","revOperatorDefinition","cardinality","defaultValue","_ref","_ref2","fieldName","valueSrcs","valueTypes","useExpr","fvalue","currentValue","ind","valueSrc","valueType","cValue","completeValue","widget","getWidgetForFieldOp","fieldWidgetDef","getFieldWidgetConfig","_formatValue","formatValue","_formatValue2","fv","fvUseExpr","wrapExpr","hasUndefinedValues","formattedValue","toArray","fn","mongoFormatOp","args","ruleQuery","operatorDef","ret","_formatRightField","formatRightField","_formatRightField2","_formatFunc","formatFunc","_formatFunc2","mongoFormatValue","fieldSeparator","fieldParts","split","join","parentFieldDef","parentFieldName","indexOf","rightField","rightFieldDefinition","_fieldKeys","getFieldPath","fieldPartsLabels","getFieldPathLabels","fieldFullLabel","formatFieldFn","formatField","rightFieldName","formattedField","funcKey","funcConfig","getFuncConfig","funcName","mongoFunc","mongoArgsAsObject","formattedArgs","argsCnt","lastArg","argKey","argConfig","argVal","argValue","argValueSrc","argAsyncListValues","_formatValue3","_formatValue4","formattedArgVal","_argUseExpr","mongoFormatFunc","_args","values"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.mongodbFormat = exports._mongodbFormat = void 0;\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nvar _stuff = require(\"../utils/stuff\");\n\nvar _configUtils = require(\"../utils/configUtils\");\n\nvar _ruleUtils = require(\"../utils/ruleUtils\");\n\nvar _defaultUtils = require(\"../utils/defaultUtils\");\n\nvar _funcUtils = require(\"../utils/funcUtils\");\n\nvar _omit = _interopRequireDefault(require(\"lodash/omit\"));\n\nvar _pick = _interopRequireDefault(require(\"lodash/pick\"));\n\nvar _immutable = require(\"immutable\");\n\nvar _default = require(\"../config/default\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2[\"default\"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\n// helpers\nvar isObject = function isObject(v) {\n  return (0, _typeof2[\"default\"])(v) == \"object\" && v !== null && !Array.isArray(v);\n};\n\nvar mongodbFormat = function mongodbFormat(tree, config) {\n  return _mongodbFormat(tree, config, false);\n};\n\nexports.mongodbFormat = mongodbFormat;\n\nvar _mongodbFormat = function _mongodbFormat(tree, config) {\n  var returnErrors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  //meta is mutable\n  var meta = {\n    errors: []\n  };\n  var res = formatItem([], tree, config, meta);\n\n  if (returnErrors) {\n    return [res, meta.errors];\n  } else {\n    if (meta.errors.length) console.warn(\"Errors while exporting to MongoDb:\", meta.errors);\n    return res;\n  }\n};\n\nexports._mongodbFormat = _mongodbFormat;\n\nvar formatItem = function formatItem(parents, item, config, meta) {\n  var _not = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n  var _canWrapExpr = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n\n  var _fieldName = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : undefined;\n\n  var _value = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : undefined;\n\n  if (!item) return undefined;\n  var type = item.get(\"type\");\n\n  if (type === \"group\" || type === \"rule_group\") {\n    return formatGroup(parents, item, config, meta, _not, _canWrapExpr, _fieldName, _value);\n  } else if (type === \"rule\") {\n    return formatRule(parents, item, config, meta, _not, _canWrapExpr, _fieldName, _value);\n  }\n\n  return undefined;\n};\n\nvar formatGroup = function formatGroup(parents, item, config, meta) {\n  var _not = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n  var _canWrapExpr = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n\n  var _fieldName = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : undefined;\n\n  var _value = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : undefined;\n\n  var type = item.get(\"type\");\n  var properties = item.get(\"properties\") || new _immutable.Map();\n  var children = item.get(\"children1\");\n  var canShortMongoQuery = config.settings.canShortMongoQuery;\n  if (!children) return undefined;\n  var hasParentRuleGroup = parents.filter(function (it) {\n    return it.get(\"type\") == \"rule_group\";\n  }).length > 0;\n  var parentPath = parents.filter(function (it) {\n    return it.get(\"type\") == \"rule_group\";\n  }).map(function (it) {\n    return it.get(\"properties\").get(\"field\");\n  }).slice(-1).pop();\n  var realParentPath = hasParentRuleGroup && parentPath;\n  var groupField = type === \"rule_group\" ? properties.get(\"field\") : null;\n  var groupFieldName = formatFieldName(groupField, config, meta, realParentPath);\n  var groupFieldDef = (0, _configUtils.getFieldConfig)(config, groupField) || {};\n  var mode = groupFieldDef.mode; //properties.get(\"mode\");\n\n  var canHaveEmptyChildren = groupField && mode == \"array\";\n  var not = _not ? !properties.get(\"not\") : properties.get(\"not\");\n  var list = children.map(function (currentChild) {\n    return formatItem([].concat((0, _toConsumableArray2[\"default\"])(parents), [item]), currentChild, config, meta, not, true, mode == \"array\" ? function (f) {\n      return \"$$el.\".concat(f);\n    } : undefined);\n  }).filter(function (currentChild) {\n    return typeof currentChild !== \"undefined\";\n  });\n  if (!canHaveEmptyChildren && !list.size) return undefined;\n  var conjunction = properties.get(\"conjunction\");\n  if (!conjunction) conjunction = (0, _defaultUtils.defaultConjunction)(config);\n  var conjunctionDefinition = config.conjunctions[conjunction];\n  var reversedConj = conjunctionDefinition.reversedConj;\n\n  if (not && reversedConj) {\n    conjunction = reversedConj;\n    conjunctionDefinition = config.conjunctions[conjunction];\n  }\n\n  var mongoConj = conjunctionDefinition.mongoConj;\n  var resultQuery;\n\n  if (list.size == 1) {\n    resultQuery = list.first();\n  } else if (list.size > 1) {\n    var rules = list.toList().toJS();\n    var canShort = canShortMongoQuery && mongoConj == \"$and\";\n\n    if (canShort) {\n      resultQuery = rules.reduce(function (acc, rule) {\n        if (!acc) return undefined;\n\n        for (var k in rule) {\n          if (k[0] == \"$\") {\n            acc = undefined;\n            break;\n          }\n\n          if (acc[k] == undefined) {\n            acc[k] = rule[k];\n          } else {\n            // https://github.com/ukrbublik/react-awesome-query-builder/issues/182\n            var prev = acc[k],\n                next = rule[k];\n\n            if (!isObject(prev)) {\n              prev = {\n                \"$eq\": prev\n              };\n            }\n\n            if (!isObject(next)) {\n              next = {\n                \"$eq\": next\n              };\n            }\n\n            var prevOp = Object.keys(prev)[0],\n                nextOp = Object.keys(next)[0];\n\n            if (prevOp == nextOp) {\n              acc = undefined;\n              break;\n            }\n\n            acc[k] = Object.assign({}, prev, next);\n          }\n        }\n\n        return acc;\n      }, {});\n    }\n\n    if (!resultQuery) // can't be shorten\n      resultQuery = (0, _defineProperty2[\"default\"])({}, mongoConj, rules);\n  }\n\n  if (groupField) {\n    if (mode == \"array\") {\n      var totalQuery = {\n        \"$size\": groupFieldName\n      };\n      var filterQuery = resultQuery ? {\n        \"$size\": {\n          \"$filter\": {\n            input: \"$\" + groupFieldName,\n            as: \"el\",\n            cond: resultQuery\n          }\n        }\n      } : totalQuery;\n      resultQuery = formatItem(parents, item.set(\"type\", \"rule\"), config, meta, false, false, function (_f) {\n        return filterQuery;\n      }, totalQuery);\n      resultQuery = {\n        \"$expr\": resultQuery\n      };\n    } else {\n      resultQuery = (0, _defineProperty2[\"default\"])({}, groupFieldName, {\n        \"$elemMatch\": resultQuery\n      });\n    }\n  }\n\n  return resultQuery;\n};\n\nvar formatRule = function formatRule(parents, item, config, meta) {\n  var _not = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n  var _canWrapExpr = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n\n  var _fieldName = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : undefined;\n\n  var _value = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : undefined;\n\n  var properties = item.get(\"properties\") || new _immutable.Map();\n  var hasParentRuleGroup = parents.filter(function (it) {\n    return it.get(\"type\") == \"rule_group\";\n  }).length > 0;\n  var parentPath = parents.filter(function (it) {\n    return it.get(\"type\") == \"rule_group\";\n  }).map(function (it) {\n    return it.get(\"properties\").get(\"field\");\n  }).slice(-1).pop();\n  var realParentPath = hasParentRuleGroup && parentPath;\n  var operator = properties.get(\"operator\");\n  var operatorOptions = properties.get(\"operatorOptions\");\n  var field = properties.get(\"field\");\n  var iValue = properties.get(\"value\");\n  var iValueSrc = properties.get(\"valueSrc\");\n  var iValueType = properties.get(\"valueType\");\n  var asyncListValues = properties.get(\"asyncListValues\");\n  if (field == null || operator == null || iValue === undefined) return undefined;\n  var fieldDef = (0, _configUtils.getFieldConfig)(config, field) || {};\n  var operatorDefinition = (0, _configUtils.getOperatorConfig)(config, operator, field) || {};\n  var reversedOp = operatorDefinition.reversedOp;\n  var revOperatorDefinition = (0, _configUtils.getOperatorConfig)(config, reversedOp, field) || {};\n  var cardinality = (0, _stuff.defaultValue)(operatorDefinition.cardinality, 1);\n  var not = _not;\n\n  if (not && reversedOp) {\n    var _ref = [reversedOp, operator];\n    operator = _ref[0];\n    reversedOp = _ref[1];\n    var _ref2 = [revOperatorDefinition, operatorDefinition];\n    operatorDefinition = _ref2[0];\n    revOperatorDefinition = _ref2[1];\n    not = false;\n  }\n\n  var fieldName = formatFieldName(field, config, meta, realParentPath); //format value\n\n  var valueSrcs = [];\n  var valueTypes = [];\n  var useExpr = false;\n  var fvalue = iValue.map(function (currentValue, ind) {\n    var valueSrc = iValueSrc ? iValueSrc.get(ind) : null;\n    var valueType = iValueType ? iValueType.get(ind) : null;\n    var cValue = (0, _funcUtils.completeValue)(currentValue, valueSrc, config);\n    var widget = (0, _ruleUtils.getWidgetForFieldOp)(config, field, operator, valueSrc);\n    var fieldWidgetDef = (0, _omit[\"default\"])((0, _configUtils.getFieldWidgetConfig)(config, field, operator, widget, valueSrc), [\"factory\"]);\n\n    var _formatValue = formatValue(meta, config, cValue, valueSrc, valueType, fieldWidgetDef, fieldDef, realParentPath, operator, operatorDefinition, asyncListValues),\n        _formatValue2 = (0, _slicedToArray2[\"default\"])(_formatValue, 2),\n        fv = _formatValue2[0],\n        fvUseExpr = _formatValue2[1];\n\n    if (fv !== undefined) {\n      useExpr = useExpr || fvUseExpr;\n      valueSrcs.push(valueSrc);\n      valueTypes.push(valueType);\n    }\n\n    return fv;\n  });\n  if (_fieldName) useExpr = true;\n  var wrapExpr = useExpr && _canWrapExpr;\n  var hasUndefinedValues = fvalue.filter(function (v) {\n    return v === undefined;\n  }).size > 0;\n  if (fvalue.size < cardinality || hasUndefinedValues) return undefined;\n  var formattedValue = cardinality > 1 ? fvalue.toArray() : cardinality == 1 ? fvalue.first() : null; //build rule\n\n  var fn = operatorDefinition.mongoFormatOp;\n\n  if (!fn) {\n    meta.errors.push(\"Operator \".concat(operator, \" is not supported\"));\n    return undefined;\n  }\n\n  var args = [_fieldName ? _fieldName(fieldName) : fieldName, operator, _value !== undefined && formattedValue == null ? _value : formattedValue, useExpr, valueSrcs.length > 1 ? valueSrcs : valueSrcs[0], valueTypes.length > 1 ? valueTypes : valueTypes[0], (0, _omit[\"default\"])(operatorDefinition, [\"formatOp\", \"mongoFormatOp\", \"sqlFormatOp\", \"jsonLogic\", \"spelFormatOp\"]), operatorOptions, fieldDef];\n  var ruleQuery = fn.apply(void 0, args);\n\n  if (wrapExpr) {\n    ruleQuery = {\n      \"$expr\": ruleQuery\n    };\n  }\n\n  if (not) {\n    ruleQuery = {\n      \"$not\": ruleQuery\n    };\n  }\n\n  return ruleQuery;\n};\n\nvar formatValue = function formatValue(meta, config, currentValue, valueSrc, valueType, fieldWidgetDef, fieldDef, parentPath, operator, operatorDef, asyncListValues) {\n  if (currentValue === undefined) return [undefined, false];\n  var ret;\n  var useExpr = false;\n\n  if (valueSrc == \"field\") {\n    var _formatRightField = formatRightField(meta, config, currentValue, parentPath);\n\n    var _formatRightField2 = (0, _slicedToArray2[\"default\"])(_formatRightField, 2);\n\n    ret = _formatRightField2[0];\n    useExpr = _formatRightField2[1];\n  } else if (valueSrc == \"func\") {\n    var _formatFunc = formatFunc(meta, config, currentValue, parentPath);\n\n    var _formatFunc2 = (0, _slicedToArray2[\"default\"])(_formatFunc, 2);\n\n    ret = _formatFunc2[0];\n    useExpr = _formatFunc2[1];\n  } else {\n    if (typeof fieldWidgetDef.mongoFormatValue === \"function\") {\n      var fn = fieldWidgetDef.mongoFormatValue;\n      var args = [currentValue, _objectSpread(_objectSpread({}, (0, _pick[\"default\"])(fieldDef, [\"fieldSettings\", \"listValues\"])), {}, {\n        asyncListValues: asyncListValues\n      }), //useful options: valueFormat for date/time\n      (0, _omit[\"default\"])(fieldWidgetDef, [\"formatValue\", \"mongoFormatValue\", \"sqlFormatValue\", \"jsonLogic\", \"elasticSearchFormatValue\", \"spelFormatValue\"])];\n\n      if (operator) {\n        args.push(operator);\n        args.push(operatorDef);\n      }\n\n      ret = fn.apply(void 0, args);\n    } else {\n      ret = currentValue;\n    }\n  }\n\n  return [ret, useExpr];\n};\n\nvar formatFieldName = function formatFieldName(field, config, meta, parentPath) {\n  if (!field) return;\n  var fieldDef = (0, _configUtils.getFieldConfig)(config, field) || {};\n  var fieldSeparator = config.settings.fieldSeparator;\n  var fieldParts = Array.isArray(field) ? field : field.split(fieldSeparator);\n  var fieldName = Array.isArray(field) ? field.join(fieldSeparator) : field; // if (fieldDef.tableName) { // legacy\n  //     const fieldPartsCopy = [...fieldParts];\n  //     fieldPartsCopy[0] = fieldDef.tableName;\n  //     fieldName = fieldPartsCopy.join(fieldSeparator);\n  // }\n\n  if (fieldDef.fieldName) {\n    fieldName = fieldDef.fieldName;\n  }\n\n  if (parentPath) {\n    var parentFieldDef = (0, _configUtils.getFieldConfig)(config, parentPath) || {};\n    var parentFieldName = parentPath;\n\n    if (parentFieldDef.fieldName) {\n      parentFieldName = parentFieldDef.fieldName;\n    }\n\n    if (fieldName.indexOf(parentFieldName + \".\") == 0) {\n      fieldName = fieldName.slice((parentFieldName + \".\").length);\n    } else {\n      meta.errors.push(\"Can't cut group \".concat(parentFieldName, \" from field \").concat(fieldName));\n    }\n  }\n\n  return fieldName;\n};\n\nvar formatRightField = function formatRightField(meta, config, rightField, parentPath) {\n  var fieldSeparator = config.settings.fieldSeparator;\n  var ret;\n  var useExpr = true;\n\n  if (rightField) {\n    var rightFieldDefinition = (0, _configUtils.getFieldConfig)(config, rightField) || {};\n    var fieldParts = Array.isArray(rightField) ? rightField : rightField.split(fieldSeparator);\n\n    var _fieldKeys = (0, _ruleUtils.getFieldPath)(rightField, config);\n\n    var fieldPartsLabels = (0, _ruleUtils.getFieldPathLabels)(rightField, config);\n    var fieldFullLabel = fieldPartsLabels ? fieldPartsLabels.join(fieldSeparator) : null;\n    var formatFieldFn = config.settings.formatField || _default.settings.formatField;\n    var rightFieldName = formatFieldName(rightField, config, meta, parentPath);\n    var formattedField = formatFieldFn(rightFieldName, fieldParts, fieldFullLabel, rightFieldDefinition, config, false);\n    ret = \"$\" + formattedField;\n  }\n\n  return [ret, useExpr];\n};\n\nvar formatFunc = function formatFunc(meta, config, currentValue, parentPath) {\n  var useExpr = true;\n  var ret;\n  var funcKey = currentValue.get(\"func\");\n  var args = currentValue.get(\"args\");\n  var funcConfig = (0, _configUtils.getFuncConfig)(config, funcKey);\n  var funcName = funcConfig.mongoFunc || funcKey;\n  var mongoArgsAsObject = funcConfig.mongoArgsAsObject;\n  var formattedArgs = {};\n  var argsCnt = 0;\n  var lastArg = undefined;\n\n  for (var argKey in funcConfig.args) {\n    var argConfig = funcConfig.args[argKey];\n    var fieldDef = (0, _configUtils.getFieldConfig)(config, argConfig);\n    var argVal = args ? args.get(argKey) : undefined;\n    var argValue = argVal ? argVal.get(\"value\") : undefined;\n    var argValueSrc = argVal ? argVal.get(\"valueSrc\") : undefined;\n    var argAsyncListValues = argVal ? argVal.get(\"asyncListValues\") : undefined;\n    var widget = (0, _ruleUtils.getWidgetForFieldOp)(config, fieldDef, null, argValueSrc);\n    var fieldWidgetDef = (0, _omit[\"default\"])((0, _configUtils.getFieldWidgetConfig)(config, fieldDef, null, widget, argValueSrc), [\"factory\"]);\n\n    var _formatValue3 = formatValue(meta, config, argValue, argValueSrc, argConfig.type, fieldWidgetDef, fieldDef, parentPath, null, null, argAsyncListValues),\n        _formatValue4 = (0, _slicedToArray2[\"default\"])(_formatValue3, 2),\n        formattedArgVal = _formatValue4[0],\n        _argUseExpr = _formatValue4[1];\n\n    if (argValue != undefined && formattedArgVal === undefined) {\n      meta.errors.push(\"Can't format value of arg \".concat(argKey, \" for func \").concat(funcKey));\n      return [undefined, false];\n    }\n\n    argsCnt++;\n\n    if (formattedArgVal !== undefined) {\n      // skip optional in the end\n      formattedArgs[argKey] = formattedArgVal;\n      lastArg = formattedArgVal;\n    }\n  }\n\n  if (typeof funcConfig.mongoFormatFunc === \"function\") {\n    var fn = funcConfig.mongoFormatFunc;\n    var _args = [formattedArgs];\n    ret = fn.apply(void 0, _args);\n  } else if (funcConfig.mongoFormatFunc === null) {\n    meta.errors.push(\"Functon \".concat(funcName, \" is not supported\"));\n    return [undefined, false];\n  } else {\n    if (mongoArgsAsObject) ret = (0, _defineProperty2[\"default\"])({}, funcName, formattedArgs);else if (argsCnt == 1 && lastArg !== undefined) ret = (0, _defineProperty2[\"default\"])({}, funcName, lastArg);else ret = (0, _defineProperty2[\"default\"])({}, funcName, Object.values(formattedArgs));\n  }\n\n  return [ret, useExpr];\n};"]},"metadata":{},"sourceType":"script"}