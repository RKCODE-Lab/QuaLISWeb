{"ast":null,"code":"import { RemoveMarkStep } from 'prosemirror-transform';\nimport { MarkType } from 'prosemirror-model';\nexport var markApplies = function markApplies(doc, ranges, type) {\n  var loop = function loop(i) {\n    var ref = ranges[i];\n    var $from = ref.$from;\n    var $to = ref.$to;\n    var can = $from.depth === 0 ? doc.type.allowsMarkType(type) : false;\n    doc.nodesBetween($from.pos, $to.pos, function (node) {\n      if (can) {\n        return false;\n      }\n\n      can = node.inlineContent && node.type.allowsMarkType(type);\n    });\n\n    if (can) {\n      return {\n        v: true\n      };\n    }\n  };\n\n  for (var i = 0; i < ranges.length; i++) {\n    var returned = loop(i);\n\n    if (returned) {\n      return returned.v;\n    }\n  }\n\n  return false;\n};\nexport var toggleMark = function toggleMark(markType, attrs, tr) {\n  return function (state, dispatch) {\n    var _a = state.selection,\n        empty = _a.empty,\n        $cursor = _a.$cursor,\n        ranges = _a.ranges;\n\n    if (empty && !$cursor || !markApplies(state.doc, ranges, markType)) {\n      return false;\n    }\n\n    if (dispatch) {\n      if ($cursor) {\n        if (markType.isInSet(state.storedMarks || $cursor.marks())) {\n          dispatch(tr.removeStoredMark(markType));\n        } else {\n          dispatch(tr.addStoredMark(markType.create(attrs)));\n        }\n      } else {\n        var has = false;\n\n        for (var i = 0; !has && i < ranges.length; i++) {\n          var _b = ranges[i],\n              $from = _b.$from,\n              $to = _b.$to;\n          has = state.doc.rangeHasMark($from.pos, $to.pos, markType);\n        }\n\n        for (var i = 0; i < ranges.length; i++) {\n          var _c = ranges[i],\n              $from = _c.$from,\n              $to = _c.$to;\n\n          if (has) {\n            tr.removeMark($from.pos, $to.pos, markType);\n          } else {\n            tr.addMark($from.pos, $to.pos, markType.create(attrs));\n          }\n        }\n\n        dispatch(tr.scrollIntoView());\n      }\n    }\n\n    return true;\n  };\n};\nexport var removeMark = function removeMark(tr, from, to, mark) {\n  if (mark === void 0) {\n    mark = null;\n  }\n\n  var matched = [],\n      step = 0;\n  tr.doc.nodesBetween(from, to, function (node, pos) {\n    if (!node.isInline) {\n      return;\n    }\n\n    step++;\n    var toRemove = null;\n\n    if (mark instanceof MarkType) {\n      var found = mark.isInSet(node.marks);\n\n      if (found) {\n        toRemove = [found];\n      }\n    } else if (mark) {\n      if (mark.isInSet(node.marks)) {\n        toRemove = [mark];\n      }\n    } else {\n      toRemove = node.marks;\n    }\n\n    if (toRemove && toRemove.length) {\n      var end = Math.min(pos + node.nodeSize, to);\n\n      for (var i = 0; i < toRemove.length; i++) {\n        var style = toRemove[i],\n            found$1 = void 0;\n\n        for (var j = 0; j < matched.length; j++) {\n          var m = matched[j];\n\n          if (m.step === step - 1 && style.eq(m.style)) {\n            found$1 = m;\n          }\n        }\n\n        if (found$1) {\n          found$1.to = end;\n          found$1.step = step;\n        } else {\n          matched.push({\n            style: style,\n            from: Math.max(pos, from),\n            to: end,\n            step: step\n          });\n        }\n      }\n    }\n  });\n  matched.forEach(function (m) {\n    return tr.step(new RemoveMarkStep(m.from, m.to, m.style));\n  });\n  return tr;\n};\nexport var removeMarks = function removeMarks(marks, state, dispatch, tr) {\n  var _a = state.selection,\n      $cursor = _a.$cursor,\n      ranges = _a.ranges;\n  tr = tr || state.tr;\n\n  if ($cursor) {\n    marks.forEach(function (m) {\n      if (m.isInSet(state.storedMarks || $cursor.marks())) {\n        dispatch(tr.removeStoredMark(m));\n      }\n    });\n  } else {\n    var _loop_1 = function _loop_1(i) {\n      var _a = ranges[i],\n          $from = _a.$from,\n          $to = _a.$to;\n      marks.forEach(function (m) {\n        removeMark(tr, $from.pos, $to.pos, m);\n      });\n    };\n\n    for (var i = 0; i < ranges.length; i++) {\n      _loop_1(i);\n    }\n\n    dispatch(tr.scrollIntoView());\n  }\n\n  return true;\n};\n\nvar toArray = function toArray(x) {\n  return x instanceof Array ? x : [x];\n};\n\nexport var removeAllMarks = function removeAllMarks(_a) {\n  var _b = (_a === void 0 ? {} : _a).except,\n      except = _b === void 0 ? [] : _b;\n  return function (state, dispatch) {\n    var tr = state.tr;\n    cleanMarks(tr, {\n      except: toArray(except)\n    });\n\n    if (tr.docChanged) {\n      dispatch(tr);\n    }\n  };\n};\n/**\n * Removes the marks from the selection base on the passed parameter.\n * Requires to dispatch the transaction.\n *\n * @example\n * See `removeAllMarks` or `cleanFormatting` function.\n */\n\nexport var cleanMarks = function cleanMarks(tr, _a) {\n  var except = _a.except;\n  var doc = tr.doc,\n      selection = tr.selection;\n  var schema = doc.type.schema;\n  var empty = selection.empty,\n      ranges = selection.ranges;\n  var excludedMarkTypes = (except || []).map(function (mt) {\n    return mt.name;\n  });\n\n  if (!empty) {\n    var marks_1 = Object.keys(schema.marks).map(function (m) {\n      return schema.marks[m];\n    }).filter(function (mt) {\n      return excludedMarkTypes.indexOf(mt.name) === -1;\n    });\n    ranges.forEach(function (_a) {\n      var $from = _a.$from,\n          $to = _a.$to;\n      marks_1.forEach(function (mark) {\n        return tr.removeMark($from.pos, $to.pos, mark);\n      });\n    });\n  }\n};\n/**\n * Checks if a mark exists in the selection.\n * Used for checking the state of bold, italic, ... and unlink tools.\n */\n\nexport var hasMark = function hasMark(state, options) {\n  var marks = state.schema.marks;\n  var altMarks = (options.altMarks || []).filter(function (m) {\n    return marks[m];\n  });\n  var altStyle = options.altStyle;\n  var _a = state.selection,\n      from = _a.from,\n      $from = _a.$from,\n      to = _a.to,\n      empty = _a.empty;\n  var type = marks[options.mark];\n  var doc = state.doc;\n  var result = false;\n  var currMarks;\n\n  if (empty) {\n    currMarks = state.storedMarks || $from.marks();\n    result = type && type.isInSet(currMarks) || altMarks.some(function (m) {\n      return marks[m].isInSet(currMarks);\n    });\n  } else {\n    result = type && doc.rangeHasMark(from, to, type) || altMarks.some(function (m) {\n      return doc.rangeHasMark(from, to, marks[m]);\n    });\n  }\n\n  if (!result && altStyle && marks.style) {\n    return selectionMarks(state, marks.style).some(function (mark) {\n      return styleValue(mark, altStyle) !== null;\n    });\n  }\n\n  return Boolean(result);\n};\nexport var styleValue = function styleValue(mark, style) {\n  var styleText = mark && mark.attrs.style || '';\n  var styles = styleText.split(/\\s*;\\s*/).filter(function (s) {\n    return Boolean(s);\n  });\n\n  for (var i = 0; i < styles.length; i++) {\n    var nameValue = styles[i].split(/\\s*:\\s*/);\n\n    if (nameValue[0].toLowerCase() === style.name && style.value.test(nameValue[1])) {\n      return nameValue[1];\n    }\n  }\n\n  return null;\n};\n/**\n * Returns the marks of a specific type for every inline node in the selection.\n */\n\nexport var selectionMarks = function selectionMarks(state, markType) {\n  var _a = state.selection,\n      from = _a.from,\n      $from = _a.$from,\n      to = _a.to,\n      empty = _a.empty;\n  var marks = [];\n\n  if (empty) {\n    marks.push(markType.isInSet(state.storedMarks || $from.marks()));\n  } else {\n    state.doc.nodesBetween(from, to, function (node) {\n      if (node.isInline) {\n        marks.push(markType.isInSet(node.marks));\n      }\n    });\n  }\n\n  return marks;\n};\n/**\n * Returns the specified mark which wraps the selection.\n * Used by link tools.\n */\n\nexport var getMark = function getMark(state, markType) {\n  var marks = selectionMarks(state, markType);\n  var filtered = marks.filter(function (m) {\n    return Boolean(m);\n  });\n  return marks.length === filtered.length ? marks[0] : undefined;\n};\n/**\n * **Deprecated.** Use `selectionMarks` function instead.\n */\n\nexport var getActiveMarks = function getActiveMarks(state, markType) {\n  var marks = selectionMarks(state, markType);\n  var filtered = marks.filter(function (m) {\n    return Boolean(m);\n  });\n  var hasNodesWithoutMarks = marks.length !== filtered.length;\n  return {\n    hasNodesWithoutMarks: hasNodesWithoutMarks,\n    marks: filtered\n  };\n};","map":{"version":3,"sources":["D:/Postgres_workingFolder/QuaLISWeb/node_modules/@progress/kendo-editor-common/dist/es/mark.js"],"names":["RemoveMarkStep","MarkType","markApplies","doc","ranges","type","loop","i","ref","$from","$to","can","depth","allowsMarkType","nodesBetween","pos","node","inlineContent","v","length","returned","toggleMark","markType","attrs","tr","state","dispatch","_a","selection","empty","$cursor","isInSet","storedMarks","marks","removeStoredMark","addStoredMark","create","has","_b","rangeHasMark","_c","removeMark","addMark","scrollIntoView","from","to","mark","matched","step","isInline","toRemove","found","end","Math","min","nodeSize","style","found$1","j","m","eq","push","max","forEach","removeMarks","_loop_1","toArray","x","Array","removeAllMarks","except","cleanMarks","docChanged","schema","excludedMarkTypes","map","mt","name","marks_1","Object","keys","filter","indexOf","hasMark","options","altMarks","altStyle","result","currMarks","some","selectionMarks","styleValue","Boolean","styleText","styles","split","s","nameValue","toLowerCase","value","test","getMark","filtered","undefined","getActiveMarks","hasNodesWithoutMarks"],"mappings":"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","sourcesContent":["import { RemoveMarkStep } from 'prosemirror-transform';\nimport { MarkType } from 'prosemirror-model';\nexport var markApplies = function (doc, ranges, type) {\n    var loop = function (i) {\n        var ref = ranges[i];\n        var $from = ref.$from;\n        var $to = ref.$to;\n        var can = $from.depth === 0 ? doc.type.allowsMarkType(type) : false;\n        doc.nodesBetween($from.pos, $to.pos, function (node) {\n            if (can) {\n                return false;\n            }\n            can = node.inlineContent && node.type.allowsMarkType(type);\n        });\n        if (can) {\n            return { v: true };\n        }\n    };\n    for (var i = 0; i < ranges.length; i++) {\n        var returned = loop(i);\n        if (returned) {\n            return returned.v;\n        }\n    }\n    return false;\n};\nexport var toggleMark = function (markType, attrs, tr) { return function (state, dispatch) {\n    var _a = state.selection, empty = _a.empty, $cursor = _a.$cursor, ranges = _a.ranges;\n    if ((empty && !$cursor) || !markApplies(state.doc, ranges, markType)) {\n        return false;\n    }\n    if (dispatch) {\n        if ($cursor) {\n            if (markType.isInSet(state.storedMarks || $cursor.marks())) {\n                dispatch(tr.removeStoredMark(markType));\n            }\n            else {\n                dispatch(tr.addStoredMark(markType.create(attrs)));\n            }\n        }\n        else {\n            var has = false;\n            for (var i = 0; !has && i < ranges.length; i++) {\n                var _b = ranges[i], $from = _b.$from, $to = _b.$to;\n                has = state.doc.rangeHasMark($from.pos, $to.pos, markType);\n            }\n            for (var i = 0; i < ranges.length; i++) {\n                var _c = ranges[i], $from = _c.$from, $to = _c.$to;\n                if (has) {\n                    tr.removeMark($from.pos, $to.pos, markType);\n                }\n                else {\n                    tr.addMark($from.pos, $to.pos, markType.create(attrs));\n                }\n            }\n            dispatch(tr.scrollIntoView());\n        }\n    }\n    return true;\n}; };\nexport var removeMark = function (tr, from, to, mark) {\n    if (mark === void 0) {\n        mark = null;\n    }\n    var matched = [], step = 0;\n    tr.doc.nodesBetween(from, to, function (node, pos) {\n        if (!node.isInline) {\n            return;\n        }\n        step++;\n        var toRemove = null;\n        if (mark instanceof MarkType) {\n            var found = mark.isInSet(node.marks);\n            if (found) {\n                toRemove = [found];\n            }\n        }\n        else if (mark) {\n            if (mark.isInSet(node.marks)) {\n                toRemove = [mark];\n            }\n        }\n        else {\n            toRemove = node.marks;\n        }\n        if (toRemove && toRemove.length) {\n            var end = Math.min(pos + node.nodeSize, to);\n            for (var i = 0; i < toRemove.length; i++) {\n                var style = toRemove[i], found$1 = (void 0);\n                for (var j = 0; j < matched.length; j++) {\n                    var m = matched[j];\n                    if (m.step === step - 1 && style.eq(m.style)) {\n                        found$1 = m;\n                    }\n                }\n                if (found$1) {\n                    found$1.to = end;\n                    found$1.step = step;\n                }\n                else {\n                    matched.push({ style: style, from: Math.max(pos, from), to: end, step: step });\n                }\n            }\n        }\n    });\n    matched.forEach(function (m) { return tr.step(new RemoveMarkStep(m.from, m.to, m.style)); });\n    return tr;\n};\nexport var removeMarks = function (marks, state, dispatch, tr) {\n    var _a = state.selection, $cursor = _a.$cursor, ranges = _a.ranges;\n    tr = tr || state.tr;\n    if ($cursor) {\n        marks.forEach(function (m) {\n            if (m.isInSet(state.storedMarks || $cursor.marks())) {\n                dispatch(tr.removeStoredMark(m));\n            }\n        });\n    }\n    else {\n        var _loop_1 = function (i) {\n            var _a = ranges[i], $from = _a.$from, $to = _a.$to;\n            marks.forEach(function (m) {\n                removeMark(tr, $from.pos, $to.pos, m);\n            });\n        };\n        for (var i = 0; i < ranges.length; i++) {\n            _loop_1(i);\n        }\n        dispatch(tr.scrollIntoView());\n    }\n    return true;\n};\nvar toArray = function (x) { return x instanceof Array ? x : [x]; };\nexport var removeAllMarks = function (_a) {\n    var _b = (_a === void 0 ? {} : _a).except, except = _b === void 0 ? [] : _b;\n    return function (state, dispatch) {\n        var tr = state.tr;\n        cleanMarks(tr, { except: toArray(except) });\n        if (tr.docChanged) {\n            dispatch(tr);\n        }\n    };\n};\n/**\n * Removes the marks from the selection base on the passed parameter.\n * Requires to dispatch the transaction.\n *\n * @example\n * See `removeAllMarks` or `cleanFormatting` function.\n */\nexport var cleanMarks = function (tr, _a) {\n    var except = _a.except;\n    var doc = tr.doc, selection = tr.selection;\n    var schema = doc.type.schema;\n    var empty = selection.empty, ranges = selection.ranges;\n    var excludedMarkTypes = (except || []).map(function (mt) { return mt.name; });\n    if (!empty) {\n        var marks_1 = Object.keys(schema.marks)\n            .map(function (m) { return schema.marks[m]; })\n            .filter(function (mt) { return excludedMarkTypes.indexOf(mt.name) === -1; });\n        ranges.forEach(function (_a) {\n            var $from = _a.$from, $to = _a.$to;\n            marks_1.forEach(function (mark) { return tr.removeMark($from.pos, $to.pos, mark); });\n        });\n    }\n};\n/**\n * Checks if a mark exists in the selection.\n * Used for checking the state of bold, italic, ... and unlink tools.\n */\nexport var hasMark = function (state, options) {\n    var marks = state.schema.marks;\n    var altMarks = (options.altMarks || []).filter(function (m) { return marks[m]; });\n    var altStyle = options.altStyle;\n    var _a = state.selection, from = _a.from, $from = _a.$from, to = _a.to, empty = _a.empty;\n    var type = marks[options.mark];\n    var doc = state.doc;\n    var result = false;\n    var currMarks;\n    if (empty) {\n        currMarks = state.storedMarks || $from.marks();\n        result = (type && type.isInSet(currMarks)) || altMarks.some(function (m) { return marks[m].isInSet(currMarks); });\n    }\n    else {\n        result = (type && doc.rangeHasMark(from, to, type)) || altMarks.some(function (m) { return doc.rangeHasMark(from, to, marks[m]); });\n    }\n    if (!result && altStyle && marks.style) {\n        return selectionMarks(state, marks.style)\n            .some(function (mark) { return styleValue(mark, altStyle) !== null; });\n    }\n    return Boolean(result);\n};\nexport var styleValue = function (mark, style) {\n    var styleText = (mark && mark.attrs.style) || '';\n    var styles = styleText.split(/\\s*;\\s*/).filter(function (s) { return Boolean(s); });\n    for (var i = 0; i < styles.length; i++) {\n        var nameValue = styles[i].split(/\\s*:\\s*/);\n        if (nameValue[0].toLowerCase() === style.name && style.value.test(nameValue[1])) {\n            return nameValue[1];\n        }\n    }\n    return null;\n};\n/**\n * Returns the marks of a specific type for every inline node in the selection.\n */\nexport var selectionMarks = function (state, markType) {\n    var _a = state.selection, from = _a.from, $from = _a.$from, to = _a.to, empty = _a.empty;\n    var marks = [];\n    if (empty) {\n        marks.push(markType.isInSet(state.storedMarks || $from.marks()));\n    }\n    else {\n        state.doc.nodesBetween(from, to, function (node) {\n            if (node.isInline) {\n                marks.push(markType.isInSet(node.marks));\n            }\n        });\n    }\n    return marks;\n};\n/**\n * Returns the specified mark which wraps the selection.\n * Used by link tools.\n */\nexport var getMark = function (state, markType) {\n    var marks = selectionMarks(state, markType);\n    var filtered = marks.filter(function (m) { return Boolean(m); });\n    return marks.length === filtered.length ? marks[0] : undefined;\n};\n/**\n * **Deprecated.** Use `selectionMarks` function instead.\n */\nexport var getActiveMarks = function (state, markType) {\n    var marks = selectionMarks(state, markType);\n    var filtered = marks.filter(function (m) { return Boolean(m); });\n    var hasNodesWithoutMarks = marks.length !== filtered.length;\n    return {\n        hasNodesWithoutMarks: hasNodesWithoutMarks,\n        marks: filtered\n    };\n};\n"]},"metadata":{},"sourceType":"module"}