{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nimport { getWidgetForFieldOp } from \"../utils/ruleUtils\";\nimport { defaultConjunction } from \"../utils/defaultUtils\";\n/**\n * Converts a string representation of top_left and bottom_right cords to\n * a ES geo_point required for query\n *\n * @param {string} geoPointString - comma separated string of lat/lon coods\n * @returns {{top_left: {lon: number, lat: number}, bottom_right: {lon: number, lat: number}}} - ES geoPoint formatted object\n * @private\n */\n\nfunction buildEsGeoPoint(geoPointString) {\n  if (geoPointString == null) {\n    return null;\n  }\n\n  var coordsNumberArray = geoPointString.split(\",\").map(Number);\n  return {\n    top_left: {\n      lat: coordsNumberArray[0],\n      lon: coordsNumberArray[1]\n    },\n    bottom_right: {\n      lat: coordsNumberArray[2],\n      lon: coordsNumberArray[3]\n    }\n  };\n}\n/**\n * Converts a dateTime string from the query builder to a ES range formatted object\n *\n * @param {string} dateTime - dateTime formatted string\n * @param {string} operator - query builder operator type, see constants.js and query builder docs\n * @returns {{lt: string}|{lte: string}|{gte: string}|{gte: string, lte: string}|undefined} - ES range query parameter\n *\n * @private\n */\n\n\nfunction buildEsRangeParameters(value, operator) {\n  // -- if value is greater than 1 then we assume this is a between operator : BUG this is wrong, a selectable list can have multiple values\n  if (value.length > 1) {\n    return {\n      gte: \"\".concat(value[0]),\n      lte: \"\".concat(value[1])\n    };\n  } // -- if value is only one we assume this is a date time query for a specific day\n\n\n  var dateTime = value[0]; //TODO: Rethink about this part, what if someone adds a new type of opperator\n  //todo: move this logic into config\n\n  switch (operator) {\n    case \"on_date\": //todo: not used\n\n    case \"not_on_date\":\n    case \"equal\":\n    case \"select_equals\":\n    case \"not_equal\":\n      return {\n        gte: \"\".concat(dateTime, \"||/d\"),\n        lte: \"\".concat(dateTime, \"||+1d\")\n      };\n\n    case \"less_or_equal\":\n      return {\n        lte: \"\".concat(dateTime)\n      };\n\n    case \"greater_or_equal\":\n      return {\n        gte: \"\".concat(dateTime)\n      };\n\n    case \"less\":\n      return {\n        lt: \"\".concat(dateTime)\n      };\n\n    case \"greater\":\n      return {\n        gt: \"\".concat(dateTime)\n      };\n\n    default:\n      return undefined;\n  }\n}\n/**\n * Builds the DSL parameters for a Wildcard query\n *\n * @param {string} value - The match value\n * @returns {{value: string}} - The value = value parameter surrounded with * on each end\n * @private\n */\n\n\nfunction buildEsWildcardParameters(value) {\n  return {\n    value: \"*\" + value + \"*\"\n  };\n}\n/**\n * Takes the match type string from awesome query builder like 'greater_or_equal' and\n * returns the ES occurrence required for bool queries\n *\n * @param {string} combinator - query group type or rule condition\n * @param {bool} not\n * @returns {string} - ES occurrence type. See constants.js\n * @private\n */\n\n\nfunction determineOccurrence(combinator, not) {\n  //todo: move into config, like mongoConj\n  switch (combinator) {\n    case \"AND\":\n      return not ? \"must_not\" : \"must\";\n    // -- AND\n\n    case \"OR\":\n      return not ? \"should_not\" : \"should\";\n    // -- OR\n\n    case \"NOT\":\n      return not ? \"must\" : \"must_not\";\n    // -- NOT AND\n\n    default:\n      return undefined;\n  }\n}\n/**\n * Determines what field to query off of given the operator type\n *\n * @param {string} fieldDataType - The type of data\n * @param {string} fullFieldName - A '.' separated string containing the property lineage (including self)\n * @param {string} queryType - The query type\n * @returns {string|*} - will be either the fullFieldName or fullFieldName.keyword\n * @private\n */\n//todo: not used\n\n\nfunction determineQueryField(fieldDataType, fullFieldName, queryType) {\n  if (fieldDataType === \"boolean\") {\n    return fullFieldName;\n  }\n\n  switch (queryType) {\n    case \"term\":\n    case \"wildcard\":\n      return \"\".concat(fullFieldName, \".keyword\");\n\n    case \"geo_bounding_box\":\n    case \"range\":\n    case \"match\":\n      return fullFieldName;\n\n    default:\n      console.error(\"Can't determine query field for query type \".concat(queryType));\n      return null;\n  }\n}\n\nfunction buildRegexpParameters(value) {\n  return {\n    value: value\n  };\n}\n\nfunction determineField(fieldName, config) {\n  //todo: ElasticSearchTextField - not used\n  //return config.fields[fieldName].ElasticSearchTextField || fieldName;\n  return fieldName;\n}\n\nfunction buildParameters(queryType, value, operator, fieldName, config) {\n  var textField = determineField(fieldName, config);\n\n  switch (queryType) {\n    case \"filter\":\n      //todo: elasticSearchScript - not used\n      return {\n        script: config.operators[operator].elasticSearchScript(fieldName, value)\n      };\n\n    case \"exists\":\n      return {\n        field: fieldName\n      };\n\n    case \"match\":\n      return _defineProperty({}, textField, value[0]);\n\n    case \"term\":\n      return _defineProperty({}, fieldName, value[0]);\n    //todo: not used\n    // need to add geo type into RAQB or remove this code\n\n    case \"geo_bounding_box\":\n      return _defineProperty({}, fieldName, buildEsGeoPoint(value[0]));\n\n    case \"range\":\n      return _defineProperty({}, fieldName, buildEsRangeParameters(value, operator));\n\n    case \"wildcard\":\n      return _defineProperty({}, fieldName, buildEsWildcardParameters(value[0]));\n\n    case \"regexp\":\n      return _defineProperty({}, fieldName, buildRegexpParameters(value[0]));\n\n    default:\n      return undefined;\n  }\n}\n/**\n * Handles the building of the group portion of the DSL\n *\n * @param {string} fieldName - The name of the field you are building a rule for\n * @param {string} fieldDataType - The type of data this field holds\n * @param {string} value - The value of this rule\n * @param {string} operator - The condition on how the value is matched\n * @returns {object} - The ES rule\n * @private\n */\n\n\nfunction buildEsRule(fieldName, value, operator, config, valueSrc) {\n  if (!fieldName || !operator || value == undefined) return undefined; // rule is not fully entered\n\n  var op = operator;\n  var opConfig = config.operators[op];\n  if (!opConfig) return undefined; // unknown operator\n\n  var _opConfig = opConfig,\n      elasticSearchQueryType = _opConfig.elasticSearchQueryType; // not\n\n  var not = false;\n\n  if (!elasticSearchQueryType && opConfig.reversedOp) {\n    not = true;\n    op = opConfig.reversedOp;\n    opConfig = config.operators[op];\n    var _opConfig2 = opConfig;\n    elasticSearchQueryType = _opConfig2.elasticSearchQueryType;\n  } // handle if value 0 has multiple values like a select in a array\n\n\n  var widget = getWidgetForFieldOp(config, fieldName, op, valueSrc);\n  var widgetConfig = config.widgets[widget];\n  if (!widgetConfig) return undefined; // unknown widget\n\n  var elasticSearchFormatValue = widgetConfig.elasticSearchFormatValue;\n  /** In most cases the queryType will be static however in some casese (like between) the query type will change\n   * based on the data type. i.e. a between time will be different than between number, date, letters etc... */\n\n  var queryType;\n\n  if (typeof elasticSearchQueryType === \"function\") {\n    queryType = elasticSearchQueryType(widget);\n  } else {\n    queryType = elasticSearchQueryType;\n  }\n\n  if (!queryType) {\n    // Not supported\n    return undefined;\n  }\n  /** If a widget has a rule on how to format that data then use that otherwise use default way of determineing search parameters\n   * */\n\n\n  var parameters;\n\n  if (typeof elasticSearchFormatValue === \"function\") {\n    parameters = elasticSearchFormatValue(queryType, value, op, fieldName, config);\n  } else {\n    parameters = buildParameters(queryType, value, op, fieldName, config);\n  }\n\n  if (not) {\n    return {\n      bool: {\n        must_not: _defineProperty({}, queryType, _objectSpread({}, parameters))\n      }\n    };\n  } else {\n    return _defineProperty({}, queryType, _objectSpread({}, parameters));\n  }\n}\n/**\n * Handles the building of the group portion of the DSL\n *\n * @param {object} children - The contents of the group\n * @param {string} conjunction - The way the contents of the group are joined together i.e. AND OR\n * @param {bool} not\n * @param {Function} recursiveFxn - The recursive fxn to build the contents of the groups children\n * @private\n * @returns {object} - The ES group\n */\n\n\nfunction buildEsGroup(children, conjunction, not, recursiveFxn, config) {\n  if (!children || !children.size) return undefined;\n  var childrenArray = children.valueSeq().toArray();\n  var occurrence = determineOccurrence(conjunction, not);\n  var result = childrenArray.map(function (c) {\n    return recursiveFxn(c, config);\n  }).filter(function (v) {\n    return v !== undefined;\n  });\n  if (!result.length) return undefined;\n  var resultFlat = result.flat(Infinity);\n  return {\n    bool: _defineProperty({}, occurrence, resultFlat)\n  };\n}\n\nexport function elasticSearchFormat(tree, config) {\n  // -- format the es dsl here\n  if (!tree) return undefined;\n  var type = tree.get(\"type\");\n  var properties = tree.get(\"properties\") || new Map();\n\n  if (type === \"rule\" && properties.get(\"field\")) {\n    var _properties$get, _properties$get2; // -- field is null when a new blank rule is added\n\n\n    var operator = properties.get(\"operator\");\n    var field = properties.get(\"field\");\n    var value = properties.get(\"value\").toJS();\n\n    var _valueType = (_properties$get = properties.get(\"valueType\")) === null || _properties$get === void 0 ? void 0 : _properties$get.get(0);\n\n    var valueSrc = (_properties$get2 = properties.get(\"valueSrc\")) === null || _properties$get2 === void 0 ? void 0 : _properties$get2.get(0);\n\n    if (valueSrc === \"func\") {\n      // -- elastic search doesn't support functions (that is post processing)\n      return;\n    }\n\n    if (value && Array.isArray(value[0])) {\n      //TODO : Handle case where the value has multiple values such as in the case of a list\n      return value[0].map(function (val) {\n        return buildEsRule(field, [val], operator, config, valueSrc);\n      });\n    } else {\n      return buildEsRule(field, value, operator, config, valueSrc);\n    }\n  }\n\n  if (type === \"group\" || type === \"rule_group\") {\n    var not = properties.get(\"not\");\n    var conjunction = properties.get(\"conjunction\");\n    if (!conjunction) conjunction = defaultConjunction(config);\n    var children = tree.get(\"children1\");\n    return buildEsGroup(children, conjunction, not, elasticSearchFormat, config);\n  }\n}","map":{"version":3,"sources":["D:/LIMSWFH/LIMSPOSTGRESQL/QuaLISWeb/node_modules/@react-awesome-query-builder/core/esm/export/elasticSearch.js"],"names":["_defineProperty","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","getWidgetForFieldOp","defaultConjunction","buildEsGeoPoint","geoPointString","coordsNumberArray","split","map","Number","top_left","lat","lon","bottom_right","buildEsRangeParameters","value","operator","gte","concat","lte","dateTime","lt","gt","undefined","buildEsWildcardParameters","determineOccurrence","combinator","not","determineQueryField","fieldDataType","fullFieldName","queryType","console","error","buildRegexpParameters","determineField","fieldName","config","buildParameters","textField","script","operators","elasticSearchScript","field","buildEsRule","valueSrc","op","opConfig","_opConfig","elasticSearchQueryType","reversedOp","_opConfig2","widget","widgetConfig","widgets","elasticSearchFormatValue","parameters","bool","must_not","buildEsGroup","children","conjunction","recursiveFxn","size","childrenArray","valueSeq","toArray","occurrence","result","c","v","resultFlat","flat","Infinity","elasticSearchFormat","tree","type","get","properties","Map","_properties$get","_properties$get2","toJS","_valueType","Array","isArray","val"],"mappings":"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","sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nimport { getWidgetForFieldOp } from \"../utils/ruleUtils\";\nimport { defaultConjunction } from \"../utils/defaultUtils\";\n\n/**\n * Converts a string representation of top_left and bottom_right cords to\n * a ES geo_point required for query\n *\n * @param {string} geoPointString - comma separated string of lat/lon coods\n * @returns {{top_left: {lon: number, lat: number}, bottom_right: {lon: number, lat: number}}} - ES geoPoint formatted object\n * @private\n */\nfunction buildEsGeoPoint(geoPointString) {\n  if (geoPointString == null) {\n    return null;\n  }\n  var coordsNumberArray = geoPointString.split(\",\").map(Number);\n  return {\n    top_left: {\n      lat: coordsNumberArray[0],\n      lon: coordsNumberArray[1]\n    },\n    bottom_right: {\n      lat: coordsNumberArray[2],\n      lon: coordsNumberArray[3]\n    }\n  };\n}\n\n/**\n * Converts a dateTime string from the query builder to a ES range formatted object\n *\n * @param {string} dateTime - dateTime formatted string\n * @param {string} operator - query builder operator type, see constants.js and query builder docs\n * @returns {{lt: string}|{lte: string}|{gte: string}|{gte: string, lte: string}|undefined} - ES range query parameter\n *\n * @private\n */\nfunction buildEsRangeParameters(value, operator) {\n  // -- if value is greater than 1 then we assume this is a between operator : BUG this is wrong, a selectable list can have multiple values\n  if (value.length > 1) {\n    return {\n      gte: \"\".concat(value[0]),\n      lte: \"\".concat(value[1])\n    };\n  } // -- if value is only one we assume this is a date time query for a specific day\n\n  var dateTime = value[0]; //TODO: Rethink about this part, what if someone adds a new type of opperator\n\n  //todo: move this logic into config\n  switch (operator) {\n    case \"on_date\": //todo: not used\n    case \"not_on_date\":\n    case \"equal\":\n    case \"select_equals\":\n    case \"not_equal\":\n      return {\n        gte: \"\".concat(dateTime, \"||/d\"),\n        lte: \"\".concat(dateTime, \"||+1d\")\n      };\n    case \"less_or_equal\":\n      return {\n        lte: \"\".concat(dateTime)\n      };\n    case \"greater_or_equal\":\n      return {\n        gte: \"\".concat(dateTime)\n      };\n    case \"less\":\n      return {\n        lt: \"\".concat(dateTime)\n      };\n    case \"greater\":\n      return {\n        gt: \"\".concat(dateTime)\n      };\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Builds the DSL parameters for a Wildcard query\n *\n * @param {string} value - The match value\n * @returns {{value: string}} - The value = value parameter surrounded with * on each end\n * @private\n */\nfunction buildEsWildcardParameters(value) {\n  return {\n    value: \"*\" + value + \"*\"\n  };\n}\n\n/**\n * Takes the match type string from awesome query builder like 'greater_or_equal' and\n * returns the ES occurrence required for bool queries\n *\n * @param {string} combinator - query group type or rule condition\n * @param {bool} not\n * @returns {string} - ES occurrence type. See constants.js\n * @private\n */\nfunction determineOccurrence(combinator, not) {\n  //todo: move into config, like mongoConj\n  switch (combinator) {\n    case \"AND\":\n      return not ? \"must_not\" : \"must\";\n    // -- AND\n\n    case \"OR\":\n      return not ? \"should_not\" : \"should\";\n    // -- OR\n\n    case \"NOT\":\n      return not ? \"must\" : \"must_not\";\n    // -- NOT AND\n\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Determines what field to query off of given the operator type\n *\n * @param {string} fieldDataType - The type of data\n * @param {string} fullFieldName - A '.' separated string containing the property lineage (including self)\n * @param {string} queryType - The query type\n * @returns {string|*} - will be either the fullFieldName or fullFieldName.keyword\n * @private\n */\n//todo: not used\nfunction determineQueryField(fieldDataType, fullFieldName, queryType) {\n  if (fieldDataType === \"boolean\") {\n    return fullFieldName;\n  }\n  switch (queryType) {\n    case \"term\":\n    case \"wildcard\":\n      return \"\".concat(fullFieldName, \".keyword\");\n    case \"geo_bounding_box\":\n    case \"range\":\n    case \"match\":\n      return fullFieldName;\n    default:\n      console.error(\"Can't determine query field for query type \".concat(queryType));\n      return null;\n  }\n}\nfunction buildRegexpParameters(value) {\n  return {\n    value: value\n  };\n}\nfunction determineField(fieldName, config) {\n  //todo: ElasticSearchTextField - not used\n  //return config.fields[fieldName].ElasticSearchTextField || fieldName;\n  return fieldName;\n}\nfunction buildParameters(queryType, value, operator, fieldName, config) {\n  var textField = determineField(fieldName, config);\n  switch (queryType) {\n    case \"filter\":\n      //todo: elasticSearchScript - not used\n      return {\n        script: config.operators[operator].elasticSearchScript(fieldName, value)\n      };\n    case \"exists\":\n      return {\n        field: fieldName\n      };\n    case \"match\":\n      return _defineProperty({}, textField, value[0]);\n    case \"term\":\n      return _defineProperty({}, fieldName, value[0]);\n\n    //todo: not used\n    // need to add geo type into RAQB or remove this code\n    case \"geo_bounding_box\":\n      return _defineProperty({}, fieldName, buildEsGeoPoint(value[0]));\n    case \"range\":\n      return _defineProperty({}, fieldName, buildEsRangeParameters(value, operator));\n    case \"wildcard\":\n      return _defineProperty({}, fieldName, buildEsWildcardParameters(value[0]));\n    case \"regexp\":\n      return _defineProperty({}, fieldName, buildRegexpParameters(value[0]));\n    default:\n      return undefined;\n  }\n}\n/**\n * Handles the building of the group portion of the DSL\n *\n * @param {string} fieldName - The name of the field you are building a rule for\n * @param {string} fieldDataType - The type of data this field holds\n * @param {string} value - The value of this rule\n * @param {string} operator - The condition on how the value is matched\n * @returns {object} - The ES rule\n * @private\n */\nfunction buildEsRule(fieldName, value, operator, config, valueSrc) {\n  if (!fieldName || !operator || value == undefined) return undefined; // rule is not fully entered\n  var op = operator;\n  var opConfig = config.operators[op];\n  if (!opConfig) return undefined; // unknown operator\n  var _opConfig = opConfig,\n    elasticSearchQueryType = _opConfig.elasticSearchQueryType;\n\n  // not\n  var not = false;\n  if (!elasticSearchQueryType && opConfig.reversedOp) {\n    not = true;\n    op = opConfig.reversedOp;\n    opConfig = config.operators[op];\n    var _opConfig2 = opConfig;\n    elasticSearchQueryType = _opConfig2.elasticSearchQueryType;\n  }\n\n  // handle if value 0 has multiple values like a select in a array\n  var widget = getWidgetForFieldOp(config, fieldName, op, valueSrc);\n  var widgetConfig = config.widgets[widget];\n  if (!widgetConfig) return undefined; // unknown widget\n  var elasticSearchFormatValue = widgetConfig.elasticSearchFormatValue;\n\n  /** In most cases the queryType will be static however in some casese (like between) the query type will change\n   * based on the data type. i.e. a between time will be different than between number, date, letters etc... */\n  var queryType;\n  if (typeof elasticSearchQueryType === \"function\") {\n    queryType = elasticSearchQueryType(widget);\n  } else {\n    queryType = elasticSearchQueryType;\n  }\n  if (!queryType) {\n    // Not supported\n    return undefined;\n  }\n\n  /** If a widget has a rule on how to format that data then use that otherwise use default way of determineing search parameters\n   * */\n  var parameters;\n  if (typeof elasticSearchFormatValue === \"function\") {\n    parameters = elasticSearchFormatValue(queryType, value, op, fieldName, config);\n  } else {\n    parameters = buildParameters(queryType, value, op, fieldName, config);\n  }\n  if (not) {\n    return {\n      bool: {\n        must_not: _defineProperty({}, queryType, _objectSpread({}, parameters))\n      }\n    };\n  } else {\n    return _defineProperty({}, queryType, _objectSpread({}, parameters));\n  }\n}\n\n/**\n * Handles the building of the group portion of the DSL\n *\n * @param {object} children - The contents of the group\n * @param {string} conjunction - The way the contents of the group are joined together i.e. AND OR\n * @param {bool} not\n * @param {Function} recursiveFxn - The recursive fxn to build the contents of the groups children\n * @private\n * @returns {object} - The ES group\n */\nfunction buildEsGroup(children, conjunction, not, recursiveFxn, config) {\n  if (!children || !children.size) return undefined;\n  var childrenArray = children.valueSeq().toArray();\n  var occurrence = determineOccurrence(conjunction, not);\n  var result = childrenArray.map(function (c) {\n    return recursiveFxn(c, config);\n  }).filter(function (v) {\n    return v !== undefined;\n  });\n  if (!result.length) return undefined;\n  var resultFlat = result.flat(Infinity);\n  return {\n    bool: _defineProperty({}, occurrence, resultFlat)\n  };\n}\nexport function elasticSearchFormat(tree, config) {\n  // -- format the es dsl here\n  if (!tree) return undefined;\n  var type = tree.get(\"type\");\n  var properties = tree.get(\"properties\") || new Map();\n  if (type === \"rule\" && properties.get(\"field\")) {\n    var _properties$get, _properties$get2;\n    // -- field is null when a new blank rule is added\n    var operator = properties.get(\"operator\");\n    var field = properties.get(\"field\");\n    var value = properties.get(\"value\").toJS();\n    var _valueType = (_properties$get = properties.get(\"valueType\")) === null || _properties$get === void 0 ? void 0 : _properties$get.get(0);\n    var valueSrc = (_properties$get2 = properties.get(\"valueSrc\")) === null || _properties$get2 === void 0 ? void 0 : _properties$get2.get(0);\n    if (valueSrc === \"func\") {\n      // -- elastic search doesn't support functions (that is post processing)\n      return;\n    }\n    if (value && Array.isArray(value[0])) {\n      //TODO : Handle case where the value has multiple values such as in the case of a list\n      return value[0].map(function (val) {\n        return buildEsRule(field, [val], operator, config, valueSrc);\n      });\n    } else {\n      return buildEsRule(field, value, operator, config, valueSrc);\n    }\n  }\n  if (type === \"group\" || type === \"rule_group\") {\n    var not = properties.get(\"not\");\n    var conjunction = properties.get(\"conjunction\");\n    if (!conjunction) conjunction = defaultConjunction(config);\n    var children = tree.get(\"children1\");\n    return buildEsGroup(children, conjunction, not, elasticSearchFormat, config);\n  }\n}"]},"metadata":{},"sourceType":"module"}