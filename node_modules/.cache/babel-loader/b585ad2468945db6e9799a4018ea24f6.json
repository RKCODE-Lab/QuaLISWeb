{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.sqlFormat = void 0;\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _configUtils = require(\"../utils/configUtils\");\n\nvar _ruleUtils = require(\"../utils/ruleUtils\");\n\nvar _omit = _interopRequireDefault(require(\"lodash/omit\"));\n\nvar _pick = _interopRequireDefault(require(\"lodash/pick\"));\n\nvar _stuff = require(\"../utils/stuff\");\n\nvar _defaultUtils = require(\"../utils/defaultUtils\");\n\nvar _default = require(\"../config/default\");\n\nvar _funcUtils = require(\"../utils/funcUtils\");\n\nvar _immutable = require(\"immutable\");\n\nvar _export = require(\"../utils/export\");\n\nvar sqlFormat = function sqlFormat(tree, config) {\n  //meta is mutable\n  var meta = {\n    errors: []\n  };\n  var res = formatItem(tree, config, meta);\n  if (meta.errors.length) console.warn(\"Errors while exporting to SQL:\", meta.errors);\n  return res;\n};\n\nexports.sqlFormat = sqlFormat;\n\nvar formatItem = function formatItem(item, config, meta) {\n  if (!item) return undefined;\n  var type = item.get(\"type\");\n  var children = item.get(\"children1\");\n\n  if ((type === \"group\" || type === \"rule_group\") && children && children.size) {\n    return formatGroup(item, config, meta);\n  } else if (type === \"rule\") {\n    return formatRule(item, config, meta);\n  }\n\n  return undefined;\n};\n\nvar formatGroup = function formatGroup(item, config, meta) {\n  var type = item.get(\"type\");\n  var properties = item.get(\"properties\") || new _immutable.Map();\n  var children = item.get(\"children1\");\n  var groupField = type === \"rule_group\" ? properties.get(\"field\") : null;\n  var groupFieldDef = (0, _configUtils.getFieldConfig)(config, groupField) || {};\n\n  if (groupFieldDef.mode == \"array\") {\n    meta.errors.push(\"Aggregation is not supported for \".concat(groupField));\n  }\n\n  var not = properties.get(\"not\");\n  var list = children.map(function (currentChild) {\n    return formatItem(currentChild, config, meta);\n  }).filter(function (currentChild) {\n    return typeof currentChild !== \"undefined\";\n  });\n  if (!list.size) return undefined;\n  var conjunction = properties.get(\"conjunction\");\n  if (!conjunction) conjunction = (0, _defaultUtils.defaultConjunction)(config);\n  var conjunctionDefinition = config.conjunctions[conjunction];\n  return conjunctionDefinition.sqlFormatConj(list, conjunction, not);\n};\n\nvar formatRule = function formatRule(item, config, meta) {\n  var properties = item.get(\"properties\") || new _immutable.Map();\n  var field = properties.get(\"field\");\n  var operator = properties.get(\"operator\");\n  var operatorOptions = properties.get(\"operatorOptions\");\n  var iValueSrc = properties.get(\"valueSrc\");\n  var iValueType = properties.get(\"valueType\");\n  var iValue = properties.get(\"value\");\n  if (field == null || operator == null) return undefined;\n  var fieldDefinition = (0, _configUtils.getFieldConfig)(config, field) || {};\n  var operatorDefinition = (0, _configUtils.getOperatorConfig)(config, operator, field) || {};\n  var reversedOp = operatorDefinition.reversedOp;\n  var revOperatorDefinition = (0, _configUtils.getOperatorConfig)(config, reversedOp, field) || {};\n  var cardinality = (0, _stuff.defaultValue)(operatorDefinition.cardinality, 1); //format value\n\n  var valueSrcs = [];\n  var valueTypes = [];\n  var fvalue = iValue.map(function (currentValue, ind) {\n    var valueSrc = iValueSrc ? iValueSrc.get(ind) : null;\n    var valueType = iValueType ? iValueType.get(ind) : null;\n    var cValue = (0, _funcUtils.completeValue)(currentValue, valueSrc, config);\n    var widget = (0, _ruleUtils.getWidgetForFieldOp)(config, field, operator, valueSrc);\n    var fieldWidgetDefinition = (0, _omit[\"default\"])((0, _configUtils.getFieldWidgetConfig)(config, field, operator, widget, valueSrc), [\"factory\"]);\n    var fv = formatValue(meta, config, cValue, valueSrc, valueType, fieldWidgetDefinition, fieldDefinition, operator, operatorDefinition);\n\n    if (fv !== undefined) {\n      valueSrcs.push(valueSrc);\n      valueTypes.push(valueType);\n    }\n\n    return fv;\n  });\n  var hasUndefinedValues = fvalue.filter(function (v) {\n    return v === undefined;\n  }).size > 0;\n  if (hasUndefinedValues || fvalue.size < cardinality) return undefined;\n  var formattedValue = cardinality == 1 ? fvalue.first() : fvalue; //find fn to format expr\n\n  var isRev = false;\n  var fn = operatorDefinition.sqlFormatOp;\n\n  if (!fn && reversedOp) {\n    fn = revOperatorDefinition.sqlFormatOp;\n\n    if (fn) {\n      isRev = true;\n    }\n  }\n\n  if (!fn) {\n    var sqlOp = operatorDefinition.sqlOp || operator;\n\n    if (cardinality == 0) {\n      fn = function fn(field, op, values, valueSrc, valueType, opDef, operatorOptions, fieldDef) {\n        return \"\".concat(field, \" \").concat(sqlOp);\n      };\n    } else if (cardinality == 1) {\n      fn = function fn(field, op, value, valueSrc, valueType, opDef, operatorOptions, fieldDef) {\n        return \"\".concat(field, \" \").concat(sqlOp, \" \").concat(value);\n      };\n    } else if (cardinality == 2) {\n      // between\n      fn = function fn(field, op, values, valueSrc, valueType, opDef, operatorOptions, fieldDef) {\n        var valFrom = values.first();\n        var valTo = values.get(1);\n        return \"\".concat(field, \" \").concat(sqlOp, \" \").concat(valFrom, \" AND \").concat(valTo);\n      };\n    }\n  }\n\n  if (!fn) {\n    meta.errors.push(\"Operator \".concat(operator, \" is not supported\"));\n    return undefined;\n  } //format field\n\n\n  var formattedField = formatField(meta, config, field); //format expr\n\n  var args = [formattedField, operator, formattedValue, valueSrcs.length > 1 ? valueSrcs : valueSrcs[0], valueTypes.length > 1 ? valueTypes : valueTypes[0], (0, _omit[\"default\"])(operatorDefinition, [\"formatOp\", \"mongoFormatOp\", \"sqlFormatOp\", \"jsonLogic\"]), operatorOptions, fieldDefinition];\n  var ret;\n  ret = fn.apply(void 0, args);\n\n  if (isRev) {\n    ret = config.settings.sqlFormatReverse(ret, operator, reversedOp, operatorDefinition, revOperatorDefinition);\n  }\n\n  if (ret === undefined) {\n    meta.errors.push(\"Operator \".concat(operator, \" is not supported for value source \").concat(valueSrcs.join(\", \")));\n    return undefined;\n  }\n\n  return ret;\n};\n\nvar formatValue = function formatValue(meta, config, currentValue, valueSrc, valueType, fieldWidgetDef, fieldDef, operator, operatorDef) {\n  if (currentValue === undefined) return undefined;\n  var ret;\n\n  if (valueSrc == \"field\") {\n    ret = formatField(meta, config, currentValue);\n  } else if (valueSrc == \"func\") {\n    ret = formatFunc(meta, config, currentValue);\n  } else {\n    if (typeof fieldWidgetDef.sqlFormatValue === \"function\") {\n      var fn = fieldWidgetDef.sqlFormatValue;\n      var args = [currentValue, (0, _pick[\"default\"])(fieldDef, [\"fieldSettings\", \"listValues\"]), //useful options: valueFormat for date/time\n      (0, _omit[\"default\"])(fieldWidgetDef, [\"formatValue\", \"mongoFormatValue\", \"sqlFormatValue\", \"jsonLogic\", \"elasticSearchFormatValue\"])];\n\n      if (operator) {\n        args.push(operator);\n        args.push(operatorDef);\n      }\n\n      if (valueSrc == \"field\") {\n        var valFieldDefinition = (0, _configUtils.getFieldConfig)(config, currentValue) || {};\n        args.push(valFieldDefinition);\n      }\n\n      ret = fn.apply(void 0, args);\n    } else {\n      ret = _export.SqlString.escape(currentValue);\n    }\n  }\n\n  return ret;\n};\n\nvar formatField = function formatField(meta, config, field) {\n  var fieldSeparator = config.settings.fieldSeparator;\n  var fieldDefinition = (0, _configUtils.getFieldConfig)(config, field) || {};\n  var fieldParts = Array.isArray(field) ? field : field.split(fieldSeparator);\n\n  var _fieldKeys = (0, _ruleUtils.getFieldPath)(field, config);\n\n  var fieldPartsLabels = (0, _ruleUtils.getFieldPathLabels)(field, config);\n  var fieldFullLabel = fieldPartsLabels ? fieldPartsLabels.join(fieldSeparator) : null;\n  var formatFieldFn = config.settings.formatField || _default.settings.formatField;\n  var fieldName = (0, _ruleUtils.formatFieldName)(field, config, meta);\n  var formattedField = formatFieldFn(fieldName, fieldParts, fieldFullLabel, fieldDefinition, config);\n  return formattedField;\n};\n\nvar formatFunc = function formatFunc(meta, config, currentValue) {\n  var funcKey = currentValue.get(\"func\");\n  var args = currentValue.get(\"args\");\n  var funcConfig = (0, _configUtils.getFuncConfig)(config, funcKey);\n  var funcName = funcConfig.sqlFunc || funcKey;\n  var formattedArgs = {};\n\n  for (var argKey in funcConfig.args) {\n    var argConfig = funcConfig.args[argKey];\n    var fieldDef = (0, _configUtils.getFieldConfig)(config, argConfig);\n    var argVal = args ? args.get(argKey) : undefined;\n    var argValue = argVal ? argVal.get(\"value\") : undefined;\n    var argValueSrc = argVal ? argVal.get(\"valueSrc\") : undefined;\n    var formattedArgVal = formatValue(meta, config, argValue, argValueSrc, argConfig.type, fieldDef, argConfig, null, null);\n\n    if (argValue != undefined && formattedArgVal === undefined) {\n      meta.errors.push(\"Can't format value of arg \".concat(argKey, \" for func \").concat(funcKey));\n      return undefined;\n    }\n\n    if (formattedArgVal !== undefined) {\n      // skip optional in the end\n      formattedArgs[argKey] = formattedArgVal;\n    }\n  }\n\n  var ret;\n\n  if (typeof funcConfig.sqlFormatFunc === \"function\") {\n    var fn = funcConfig.sqlFormatFunc;\n    var _args = [formattedArgs];\n    ret = fn.apply(void 0, _args);\n  } else {\n    var argsStr = Object.entries(formattedArgs).map(function (_ref) {\n      var _ref2 = (0, _slicedToArray2[\"default\"])(_ref, 2),\n          k = _ref2[0],\n          v = _ref2[1];\n\n      return v;\n    }).join(\", \");\n    ret = \"\".concat(funcName, \"(\").concat(argsStr, \")\");\n  }\n\n  return ret;\n};","map":{"version":3,"sources":["D:/Postgres_workingFolder/QuaLISWeb/node_modules/react-awesome-query-builder/lib/export/sql.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","sqlFormat","_slicedToArray2","_configUtils","_ruleUtils","_omit","_pick","_stuff","_defaultUtils","_default","_funcUtils","_immutable","_export","tree","config","meta","errors","res","formatItem","length","console","warn","item","undefined","type","get","children","size","formatGroup","formatRule","properties","Map","groupField","groupFieldDef","getFieldConfig","mode","push","concat","not","list","map","currentChild","filter","conjunction","defaultConjunction","conjunctionDefinition","conjunctions","sqlFormatConj","field","operator","operatorOptions","iValueSrc","iValueType","iValue","fieldDefinition","operatorDefinition","getOperatorConfig","reversedOp","revOperatorDefinition","cardinality","defaultValue","valueSrcs","valueTypes","fvalue","currentValue","ind","valueSrc","valueType","cValue","completeValue","widget","getWidgetForFieldOp","fieldWidgetDefinition","getFieldWidgetConfig","fv","formatValue","hasUndefinedValues","v","formattedValue","first","isRev","fn","sqlFormatOp","sqlOp","op","values","opDef","fieldDef","valFrom","valTo","formattedField","formatField","args","ret","apply","settings","sqlFormatReverse","join","fieldWidgetDef","operatorDef","formatFunc","sqlFormatValue","valFieldDefinition","SqlString","escape","fieldSeparator","fieldParts","Array","isArray","split","_fieldKeys","getFieldPath","fieldPartsLabels","getFieldPathLabels","fieldFullLabel","formatFieldFn","fieldName","formatFieldName","funcKey","funcConfig","getFuncConfig","funcName","sqlFunc","formattedArgs","argKey","argConfig","argVal","argValue","argValueSrc","formattedArgVal","sqlFormatFunc","_args","argsStr","entries","_ref","_ref2","k"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.sqlFormat = void 0;\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _configUtils = require(\"../utils/configUtils\");\n\nvar _ruleUtils = require(\"../utils/ruleUtils\");\n\nvar _omit = _interopRequireDefault(require(\"lodash/omit\"));\n\nvar _pick = _interopRequireDefault(require(\"lodash/pick\"));\n\nvar _stuff = require(\"../utils/stuff\");\n\nvar _defaultUtils = require(\"../utils/defaultUtils\");\n\nvar _default = require(\"../config/default\");\n\nvar _funcUtils = require(\"../utils/funcUtils\");\n\nvar _immutable = require(\"immutable\");\n\nvar _export = require(\"../utils/export\");\n\nvar sqlFormat = function sqlFormat(tree, config) {\n  //meta is mutable\n  var meta = {\n    errors: []\n  };\n  var res = formatItem(tree, config, meta);\n  if (meta.errors.length) console.warn(\"Errors while exporting to SQL:\", meta.errors);\n  return res;\n};\n\nexports.sqlFormat = sqlFormat;\n\nvar formatItem = function formatItem(item, config, meta) {\n  if (!item) return undefined;\n  var type = item.get(\"type\");\n  var children = item.get(\"children1\");\n\n  if ((type === \"group\" || type === \"rule_group\") && children && children.size) {\n    return formatGroup(item, config, meta);\n  } else if (type === \"rule\") {\n    return formatRule(item, config, meta);\n  }\n\n  return undefined;\n};\n\nvar formatGroup = function formatGroup(item, config, meta) {\n  var type = item.get(\"type\");\n  var properties = item.get(\"properties\") || new _immutable.Map();\n  var children = item.get(\"children1\");\n  var groupField = type === \"rule_group\" ? properties.get(\"field\") : null;\n  var groupFieldDef = (0, _configUtils.getFieldConfig)(config, groupField) || {};\n\n  if (groupFieldDef.mode == \"array\") {\n    meta.errors.push(\"Aggregation is not supported for \".concat(groupField));\n  }\n\n  var not = properties.get(\"not\");\n  var list = children.map(function (currentChild) {\n    return formatItem(currentChild, config, meta);\n  }).filter(function (currentChild) {\n    return typeof currentChild !== \"undefined\";\n  });\n  if (!list.size) return undefined;\n  var conjunction = properties.get(\"conjunction\");\n  if (!conjunction) conjunction = (0, _defaultUtils.defaultConjunction)(config);\n  var conjunctionDefinition = config.conjunctions[conjunction];\n  return conjunctionDefinition.sqlFormatConj(list, conjunction, not);\n};\n\nvar formatRule = function formatRule(item, config, meta) {\n  var properties = item.get(\"properties\") || new _immutable.Map();\n  var field = properties.get(\"field\");\n  var operator = properties.get(\"operator\");\n  var operatorOptions = properties.get(\"operatorOptions\");\n  var iValueSrc = properties.get(\"valueSrc\");\n  var iValueType = properties.get(\"valueType\");\n  var iValue = properties.get(\"value\");\n  if (field == null || operator == null) return undefined;\n  var fieldDefinition = (0, _configUtils.getFieldConfig)(config, field) || {};\n  var operatorDefinition = (0, _configUtils.getOperatorConfig)(config, operator, field) || {};\n  var reversedOp = operatorDefinition.reversedOp;\n  var revOperatorDefinition = (0, _configUtils.getOperatorConfig)(config, reversedOp, field) || {};\n  var cardinality = (0, _stuff.defaultValue)(operatorDefinition.cardinality, 1); //format value\n\n  var valueSrcs = [];\n  var valueTypes = [];\n  var fvalue = iValue.map(function (currentValue, ind) {\n    var valueSrc = iValueSrc ? iValueSrc.get(ind) : null;\n    var valueType = iValueType ? iValueType.get(ind) : null;\n    var cValue = (0, _funcUtils.completeValue)(currentValue, valueSrc, config);\n    var widget = (0, _ruleUtils.getWidgetForFieldOp)(config, field, operator, valueSrc);\n    var fieldWidgetDefinition = (0, _omit[\"default\"])((0, _configUtils.getFieldWidgetConfig)(config, field, operator, widget, valueSrc), [\"factory\"]);\n    var fv = formatValue(meta, config, cValue, valueSrc, valueType, fieldWidgetDefinition, fieldDefinition, operator, operatorDefinition);\n\n    if (fv !== undefined) {\n      valueSrcs.push(valueSrc);\n      valueTypes.push(valueType);\n    }\n\n    return fv;\n  });\n  var hasUndefinedValues = fvalue.filter(function (v) {\n    return v === undefined;\n  }).size > 0;\n  if (hasUndefinedValues || fvalue.size < cardinality) return undefined;\n  var formattedValue = cardinality == 1 ? fvalue.first() : fvalue; //find fn to format expr\n\n  var isRev = false;\n  var fn = operatorDefinition.sqlFormatOp;\n\n  if (!fn && reversedOp) {\n    fn = revOperatorDefinition.sqlFormatOp;\n\n    if (fn) {\n      isRev = true;\n    }\n  }\n\n  if (!fn) {\n    var sqlOp = operatorDefinition.sqlOp || operator;\n\n    if (cardinality == 0) {\n      fn = function fn(field, op, values, valueSrc, valueType, opDef, operatorOptions, fieldDef) {\n        return \"\".concat(field, \" \").concat(sqlOp);\n      };\n    } else if (cardinality == 1) {\n      fn = function fn(field, op, value, valueSrc, valueType, opDef, operatorOptions, fieldDef) {\n        return \"\".concat(field, \" \").concat(sqlOp, \" \").concat(value);\n      };\n    } else if (cardinality == 2) {\n      // between\n      fn = function fn(field, op, values, valueSrc, valueType, opDef, operatorOptions, fieldDef) {\n        var valFrom = values.first();\n        var valTo = values.get(1);\n        return \"\".concat(field, \" \").concat(sqlOp, \" \").concat(valFrom, \" AND \").concat(valTo);\n      };\n    }\n  }\n\n  if (!fn) {\n    meta.errors.push(\"Operator \".concat(operator, \" is not supported\"));\n    return undefined;\n  } //format field\n\n\n  var formattedField = formatField(meta, config, field); //format expr\n\n  var args = [formattedField, operator, formattedValue, valueSrcs.length > 1 ? valueSrcs : valueSrcs[0], valueTypes.length > 1 ? valueTypes : valueTypes[0], (0, _omit[\"default\"])(operatorDefinition, [\"formatOp\", \"mongoFormatOp\", \"sqlFormatOp\", \"jsonLogic\"]), operatorOptions, fieldDefinition];\n  var ret;\n  ret = fn.apply(void 0, args);\n\n  if (isRev) {\n    ret = config.settings.sqlFormatReverse(ret, operator, reversedOp, operatorDefinition, revOperatorDefinition);\n  }\n\n  if (ret === undefined) {\n    meta.errors.push(\"Operator \".concat(operator, \" is not supported for value source \").concat(valueSrcs.join(\", \")));\n    return undefined;\n  }\n\n  return ret;\n};\n\nvar formatValue = function formatValue(meta, config, currentValue, valueSrc, valueType, fieldWidgetDef, fieldDef, operator, operatorDef) {\n  if (currentValue === undefined) return undefined;\n  var ret;\n\n  if (valueSrc == \"field\") {\n    ret = formatField(meta, config, currentValue);\n  } else if (valueSrc == \"func\") {\n    ret = formatFunc(meta, config, currentValue);\n  } else {\n    if (typeof fieldWidgetDef.sqlFormatValue === \"function\") {\n      var fn = fieldWidgetDef.sqlFormatValue;\n      var args = [currentValue, (0, _pick[\"default\"])(fieldDef, [\"fieldSettings\", \"listValues\"]), //useful options: valueFormat for date/time\n      (0, _omit[\"default\"])(fieldWidgetDef, [\"formatValue\", \"mongoFormatValue\", \"sqlFormatValue\", \"jsonLogic\", \"elasticSearchFormatValue\"])];\n\n      if (operator) {\n        args.push(operator);\n        args.push(operatorDef);\n      }\n\n      if (valueSrc == \"field\") {\n        var valFieldDefinition = (0, _configUtils.getFieldConfig)(config, currentValue) || {};\n        args.push(valFieldDefinition);\n      }\n\n      ret = fn.apply(void 0, args);\n    } else {\n      ret = _export.SqlString.escape(currentValue);\n    }\n  }\n\n  return ret;\n};\n\nvar formatField = function formatField(meta, config, field) {\n  var fieldSeparator = config.settings.fieldSeparator;\n  var fieldDefinition = (0, _configUtils.getFieldConfig)(config, field) || {};\n  var fieldParts = Array.isArray(field) ? field : field.split(fieldSeparator);\n\n  var _fieldKeys = (0, _ruleUtils.getFieldPath)(field, config);\n\n  var fieldPartsLabels = (0, _ruleUtils.getFieldPathLabels)(field, config);\n  var fieldFullLabel = fieldPartsLabels ? fieldPartsLabels.join(fieldSeparator) : null;\n  var formatFieldFn = config.settings.formatField || _default.settings.formatField;\n  var fieldName = (0, _ruleUtils.formatFieldName)(field, config, meta);\n  var formattedField = formatFieldFn(fieldName, fieldParts, fieldFullLabel, fieldDefinition, config);\n  return formattedField;\n};\n\nvar formatFunc = function formatFunc(meta, config, currentValue) {\n  var funcKey = currentValue.get(\"func\");\n  var args = currentValue.get(\"args\");\n  var funcConfig = (0, _configUtils.getFuncConfig)(config, funcKey);\n  var funcName = funcConfig.sqlFunc || funcKey;\n  var formattedArgs = {};\n\n  for (var argKey in funcConfig.args) {\n    var argConfig = funcConfig.args[argKey];\n    var fieldDef = (0, _configUtils.getFieldConfig)(config, argConfig);\n    var argVal = args ? args.get(argKey) : undefined;\n    var argValue = argVal ? argVal.get(\"value\") : undefined;\n    var argValueSrc = argVal ? argVal.get(\"valueSrc\") : undefined;\n    var formattedArgVal = formatValue(meta, config, argValue, argValueSrc, argConfig.type, fieldDef, argConfig, null, null);\n\n    if (argValue != undefined && formattedArgVal === undefined) {\n      meta.errors.push(\"Can't format value of arg \".concat(argKey, \" for func \").concat(funcKey));\n      return undefined;\n    }\n\n    if (formattedArgVal !== undefined) {\n      // skip optional in the end\n      formattedArgs[argKey] = formattedArgVal;\n    }\n  }\n\n  var ret;\n\n  if (typeof funcConfig.sqlFormatFunc === \"function\") {\n    var fn = funcConfig.sqlFormatFunc;\n    var _args = [formattedArgs];\n    ret = fn.apply(void 0, _args);\n  } else {\n    var argsStr = Object.entries(formattedArgs).map(function (_ref) {\n      var _ref2 = (0, _slicedToArray2[\"default\"])(_ref, 2),\n          k = _ref2[0],\n          v = _ref2[1];\n\n      return v;\n    }).join(\", \");\n    ret = \"\".concat(funcName, \"(\").concat(argsStr, \")\");\n  }\n\n  return ret;\n};"]},"metadata":{},"sourceType":"script"}