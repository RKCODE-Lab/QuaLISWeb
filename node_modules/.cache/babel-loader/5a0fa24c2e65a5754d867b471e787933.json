{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _typeof = require(\"@babel/runtime/helpers/typeof\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime/helpers/assertThisInitialized\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _react = _interopRequireWildcard(require(\"react\"));\n\nvar _reactRedux = require(\"react-redux\");\n\nvar _treeUtils = require(\"../../utils/treeUtils\");\n\nvar _stuff = require(\"../../utils/stuff\");\n\nvar _context = _interopRequireDefault(require(\"../../stores/context\"));\n\nvar constants = _interopRequireWildcard(require(\"../../constants\"));\n\nvar _clone = _interopRequireDefault(require(\"clone\"));\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar actions = _interopRequireWildcard(require(\"../../actions\"));\n\nvar _reactUtils = require(\"../../utils/reactUtils\");\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n    return {\n      \"default\": obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache(nodeInterop);\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj[\"default\"] = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = (0, _getPrototypeOf2[\"default\"])(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = (0, _getPrototypeOf2[\"default\"])(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return (0, _possibleConstructorReturn2[\"default\"])(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nvar createSortableContainer = function createSortableContainer(Builder) {\n  var _class;\n\n  var CanMoveFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  return _class = /*#__PURE__*/function (_Component) {\n    (0, _inherits2[\"default\"])(SortableContainer, _Component);\n\n    var _super = _createSuper(SortableContainer);\n\n    function SortableContainer(props) {\n      var _this;\n\n      (0, _classCallCheck2[\"default\"])(this, SortableContainer);\n      _this = _super.call(this, props);\n\n      _this._getEventTarget = function (e, dragStart) {\n        return e && e.__mocked_window || document.body || window;\n      };\n\n      _this.onDragStart = function (id, dom, e) {\n        var treeEl = dom.closest(\".query-builder\");\n        document.body.classList.add(\"qb-dragging\");\n        treeEl.classList.add(\"qb-dragging\");\n        var treeElContainer = treeEl.closest(\".query-builder-container\") || treeEl;\n        treeElContainer = _this._getScrollParent(treeElContainer) || document.body;\n        var scrollTop = treeElContainer.scrollTop;\n\n        var _dragEl = _this._getDraggableNodeEl(treeEl);\n\n        var _plhEl = _this._getPlaceholderNodeEl(treeEl);\n\n        var tmpAllGroups = treeEl.querySelectorAll(\".group--children\");\n        var anyGroup = tmpAllGroups.length ? tmpAllGroups[0] : null;\n        var groupPadding;\n\n        if (anyGroup) {\n          groupPadding = window.getComputedStyle(anyGroup, null).getPropertyValue(\"padding-left\");\n          groupPadding = parseInt(groupPadding);\n        }\n\n        var dragging = {\n          id: id,\n          x: dom.offsetLeft,\n          y: dom.offsetTop,\n          w: dom.offsetWidth,\n          h: dom.offsetHeight,\n          itemInfo: _this.tree.items[id],\n          paddingLeft: groupPadding\n        };\n        var dragStart = {\n          id: id,\n          x: dom.offsetLeft,\n          y: dom.offsetTop,\n          scrollTop: scrollTop,\n          clientX: e.clientX,\n          clientY: e.clientY,\n          itemInfo: (0, _clone[\"default\"])(_this.tree.items[id]),\n          treeEl: treeEl,\n          treeElContainer: treeElContainer\n        };\n        var mousePos = {\n          clientX: e.clientX,\n          clientY: e.clientY\n        };\n\n        var target = _this._getEventTarget(e, dragStart);\n\n        _this.eventTarget = target;\n        target.addEventListener(\"mousemove\", _this.onDrag);\n        target.addEventListener(\"mouseup\", _this.onDragEnd);\n\n        _this.props.setDragStart(dragStart, dragging, mousePos);\n      };\n\n      _this.onDrag = function (e) {\n        var doHandleDrag = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        var dragging = Object.assign({}, _this.props.dragging);\n        var startDragging = _this.props.dragStart;\n        var paddingLeft = dragging.paddingLeft; //this.props.paddingLeft;\n\n        var treeElContainer = startDragging.treeElContainer;\n        var scrollTop = treeElContainer.scrollTop;\n        dragging.itemInfo = _this.tree.items[dragging.id];\n\n        if (!dragging.itemInfo) {\n          return;\n        }\n\n        var mousePos = {\n          clientX: e.clientX,\n          clientY: e.clientY\n        };\n        var startMousePos = {\n          clientX: startDragging.clientX,\n          clientY: startDragging.clientY\n        };\n\n        if (e.__mock_dom) {\n          var treeEl = startDragging.treeEl;\n\n          var dragEl = _this._getDraggableNodeEl(treeEl);\n\n          var plhEl = _this._getPlaceholderNodeEl(treeEl);\n\n          e.__mock_dom({\n            treeEl: treeEl,\n            dragEl: dragEl,\n            plhEl: plhEl\n          });\n        } //first init plX/plY\n\n\n        if (!startDragging.plX) {\n          var _treeEl = startDragging.treeEl;\n\n          var _plhEl2 = _this._getPlaceholderNodeEl(_treeEl);\n\n          if (_plhEl2) {\n            startDragging.plX = _plhEl2.getBoundingClientRect().left + window.scrollX;\n            startDragging.plY = _plhEl2.getBoundingClientRect().top + window.scrollY;\n          }\n        }\n\n        var startX = startDragging.x;\n        var startY = startDragging.y;\n        var startClientX = startDragging.clientX;\n        var startClientY = startDragging.clientY;\n        var startScrollTop = startDragging.scrollTop;\n        var pos = {\n          x: startX + (e.clientX - startClientX),\n          y: startY + (e.clientY - startClientY) + (scrollTop - startScrollTop)\n        };\n        dragging.x = pos.x;\n        dragging.y = pos.y;\n        dragging.paddingLeft = paddingLeft;\n        dragging.mousePos = mousePos;\n        dragging.startMousePos = startMousePos;\n\n        _this.props.setDragProgress(mousePos, dragging);\n\n        var moved = doHandleDrag ? _this.handleDrag(dragging, e, CanMoveFn) : false;\n\n        if (!moved) {\n          if (e.preventDefault) e.preventDefault();\n        }\n      };\n\n      _this.onDragEnd = function () {\n        var treeEl = _this.props.dragStart.treeEl;\n\n        _this.props.setDragEnd();\n\n        treeEl.classList.remove(\"qb-dragging\");\n        document.body.classList.remove(\"qb-dragging\");\n        _this._cacheEls = {};\n\n        var target = _this.eventTarget || _this._getEventTarget();\n\n        target.removeEventListener(\"mousemove\", _this.onDrag);\n        target.removeEventListener(\"mouseup\", _this.onDragEnd);\n      };\n\n      (0, _reactUtils.useOnPropsChanged)((0, _assertThisInitialized2[\"default\"])(_this));\n\n      _this.onPropsChanged(props);\n\n      return _this;\n    }\n\n    (0, _createClass2[\"default\"])(SortableContainer, [{\n      key: \"onPropsChanged\",\n      value: function onPropsChanged(nextProps) {\n        this.tree = (0, _treeUtils.getFlatTree)(nextProps.tree);\n      }\n    }, {\n      key: \"shouldComponentUpdate\",\n      value: function shouldComponentUpdate(nextProps, nextState) {\n        var prevProps = this.props;\n        var prevState = this.state;\n        var should = (0, _reactUtils.pureShouldComponentUpdate)(this)(nextProps, nextState);\n\n        if (should) {\n          if (prevState == nextState && prevProps != nextProps) {\n            var chs = [];\n\n            for (var k in nextProps) {\n              var changed = nextProps[k] != prevProps[k];\n\n              if (changed) {\n                //don't render <Builder> on dragging - appropriate redux-connected components will do it\n                if (k != \"dragging\" && k != \"mousePos\") chs.push(k);\n              }\n            }\n\n            if (!chs.length) should = false;\n          }\n        }\n\n        return should;\n      }\n    }, {\n      key: \"componentDidUpdate\",\n      value: function componentDidUpdate(_prevProps, _prevState) {\n        var dragging = this.props.dragging;\n        var startDragging = this.props.dragStart;\n\n        if (startDragging && startDragging.id) {\n          dragging.itemInfo = this.tree.items[dragging.id];\n\n          if (dragging.itemInfo) {\n            if (dragging.itemInfo.index != startDragging.itemInfo.index || dragging.itemInfo.parent != startDragging.itemInfo.parent) {\n              var treeEl = startDragging.treeEl;\n              var treeElContainer = startDragging.treeElContainer;\n\n              var plhEl = this._getPlaceholderNodeEl(treeEl, true);\n\n              if (plhEl) {\n                var plX = plhEl.getBoundingClientRect().left + window.scrollX;\n                var plY = plhEl.getBoundingClientRect().top + window.scrollY;\n                var oldPlX = startDragging.plX;\n                var oldPlY = startDragging.plY;\n                var scrollTop = treeElContainer.scrollTop;\n                startDragging.plX = plX;\n                startDragging.plY = plY;\n                startDragging.itemInfo = (0, _clone[\"default\"])(dragging.itemInfo);\n                startDragging.y = plhEl.offsetTop;\n                startDragging.x = plhEl.offsetLeft;\n                startDragging.clientY += plY - oldPlY;\n                startDragging.clientX += plX - oldPlX;\n                if (treeElContainer != document.body) startDragging.scrollTop = scrollTop;\n                this.onDrag(this.props.mousePos, false);\n              }\n            }\n          }\n        }\n      }\n    }, {\n      key: \"_getNodeElById\",\n      value: function _getNodeElById(treeEl, indexId) {\n        var ignoreCache = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        if (indexId == null) return null;\n        if (!this._cacheEls) this._cacheEls = {};\n        var el = this._cacheEls[indexId];\n        if (el && document.contains(el) && !ignoreCache) return el;\n        el = treeEl.querySelector('.group-or-rule-container[data-id=\"' + indexId + '\"]');\n        this._cacheEls[indexId] = el;\n        return el;\n      }\n    }, {\n      key: \"_getDraggableNodeEl\",\n      value: function _getDraggableNodeEl(treeEl) {\n        var ignoreCache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        if (!this._cacheEls) this._cacheEls = {};\n        var el = this._cacheEls[\"draggable\"];\n        if (el && document.contains(el) && !ignoreCache) return el;\n        var els = treeEl.getElementsByClassName(\"qb-draggable\");\n        el = els.length ? els[0] : null;\n        this._cacheEls[\"draggable\"] = el;\n        return el;\n      }\n    }, {\n      key: \"_getPlaceholderNodeEl\",\n      value: function _getPlaceholderNodeEl(treeEl) {\n        var ignoreCache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        if (!this._cacheEls) this._cacheEls = {};\n        var el = this._cacheEls[\"placeholder\"];\n        if (el && document.contains(el) && !ignoreCache) return el;\n        var els = treeEl.getElementsByClassName(\"qb-placeholder\");\n        el = els.length ? els[0] : null;\n        this._cacheEls[\"placeholder\"] = el;\n        return el;\n      }\n    }, {\n      key: \"_isScrollable\",\n      value: function _isScrollable(node) {\n        var overflowY = window.getComputedStyle(node)[\"overflow-y\"];\n        return (overflowY === \"scroll\" || overflowY === \"auto\") && node.scrollHeight > node.offsetHeight;\n      }\n    }, {\n      key: \"_getScrollParent\",\n      value: function _getScrollParent(node) {\n        if (node == null) return null;\n\n        if (node === document.body || this._isScrollable(node)) {\n          return node;\n        } else {\n          return this._getScrollParent(node.parentNode);\n        }\n      }\n    }, {\n      key: \"handleDrag\",\n      value: function handleDrag(dragInfo, e, canMoveFn) {\n        var _this2 = this;\n\n        var canMoveBeforeAfterGroup = true;\n        var itemInfo = dragInfo.itemInfo;\n        var paddingLeft = dragInfo.paddingLeft;\n        var moveInfo = null;\n        var treeEl = this.props.dragStart.treeEl;\n        var dragId = dragInfo.id;\n\n        var dragEl = this._getDraggableNodeEl(treeEl);\n\n        var plhEl = this._getPlaceholderNodeEl(treeEl);\n\n        var dragRect, plhRect, hovRect, treeRect;\n\n        if (dragEl && plhEl) {\n          dragRect = dragEl.getBoundingClientRect();\n          plhRect = plhEl.getBoundingClientRect();\n\n          if (!plhRect.width) {\n            return;\n          }\n\n          var dragDirs = {\n            hrz: 0,\n            vrt: 0\n          };\n          if (dragRect.top < plhRect.top) dragDirs.vrt = -1; //up\n          else if (dragRect.bottom > plhRect.bottom) dragDirs.vrt = +1; //down\n\n          if (dragRect.left > plhRect.left) dragDirs.hrz = +1; //right\n          else if (dragRect.left < plhRect.left) dragDirs.hrz = -1; //left\n\n          treeRect = treeEl.getBoundingClientRect();\n          var trgCoord = {\n            x: treeRect.left + (treeRect.right - treeRect.left) / 2,\n            y: dragDirs.vrt >= 0 ? dragRect.bottom : dragRect.top\n          };\n          var hovCNodeEl;\n\n          if (e.__mocked_hov_container) {\n            hovCNodeEl = e.__mocked_hov_container;\n          } else {\n            var hovNodeEl = document.elementFromPoint(trgCoord.x, trgCoord.y - 1);\n            hovCNodeEl = hovNodeEl ? hovNodeEl.closest(\".group-or-rule-container\") : null;\n\n            if (!hovCNodeEl && hovNodeEl && hovNodeEl.classList.contains(\"query-builder-container\")) {\n              var _hovNodeEl$firstChild; // fix 2022-01-24 - get root .group-or-rule-container\n\n\n              var rootGroupContainer = hovNodeEl === null || hovNodeEl === void 0 ? void 0 : (_hovNodeEl$firstChild = hovNodeEl.firstChild) === null || _hovNodeEl$firstChild === void 0 ? void 0 : _hovNodeEl$firstChild.firstChild;\n\n              if (rootGroupContainer && rootGroupContainer.classList.contains(\"group-or-rule-container\")) {\n                hovCNodeEl = rootGroupContainer;\n              }\n            }\n          }\n\n          if (!hovCNodeEl) {\n            _stuff.logger.log(\"out of tree bounds!\");\n          } else {\n            var isGroup = hovCNodeEl.classList.contains(\"group-container\");\n            var hovNodeId = hovCNodeEl.getAttribute(\"data-id\");\n            var hovEl = hovCNodeEl;\n            var doAppend = false;\n            var doPrepend = false;\n\n            if (hovEl) {\n              hovRect = hovEl.getBoundingClientRect();\n              var hovHeight = hovRect.bottom - hovRect.top;\n              var hovII = this.tree.items[hovNodeId];\n              var trgRect = null,\n                  trgEl = null,\n                  trgII = null,\n                  altII = null; //for canMoveBeforeAfterGroup\n\n              if (dragDirs.vrt == 0) {\n                trgII = itemInfo;\n                trgEl = plhEl;\n                if (trgEl) trgRect = trgEl.getBoundingClientRect();\n              } else {\n                if (isGroup) {\n                  if (dragDirs.vrt > 0) {\n                    //down\n                    //take group header (for prepend only)\n                    var hovInnerEl = hovCNodeEl.getElementsByClassName(\"group--header\");\n                    var hovEl2 = hovInnerEl.length ? hovInnerEl[0] : null;\n\n                    if (hovEl2) {\n                      var hovRect2 = hovEl2.getBoundingClientRect();\n                      var hovHeight2 = hovRect2.bottom - hovRect2.top;\n                      var isOverHover = dragRect.bottom - hovRect2.top > hovHeight2 * 3 / 4;\n\n                      if (isOverHover && hovII.top > dragInfo.itemInfo.top) {\n                        trgII = hovII;\n                        trgRect = hovRect2;\n                        trgEl = hovEl2;\n                        doPrepend = true;\n                      }\n                    }\n                  } else if (dragDirs.vrt < 0) {\n                    //up\n                    if (hovII.lev >= itemInfo.lev) {\n                      //take whole group\n                      var isClimbToHover = hovRect.bottom - dragRect.top >= 2;\n\n                      if (isClimbToHover && hovII.top < dragInfo.itemInfo.top) {\n                        trgII = hovII;\n                        trgRect = hovRect;\n                        trgEl = hovEl;\n                        doAppend = true;\n                      }\n                    }\n                  }\n\n                  if (!doPrepend && !doAppend || canMoveBeforeAfterGroup) {\n                    //take whole group and check if we can move before/after group\n                    var _isOverHover = dragDirs.vrt < 0 //up\n                    ? hovRect.bottom - dragRect.top > hovHeight - 5 : dragRect.bottom - hovRect.top > hovHeight - 5;\n\n                    if (_isOverHover) {\n                      if (!doPrepend && !doAppend) {\n                        trgII = hovII;\n                        trgRect = hovRect;\n                        trgEl = hovEl;\n                      }\n\n                      if (canMoveBeforeAfterGroup) {\n                        altII = hovII;\n                      }\n                    }\n                  }\n                } else {\n                  //check if we can move before/after group\n                  var _isOverHover2 = dragDirs.vrt < 0 //up\n                  ? hovRect.bottom - dragRect.top > hovHeight / 2 : dragRect.bottom - hovRect.top > hovHeight / 2;\n\n                  if (_isOverHover2) {\n                    trgII = hovII;\n                    trgRect = hovRect;\n                    trgEl = hovEl;\n                  }\n                }\n              }\n\n              var isSamePos = trgII && trgII.id == dragId;\n\n              if (trgRect) {\n                var dragLeftOffset = dragRect.left - treeRect.left;\n                var trgLeftOffset = trgRect.left - treeRect.left;\n\n                var _trgLev = trgLeftOffset / paddingLeft;\n\n                var dragLev = Math.max(0, Math.round(dragLeftOffset / paddingLeft)); //find all possible moves\n\n                var availMoves = [];\n                var altMoves = []; //alternatively can move after/before group, if can't move into it\n\n                if (isSamePos) {//do nothing\n                } else {\n                  if (isGroup) {\n                    if (doAppend) {\n                      availMoves.push([constants.PLACEMENT_APPEND, trgII, trgII.lev + 1]);\n                    } else if (doPrepend) {\n                      availMoves.push([constants.PLACEMENT_PREPEND, trgII, trgII.lev + 1]);\n                    } //alt\n\n\n                    if (canMoveBeforeAfterGroup && altII) {\n                      // fix 2022-01-24: do prepend/append instead of before/after for root\n                      var isToRoot = altII.lev == 0; // fix 2022-01-25: fix prepend/append instead of before/after for case_group\n\n                      var isToCase = altII.type == \"case_group\" && itemInfo.type != \"case_group\";\n                      var prevCaseId = altII.prev && this.tree.items[altII.prev].caseId;\n                      var nextCaseId = altII.next && this.tree.items[altII.next].caseId;\n                      if (itemInfo.caseId == prevCaseId) prevCaseId = null;\n                      if (itemInfo.caseId == nextCaseId) nextCaseId = null;\n                      var prevCase = prevCaseId && this.tree.items[prevCaseId];\n                      var nextCase = nextCaseId && this.tree.items[nextCaseId];\n\n                      if (dragDirs.vrt > 0) {\n                        //down\n                        if (isToRoot) {\n                          altMoves.push([constants.PLACEMENT_APPEND, altII, altII.lev + 1]);\n                        } else if (isToCase && nextCase) {\n                          altMoves.push([constants.PLACEMENT_PREPEND, nextCase, nextCase.lev + 1]);\n                        } else {\n                          altMoves.push([constants.PLACEMENT_AFTER, altII, altII.lev]);\n                        }\n                      } else if (dragDirs.vrt < 0) {\n                        //up\n                        if (isToRoot) {\n                          altMoves.push([constants.PLACEMENT_PREPEND, altII, altII.lev + 1]);\n                        } else if (isToCase && prevCase) {\n                          altMoves.push([constants.PLACEMENT_APPEND, prevCase, prevCase.lev + 1]);\n                        } else {\n                          altMoves.push([constants.PLACEMENT_BEFORE, altII, altII.lev]);\n                        }\n                      }\n                    }\n                  }\n\n                  if (!doAppend && !doPrepend) {\n                    if (dragDirs.vrt < 0) {\n                      //up\n                      availMoves.push([constants.PLACEMENT_BEFORE, trgII, trgII.lev]);\n                    } else if (dragDirs.vrt > 0) {\n                      //down\n                      availMoves.push([constants.PLACEMENT_AFTER, trgII, trgII.lev]);\n                    }\n                  }\n                } //add case\n\n\n                var addCaseII = function addCaseII(am) {\n                  var toII = am[1];\n                  var fromCaseII = itemInfo.caseId ? _this2.tree.items[itemInfo.caseId] : null;\n                  var toCaseII = toII.caseId ? _this2.tree.items[toII.caseId] : null;\n                  return [].concat((0, _toConsumableArray2[\"default\"])(am), [fromCaseII, toCaseII]);\n                };\n\n                availMoves = availMoves.map(addCaseII);\n                altMoves = altMoves.map(addCaseII); //sanitize\n\n                availMoves = availMoves.filter(function (am) {\n                  var placement = am[0];\n                  var trg = am[1];\n                  if ((placement == constants.PLACEMENT_BEFORE || placement == constants.PLACEMENT_AFTER) && trg.parent == null) return false;\n                  if (trg.collapsed && (placement == constants.PLACEMENT_APPEND || placement == constants.PLACEMENT_PREPEND)) return false;\n                  var isInside = trg.id == itemInfo.id;\n\n                  if (!isInside) {\n                    var tmp = trg;\n\n                    while (tmp.parent) {\n                      tmp = _this2.tree.items[tmp.parent];\n\n                      if (tmp.id == itemInfo.id) {\n                        isInside = true;\n                        break;\n                      }\n                    }\n                  }\n\n                  return !isInside;\n                }).map(function (am) {\n                  var placement = am[0],\n                      toII = am[1],\n                      _lev = am[2],\n                      _fromCaseII = am[3],\n                      _toCaseII = am[4];\n                  var toParentII = null;\n                  if (placement == constants.PLACEMENT_APPEND || placement == constants.PLACEMENT_PREPEND) toParentII = toII;else toParentII = _this2.tree.items[toII.parent];\n                  if (toParentII && toParentII.parent == null) toParentII = null;\n                  am[5] = toParentII;\n                  return am;\n                });\n                var bestMode = null;\n                var filteredMoves = availMoves.filter(function (am) {\n                  return _this2.canMove(itemInfo, am[1], am[0], am[3], am[4], am[5], canMoveFn);\n                });\n\n                if (canMoveBeforeAfterGroup && filteredMoves.length == 0 && altMoves.length > 0) {\n                  filteredMoves = altMoves.filter(function (am) {\n                    return _this2.canMove(itemInfo, am[1], am[0], am[3], am[4], am[5], canMoveFn);\n                  });\n                }\n\n                var levs = filteredMoves.map(function (am) {\n                  return am[2];\n                });\n                var curLev = itemInfo.lev;\n                var allLevs = levs.concat(curLev);\n                var closestDragLev = null;\n                if (allLevs.indexOf(dragLev) != -1) closestDragLev = dragLev;else if (dragLev > Math.max.apply(Math, (0, _toConsumableArray2[\"default\"])(allLevs))) closestDragLev = Math.max.apply(Math, (0, _toConsumableArray2[\"default\"])(allLevs));else if (dragLev < Math.min.apply(Math, (0, _toConsumableArray2[\"default\"])(allLevs))) closestDragLev = Math.min.apply(Math, (0, _toConsumableArray2[\"default\"])(allLevs));\n                bestMode = filteredMoves.find(function (am) {\n                  return am[2] == closestDragLev;\n                });\n                if (!isSamePos && !bestMode && filteredMoves.length) bestMode = filteredMoves[0];\n                moveInfo = bestMode;\n              }\n            }\n          }\n        }\n\n        if (moveInfo) {\n          this.move(itemInfo, moveInfo[1], moveInfo[0], moveInfo[3]); // logger.log(\"DRAG-N-DROP\", JSON.stringify({\n          //   dragRect,\n          //   plhRect,\n          //   treeRect,\n          //   hovRect,\n          //   startMousePos: dragInfo.startMousePos,\n          //   mousePos: dragInfo.mousePos,\n          // }));\n\n          return true;\n        }\n\n        return false;\n      }\n    }, {\n      key: \"canMove\",\n      value: function canMove(fromII, toII, placement, fromCaseII, toCaseII, toParentII, canMoveFn) {\n        if (!fromII || !toII) return false;\n        if (fromII.id === toII.id) return false;\n        var _this$props$config$se = this.props.config.settings,\n            canRegroup = _this$props$config$se.canRegroup,\n            canRegroupCases = _this$props$config$se.canRegroupCases,\n            maxNesting = _this$props$config$se.maxNesting,\n            maxNumberOfRules = _this$props$config$se.maxNumberOfRules,\n            canLeaveEmptyCase = _this$props$config$se.canLeaveEmptyCase;\n        var newLev = toParentII ? toParentII.lev + 1 : toII.lev;\n        var isBeforeAfter = placement == constants.PLACEMENT_BEFORE || placement == constants.PLACEMENT_AFTER;\n        var isPend = placement == constants.PLACEMENT_PREPEND || placement == constants.PLACEMENT_APPEND;\n        var isLev1 = isBeforeAfter && toII.lev == 1 || isPend && toII.lev == 0;\n        var isParentChange = fromII.parent != toII.parent;\n        var isStructChange = isPend || isParentChange; // can't move `case_group` anywhere but before/after anoter `case_group`\n\n        var isForbiddenStructChange = fromII.type == \"case_group\" && !isLev1 // can't restruct `rule_group`\n        || fromII.parentType == \"rule_group\" || toII.type == \"rule_group\" || toII.parentType == \"rule_group\" // only `case_group` can be placed under `switch_group`\n        || fromII.type != \"case_group\" && toII.type == \"case_group\" && isBeforeAfter || fromII.type != \"case_group\" && toII.type == \"switch_group\" // can't move rule/group to another case\n        || !canRegroupCases && fromII.caseId != toII.caseId;\n        var isLockedChange = toII.isLocked || fromII.isLocked || toParentII && toParentII.isLocked;\n        if (maxNesting && newLev > maxNesting) return false;\n        if (isStructChange && (!canRegroup || isForbiddenStructChange || isLockedChange)) return false;\n\n        if (fromII.type != \"case_group\" && fromII.caseId != toII.caseId) {\n          var isLastFromCase = fromCaseII ? fromCaseII._height == 2 : false;\n          var newRulesInTargetCase = toCaseII ? toCaseII.leafsCount + 1 : 0;\n          if (maxNumberOfRules && newRulesInTargetCase > maxNumberOfRules) return false;\n          if (isLastFromCase && !canLeaveEmptyCase) return false;\n        }\n\n        if (fromII.type == \"case_group\" && (fromII.isDefaultCase || toII.isDefaultCase || toII.type == \"switch_group\" && placement == constants.PLACEMENT_APPEND)) {\n          // leave default case alone\n          return false;\n        }\n\n        var res = true;\n\n        if (canMoveFn) {\n          res = canMoveFn(fromII.node.toJS(), toII.node.toJS(), placement, toParentII ? toParentII.node.toJS() : null);\n        }\n\n        return res;\n      }\n    }, {\n      key: \"move\",\n      value: function move(fromII, toII, placement, toParentII) {\n        //logger.log(\"move\", fromII, toII, placement, toParentII);\n        this.props.actions.moveItem(fromII.path, toII.path, placement);\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        return /*#__PURE__*/_react[\"default\"].createElement(Builder, (0, _extends2[\"default\"])({}, this.props, {\n          onDragStart: this.onDragStart\n        }));\n      }\n    }]);\n    return SortableContainer;\n  }(_react.Component), _class.propTypes = {\n    tree: _propTypes[\"default\"].any.isRequired,\n    //instanceOf(Immutable.Map)\n    actions: _propTypes[\"default\"].object.isRequired // {moveItem: Function, ..}\n    //... see Builder\n\n  }, _class;\n};\n\nvar _default = function _default(Builder) {\n  var CanMoveFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var ConnectedSortableContainer = (0, _reactRedux.connect)(function (state) {\n    return {\n      dragging: state.dragging,\n      dragStart: state.dragStart,\n      mousePos: state.mousePos\n    };\n  }, {\n    setDragStart: actions.drag.setDragStart,\n    setDragProgress: actions.drag.setDragProgress,\n    setDragEnd: actions.drag.setDragEnd\n  }, null, {\n    context: _context[\"default\"]\n  })(createSortableContainer(Builder, CanMoveFn));\n  ConnectedSortableContainer.displayName = \"ConnectedSortableContainer\";\n  return ConnectedSortableContainer;\n};\n\nexports[\"default\"] = _default;","map":{"version":3,"sources":["D:/LIMSWFH/LIMSPOSTGRESQL/QuaLISWeb/node_modules/react-awesome-query-builder/lib/components/containers/SortableContainer.js"],"names":["_interopRequireDefault","require","_typeof","Object","defineProperty","exports","value","_extends2","_toConsumableArray2","_classCallCheck2","_createClass2","_assertThisInitialized2","_inherits2","_possibleConstructorReturn2","_getPrototypeOf2","_react","_interopRequireWildcard","_reactRedux","_treeUtils","_stuff","_context","constants","_clone","_propTypes","actions","_reactUtils","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","obj","__esModule","cache","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","_createSuper","Derived","hasNativeReflectConstruct","_isNativeReflectConstruct","_createSuperInternal","Super","result","NewTarget","constructor","Reflect","construct","arguments","apply","sham","Proxy","Boolean","valueOf","e","createSortableContainer","Builder","_class","CanMoveFn","length","undefined","_Component","SortableContainer","_super","props","_this","_getEventTarget","dragStart","__mocked_window","document","body","window","onDragStart","id","dom","treeEl","closest","classList","add","treeElContainer","_getScrollParent","scrollTop","_dragEl","_getDraggableNodeEl","_plhEl","_getPlaceholderNodeEl","tmpAllGroups","querySelectorAll","anyGroup","groupPadding","getComputedStyle","getPropertyValue","parseInt","dragging","x","offsetLeft","y","offsetTop","w","offsetWidth","h","offsetHeight","itemInfo","tree","items","paddingLeft","clientX","clientY","mousePos","target","eventTarget","addEventListener","onDrag","onDragEnd","setDragStart","doHandleDrag","assign","startDragging","startMousePos","__mock_dom","dragEl","plhEl","plX","_treeEl","_plhEl2","getBoundingClientRect","left","scrollX","plY","top","scrollY","startX","startY","startClientX","startClientY","startScrollTop","pos","setDragProgress","moved","handleDrag","preventDefault","setDragEnd","remove","_cacheEls","removeEventListener","useOnPropsChanged","onPropsChanged","nextProps","getFlatTree","shouldComponentUpdate","nextState","prevProps","prevState","state","should","pureShouldComponentUpdate","chs","k","changed","push","componentDidUpdate","_prevProps","_prevState","index","parent","oldPlX","oldPlY","_getNodeElById","indexId","ignoreCache","el","contains","querySelector","els","getElementsByClassName","_isScrollable","node","overflowY","scrollHeight","parentNode","dragInfo","canMoveFn","_this2","canMoveBeforeAfterGroup","moveInfo","dragId","dragRect","plhRect","hovRect","treeRect","width","dragDirs","hrz","vrt","bottom","trgCoord","right","hovCNodeEl","__mocked_hov_container","hovNodeEl","elementFromPoint","_hovNodeEl$firstChild","rootGroupContainer","firstChild","logger","log","isGroup","hovNodeId","getAttribute","hovEl","doAppend","doPrepend","hovHeight","hovII","trgRect","trgEl","trgII","altII","hovInnerEl","hovEl2","hovRect2","hovHeight2","isOverHover","lev","isClimbToHover","_isOverHover","_isOverHover2","isSamePos","dragLeftOffset","trgLeftOffset","_trgLev","dragLev","Math","max","round","availMoves","altMoves","PLACEMENT_APPEND","PLACEMENT_PREPEND","isToRoot","isToCase","type","prevCaseId","prev","caseId","nextCaseId","next","prevCase","nextCase","PLACEMENT_AFTER","PLACEMENT_BEFORE","addCaseII","am","toII","fromCaseII","toCaseII","concat","map","filter","placement","trg","collapsed","isInside","tmp","_lev","_fromCaseII","_toCaseII","toParentII","bestMode","filteredMoves","canMove","levs","curLev","allLevs","closestDragLev","indexOf","min","find","move","fromII","_this$props$config$se","config","settings","canRegroup","canRegroupCases","maxNesting","maxNumberOfRules","canLeaveEmptyCase","newLev","isBeforeAfter","isPend","isLev1","isParentChange","isStructChange","isForbiddenStructChange","parentType","isLockedChange","isLocked","isLastFromCase","_height","newRulesInTargetCase","leafsCount","isDefaultCase","res","toJS","moveItem","path","render","createElement","Component","propTypes","any","isRequired","object","_default","ConnectedSortableContainer","connect","drag","context","displayName"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _typeof = require(\"@babel/runtime/helpers/typeof\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime/helpers/assertThisInitialized\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _react = _interopRequireWildcard(require(\"react\"));\n\nvar _reactRedux = require(\"react-redux\");\n\nvar _treeUtils = require(\"../../utils/treeUtils\");\n\nvar _stuff = require(\"../../utils/stuff\");\n\nvar _context = _interopRequireDefault(require(\"../../stores/context\"));\n\nvar constants = _interopRequireWildcard(require(\"../../constants\"));\n\nvar _clone = _interopRequireDefault(require(\"clone\"));\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar actions = _interopRequireWildcard(require(\"../../actions\"));\n\nvar _reactUtils = require(\"../../utils/reactUtils\");\n\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\n\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") { return { \"default\": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj[\"default\"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2[\"default\"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2[\"default\"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2[\"default\"])(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nvar createSortableContainer = function createSortableContainer(Builder) {\n  var _class;\n\n  var CanMoveFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  return _class = /*#__PURE__*/function (_Component) {\n    (0, _inherits2[\"default\"])(SortableContainer, _Component);\n\n    var _super = _createSuper(SortableContainer);\n\n    function SortableContainer(props) {\n      var _this;\n\n      (0, _classCallCheck2[\"default\"])(this, SortableContainer);\n      _this = _super.call(this, props);\n\n      _this._getEventTarget = function (e, dragStart) {\n        return e && e.__mocked_window || document.body || window;\n      };\n\n      _this.onDragStart = function (id, dom, e) {\n        var treeEl = dom.closest(\".query-builder\");\n        document.body.classList.add(\"qb-dragging\");\n        treeEl.classList.add(\"qb-dragging\");\n        var treeElContainer = treeEl.closest(\".query-builder-container\") || treeEl;\n        treeElContainer = _this._getScrollParent(treeElContainer) || document.body;\n        var scrollTop = treeElContainer.scrollTop;\n\n        var _dragEl = _this._getDraggableNodeEl(treeEl);\n\n        var _plhEl = _this._getPlaceholderNodeEl(treeEl);\n\n        var tmpAllGroups = treeEl.querySelectorAll(\".group--children\");\n        var anyGroup = tmpAllGroups.length ? tmpAllGroups[0] : null;\n        var groupPadding;\n\n        if (anyGroup) {\n          groupPadding = window.getComputedStyle(anyGroup, null).getPropertyValue(\"padding-left\");\n          groupPadding = parseInt(groupPadding);\n        }\n\n        var dragging = {\n          id: id,\n          x: dom.offsetLeft,\n          y: dom.offsetTop,\n          w: dom.offsetWidth,\n          h: dom.offsetHeight,\n          itemInfo: _this.tree.items[id],\n          paddingLeft: groupPadding\n        };\n        var dragStart = {\n          id: id,\n          x: dom.offsetLeft,\n          y: dom.offsetTop,\n          scrollTop: scrollTop,\n          clientX: e.clientX,\n          clientY: e.clientY,\n          itemInfo: (0, _clone[\"default\"])(_this.tree.items[id]),\n          treeEl: treeEl,\n          treeElContainer: treeElContainer\n        };\n        var mousePos = {\n          clientX: e.clientX,\n          clientY: e.clientY\n        };\n\n        var target = _this._getEventTarget(e, dragStart);\n\n        _this.eventTarget = target;\n        target.addEventListener(\"mousemove\", _this.onDrag);\n        target.addEventListener(\"mouseup\", _this.onDragEnd);\n\n        _this.props.setDragStart(dragStart, dragging, mousePos);\n      };\n\n      _this.onDrag = function (e) {\n        var doHandleDrag = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        var dragging = Object.assign({}, _this.props.dragging);\n        var startDragging = _this.props.dragStart;\n        var paddingLeft = dragging.paddingLeft; //this.props.paddingLeft;\n\n        var treeElContainer = startDragging.treeElContainer;\n        var scrollTop = treeElContainer.scrollTop;\n        dragging.itemInfo = _this.tree.items[dragging.id];\n\n        if (!dragging.itemInfo) {\n          return;\n        }\n\n        var mousePos = {\n          clientX: e.clientX,\n          clientY: e.clientY\n        };\n        var startMousePos = {\n          clientX: startDragging.clientX,\n          clientY: startDragging.clientY\n        };\n\n        if (e.__mock_dom) {\n          var treeEl = startDragging.treeEl;\n\n          var dragEl = _this._getDraggableNodeEl(treeEl);\n\n          var plhEl = _this._getPlaceholderNodeEl(treeEl);\n\n          e.__mock_dom({\n            treeEl: treeEl,\n            dragEl: dragEl,\n            plhEl: plhEl\n          });\n        } //first init plX/plY\n\n\n        if (!startDragging.plX) {\n          var _treeEl = startDragging.treeEl;\n\n          var _plhEl2 = _this._getPlaceholderNodeEl(_treeEl);\n\n          if (_plhEl2) {\n            startDragging.plX = _plhEl2.getBoundingClientRect().left + window.scrollX;\n            startDragging.plY = _plhEl2.getBoundingClientRect().top + window.scrollY;\n          }\n        }\n\n        var startX = startDragging.x;\n        var startY = startDragging.y;\n        var startClientX = startDragging.clientX;\n        var startClientY = startDragging.clientY;\n        var startScrollTop = startDragging.scrollTop;\n        var pos = {\n          x: startX + (e.clientX - startClientX),\n          y: startY + (e.clientY - startClientY) + (scrollTop - startScrollTop)\n        };\n        dragging.x = pos.x;\n        dragging.y = pos.y;\n        dragging.paddingLeft = paddingLeft;\n        dragging.mousePos = mousePos;\n        dragging.startMousePos = startMousePos;\n\n        _this.props.setDragProgress(mousePos, dragging);\n\n        var moved = doHandleDrag ? _this.handleDrag(dragging, e, CanMoveFn) : false;\n\n        if (!moved) {\n          if (e.preventDefault) e.preventDefault();\n        }\n      };\n\n      _this.onDragEnd = function () {\n        var treeEl = _this.props.dragStart.treeEl;\n\n        _this.props.setDragEnd();\n\n        treeEl.classList.remove(\"qb-dragging\");\n        document.body.classList.remove(\"qb-dragging\");\n        _this._cacheEls = {};\n\n        var target = _this.eventTarget || _this._getEventTarget();\n\n        target.removeEventListener(\"mousemove\", _this.onDrag);\n        target.removeEventListener(\"mouseup\", _this.onDragEnd);\n      };\n\n      (0, _reactUtils.useOnPropsChanged)((0, _assertThisInitialized2[\"default\"])(_this));\n\n      _this.onPropsChanged(props);\n\n      return _this;\n    }\n\n    (0, _createClass2[\"default\"])(SortableContainer, [{\n      key: \"onPropsChanged\",\n      value: function onPropsChanged(nextProps) {\n        this.tree = (0, _treeUtils.getFlatTree)(nextProps.tree);\n      }\n    }, {\n      key: \"shouldComponentUpdate\",\n      value: function shouldComponentUpdate(nextProps, nextState) {\n        var prevProps = this.props;\n        var prevState = this.state;\n        var should = (0, _reactUtils.pureShouldComponentUpdate)(this)(nextProps, nextState);\n\n        if (should) {\n          if (prevState == nextState && prevProps != nextProps) {\n            var chs = [];\n\n            for (var k in nextProps) {\n              var changed = nextProps[k] != prevProps[k];\n\n              if (changed) {\n                //don't render <Builder> on dragging - appropriate redux-connected components will do it\n                if (k != \"dragging\" && k != \"mousePos\") chs.push(k);\n              }\n            }\n\n            if (!chs.length) should = false;\n          }\n        }\n\n        return should;\n      }\n    }, {\n      key: \"componentDidUpdate\",\n      value: function componentDidUpdate(_prevProps, _prevState) {\n        var dragging = this.props.dragging;\n        var startDragging = this.props.dragStart;\n\n        if (startDragging && startDragging.id) {\n          dragging.itemInfo = this.tree.items[dragging.id];\n\n          if (dragging.itemInfo) {\n            if (dragging.itemInfo.index != startDragging.itemInfo.index || dragging.itemInfo.parent != startDragging.itemInfo.parent) {\n              var treeEl = startDragging.treeEl;\n              var treeElContainer = startDragging.treeElContainer;\n\n              var plhEl = this._getPlaceholderNodeEl(treeEl, true);\n\n              if (plhEl) {\n                var plX = plhEl.getBoundingClientRect().left + window.scrollX;\n                var plY = plhEl.getBoundingClientRect().top + window.scrollY;\n                var oldPlX = startDragging.plX;\n                var oldPlY = startDragging.plY;\n                var scrollTop = treeElContainer.scrollTop;\n                startDragging.plX = plX;\n                startDragging.plY = plY;\n                startDragging.itemInfo = (0, _clone[\"default\"])(dragging.itemInfo);\n                startDragging.y = plhEl.offsetTop;\n                startDragging.x = plhEl.offsetLeft;\n                startDragging.clientY += plY - oldPlY;\n                startDragging.clientX += plX - oldPlX;\n                if (treeElContainer != document.body) startDragging.scrollTop = scrollTop;\n                this.onDrag(this.props.mousePos, false);\n              }\n            }\n          }\n        }\n      }\n    }, {\n      key: \"_getNodeElById\",\n      value: function _getNodeElById(treeEl, indexId) {\n        var ignoreCache = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        if (indexId == null) return null;\n        if (!this._cacheEls) this._cacheEls = {};\n        var el = this._cacheEls[indexId];\n        if (el && document.contains(el) && !ignoreCache) return el;\n        el = treeEl.querySelector('.group-or-rule-container[data-id=\"' + indexId + '\"]');\n        this._cacheEls[indexId] = el;\n        return el;\n      }\n    }, {\n      key: \"_getDraggableNodeEl\",\n      value: function _getDraggableNodeEl(treeEl) {\n        var ignoreCache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        if (!this._cacheEls) this._cacheEls = {};\n        var el = this._cacheEls[\"draggable\"];\n        if (el && document.contains(el) && !ignoreCache) return el;\n        var els = treeEl.getElementsByClassName(\"qb-draggable\");\n        el = els.length ? els[0] : null;\n        this._cacheEls[\"draggable\"] = el;\n        return el;\n      }\n    }, {\n      key: \"_getPlaceholderNodeEl\",\n      value: function _getPlaceholderNodeEl(treeEl) {\n        var ignoreCache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        if (!this._cacheEls) this._cacheEls = {};\n        var el = this._cacheEls[\"placeholder\"];\n        if (el && document.contains(el) && !ignoreCache) return el;\n        var els = treeEl.getElementsByClassName(\"qb-placeholder\");\n        el = els.length ? els[0] : null;\n        this._cacheEls[\"placeholder\"] = el;\n        return el;\n      }\n    }, {\n      key: \"_isScrollable\",\n      value: function _isScrollable(node) {\n        var overflowY = window.getComputedStyle(node)[\"overflow-y\"];\n        return (overflowY === \"scroll\" || overflowY === \"auto\") && node.scrollHeight > node.offsetHeight;\n      }\n    }, {\n      key: \"_getScrollParent\",\n      value: function _getScrollParent(node) {\n        if (node == null) return null;\n\n        if (node === document.body || this._isScrollable(node)) {\n          return node;\n        } else {\n          return this._getScrollParent(node.parentNode);\n        }\n      }\n    }, {\n      key: \"handleDrag\",\n      value: function handleDrag(dragInfo, e, canMoveFn) {\n        var _this2 = this;\n\n        var canMoveBeforeAfterGroup = true;\n        var itemInfo = dragInfo.itemInfo;\n        var paddingLeft = dragInfo.paddingLeft;\n        var moveInfo = null;\n        var treeEl = this.props.dragStart.treeEl;\n        var dragId = dragInfo.id;\n\n        var dragEl = this._getDraggableNodeEl(treeEl);\n\n        var plhEl = this._getPlaceholderNodeEl(treeEl);\n\n        var dragRect, plhRect, hovRect, treeRect;\n\n        if (dragEl && plhEl) {\n          dragRect = dragEl.getBoundingClientRect();\n          plhRect = plhEl.getBoundingClientRect();\n\n          if (!plhRect.width) {\n            return;\n          }\n\n          var dragDirs = {\n            hrz: 0,\n            vrt: 0\n          };\n          if (dragRect.top < plhRect.top) dragDirs.vrt = -1; //up\n          else if (dragRect.bottom > plhRect.bottom) dragDirs.vrt = +1; //down\n\n          if (dragRect.left > plhRect.left) dragDirs.hrz = +1; //right\n          else if (dragRect.left < plhRect.left) dragDirs.hrz = -1; //left\n\n          treeRect = treeEl.getBoundingClientRect();\n          var trgCoord = {\n            x: treeRect.left + (treeRect.right - treeRect.left) / 2,\n            y: dragDirs.vrt >= 0 ? dragRect.bottom : dragRect.top\n          };\n          var hovCNodeEl;\n\n          if (e.__mocked_hov_container) {\n            hovCNodeEl = e.__mocked_hov_container;\n          } else {\n            var hovNodeEl = document.elementFromPoint(trgCoord.x, trgCoord.y - 1);\n            hovCNodeEl = hovNodeEl ? hovNodeEl.closest(\".group-or-rule-container\") : null;\n\n            if (!hovCNodeEl && hovNodeEl && hovNodeEl.classList.contains(\"query-builder-container\")) {\n              var _hovNodeEl$firstChild;\n\n              // fix 2022-01-24 - get root .group-or-rule-container\n              var rootGroupContainer = hovNodeEl === null || hovNodeEl === void 0 ? void 0 : (_hovNodeEl$firstChild = hovNodeEl.firstChild) === null || _hovNodeEl$firstChild === void 0 ? void 0 : _hovNodeEl$firstChild.firstChild;\n\n              if (rootGroupContainer && rootGroupContainer.classList.contains(\"group-or-rule-container\")) {\n                hovCNodeEl = rootGroupContainer;\n              }\n            }\n          }\n\n          if (!hovCNodeEl) {\n            _stuff.logger.log(\"out of tree bounds!\");\n          } else {\n            var isGroup = hovCNodeEl.classList.contains(\"group-container\");\n            var hovNodeId = hovCNodeEl.getAttribute(\"data-id\");\n            var hovEl = hovCNodeEl;\n            var doAppend = false;\n            var doPrepend = false;\n\n            if (hovEl) {\n              hovRect = hovEl.getBoundingClientRect();\n              var hovHeight = hovRect.bottom - hovRect.top;\n              var hovII = this.tree.items[hovNodeId];\n              var trgRect = null,\n                  trgEl = null,\n                  trgII = null,\n                  altII = null; //for canMoveBeforeAfterGroup\n\n              if (dragDirs.vrt == 0) {\n                trgII = itemInfo;\n                trgEl = plhEl;\n                if (trgEl) trgRect = trgEl.getBoundingClientRect();\n              } else {\n                if (isGroup) {\n                  if (dragDirs.vrt > 0) {\n                    //down\n                    //take group header (for prepend only)\n                    var hovInnerEl = hovCNodeEl.getElementsByClassName(\"group--header\");\n                    var hovEl2 = hovInnerEl.length ? hovInnerEl[0] : null;\n\n                    if (hovEl2) {\n                      var hovRect2 = hovEl2.getBoundingClientRect();\n                      var hovHeight2 = hovRect2.bottom - hovRect2.top;\n                      var isOverHover = dragRect.bottom - hovRect2.top > hovHeight2 * 3 / 4;\n\n                      if (isOverHover && hovII.top > dragInfo.itemInfo.top) {\n                        trgII = hovII;\n                        trgRect = hovRect2;\n                        trgEl = hovEl2;\n                        doPrepend = true;\n                      }\n                    }\n                  } else if (dragDirs.vrt < 0) {\n                    //up\n                    if (hovII.lev >= itemInfo.lev) {\n                      //take whole group\n                      var isClimbToHover = hovRect.bottom - dragRect.top >= 2;\n\n                      if (isClimbToHover && hovII.top < dragInfo.itemInfo.top) {\n                        trgII = hovII;\n                        trgRect = hovRect;\n                        trgEl = hovEl;\n                        doAppend = true;\n                      }\n                    }\n                  }\n\n                  if (!doPrepend && !doAppend || canMoveBeforeAfterGroup) {\n                    //take whole group and check if we can move before/after group\n                    var _isOverHover = dragDirs.vrt < 0 //up\n                    ? hovRect.bottom - dragRect.top > hovHeight - 5 : dragRect.bottom - hovRect.top > hovHeight - 5;\n\n                    if (_isOverHover) {\n                      if (!doPrepend && !doAppend) {\n                        trgII = hovII;\n                        trgRect = hovRect;\n                        trgEl = hovEl;\n                      }\n\n                      if (canMoveBeforeAfterGroup) {\n                        altII = hovII;\n                      }\n                    }\n                  }\n                } else {\n                  //check if we can move before/after group\n                  var _isOverHover2 = dragDirs.vrt < 0 //up\n                  ? hovRect.bottom - dragRect.top > hovHeight / 2 : dragRect.bottom - hovRect.top > hovHeight / 2;\n\n                  if (_isOverHover2) {\n                    trgII = hovII;\n                    trgRect = hovRect;\n                    trgEl = hovEl;\n                  }\n                }\n              }\n\n              var isSamePos = trgII && trgII.id == dragId;\n\n              if (trgRect) {\n                var dragLeftOffset = dragRect.left - treeRect.left;\n                var trgLeftOffset = trgRect.left - treeRect.left;\n\n                var _trgLev = trgLeftOffset / paddingLeft;\n\n                var dragLev = Math.max(0, Math.round(dragLeftOffset / paddingLeft)); //find all possible moves\n\n                var availMoves = [];\n                var altMoves = []; //alternatively can move after/before group, if can't move into it\n\n                if (isSamePos) {//do nothing\n                } else {\n                  if (isGroup) {\n                    if (doAppend) {\n                      availMoves.push([constants.PLACEMENT_APPEND, trgII, trgII.lev + 1]);\n                    } else if (doPrepend) {\n                      availMoves.push([constants.PLACEMENT_PREPEND, trgII, trgII.lev + 1]);\n                    } //alt\n\n\n                    if (canMoveBeforeAfterGroup && altII) {\n                      // fix 2022-01-24: do prepend/append instead of before/after for root\n                      var isToRoot = altII.lev == 0; // fix 2022-01-25: fix prepend/append instead of before/after for case_group\n\n                      var isToCase = altII.type == \"case_group\" && itemInfo.type != \"case_group\";\n                      var prevCaseId = altII.prev && this.tree.items[altII.prev].caseId;\n                      var nextCaseId = altII.next && this.tree.items[altII.next].caseId;\n                      if (itemInfo.caseId == prevCaseId) prevCaseId = null;\n                      if (itemInfo.caseId == nextCaseId) nextCaseId = null;\n                      var prevCase = prevCaseId && this.tree.items[prevCaseId];\n                      var nextCase = nextCaseId && this.tree.items[nextCaseId];\n\n                      if (dragDirs.vrt > 0) {\n                        //down\n                        if (isToRoot) {\n                          altMoves.push([constants.PLACEMENT_APPEND, altII, altII.lev + 1]);\n                        } else if (isToCase && nextCase) {\n                          altMoves.push([constants.PLACEMENT_PREPEND, nextCase, nextCase.lev + 1]);\n                        } else {\n                          altMoves.push([constants.PLACEMENT_AFTER, altII, altII.lev]);\n                        }\n                      } else if (dragDirs.vrt < 0) {\n                        //up\n                        if (isToRoot) {\n                          altMoves.push([constants.PLACEMENT_PREPEND, altII, altII.lev + 1]);\n                        } else if (isToCase && prevCase) {\n                          altMoves.push([constants.PLACEMENT_APPEND, prevCase, prevCase.lev + 1]);\n                        } else {\n                          altMoves.push([constants.PLACEMENT_BEFORE, altII, altII.lev]);\n                        }\n                      }\n                    }\n                  }\n\n                  if (!doAppend && !doPrepend) {\n                    if (dragDirs.vrt < 0) {\n                      //up\n                      availMoves.push([constants.PLACEMENT_BEFORE, trgII, trgII.lev]);\n                    } else if (dragDirs.vrt > 0) {\n                      //down\n                      availMoves.push([constants.PLACEMENT_AFTER, trgII, trgII.lev]);\n                    }\n                  }\n                } //add case\n\n\n                var addCaseII = function addCaseII(am) {\n                  var toII = am[1];\n                  var fromCaseII = itemInfo.caseId ? _this2.tree.items[itemInfo.caseId] : null;\n                  var toCaseII = toII.caseId ? _this2.tree.items[toII.caseId] : null;\n                  return [].concat((0, _toConsumableArray2[\"default\"])(am), [fromCaseII, toCaseII]);\n                };\n\n                availMoves = availMoves.map(addCaseII);\n                altMoves = altMoves.map(addCaseII); //sanitize\n\n                availMoves = availMoves.filter(function (am) {\n                  var placement = am[0];\n                  var trg = am[1];\n                  if ((placement == constants.PLACEMENT_BEFORE || placement == constants.PLACEMENT_AFTER) && trg.parent == null) return false;\n                  if (trg.collapsed && (placement == constants.PLACEMENT_APPEND || placement == constants.PLACEMENT_PREPEND)) return false;\n                  var isInside = trg.id == itemInfo.id;\n\n                  if (!isInside) {\n                    var tmp = trg;\n\n                    while (tmp.parent) {\n                      tmp = _this2.tree.items[tmp.parent];\n\n                      if (tmp.id == itemInfo.id) {\n                        isInside = true;\n                        break;\n                      }\n                    }\n                  }\n\n                  return !isInside;\n                }).map(function (am) {\n                  var placement = am[0],\n                      toII = am[1],\n                      _lev = am[2],\n                      _fromCaseII = am[3],\n                      _toCaseII = am[4];\n                  var toParentII = null;\n                  if (placement == constants.PLACEMENT_APPEND || placement == constants.PLACEMENT_PREPEND) toParentII = toII;else toParentII = _this2.tree.items[toII.parent];\n                  if (toParentII && toParentII.parent == null) toParentII = null;\n                  am[5] = toParentII;\n                  return am;\n                });\n                var bestMode = null;\n                var filteredMoves = availMoves.filter(function (am) {\n                  return _this2.canMove(itemInfo, am[1], am[0], am[3], am[4], am[5], canMoveFn);\n                });\n\n                if (canMoveBeforeAfterGroup && filteredMoves.length == 0 && altMoves.length > 0) {\n                  filteredMoves = altMoves.filter(function (am) {\n                    return _this2.canMove(itemInfo, am[1], am[0], am[3], am[4], am[5], canMoveFn);\n                  });\n                }\n\n                var levs = filteredMoves.map(function (am) {\n                  return am[2];\n                });\n                var curLev = itemInfo.lev;\n                var allLevs = levs.concat(curLev);\n                var closestDragLev = null;\n                if (allLevs.indexOf(dragLev) != -1) closestDragLev = dragLev;else if (dragLev > Math.max.apply(Math, (0, _toConsumableArray2[\"default\"])(allLevs))) closestDragLev = Math.max.apply(Math, (0, _toConsumableArray2[\"default\"])(allLevs));else if (dragLev < Math.min.apply(Math, (0, _toConsumableArray2[\"default\"])(allLevs))) closestDragLev = Math.min.apply(Math, (0, _toConsumableArray2[\"default\"])(allLevs));\n                bestMode = filteredMoves.find(function (am) {\n                  return am[2] == closestDragLev;\n                });\n                if (!isSamePos && !bestMode && filteredMoves.length) bestMode = filteredMoves[0];\n                moveInfo = bestMode;\n              }\n            }\n          }\n        }\n\n        if (moveInfo) {\n          this.move(itemInfo, moveInfo[1], moveInfo[0], moveInfo[3]); // logger.log(\"DRAG-N-DROP\", JSON.stringify({\n          //   dragRect,\n          //   plhRect,\n          //   treeRect,\n          //   hovRect,\n          //   startMousePos: dragInfo.startMousePos,\n          //   mousePos: dragInfo.mousePos,\n          // }));\n\n          return true;\n        }\n\n        return false;\n      }\n    }, {\n      key: \"canMove\",\n      value: function canMove(fromII, toII, placement, fromCaseII, toCaseII, toParentII, canMoveFn) {\n        if (!fromII || !toII) return false;\n        if (fromII.id === toII.id) return false;\n        var _this$props$config$se = this.props.config.settings,\n            canRegroup = _this$props$config$se.canRegroup,\n            canRegroupCases = _this$props$config$se.canRegroupCases,\n            maxNesting = _this$props$config$se.maxNesting,\n            maxNumberOfRules = _this$props$config$se.maxNumberOfRules,\n            canLeaveEmptyCase = _this$props$config$se.canLeaveEmptyCase;\n        var newLev = toParentII ? toParentII.lev + 1 : toII.lev;\n        var isBeforeAfter = placement == constants.PLACEMENT_BEFORE || placement == constants.PLACEMENT_AFTER;\n        var isPend = placement == constants.PLACEMENT_PREPEND || placement == constants.PLACEMENT_APPEND;\n        var isLev1 = isBeforeAfter && toII.lev == 1 || isPend && toII.lev == 0;\n        var isParentChange = fromII.parent != toII.parent;\n        var isStructChange = isPend || isParentChange; // can't move `case_group` anywhere but before/after anoter `case_group`\n\n        var isForbiddenStructChange = fromII.type == \"case_group\" && !isLev1 // can't restruct `rule_group`\n        || fromII.parentType == \"rule_group\" || toII.type == \"rule_group\" || toII.parentType == \"rule_group\" // only `case_group` can be placed under `switch_group`\n        || fromII.type != \"case_group\" && toII.type == \"case_group\" && isBeforeAfter || fromII.type != \"case_group\" && toII.type == \"switch_group\" // can't move rule/group to another case\n        || !canRegroupCases && fromII.caseId != toII.caseId;\n        var isLockedChange = toII.isLocked || fromII.isLocked || toParentII && toParentII.isLocked;\n        if (maxNesting && newLev > maxNesting) return false;\n        if (isStructChange && (!canRegroup || isForbiddenStructChange || isLockedChange)) return false;\n\n        if (fromII.type != \"case_group\" && fromII.caseId != toII.caseId) {\n          var isLastFromCase = fromCaseII ? fromCaseII._height == 2 : false;\n          var newRulesInTargetCase = toCaseII ? toCaseII.leafsCount + 1 : 0;\n          if (maxNumberOfRules && newRulesInTargetCase > maxNumberOfRules) return false;\n          if (isLastFromCase && !canLeaveEmptyCase) return false;\n        }\n\n        if (fromII.type == \"case_group\" && (fromII.isDefaultCase || toII.isDefaultCase || toII.type == \"switch_group\" && placement == constants.PLACEMENT_APPEND)) {\n          // leave default case alone\n          return false;\n        }\n\n        var res = true;\n\n        if (canMoveFn) {\n          res = canMoveFn(fromII.node.toJS(), toII.node.toJS(), placement, toParentII ? toParentII.node.toJS() : null);\n        }\n\n        return res;\n      }\n    }, {\n      key: \"move\",\n      value: function move(fromII, toII, placement, toParentII) {\n        //logger.log(\"move\", fromII, toII, placement, toParentII);\n        this.props.actions.moveItem(fromII.path, toII.path, placement);\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        return /*#__PURE__*/_react[\"default\"].createElement(Builder, (0, _extends2[\"default\"])({}, this.props, {\n          onDragStart: this.onDragStart\n        }));\n      }\n    }]);\n    return SortableContainer;\n  }(_react.Component), _class.propTypes = {\n    tree: _propTypes[\"default\"].any.isRequired,\n    //instanceOf(Immutable.Map)\n    actions: _propTypes[\"default\"].object.isRequired // {moveItem: Function, ..}\n    //... see Builder\n\n  }, _class;\n};\n\nvar _default = function _default(Builder) {\n  var CanMoveFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var ConnectedSortableContainer = (0, _reactRedux.connect)(function (state) {\n    return {\n      dragging: state.dragging,\n      dragStart: state.dragStart,\n      mousePos: state.mousePos\n    };\n  }, {\n    setDragStart: actions.drag.setDragStart,\n    setDragProgress: actions.drag.setDragProgress,\n    setDragEnd: actions.drag.setDragEnd\n  }, null, {\n    context: _context[\"default\"]\n  })(createSortableContainer(Builder, CanMoveFn));\n  ConnectedSortableContainer.displayName = \"ConnectedSortableContainer\";\n  return ConnectedSortableContainer;\n};\n\nexports[\"default\"] = _default;"]},"metadata":{},"sourceType":"script"}