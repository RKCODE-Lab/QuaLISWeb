{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.queryString = void 0;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _configUtils = require(\"../utils/configUtils\");\n\nvar _ruleUtils = require(\"../utils/ruleUtils\");\n\nvar _omit = _interopRequireDefault(require(\"lodash/omit\"));\n\nvar _pick = _interopRequireDefault(require(\"lodash/pick\"));\n\nvar _stuff = require(\"../utils/stuff\");\n\nvar _defaultUtils = require(\"../utils/defaultUtils\");\n\nvar _default = require(\"../config/default\");\n\nvar _funcUtils = require(\"../utils/funcUtils\");\n\nvar _immutable = require(\"immutable\");\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2[\"default\"])(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar queryString = function queryString(item, config) {\n  var isForDisplay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false; //meta is mutable\n\n  var meta = {\n    errors: []\n  };\n  var res = formatItem(item, config, meta, isForDisplay, null);\n  if (meta.errors.length) console.warn(\"Errors while exporting to string:\", meta.errors);\n  return res;\n};\n\nexports.queryString = queryString;\n\nvar formatItem = function formatItem(item, config, meta) {\n  var isForDisplay = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var parentField = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  if (!item) return undefined;\n  var type = item.get(\"type\");\n  var children = item.get(\"children1\");\n\n  if ((type === \"group\" || type === \"rule_group\") && children && children.size) {\n    return formatGroup(item, config, meta, isForDisplay, parentField);\n  } else if (type === \"rule\") {\n    return formatRule(item, config, meta, isForDisplay, parentField);\n  }\n\n  return undefined;\n};\n\nvar formatGroup = function formatGroup(item, config, meta) {\n  var isForDisplay = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var parentField = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  var type = item.get(\"type\");\n  var properties = item.get(\"properties\") || new _immutable.Map();\n  var mode = properties.get(\"mode\");\n  var children = item.get(\"children1\");\n  var isRuleGroup = type === \"rule_group\"; // TIP: don't cut group for mode == 'struct' and don't do aggr format (maybe later)\n\n  var groupField = isRuleGroup && mode == \"array\" ? properties.get(\"field\") : null;\n  var not = properties.get(\"not\");\n  var list = children.map(function (currentChild) {\n    return formatItem(currentChild, config, meta, isForDisplay, groupField);\n  }).filter(function (currentChild) {\n    return typeof currentChild !== \"undefined\";\n  });\n  if (!list.size) return undefined;\n  var conjunction = properties.get(\"conjunction\");\n  if (!conjunction) conjunction = (0, _defaultUtils.defaultConjunction)(config);\n  var conjunctionDefinition = config.conjunctions[conjunction];\n  var conjStr = conjunctionDefinition.formatConj(list, conjunction, not, isForDisplay);\n  var ret;\n\n  if (groupField) {\n    var aggrArgs = formatRule(item, config, meta, isForDisplay, parentField, true);\n\n    if (conjStr && aggrArgs) {\n      var _config$settings;\n\n      var isRev = aggrArgs.pop();\n      var args = [conjStr].concat((0, _toConsumableArray2[\"default\"])(aggrArgs));\n      ret = (_config$settings = config.settings).formatAggr.apply(_config$settings, (0, _toConsumableArray2[\"default\"])(args));\n\n      if (isRev) {\n        ret = config.settings.formatReverse(ret, null, null, null, null, isForDisplay);\n      }\n    }\n  } else {\n    ret = conjStr;\n  }\n\n  return ret;\n};\n\nvar formatItemValue = function formatItemValue(config, properties, meta, _operator, isForDisplay, parentField) {\n  var field = properties.get(\"field\");\n  var iValueSrc = properties.get(\"valueSrc\");\n  var iValueType = properties.get(\"valueType\");\n  var fieldDef = (0, _configUtils.getFieldConfig)(config, field) || {};\n\n  var operator = _operator || properties.get(\"operator\");\n\n  var operatorDef = (0, _configUtils.getOperatorConfig)(config, operator, field) || {};\n  var cardinality = (0, _stuff.defaultValue)(operatorDef.cardinality, 1);\n  var iValue = properties.get(\"value\");\n  var asyncListValues = properties.get(\"asyncListValues\");\n  var valueSrcs = [];\n  var valueTypes = [];\n  var formattedValue;\n\n  if (iValue != undefined) {\n    var fvalue = iValue.map(function (currentValue, ind) {\n      var valueSrc = iValueSrc ? iValueSrc.get(ind) : null;\n      var valueType = iValueType ? iValueType.get(ind) : null;\n      var cValue = (0, _funcUtils.completeValue)(currentValue, valueSrc, config);\n      var widget = (0, _ruleUtils.getWidgetForFieldOp)(config, field, operator, valueSrc);\n      var fieldWidgetDef = (0, _omit[\"default\"])((0, _configUtils.getFieldWidgetConfig)(config, field, operator, widget, valueSrc), [\"factory\"]);\n      var fv = formatValue(config, meta, cValue, valueSrc, valueType, fieldWidgetDef, fieldDef, operator, operatorDef, isForDisplay, parentField, asyncListValues);\n\n      if (fv !== undefined) {\n        valueSrcs.push(valueSrc);\n        valueTypes.push(valueType);\n      }\n\n      return fv;\n    });\n    var hasUndefinedValues = fvalue.filter(function (v) {\n      return v === undefined;\n    }).size > 0;\n\n    if (!(hasUndefinedValues || fvalue.size < cardinality)) {\n      formattedValue = cardinality == 1 ? fvalue.first() : fvalue;\n    }\n  }\n\n  return [formattedValue, valueSrcs.length > 1 ? valueSrcs : valueSrcs[0], valueTypes.length > 1 ? valueTypes : valueTypes[0]];\n};\n\nvar formatRule = function formatRule(item, config, meta) {\n  var isForDisplay = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var parentField = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  var returnArgs = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  var properties = item.get(\"properties\") || new _immutable.Map();\n  var field = properties.get(\"field\");\n  var operator = properties.get(\"operator\");\n  var operatorOptions = properties.get(\"operatorOptions\");\n  if (field == null || operator == null) return undefined;\n  var fieldDef = (0, _configUtils.getFieldConfig)(config, field) || {};\n  var operatorDef = (0, _configUtils.getOperatorConfig)(config, operator, field) || {};\n  var reversedOp = operatorDef.reversedOp;\n  var revOperatorDef = (0, _configUtils.getOperatorConfig)(config, reversedOp, field) || {};\n  var cardinality = (0, _stuff.defaultValue)(operatorDef.cardinality, 1); //check op\n\n  var isRev = false;\n  var fn = operatorDef.formatOp;\n\n  if (!fn && reversedOp) {\n    fn = revOperatorDef.formatOp;\n\n    if (fn) {\n      isRev = true;\n      var _ref = [reversedOp, operator];\n      operator = _ref[0];\n      reversedOp = _ref[1];\n      var _ref2 = [revOperatorDef, operatorDef];\n      operatorDef = _ref2[0];\n      revOperatorDef = _ref2[1];\n    }\n  }\n\n  var fop = operatorDef.labelForFormat || operator; //find fn to format expr\n\n  if (!fn) {\n    if (cardinality == 0) {\n      fn = function fn(field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {\n        return \"\".concat(field, \" \").concat(fop);\n      };\n    } else if (cardinality == 1) {\n      fn = function fn(field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {\n        return \"\".concat(field, \" \").concat(fop, \" \").concat(values);\n      };\n    } else if (cardinality == 2) {\n      // between\n      fn = function fn(field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {\n        var valFrom = values.first();\n        var valTo = values.get(1);\n        return \"\".concat(field, \" \").concat(fop, \" \").concat(valFrom, \" AND \").concat(valTo);\n      };\n    }\n  }\n\n  if (!fn) return undefined; //format field\n\n  var formattedField = formatField(config, meta, field, isForDisplay, parentField); //format value\n\n  var _formatItemValue = formatItemValue(config, properties, meta, operator, isForDisplay, parentField),\n      _formatItemValue2 = (0, _slicedToArray2[\"default\"])(_formatItemValue, 3),\n      formattedValue = _formatItemValue2[0],\n      valueSrc = _formatItemValue2[1],\n      valueType = _formatItemValue2[2];\n\n  if (formattedValue === undefined) return undefined;\n  var args = [formattedField, operator, formattedValue, valueSrc, valueType, (0, _omit[\"default\"])(operatorDef, [\"formatOp\", \"mongoFormatOp\", \"sqlFormatOp\", \"jsonLogic\"]), operatorOptions, isForDisplay, fieldDef, isRev];\n\n  if (returnArgs) {\n    return args;\n  } else {\n    //format expr\n    var ret = fn.apply(void 0, args); //rev\n\n    if (isRev) {\n      ret = config.settings.formatReverse(ret, operator, reversedOp, operatorDef, revOperatorDef, isForDisplay);\n    }\n\n    return ret;\n  }\n};\n\nvar formatValue = function formatValue(config, meta, value, valueSrc, valueType, fieldWidgetDef, fieldDef, operator, opDef, isForDisplay) {\n  var parentField = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : null;\n  var asyncListValues = arguments.length > 11 ? arguments[11] : undefined;\n  if (value === undefined) return undefined;\n  var ret;\n\n  if (valueSrc == \"field\") {\n    ret = formatField(config, meta, value, isForDisplay, parentField);\n  } else if (valueSrc == \"func\") {\n    ret = formatFunc(config, meta, value, isForDisplay, parentField);\n  } else {\n    if (typeof fieldWidgetDef.formatValue === \"function\") {\n      var fn = fieldWidgetDef.formatValue;\n      var args = [value, _objectSpread(_objectSpread({}, (0, _pick[\"default\"])(fieldDef, [\"fieldSettings\", \"listValues\"])), {}, {\n        asyncListValues: asyncListValues\n      }), //useful options: valueFormat for date/time\n      (0, _omit[\"default\"])(fieldWidgetDef, [\"formatValue\", \"mongoFormatValue\", \"sqlFormatValue\", \"jsonLogic\", \"elasticSearchFormatValue\"]), isForDisplay];\n\n      if (operator) {\n        args.push(operator);\n        args.push(opDef);\n      }\n\n      if (valueSrc == \"field\") {\n        var valFieldDefinition = (0, _configUtils.getFieldConfig)(config, value) || {};\n        args.push(valFieldDefinition);\n      }\n\n      ret = fn.apply(void 0, args);\n    } else {\n      ret = value;\n    }\n  }\n\n  return ret;\n};\n\nvar formatField = function formatField(config, meta, field, isForDisplay) {\n  var parentField = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  var cutParentField = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n  var _config$settings2 = config.settings,\n      fieldSeparator = _config$settings2.fieldSeparator,\n      fieldSeparatorDisplay = _config$settings2.fieldSeparatorDisplay;\n  var ret = null;\n\n  if (field) {\n    var fieldDefinition = (0, _configUtils.getFieldConfig)(config, field) || {};\n    var fieldParts = Array.isArray(field) ? field : field.split(fieldSeparator);\n\n    var _fieldKeys = (0, _ruleUtils.getFieldPath)(field, config);\n\n    var fieldPartsLabels = (0, _ruleUtils.getFieldPathLabels)(field, config, cutParentField ? parentField : null);\n    var fieldFullLabel = fieldPartsLabels ? fieldPartsLabels.join(fieldSeparatorDisplay) : null;\n    var fieldLabel2 = fieldDefinition.label2 || fieldFullLabel;\n    var formatFieldFn = config.settings.formatField || _default.settings.formatField;\n    var fieldName = (0, _ruleUtils.formatFieldName)(field, config, meta, cutParentField ? parentField : null);\n    ret = formatFieldFn(fieldName, fieldParts, fieldLabel2, fieldDefinition, config, isForDisplay);\n  }\n\n  return ret;\n};\n\nvar formatFunc = function formatFunc(config, meta, funcValue, isForDisplay) {\n  var parentField = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  var funcKey = funcValue.get(\"func\");\n  var args = funcValue.get(\"args\");\n  var funcConfig = (0, _configUtils.getFuncConfig)(config, funcKey);\n  var funcName = isForDisplay && funcConfig.label || funcKey;\n  var formattedArgs = {};\n  var formattedArgsWithNames = {};\n\n  for (var argKey in funcConfig.args) {\n    var argConfig = funcConfig.args[argKey];\n    var fieldDef = (0, _configUtils.getFieldConfig)(config, argConfig);\n    var argVal = args ? args.get(argKey) : undefined;\n    var argValue = argVal ? argVal.get(\"value\") : undefined;\n    var argValueSrc = argVal ? argVal.get(\"valueSrc\") : undefined;\n    var argAsyncListValues = argVal ? argVal.get(\"asyncListValues\") : undefined;\n    var formattedArgVal = formatValue(config, meta, argValue, argValueSrc, argConfig.type, fieldDef, argConfig, null, null, isForDisplay, parentField, argAsyncListValues);\n    var argName = isForDisplay && argConfig.label || argKey;\n\n    if (formattedArgVal !== undefined) {\n      // skip optional in the end\n      formattedArgs[argKey] = formattedArgVal;\n      formattedArgsWithNames[argName] = formattedArgVal;\n    }\n  }\n\n  var ret = null;\n\n  if (typeof funcConfig.formatFunc === \"function\") {\n    var fn = funcConfig.formatFunc;\n    var _args = [formattedArgs, isForDisplay];\n    ret = fn.apply(void 0, _args);\n  } else {\n    var argsStr = Object.entries(formattedArgsWithNames).map(function (_ref3) {\n      var _ref4 = (0, _slicedToArray2[\"default\"])(_ref3, 2),\n          k = _ref4[0],\n          v = _ref4[1];\n\n      return isForDisplay ? \"\".concat(k, \": \").concat(v) : \"\".concat(v);\n    }).join(\", \");\n    ret = \"\".concat(funcName, \"(\").concat(argsStr, \")\");\n  }\n\n  return ret;\n};","map":{"version":3,"sources":["D:/Postgres_workingFolder/QuaLISWeb/node_modules/react-awesome-query-builder/lib/export/queryString.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","queryString","_defineProperty2","_slicedToArray2","_toConsumableArray2","_configUtils","_ruleUtils","_omit","_pick","_stuff","_defaultUtils","_default","_funcUtils","_immutable","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","item","config","isForDisplay","undefined","meta","errors","res","formatItem","console","warn","parentField","type","get","children","size","formatGroup","formatRule","properties","Map","mode","isRuleGroup","groupField","not","list","map","currentChild","conjunction","defaultConjunction","conjunctionDefinition","conjunctions","conjStr","formatConj","ret","aggrArgs","_config$settings","isRev","pop","args","concat","settings","formatAggr","formatReverse","formatItemValue","_operator","field","iValueSrc","iValueType","fieldDef","getFieldConfig","operator","operatorDef","getOperatorConfig","cardinality","defaultValue","iValue","asyncListValues","valueSrcs","valueTypes","formattedValue","fvalue","currentValue","ind","valueSrc","valueType","cValue","completeValue","widget","getWidgetForFieldOp","fieldWidgetDef","getFieldWidgetConfig","fv","formatValue","hasUndefinedValues","v","first","returnArgs","operatorOptions","reversedOp","revOperatorDef","fn","formatOp","_ref","_ref2","fop","labelForFormat","op","values","opDef","valFrom","valTo","formattedField","formatField","_formatItemValue","_formatItemValue2","formatFunc","valFieldDefinition","cutParentField","_config$settings2","fieldSeparator","fieldSeparatorDisplay","fieldDefinition","fieldParts","Array","isArray","split","_fieldKeys","getFieldPath","fieldPartsLabels","getFieldPathLabels","fieldFullLabel","join","fieldLabel2","label2","formatFieldFn","fieldName","formatFieldName","funcValue","funcKey","funcConfig","getFuncConfig","funcName","label","formattedArgs","formattedArgsWithNames","argKey","argConfig","argVal","argValue","argValueSrc","argAsyncListValues","formattedArgVal","argName","_args","argsStr","entries","_ref3","_ref4","k"],"mappings":"AAAA;;AAEA,IAAIA,sBAAsB,GAAGC,OAAO,CAAC,8CAAD,CAApC;;AAEAC,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,WAAR,GAAsB,KAAK,CAA3B;;AAEA,IAAIC,gBAAgB,GAAGP,sBAAsB,CAACC,OAAO,CAAC,uCAAD,CAAR,CAA7C;;AAEA,IAAIO,eAAe,GAAGR,sBAAsB,CAACC,OAAO,CAAC,sCAAD,CAAR,CAA5C;;AAEA,IAAIQ,mBAAmB,GAAGT,sBAAsB,CAACC,OAAO,CAAC,0CAAD,CAAR,CAAhD;;AAEA,IAAIS,YAAY,GAAGT,OAAO,CAAC,sBAAD,CAA1B;;AAEA,IAAIU,UAAU,GAAGV,OAAO,CAAC,oBAAD,CAAxB;;AAEA,IAAIW,KAAK,GAAGZ,sBAAsB,CAACC,OAAO,CAAC,aAAD,CAAR,CAAlC;;AAEA,IAAIY,KAAK,GAAGb,sBAAsB,CAACC,OAAO,CAAC,aAAD,CAAR,CAAlC;;AAEA,IAAIa,MAAM,GAAGb,OAAO,CAAC,gBAAD,CAApB;;AAEA,IAAIc,aAAa,GAAGd,OAAO,CAAC,uBAAD,CAA3B;;AAEA,IAAIe,QAAQ,GAAGf,OAAO,CAAC,mBAAD,CAAtB;;AAEA,IAAIgB,UAAU,GAAGhB,OAAO,CAAC,oBAAD,CAAxB;;AAEA,IAAIiB,UAAU,GAAGjB,OAAO,CAAC,WAAD,CAAxB;;AAEA,SAASkB,OAAT,CAAiBC,MAAjB,EAAyBC,cAAzB,EAAyC;AAAE,MAAIC,IAAI,GAAGpB,MAAM,CAACoB,IAAP,CAAYF,MAAZ,CAAX;;AAAgC,MAAIlB,MAAM,CAACqB,qBAAX,EAAkC;AAAE,QAAIC,OAAO,GAAGtB,MAAM,CAACqB,qBAAP,CAA6BH,MAA7B,CAAd;;AAAoD,QAAIC,cAAJ,EAAoB;AAAEG,MAAAA,OAAO,GAAGA,OAAO,CAACC,MAAR,CAAe,UAAUC,GAAV,EAAe;AAAE,eAAOxB,MAAM,CAACyB,wBAAP,CAAgCP,MAAhC,EAAwCM,GAAxC,EAA6CE,UAApD;AAAiE,OAAjG,CAAV;AAA+G;;AAACN,IAAAA,IAAI,CAACO,IAAL,CAAUC,KAAV,CAAgBR,IAAhB,EAAsBE,OAAtB;AAAiC;;AAAC,SAAOF,IAAP;AAAc;;AAEzV,SAASS,aAAT,CAAuBC,MAAvB,EAA+B;AAAE,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGC,SAAS,CAACC,MAA9B,EAAsCF,CAAC,EAAvC,EAA2C;AAAE,QAAIG,MAAM,GAAGF,SAAS,CAACD,CAAD,CAAT,IAAgB,IAAhB,GAAuBC,SAAS,CAACD,CAAD,CAAhC,GAAsC,EAAnD;;AAAuD,QAAIA,CAAC,GAAG,CAAR,EAAW;AAAEd,MAAAA,OAAO,CAACjB,MAAM,CAACkC,MAAD,CAAP,EAAiB,IAAjB,CAAP,CAA8BC,OAA9B,CAAsC,UAAUC,GAAV,EAAe;AAAE,SAAC,GAAG/B,gBAAgB,CAAC,SAAD,CAApB,EAAiCyB,MAAjC,EAAyCM,GAAzC,EAA8CF,MAAM,CAACE,GAAD,CAApD;AAA6D,OAApH;AAAwH,KAArI,MAA2I,IAAIpC,MAAM,CAACqC,yBAAX,EAAsC;AAAErC,MAAAA,MAAM,CAACsC,gBAAP,CAAwBR,MAAxB,EAAgC9B,MAAM,CAACqC,yBAAP,CAAiCH,MAAjC,CAAhC;AAA4E,KAApH,MAA0H;AAAEjB,MAAAA,OAAO,CAACjB,MAAM,CAACkC,MAAD,CAAP,CAAP,CAAwBC,OAAxB,CAAgC,UAAUC,GAAV,EAAe;AAAEpC,QAAAA,MAAM,CAACC,cAAP,CAAsB6B,MAAtB,EAA8BM,GAA9B,EAAmCpC,MAAM,CAACyB,wBAAP,CAAgCS,MAAhC,EAAwCE,GAAxC,CAAnC;AAAmF,OAApI;AAAwI;AAAE;;AAAC,SAAON,MAAP;AAAgB;;AAEviB,IAAI1B,WAAW,GAAG,SAASA,WAAT,CAAqBmC,IAArB,EAA2BC,MAA3B,EAAmC;AACnD,MAAIC,YAAY,GAAGT,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiBU,SAAzC,GAAqDV,SAAS,CAAC,CAAD,CAA9D,GAAoE,KAAvF,CADmD,CAEnD;;AACA,MAAIW,IAAI,GAAG;AACTC,IAAAA,MAAM,EAAE;AADC,GAAX;AAGA,MAAIC,GAAG,GAAGC,UAAU,CAACP,IAAD,EAAOC,MAAP,EAAeG,IAAf,EAAqBF,YAArB,EAAmC,IAAnC,CAApB;AACA,MAAIE,IAAI,CAACC,MAAL,CAAYX,MAAhB,EAAwBc,OAAO,CAACC,IAAR,CAAa,mCAAb,EAAkDL,IAAI,CAACC,MAAvD;AACxB,SAAOC,GAAP;AACD,CATD;;AAWA3C,OAAO,CAACE,WAAR,GAAsBA,WAAtB;;AAEA,IAAI0C,UAAU,GAAG,SAASA,UAAT,CAAoBP,IAApB,EAA0BC,MAA1B,EAAkCG,IAAlC,EAAwC;AACvD,MAAIF,YAAY,GAAGT,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiBU,SAAzC,GAAqDV,SAAS,CAAC,CAAD,CAA9D,GAAoE,KAAvF;AACA,MAAIiB,WAAW,GAAGjB,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiBU,SAAzC,GAAqDV,SAAS,CAAC,CAAD,CAA9D,GAAoE,IAAtF;AACA,MAAI,CAACO,IAAL,EAAW,OAAOG,SAAP;AACX,MAAIQ,IAAI,GAAGX,IAAI,CAACY,GAAL,CAAS,MAAT,CAAX;AACA,MAAIC,QAAQ,GAAGb,IAAI,CAACY,GAAL,CAAS,WAAT,CAAf;;AAEA,MAAI,CAACD,IAAI,KAAK,OAAT,IAAoBA,IAAI,KAAK,YAA9B,KAA+CE,QAA/C,IAA2DA,QAAQ,CAACC,IAAxE,EAA8E;AAC5E,WAAOC,WAAW,CAACf,IAAD,EAAOC,MAAP,EAAeG,IAAf,EAAqBF,YAArB,EAAmCQ,WAAnC,CAAlB;AACD,GAFD,MAEO,IAAIC,IAAI,KAAK,MAAb,EAAqB;AAC1B,WAAOK,UAAU,CAAChB,IAAD,EAAOC,MAAP,EAAeG,IAAf,EAAqBF,YAArB,EAAmCQ,WAAnC,CAAjB;AACD;;AAED,SAAOP,SAAP;AACD,CAdD;;AAgBA,IAAIY,WAAW,GAAG,SAASA,WAAT,CAAqBf,IAArB,EAA2BC,MAA3B,EAAmCG,IAAnC,EAAyC;AACzD,MAAIF,YAAY,GAAGT,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiBU,SAAzC,GAAqDV,SAAS,CAAC,CAAD,CAA9D,GAAoE,KAAvF;AACA,MAAIiB,WAAW,GAAGjB,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiBU,SAAzC,GAAqDV,SAAS,CAAC,CAAD,CAA9D,GAAoE,IAAtF;AACA,MAAIkB,IAAI,GAAGX,IAAI,CAACY,GAAL,CAAS,MAAT,CAAX;AACA,MAAIK,UAAU,GAAGjB,IAAI,CAACY,GAAL,CAAS,YAAT,KAA0B,IAAInC,UAAU,CAACyC,GAAf,EAA3C;AACA,MAAIC,IAAI,GAAGF,UAAU,CAACL,GAAX,CAAe,MAAf,CAAX;AACA,MAAIC,QAAQ,GAAGb,IAAI,CAACY,GAAL,CAAS,WAAT,CAAf;AACA,MAAIQ,WAAW,GAAGT,IAAI,KAAK,YAA3B,CAPyD,CAOhB;;AAEzC,MAAIU,UAAU,GAAGD,WAAW,IAAID,IAAI,IAAI,OAAvB,GAAiCF,UAAU,CAACL,GAAX,CAAe,OAAf,CAAjC,GAA2D,IAA5E;AACA,MAAIU,GAAG,GAAGL,UAAU,CAACL,GAAX,CAAe,KAAf,CAAV;AACA,MAAIW,IAAI,GAAGV,QAAQ,CAACW,GAAT,CAAa,UAAUC,YAAV,EAAwB;AAC9C,WAAOlB,UAAU,CAACkB,YAAD,EAAexB,MAAf,EAAuBG,IAAvB,EAA6BF,YAA7B,EAA2CmB,UAA3C,CAAjB;AACD,GAFU,EAERrC,MAFQ,CAED,UAAUyC,YAAV,EAAwB;AAChC,WAAO,OAAOA,YAAP,KAAwB,WAA/B;AACD,GAJU,CAAX;AAKA,MAAI,CAACF,IAAI,CAACT,IAAV,EAAgB,OAAOX,SAAP;AAChB,MAAIuB,WAAW,GAAGT,UAAU,CAACL,GAAX,CAAe,aAAf,CAAlB;AACA,MAAI,CAACc,WAAL,EAAkBA,WAAW,GAAG,CAAC,GAAGpD,aAAa,CAACqD,kBAAlB,EAAsC1B,MAAtC,CAAd;AAClB,MAAI2B,qBAAqB,GAAG3B,MAAM,CAAC4B,YAAP,CAAoBH,WAApB,CAA5B;AACA,MAAII,OAAO,GAAGF,qBAAqB,CAACG,UAAtB,CAAiCR,IAAjC,EAAuCG,WAAvC,EAAoDJ,GAApD,EAAyDpB,YAAzD,CAAd;AACA,MAAI8B,GAAJ;;AAEA,MAAIX,UAAJ,EAAgB;AACd,QAAIY,QAAQ,GAAGjB,UAAU,CAAChB,IAAD,EAAOC,MAAP,EAAeG,IAAf,EAAqBF,YAArB,EAAmCQ,WAAnC,EAAgD,IAAhD,CAAzB;;AAEA,QAAIoB,OAAO,IAAIG,QAAf,EAAyB;AACvB,UAAIC,gBAAJ;;AAEA,UAAIC,KAAK,GAAGF,QAAQ,CAACG,GAAT,EAAZ;AACA,UAAIC,IAAI,GAAG,CAACP,OAAD,EAAUQ,MAAV,CAAiB,CAAC,GAAGtE,mBAAmB,CAAC,SAAD,CAAvB,EAAoCiE,QAApC,CAAjB,CAAX;AACAD,MAAAA,GAAG,GAAG,CAACE,gBAAgB,GAAGjC,MAAM,CAACsC,QAA3B,EAAqCC,UAArC,CAAgDnD,KAAhD,CAAsD6C,gBAAtD,EAAwE,CAAC,GAAGlE,mBAAmB,CAAC,SAAD,CAAvB,EAAoCqE,IAApC,CAAxE,CAAN;;AAEA,UAAIF,KAAJ,EAAW;AACTH,QAAAA,GAAG,GAAG/B,MAAM,CAACsC,QAAP,CAAgBE,aAAhB,CAA8BT,GAA9B,EAAmC,IAAnC,EAAyC,IAAzC,EAA+C,IAA/C,EAAqD,IAArD,EAA2D9B,YAA3D,CAAN;AACD;AACF;AACF,GAdD,MAcO;AACL8B,IAAAA,GAAG,GAAGF,OAAN;AACD;;AAED,SAAOE,GAAP;AACD,CA1CD;;AA4CA,IAAIU,eAAe,GAAG,SAASA,eAAT,CAAyBzC,MAAzB,EAAiCgB,UAAjC,EAA6Cb,IAA7C,EAAmDuC,SAAnD,EAA8DzC,YAA9D,EAA4EQ,WAA5E,EAAyF;AAC7G,MAAIkC,KAAK,GAAG3B,UAAU,CAACL,GAAX,CAAe,OAAf,CAAZ;AACA,MAAIiC,SAAS,GAAG5B,UAAU,CAACL,GAAX,CAAe,UAAf,CAAhB;AACA,MAAIkC,UAAU,GAAG7B,UAAU,CAACL,GAAX,CAAe,WAAf,CAAjB;AACA,MAAImC,QAAQ,GAAG,CAAC,GAAG9E,YAAY,CAAC+E,cAAjB,EAAiC/C,MAAjC,EAAyC2C,KAAzC,KAAmD,EAAlE;;AAEA,MAAIK,QAAQ,GAAGN,SAAS,IAAI1B,UAAU,CAACL,GAAX,CAAe,UAAf,CAA5B;;AAEA,MAAIsC,WAAW,GAAG,CAAC,GAAGjF,YAAY,CAACkF,iBAAjB,EAAoClD,MAApC,EAA4CgD,QAA5C,EAAsDL,KAAtD,KAAgE,EAAlF;AACA,MAAIQ,WAAW,GAAG,CAAC,GAAG/E,MAAM,CAACgF,YAAX,EAAyBH,WAAW,CAACE,WAArC,EAAkD,CAAlD,CAAlB;AACA,MAAIE,MAAM,GAAGrC,UAAU,CAACL,GAAX,CAAe,OAAf,CAAb;AACA,MAAI2C,eAAe,GAAGtC,UAAU,CAACL,GAAX,CAAe,iBAAf,CAAtB;AACA,MAAI4C,SAAS,GAAG,EAAhB;AACA,MAAIC,UAAU,GAAG,EAAjB;AACA,MAAIC,cAAJ;;AAEA,MAAIJ,MAAM,IAAInD,SAAd,EAAyB;AACvB,QAAIwD,MAAM,GAAGL,MAAM,CAAC9B,GAAP,CAAW,UAAUoC,YAAV,EAAwBC,GAAxB,EAA6B;AACnD,UAAIC,QAAQ,GAAGjB,SAAS,GAAGA,SAAS,CAACjC,GAAV,CAAciD,GAAd,CAAH,GAAwB,IAAhD;AACA,UAAIE,SAAS,GAAGjB,UAAU,GAAGA,UAAU,CAAClC,GAAX,CAAeiD,GAAf,CAAH,GAAyB,IAAnD;AACA,UAAIG,MAAM,GAAG,CAAC,GAAGxF,UAAU,CAACyF,aAAf,EAA8BL,YAA9B,EAA4CE,QAA5C,EAAsD7D,MAAtD,CAAb;AACA,UAAIiE,MAAM,GAAG,CAAC,GAAGhG,UAAU,CAACiG,mBAAf,EAAoClE,MAApC,EAA4C2C,KAA5C,EAAmDK,QAAnD,EAA6Da,QAA7D,CAAb;AACA,UAAIM,cAAc,GAAG,CAAC,GAAGjG,KAAK,CAAC,SAAD,CAAT,EAAsB,CAAC,GAAGF,YAAY,CAACoG,oBAAjB,EAAuCpE,MAAvC,EAA+C2C,KAA/C,EAAsDK,QAAtD,EAAgEiB,MAAhE,EAAwEJ,QAAxE,CAAtB,EAAyG,CAAC,SAAD,CAAzG,CAArB;AACA,UAAIQ,EAAE,GAAGC,WAAW,CAACtE,MAAD,EAASG,IAAT,EAAe4D,MAAf,EAAuBF,QAAvB,EAAiCC,SAAjC,EAA4CK,cAA5C,EAA4DrB,QAA5D,EAAsEE,QAAtE,EAAgFC,WAAhF,EAA6FhD,YAA7F,EAA2GQ,WAA3G,EAAwH6C,eAAxH,CAApB;;AAEA,UAAIe,EAAE,KAAKnE,SAAX,EAAsB;AACpBqD,QAAAA,SAAS,CAACpE,IAAV,CAAe0E,QAAf;AACAL,QAAAA,UAAU,CAACrE,IAAX,CAAgB2E,SAAhB;AACD;;AAED,aAAOO,EAAP;AACD,KAdY,CAAb;AAeA,QAAIE,kBAAkB,GAAGb,MAAM,CAAC3E,MAAP,CAAc,UAAUyF,CAAV,EAAa;AAClD,aAAOA,CAAC,KAAKtE,SAAb;AACD,KAFwB,EAEtBW,IAFsB,GAEf,CAFV;;AAIA,QAAI,EAAE0D,kBAAkB,IAAIb,MAAM,CAAC7C,IAAP,GAAcsC,WAAtC,CAAJ,EAAwD;AACtDM,MAAAA,cAAc,GAAGN,WAAW,IAAI,CAAf,GAAmBO,MAAM,CAACe,KAAP,EAAnB,GAAoCf,MAArD;AACD;AACF;;AAED,SAAO,CAACD,cAAD,EAAiBF,SAAS,CAAC9D,MAAV,GAAmB,CAAnB,GAAuB8D,SAAvB,GAAmCA,SAAS,CAAC,CAAD,CAA7D,EAAkEC,UAAU,CAAC/D,MAAX,GAAoB,CAApB,GAAwB+D,UAAxB,GAAqCA,UAAU,CAAC,CAAD,CAAjH,CAAP;AACD,CA1CD;;AA4CA,IAAIzC,UAAU,GAAG,SAASA,UAAT,CAAoBhB,IAApB,EAA0BC,MAA1B,EAAkCG,IAAlC,EAAwC;AACvD,MAAIF,YAAY,GAAGT,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiBU,SAAzC,GAAqDV,SAAS,CAAC,CAAD,CAA9D,GAAoE,KAAvF;AACA,MAAIiB,WAAW,GAAGjB,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiBU,SAAzC,GAAqDV,SAAS,CAAC,CAAD,CAA9D,GAAoE,IAAtF;AACA,MAAIkF,UAAU,GAAGlF,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiBU,SAAzC,GAAqDV,SAAS,CAAC,CAAD,CAA9D,GAAoE,KAArF;AACA,MAAIwB,UAAU,GAAGjB,IAAI,CAACY,GAAL,CAAS,YAAT,KAA0B,IAAInC,UAAU,CAACyC,GAAf,EAA3C;AACA,MAAI0B,KAAK,GAAG3B,UAAU,CAACL,GAAX,CAAe,OAAf,CAAZ;AACA,MAAIqC,QAAQ,GAAGhC,UAAU,CAACL,GAAX,CAAe,UAAf,CAAf;AACA,MAAIgE,eAAe,GAAG3D,UAAU,CAACL,GAAX,CAAe,iBAAf,CAAtB;AACA,MAAIgC,KAAK,IAAI,IAAT,IAAiBK,QAAQ,IAAI,IAAjC,EAAuC,OAAO9C,SAAP;AACvC,MAAI4C,QAAQ,GAAG,CAAC,GAAG9E,YAAY,CAAC+E,cAAjB,EAAiC/C,MAAjC,EAAyC2C,KAAzC,KAAmD,EAAlE;AACA,MAAIM,WAAW,GAAG,CAAC,GAAGjF,YAAY,CAACkF,iBAAjB,EAAoClD,MAApC,EAA4CgD,QAA5C,EAAsDL,KAAtD,KAAgE,EAAlF;AACA,MAAIiC,UAAU,GAAG3B,WAAW,CAAC2B,UAA7B;AACA,MAAIC,cAAc,GAAG,CAAC,GAAG7G,YAAY,CAACkF,iBAAjB,EAAoClD,MAApC,EAA4C4E,UAA5C,EAAwDjC,KAAxD,KAAkE,EAAvF;AACA,MAAIQ,WAAW,GAAG,CAAC,GAAG/E,MAAM,CAACgF,YAAX,EAAyBH,WAAW,CAACE,WAArC,EAAkD,CAAlD,CAAlB,CAbuD,CAaiB;;AAExE,MAAIjB,KAAK,GAAG,KAAZ;AACA,MAAI4C,EAAE,GAAG7B,WAAW,CAAC8B,QAArB;;AAEA,MAAI,CAACD,EAAD,IAAOF,UAAX,EAAuB;AACrBE,IAAAA,EAAE,GAAGD,cAAc,CAACE,QAApB;;AAEA,QAAID,EAAJ,EAAQ;AACN5C,MAAAA,KAAK,GAAG,IAAR;AACA,UAAI8C,IAAI,GAAG,CAACJ,UAAD,EAAa5B,QAAb,CAAX;AACAA,MAAAA,QAAQ,GAAGgC,IAAI,CAAC,CAAD,CAAf;AACAJ,MAAAA,UAAU,GAAGI,IAAI,CAAC,CAAD,CAAjB;AACA,UAAIC,KAAK,GAAG,CAACJ,cAAD,EAAiB5B,WAAjB,CAAZ;AACAA,MAAAA,WAAW,GAAGgC,KAAK,CAAC,CAAD,CAAnB;AACAJ,MAAAA,cAAc,GAAGI,KAAK,CAAC,CAAD,CAAtB;AACD;AACF;;AAED,MAAIC,GAAG,GAAGjC,WAAW,CAACkC,cAAZ,IAA8BnC,QAAxC,CAhCuD,CAgCL;;AAElD,MAAI,CAAC8B,EAAL,EAAS;AACP,QAAI3B,WAAW,IAAI,CAAnB,EAAsB;AACpB2B,MAAAA,EAAE,GAAG,SAASA,EAAT,CAAYnC,KAAZ,EAAmByC,EAAnB,EAAuBC,MAAvB,EAA+BxB,QAA/B,EAAyCC,SAAzC,EAAoDwB,KAApD,EAA2DX,eAA3D,EAA4E1E,YAA5E,EAA0F;AAC7F,eAAO,GAAGoC,MAAH,CAAUM,KAAV,EAAiB,GAAjB,EAAsBN,MAAtB,CAA6B6C,GAA7B,CAAP;AACD,OAFD;AAGD,KAJD,MAIO,IAAI/B,WAAW,IAAI,CAAnB,EAAsB;AAC3B2B,MAAAA,EAAE,GAAG,SAASA,EAAT,CAAYnC,KAAZ,EAAmByC,EAAnB,EAAuBC,MAAvB,EAA+BxB,QAA/B,EAAyCC,SAAzC,EAAoDwB,KAApD,EAA2DX,eAA3D,EAA4E1E,YAA5E,EAA0F;AAC7F,eAAO,GAAGoC,MAAH,CAAUM,KAAV,EAAiB,GAAjB,EAAsBN,MAAtB,CAA6B6C,GAA7B,EAAkC,GAAlC,EAAuC7C,MAAvC,CAA8CgD,MAA9C,CAAP;AACD,OAFD;AAGD,KAJM,MAIA,IAAIlC,WAAW,IAAI,CAAnB,EAAsB;AAC3B;AACA2B,MAAAA,EAAE,GAAG,SAASA,EAAT,CAAYnC,KAAZ,EAAmByC,EAAnB,EAAuBC,MAAvB,EAA+BxB,QAA/B,EAAyCC,SAAzC,EAAoDwB,KAApD,EAA2DX,eAA3D,EAA4E1E,YAA5E,EAA0F;AAC7F,YAAIsF,OAAO,GAAGF,MAAM,CAACZ,KAAP,EAAd;AACA,YAAIe,KAAK,GAAGH,MAAM,CAAC1E,GAAP,CAAW,CAAX,CAAZ;AACA,eAAO,GAAG0B,MAAH,CAAUM,KAAV,EAAiB,GAAjB,EAAsBN,MAAtB,CAA6B6C,GAA7B,EAAkC,GAAlC,EAAuC7C,MAAvC,CAA8CkD,OAA9C,EAAuD,OAAvD,EAAgElD,MAAhE,CAAuEmD,KAAvE,CAAP;AACD,OAJD;AAKD;AACF;;AAED,MAAI,CAACV,EAAL,EAAS,OAAO5E,SAAP,CArD8C,CAqD5B;;AAE3B,MAAIuF,cAAc,GAAGC,WAAW,CAAC1F,MAAD,EAASG,IAAT,EAAewC,KAAf,EAAsB1C,YAAtB,EAAoCQ,WAApC,CAAhC,CAvDuD,CAuD2B;;AAElF,MAAIkF,gBAAgB,GAAGlD,eAAe,CAACzC,MAAD,EAASgB,UAAT,EAAqBb,IAArB,EAA2B6C,QAA3B,EAAqC/C,YAArC,EAAmDQ,WAAnD,CAAtC;AAAA,MACImF,iBAAiB,GAAG,CAAC,GAAG9H,eAAe,CAAC,SAAD,CAAnB,EAAgC6H,gBAAhC,EAAkD,CAAlD,CADxB;AAAA,MAEIlC,cAAc,GAAGmC,iBAAiB,CAAC,CAAD,CAFtC;AAAA,MAGI/B,QAAQ,GAAG+B,iBAAiB,CAAC,CAAD,CAHhC;AAAA,MAII9B,SAAS,GAAG8B,iBAAiB,CAAC,CAAD,CAJjC;;AAMA,MAAInC,cAAc,KAAKvD,SAAvB,EAAkC,OAAOA,SAAP;AAClC,MAAIkC,IAAI,GAAG,CAACqD,cAAD,EAAiBzC,QAAjB,EAA2BS,cAA3B,EAA2CI,QAA3C,EAAqDC,SAArD,EAAgE,CAAC,GAAG5F,KAAK,CAAC,SAAD,CAAT,EAAsB+E,WAAtB,EAAmC,CAAC,UAAD,EAAa,eAAb,EAA8B,aAA9B,EAA6C,WAA7C,CAAnC,CAAhE,EAA+J0B,eAA/J,EAAgL1E,YAAhL,EAA8L6C,QAA9L,EAAwMZ,KAAxM,CAAX;;AAEA,MAAIwC,UAAJ,EAAgB;AACd,WAAOtC,IAAP;AACD,GAFD,MAEO;AACL;AACA,QAAIL,GAAG,GAAG+C,EAAE,CAAC1F,KAAH,CAAS,KAAK,CAAd,EAAiBgD,IAAjB,CAAV,CAFK,CAE6B;;AAElC,QAAIF,KAAJ,EAAW;AACTH,MAAAA,GAAG,GAAG/B,MAAM,CAACsC,QAAP,CAAgBE,aAAhB,CAA8BT,GAA9B,EAAmCiB,QAAnC,EAA6C4B,UAA7C,EAAyD3B,WAAzD,EAAsE4B,cAAtE,EAAsF5E,YAAtF,CAAN;AACD;;AAED,WAAO8B,GAAP;AACD;AACF,CA9ED;;AAgFA,IAAIuC,WAAW,GAAG,SAASA,WAAT,CAAqBtE,MAArB,EAA6BG,IAA7B,EAAmCxC,KAAnC,EAA0CkG,QAA1C,EAAoDC,SAApD,EAA+DK,cAA/D,EAA+ErB,QAA/E,EAAyFE,QAAzF,EAAmGsC,KAAnG,EAA0GrF,YAA1G,EAAwH;AACxI,MAAIQ,WAAW,GAAGjB,SAAS,CAACC,MAAV,GAAmB,EAAnB,IAAyBD,SAAS,CAAC,EAAD,CAAT,KAAkBU,SAA3C,GAAuDV,SAAS,CAAC,EAAD,CAAhE,GAAuE,IAAzF;AACA,MAAI8D,eAAe,GAAG9D,SAAS,CAACC,MAAV,GAAmB,EAAnB,GAAwBD,SAAS,CAAC,EAAD,CAAjC,GAAwCU,SAA9D;AACA,MAAIvC,KAAK,KAAKuC,SAAd,EAAyB,OAAOA,SAAP;AACzB,MAAI6B,GAAJ;;AAEA,MAAI8B,QAAQ,IAAI,OAAhB,EAAyB;AACvB9B,IAAAA,GAAG,GAAG2D,WAAW,CAAC1F,MAAD,EAASG,IAAT,EAAexC,KAAf,EAAsBsC,YAAtB,EAAoCQ,WAApC,CAAjB;AACD,GAFD,MAEO,IAAIoD,QAAQ,IAAI,MAAhB,EAAwB;AAC7B9B,IAAAA,GAAG,GAAG8D,UAAU,CAAC7F,MAAD,EAASG,IAAT,EAAexC,KAAf,EAAsBsC,YAAtB,EAAoCQ,WAApC,CAAhB;AACD,GAFM,MAEA;AACL,QAAI,OAAO0D,cAAc,CAACG,WAAtB,KAAsC,UAA1C,EAAsD;AACpD,UAAIQ,EAAE,GAAGX,cAAc,CAACG,WAAxB;AACA,UAAIlC,IAAI,GAAG,CAACzE,KAAD,EAAQ0B,aAAa,CAACA,aAAa,CAAC,EAAD,EAAK,CAAC,GAAGlB,KAAK,CAAC,SAAD,CAAT,EAAsB2E,QAAtB,EAAgC,CAAC,eAAD,EAAkB,YAAlB,CAAhC,CAAL,CAAd,EAAsF,EAAtF,EAA0F;AACxHQ,QAAAA,eAAe,EAAEA;AADuG,OAA1F,CAArB,EAEP;AACJ,OAAC,GAAGpF,KAAK,CAAC,SAAD,CAAT,EAAsBiG,cAAtB,EAAsC,CAAC,aAAD,EAAgB,kBAAhB,EAAoC,gBAApC,EAAsD,WAAtD,EAAmE,0BAAnE,CAAtC,CAHW,EAG4HlE,YAH5H,CAAX;;AAKA,UAAI+C,QAAJ,EAAc;AACZZ,QAAAA,IAAI,CAACjD,IAAL,CAAU6D,QAAV;AACAZ,QAAAA,IAAI,CAACjD,IAAL,CAAUmG,KAAV;AACD;;AAED,UAAIzB,QAAQ,IAAI,OAAhB,EAAyB;AACvB,YAAIiC,kBAAkB,GAAG,CAAC,GAAG9H,YAAY,CAAC+E,cAAjB,EAAiC/C,MAAjC,EAAyCrC,KAAzC,KAAmD,EAA5E;AACAyE,QAAAA,IAAI,CAACjD,IAAL,CAAU2G,kBAAV;AACD;;AAED/D,MAAAA,GAAG,GAAG+C,EAAE,CAAC1F,KAAH,CAAS,KAAK,CAAd,EAAiBgD,IAAjB,CAAN;AACD,KAlBD,MAkBO;AACLL,MAAAA,GAAG,GAAGpE,KAAN;AACD;AACF;;AAED,SAAOoE,GAAP;AACD,CAnCD;;AAqCA,IAAI2D,WAAW,GAAG,SAASA,WAAT,CAAqB1F,MAArB,EAA6BG,IAA7B,EAAmCwC,KAAnC,EAA0C1C,YAA1C,EAAwD;AACxE,MAAIQ,WAAW,GAAGjB,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiBU,SAAzC,GAAqDV,SAAS,CAAC,CAAD,CAA9D,GAAoE,IAAtF;AACA,MAAIuG,cAAc,GAAGvG,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiBU,SAAzC,GAAqDV,SAAS,CAAC,CAAD,CAA9D,GAAoE,IAAzF;AACA,MAAIwG,iBAAiB,GAAGhG,MAAM,CAACsC,QAA/B;AAAA,MACI2D,cAAc,GAAGD,iBAAiB,CAACC,cADvC;AAAA,MAEIC,qBAAqB,GAAGF,iBAAiB,CAACE,qBAF9C;AAGA,MAAInE,GAAG,GAAG,IAAV;;AAEA,MAAIY,KAAJ,EAAW;AACT,QAAIwD,eAAe,GAAG,CAAC,GAAGnI,YAAY,CAAC+E,cAAjB,EAAiC/C,MAAjC,EAAyC2C,KAAzC,KAAmD,EAAzE;AACA,QAAIyD,UAAU,GAAGC,KAAK,CAACC,OAAN,CAAc3D,KAAd,IAAuBA,KAAvB,GAA+BA,KAAK,CAAC4D,KAAN,CAAYN,cAAZ,CAAhD;;AAEA,QAAIO,UAAU,GAAG,CAAC,GAAGvI,UAAU,CAACwI,YAAf,EAA6B9D,KAA7B,EAAoC3C,MAApC,CAAjB;;AAEA,QAAI0G,gBAAgB,GAAG,CAAC,GAAGzI,UAAU,CAAC0I,kBAAf,EAAmChE,KAAnC,EAA0C3C,MAA1C,EAAkD+F,cAAc,GAAGtF,WAAH,GAAiB,IAAjF,CAAvB;AACA,QAAImG,cAAc,GAAGF,gBAAgB,GAAGA,gBAAgB,CAACG,IAAjB,CAAsBX,qBAAtB,CAAH,GAAkD,IAAvF;AACA,QAAIY,WAAW,GAAGX,eAAe,CAACY,MAAhB,IAA0BH,cAA5C;AACA,QAAII,aAAa,GAAGhH,MAAM,CAACsC,QAAP,CAAgBoD,WAAhB,IAA+BpH,QAAQ,CAACgE,QAAT,CAAkBoD,WAArE;AACA,QAAIuB,SAAS,GAAG,CAAC,GAAGhJ,UAAU,CAACiJ,eAAf,EAAgCvE,KAAhC,EAAuC3C,MAAvC,EAA+CG,IAA/C,EAAqD4F,cAAc,GAAGtF,WAAH,GAAiB,IAApF,CAAhB;AACAsB,IAAAA,GAAG,GAAGiF,aAAa,CAACC,SAAD,EAAYb,UAAZ,EAAwBU,WAAxB,EAAqCX,eAArC,EAAsDnG,MAAtD,EAA8DC,YAA9D,CAAnB;AACD;;AAED,SAAO8B,GAAP;AACD,CAvBD;;AAyBA,IAAI8D,UAAU,GAAG,SAASA,UAAT,CAAoB7F,MAApB,EAA4BG,IAA5B,EAAkCgH,SAAlC,EAA6ClH,YAA7C,EAA2D;AAC1E,MAAIQ,WAAW,GAAGjB,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiBU,SAAzC,GAAqDV,SAAS,CAAC,CAAD,CAA9D,GAAoE,IAAtF;AACA,MAAI4H,OAAO,GAAGD,SAAS,CAACxG,GAAV,CAAc,MAAd,CAAd;AACA,MAAIyB,IAAI,GAAG+E,SAAS,CAACxG,GAAV,CAAc,MAAd,CAAX;AACA,MAAI0G,UAAU,GAAG,CAAC,GAAGrJ,YAAY,CAACsJ,aAAjB,EAAgCtH,MAAhC,EAAwCoH,OAAxC,CAAjB;AACA,MAAIG,QAAQ,GAAGtH,YAAY,IAAIoH,UAAU,CAACG,KAA3B,IAAoCJ,OAAnD;AACA,MAAIK,aAAa,GAAG,EAApB;AACA,MAAIC,sBAAsB,GAAG,EAA7B;;AAEA,OAAK,IAAIC,MAAT,IAAmBN,UAAU,CAACjF,IAA9B,EAAoC;AAClC,QAAIwF,SAAS,GAAGP,UAAU,CAACjF,IAAX,CAAgBuF,MAAhB,CAAhB;AACA,QAAI7E,QAAQ,GAAG,CAAC,GAAG9E,YAAY,CAAC+E,cAAjB,EAAiC/C,MAAjC,EAAyC4H,SAAzC,CAAf;AACA,QAAIC,MAAM,GAAGzF,IAAI,GAAGA,IAAI,CAACzB,GAAL,CAASgH,MAAT,CAAH,GAAsBzH,SAAvC;AACA,QAAI4H,QAAQ,GAAGD,MAAM,GAAGA,MAAM,CAAClH,GAAP,CAAW,OAAX,CAAH,GAAyBT,SAA9C;AACA,QAAI6H,WAAW,GAAGF,MAAM,GAAGA,MAAM,CAAClH,GAAP,CAAW,UAAX,CAAH,GAA4BT,SAApD;AACA,QAAI8H,kBAAkB,GAAGH,MAAM,GAAGA,MAAM,CAAClH,GAAP,CAAW,iBAAX,CAAH,GAAmCT,SAAlE;AACA,QAAI+H,eAAe,GAAG3D,WAAW,CAACtE,MAAD,EAASG,IAAT,EAAe2H,QAAf,EAAyBC,WAAzB,EAAsCH,SAAS,CAAClH,IAAhD,EAAsDoC,QAAtD,EAAgE8E,SAAhE,EAA2E,IAA3E,EAAiF,IAAjF,EAAuF3H,YAAvF,EAAqGQ,WAArG,EAAkHuH,kBAAlH,CAAjC;AACA,QAAIE,OAAO,GAAGjI,YAAY,IAAI2H,SAAS,CAACJ,KAA1B,IAAmCG,MAAjD;;AAEA,QAAIM,eAAe,KAAK/H,SAAxB,EAAmC;AACjC;AACAuH,MAAAA,aAAa,CAACE,MAAD,CAAb,GAAwBM,eAAxB;AACAP,MAAAA,sBAAsB,CAACQ,OAAD,CAAtB,GAAkCD,eAAlC;AACD;AACF;;AAED,MAAIlG,GAAG,GAAG,IAAV;;AAEA,MAAI,OAAOsF,UAAU,CAACxB,UAAlB,KAAiC,UAArC,EAAiD;AAC/C,QAAIf,EAAE,GAAGuC,UAAU,CAACxB,UAApB;AACA,QAAIsC,KAAK,GAAG,CAACV,aAAD,EAAgBxH,YAAhB,CAAZ;AACA8B,IAAAA,GAAG,GAAG+C,EAAE,CAAC1F,KAAH,CAAS,KAAK,CAAd,EAAiB+I,KAAjB,CAAN;AACD,GAJD,MAIO;AACL,QAAIC,OAAO,GAAG5K,MAAM,CAAC6K,OAAP,CAAeX,sBAAf,EAAuCnG,GAAvC,CAA2C,UAAU+G,KAAV,EAAiB;AACxE,UAAIC,KAAK,GAAG,CAAC,GAAGzK,eAAe,CAAC,SAAD,CAAnB,EAAgCwK,KAAhC,EAAuC,CAAvC,CAAZ;AAAA,UACIE,CAAC,GAAGD,KAAK,CAAC,CAAD,CADb;AAAA,UAEI/D,CAAC,GAAG+D,KAAK,CAAC,CAAD,CAFb;;AAIA,aAAOtI,YAAY,GAAG,GAAGoC,MAAH,CAAUmG,CAAV,EAAa,IAAb,EAAmBnG,MAAnB,CAA0BmC,CAA1B,CAAH,GAAkC,GAAGnC,MAAH,CAAUmC,CAAV,CAArD;AACD,KANa,EAMXqC,IANW,CAMN,IANM,CAAd;AAOA9E,IAAAA,GAAG,GAAG,GAAGM,MAAH,CAAUkF,QAAV,EAAoB,GAApB,EAAyBlF,MAAzB,CAAgC+F,OAAhC,EAAyC,GAAzC,CAAN;AACD;;AAED,SAAOrG,GAAP;AACD,CA5CD","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.queryString = void 0;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _configUtils = require(\"../utils/configUtils\");\n\nvar _ruleUtils = require(\"../utils/ruleUtils\");\n\nvar _omit = _interopRequireDefault(require(\"lodash/omit\"));\n\nvar _pick = _interopRequireDefault(require(\"lodash/pick\"));\n\nvar _stuff = require(\"../utils/stuff\");\n\nvar _defaultUtils = require(\"../utils/defaultUtils\");\n\nvar _default = require(\"../config/default\");\n\nvar _funcUtils = require(\"../utils/funcUtils\");\n\nvar _immutable = require(\"immutable\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2[\"default\"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar queryString = function queryString(item, config) {\n  var isForDisplay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  //meta is mutable\n  var meta = {\n    errors: []\n  };\n  var res = formatItem(item, config, meta, isForDisplay, null);\n  if (meta.errors.length) console.warn(\"Errors while exporting to string:\", meta.errors);\n  return res;\n};\n\nexports.queryString = queryString;\n\nvar formatItem = function formatItem(item, config, meta) {\n  var isForDisplay = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var parentField = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  if (!item) return undefined;\n  var type = item.get(\"type\");\n  var children = item.get(\"children1\");\n\n  if ((type === \"group\" || type === \"rule_group\") && children && children.size) {\n    return formatGroup(item, config, meta, isForDisplay, parentField);\n  } else if (type === \"rule\") {\n    return formatRule(item, config, meta, isForDisplay, parentField);\n  }\n\n  return undefined;\n};\n\nvar formatGroup = function formatGroup(item, config, meta) {\n  var isForDisplay = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var parentField = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  var type = item.get(\"type\");\n  var properties = item.get(\"properties\") || new _immutable.Map();\n  var mode = properties.get(\"mode\");\n  var children = item.get(\"children1\");\n  var isRuleGroup = type === \"rule_group\"; // TIP: don't cut group for mode == 'struct' and don't do aggr format (maybe later)\n\n  var groupField = isRuleGroup && mode == \"array\" ? properties.get(\"field\") : null;\n  var not = properties.get(\"not\");\n  var list = children.map(function (currentChild) {\n    return formatItem(currentChild, config, meta, isForDisplay, groupField);\n  }).filter(function (currentChild) {\n    return typeof currentChild !== \"undefined\";\n  });\n  if (!list.size) return undefined;\n  var conjunction = properties.get(\"conjunction\");\n  if (!conjunction) conjunction = (0, _defaultUtils.defaultConjunction)(config);\n  var conjunctionDefinition = config.conjunctions[conjunction];\n  var conjStr = conjunctionDefinition.formatConj(list, conjunction, not, isForDisplay);\n  var ret;\n\n  if (groupField) {\n    var aggrArgs = formatRule(item, config, meta, isForDisplay, parentField, true);\n\n    if (conjStr && aggrArgs) {\n      var _config$settings;\n\n      var isRev = aggrArgs.pop();\n      var args = [conjStr].concat((0, _toConsumableArray2[\"default\"])(aggrArgs));\n      ret = (_config$settings = config.settings).formatAggr.apply(_config$settings, (0, _toConsumableArray2[\"default\"])(args));\n\n      if (isRev) {\n        ret = config.settings.formatReverse(ret, null, null, null, null, isForDisplay);\n      }\n    }\n  } else {\n    ret = conjStr;\n  }\n\n  return ret;\n};\n\nvar formatItemValue = function formatItemValue(config, properties, meta, _operator, isForDisplay, parentField) {\n  var field = properties.get(\"field\");\n  var iValueSrc = properties.get(\"valueSrc\");\n  var iValueType = properties.get(\"valueType\");\n  var fieldDef = (0, _configUtils.getFieldConfig)(config, field) || {};\n\n  var operator = _operator || properties.get(\"operator\");\n\n  var operatorDef = (0, _configUtils.getOperatorConfig)(config, operator, field) || {};\n  var cardinality = (0, _stuff.defaultValue)(operatorDef.cardinality, 1);\n  var iValue = properties.get(\"value\");\n  var asyncListValues = properties.get(\"asyncListValues\");\n  var valueSrcs = [];\n  var valueTypes = [];\n  var formattedValue;\n\n  if (iValue != undefined) {\n    var fvalue = iValue.map(function (currentValue, ind) {\n      var valueSrc = iValueSrc ? iValueSrc.get(ind) : null;\n      var valueType = iValueType ? iValueType.get(ind) : null;\n      var cValue = (0, _funcUtils.completeValue)(currentValue, valueSrc, config);\n      var widget = (0, _ruleUtils.getWidgetForFieldOp)(config, field, operator, valueSrc);\n      var fieldWidgetDef = (0, _omit[\"default\"])((0, _configUtils.getFieldWidgetConfig)(config, field, operator, widget, valueSrc), [\"factory\"]);\n      var fv = formatValue(config, meta, cValue, valueSrc, valueType, fieldWidgetDef, fieldDef, operator, operatorDef, isForDisplay, parentField, asyncListValues);\n\n      if (fv !== undefined) {\n        valueSrcs.push(valueSrc);\n        valueTypes.push(valueType);\n      }\n\n      return fv;\n    });\n    var hasUndefinedValues = fvalue.filter(function (v) {\n      return v === undefined;\n    }).size > 0;\n\n    if (!(hasUndefinedValues || fvalue.size < cardinality)) {\n      formattedValue = cardinality == 1 ? fvalue.first() : fvalue;\n    }\n  }\n\n  return [formattedValue, valueSrcs.length > 1 ? valueSrcs : valueSrcs[0], valueTypes.length > 1 ? valueTypes : valueTypes[0]];\n};\n\nvar formatRule = function formatRule(item, config, meta) {\n  var isForDisplay = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var parentField = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  var returnArgs = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  var properties = item.get(\"properties\") || new _immutable.Map();\n  var field = properties.get(\"field\");\n  var operator = properties.get(\"operator\");\n  var operatorOptions = properties.get(\"operatorOptions\");\n  if (field == null || operator == null) return undefined;\n  var fieldDef = (0, _configUtils.getFieldConfig)(config, field) || {};\n  var operatorDef = (0, _configUtils.getOperatorConfig)(config, operator, field) || {};\n  var reversedOp = operatorDef.reversedOp;\n  var revOperatorDef = (0, _configUtils.getOperatorConfig)(config, reversedOp, field) || {};\n  var cardinality = (0, _stuff.defaultValue)(operatorDef.cardinality, 1); //check op\n\n  var isRev = false;\n  var fn = operatorDef.formatOp;\n\n  if (!fn && reversedOp) {\n    fn = revOperatorDef.formatOp;\n\n    if (fn) {\n      isRev = true;\n      var _ref = [reversedOp, operator];\n      operator = _ref[0];\n      reversedOp = _ref[1];\n      var _ref2 = [revOperatorDef, operatorDef];\n      operatorDef = _ref2[0];\n      revOperatorDef = _ref2[1];\n    }\n  }\n\n  var fop = operatorDef.labelForFormat || operator; //find fn to format expr\n\n  if (!fn) {\n    if (cardinality == 0) {\n      fn = function fn(field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {\n        return \"\".concat(field, \" \").concat(fop);\n      };\n    } else if (cardinality == 1) {\n      fn = function fn(field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {\n        return \"\".concat(field, \" \").concat(fop, \" \").concat(values);\n      };\n    } else if (cardinality == 2) {\n      // between\n      fn = function fn(field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {\n        var valFrom = values.first();\n        var valTo = values.get(1);\n        return \"\".concat(field, \" \").concat(fop, \" \").concat(valFrom, \" AND \").concat(valTo);\n      };\n    }\n  }\n\n  if (!fn) return undefined; //format field\n\n  var formattedField = formatField(config, meta, field, isForDisplay, parentField); //format value\n\n  var _formatItemValue = formatItemValue(config, properties, meta, operator, isForDisplay, parentField),\n      _formatItemValue2 = (0, _slicedToArray2[\"default\"])(_formatItemValue, 3),\n      formattedValue = _formatItemValue2[0],\n      valueSrc = _formatItemValue2[1],\n      valueType = _formatItemValue2[2];\n\n  if (formattedValue === undefined) return undefined;\n  var args = [formattedField, operator, formattedValue, valueSrc, valueType, (0, _omit[\"default\"])(operatorDef, [\"formatOp\", \"mongoFormatOp\", \"sqlFormatOp\", \"jsonLogic\"]), operatorOptions, isForDisplay, fieldDef, isRev];\n\n  if (returnArgs) {\n    return args;\n  } else {\n    //format expr\n    var ret = fn.apply(void 0, args); //rev\n\n    if (isRev) {\n      ret = config.settings.formatReverse(ret, operator, reversedOp, operatorDef, revOperatorDef, isForDisplay);\n    }\n\n    return ret;\n  }\n};\n\nvar formatValue = function formatValue(config, meta, value, valueSrc, valueType, fieldWidgetDef, fieldDef, operator, opDef, isForDisplay) {\n  var parentField = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : null;\n  var asyncListValues = arguments.length > 11 ? arguments[11] : undefined;\n  if (value === undefined) return undefined;\n  var ret;\n\n  if (valueSrc == \"field\") {\n    ret = formatField(config, meta, value, isForDisplay, parentField);\n  } else if (valueSrc == \"func\") {\n    ret = formatFunc(config, meta, value, isForDisplay, parentField);\n  } else {\n    if (typeof fieldWidgetDef.formatValue === \"function\") {\n      var fn = fieldWidgetDef.formatValue;\n      var args = [value, _objectSpread(_objectSpread({}, (0, _pick[\"default\"])(fieldDef, [\"fieldSettings\", \"listValues\"])), {}, {\n        asyncListValues: asyncListValues\n      }), //useful options: valueFormat for date/time\n      (0, _omit[\"default\"])(fieldWidgetDef, [\"formatValue\", \"mongoFormatValue\", \"sqlFormatValue\", \"jsonLogic\", \"elasticSearchFormatValue\"]), isForDisplay];\n\n      if (operator) {\n        args.push(operator);\n        args.push(opDef);\n      }\n\n      if (valueSrc == \"field\") {\n        var valFieldDefinition = (0, _configUtils.getFieldConfig)(config, value) || {};\n        args.push(valFieldDefinition);\n      }\n\n      ret = fn.apply(void 0, args);\n    } else {\n      ret = value;\n    }\n  }\n\n  return ret;\n};\n\nvar formatField = function formatField(config, meta, field, isForDisplay) {\n  var parentField = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  var cutParentField = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n  var _config$settings2 = config.settings,\n      fieldSeparator = _config$settings2.fieldSeparator,\n      fieldSeparatorDisplay = _config$settings2.fieldSeparatorDisplay;\n  var ret = null;\n\n  if (field) {\n    var fieldDefinition = (0, _configUtils.getFieldConfig)(config, field) || {};\n    var fieldParts = Array.isArray(field) ? field : field.split(fieldSeparator);\n\n    var _fieldKeys = (0, _ruleUtils.getFieldPath)(field, config);\n\n    var fieldPartsLabels = (0, _ruleUtils.getFieldPathLabels)(field, config, cutParentField ? parentField : null);\n    var fieldFullLabel = fieldPartsLabels ? fieldPartsLabels.join(fieldSeparatorDisplay) : null;\n    var fieldLabel2 = fieldDefinition.label2 || fieldFullLabel;\n    var formatFieldFn = config.settings.formatField || _default.settings.formatField;\n    var fieldName = (0, _ruleUtils.formatFieldName)(field, config, meta, cutParentField ? parentField : null);\n    ret = formatFieldFn(fieldName, fieldParts, fieldLabel2, fieldDefinition, config, isForDisplay);\n  }\n\n  return ret;\n};\n\nvar formatFunc = function formatFunc(config, meta, funcValue, isForDisplay) {\n  var parentField = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  var funcKey = funcValue.get(\"func\");\n  var args = funcValue.get(\"args\");\n  var funcConfig = (0, _configUtils.getFuncConfig)(config, funcKey);\n  var funcName = isForDisplay && funcConfig.label || funcKey;\n  var formattedArgs = {};\n  var formattedArgsWithNames = {};\n\n  for (var argKey in funcConfig.args) {\n    var argConfig = funcConfig.args[argKey];\n    var fieldDef = (0, _configUtils.getFieldConfig)(config, argConfig);\n    var argVal = args ? args.get(argKey) : undefined;\n    var argValue = argVal ? argVal.get(\"value\") : undefined;\n    var argValueSrc = argVal ? argVal.get(\"valueSrc\") : undefined;\n    var argAsyncListValues = argVal ? argVal.get(\"asyncListValues\") : undefined;\n    var formattedArgVal = formatValue(config, meta, argValue, argValueSrc, argConfig.type, fieldDef, argConfig, null, null, isForDisplay, parentField, argAsyncListValues);\n    var argName = isForDisplay && argConfig.label || argKey;\n\n    if (formattedArgVal !== undefined) {\n      // skip optional in the end\n      formattedArgs[argKey] = formattedArgVal;\n      formattedArgsWithNames[argName] = formattedArgVal;\n    }\n  }\n\n  var ret = null;\n\n  if (typeof funcConfig.formatFunc === \"function\") {\n    var fn = funcConfig.formatFunc;\n    var _args = [formattedArgs, isForDisplay];\n    ret = fn.apply(void 0, _args);\n  } else {\n    var argsStr = Object.entries(formattedArgsWithNames).map(function (_ref3) {\n      var _ref4 = (0, _slicedToArray2[\"default\"])(_ref3, 2),\n          k = _ref4[0],\n          v = _ref4[1];\n\n      return isForDisplay ? \"\".concat(k, \": \").concat(v) : \"\".concat(v);\n    }).join(\", \");\n    ret = \"\".concat(funcName, \"(\").concat(argsStr, \")\");\n  }\n\n  return ret;\n};"]},"metadata":{},"sourceType":"script"}