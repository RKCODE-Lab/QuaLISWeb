{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport { TextSelection } from 'prosemirror-state';\nexport var findAt = function (doc, searchOptions, start, end, exit) {\n  var result = [],\n      exec,\n      text,\n      from,\n      to,\n      childText,\n      nextSibling;\n  var nodes = [];\n  var matchCase = searchOptions.matchCase,\n      matchWord = searchOptions.matchWord,\n      useRegExp = searchOptions.useRegExp;\n  var searchText = searchOptions.text;\n\n  if (useRegExp && (/^\\\\$/.test(searchText) || /[^\\\\]\\\\$/.test(searchText))) {\n    // lookbehind doesn't work in Edge -> /((?<!\\\\)\\\\)$/.test(searchText)\n    searchText = searchText.substring(0, searchText.length - 1);\n  }\n\n  if (!searchText) {\n    return result;\n  }\n\n  var flags = matchCase ? 'g' : 'gi';\n  var regExp = useRegExp ? new RegExp(searchText, flags) : createRegExp(searchText, flags);\n  doc.nodesBetween(start, end, function (node, pos, _parent) {\n    if (exit(result)) {\n      return false;\n    }\n\n    if (node.inlineContent && pos + node.content.size >= start) {\n      nodes.length = 0;\n      node.nodesBetween(0, node.content.size, function (child, childPos, parent, i) {\n        if (exit(result)) {\n          return false;\n        }\n\n        var posToDoc = 1 + pos + childPos;\n\n        if (child.isText && posToDoc + child.nodeSize >= start) {\n          childText = child.text || '';\n          nextSibling = parent.childCount - 1 >= i + 1 && parent.child(i + 1);\n          nodes.push(start <= posToDoc ? {\n            text: childText,\n            start: posToDoc\n          } : {\n            text: childText.slice(start - posToDoc),\n            start: start\n          });\n\n          if (nextSibling && nextSibling.isText) {\n            return;\n          }\n\n          text = nodes.map(function (t) {\n            return t.text;\n          }).join('');\n          exec = regExp.exec(text);\n\n          while (exec !== null) {\n            from = nodes[0].start + exec.index;\n            to = from + exec[0].length;\n\n            if (start <= from && end >= to && shouldMatchWord(exec, matchWord)) {\n              result.push(TextSelection.create(doc, from, to));\n            }\n\n            if (exit(result)) {\n              break;\n            }\n\n            exec = regExp.exec(text);\n          }\n        } else {\n          nodes.length = 0;\n        }\n      });\n    }\n  });\n  return result;\n};\nexport var find = function (state, searchOptions) {\n  var backward = searchOptions.backward,\n      matchCyclic = searchOptions.matchCyclic,\n      options = tslib_1.__rest(searchOptions, [\"backward\", \"matchCyclic\"]);\n\n  var exit = backward ? function () {\n    return false;\n  } : function (r) {\n    return r.length > 0;\n  };\n  var doc = state.doc,\n      selection = state.selection;\n  var result = [];\n\n  if (backward) {\n    result = findAt(doc, options, 0, selection.from, exit);\n\n    if (!result.length && matchCyclic) {\n      result = findAt(doc, options, selection.from, doc.content.size, exit);\n    }\n  } else {\n    result = findAt(doc, options, selection.to, doc.content.size, exit);\n\n    if (!result.length && matchCyclic) {\n      result = findAt(doc, options, 0, selection.to, exit);\n    }\n  }\n\n  return result.length ? result[result.length - 1] : null;\n};\nexport var findAll = function (doc, searchOptions) {\n  return findAt(doc, searchOptions, 0, doc.content.size, function () {\n    return false;\n  });\n};\nexport var replace = function (selection, text, transaction) {\n  var from = selection.from,\n      to = selection.to;\n  transaction.insertText(text, from, to).setSelection(TextSelection.create(transaction.doc, from, from + text.length));\n  return transaction;\n};\nexport var replaceAll = function (state, replaceText, searchOptions) {\n  var result = findAll(state.doc, searchOptions);\n\n  if (result.length === 0) {\n    return null;\n  }\n\n  var transaction = state.tr;\n\n  for (var i = result.length - 1; i >= 0; i--) {\n    transaction.insertText(replaceText, result[i].from, result[i].to);\n  }\n\n  return transaction;\n};\nvar notLetter = /^[\\s0-9~`!@#$%\\^&*\\(\\)_\\-=+\\\\|\\[\\]{};:'\"\\?/.,<>]?$/;\n\nvar shouldMatchWord = function (exec, matchWord) {\n  if (!matchWord) {\n    return true;\n  } else if (matchWord === true) {\n    var text = exec.input;\n    var charBefore = text.charAt(exec.index - 1);\n    var charAfter = text.charAt(exec.index + exec[0].length);\n    return notLetter.test(charBefore) && notLetter.test(charAfter);\n  } else {\n    return matchWord(exec);\n  }\n};\n\nvar createRegExp = function (inputString, flags) {\n  var escaped = inputString.replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&').replace(/-/g, '\\\\x2d').replace(/\\s/g, '\\\\s');\n  return new RegExp(escaped, flags);\n};","map":{"version":3,"sources":["D:/Postgres_workingFolder/QuaLISWeb/node_modules/@progress/kendo-editor-common/dist/es/find-replace.js"],"names":["tslib_1","TextSelection","findAt","doc","searchOptions","start","end","exit","result","exec","text","from","to","childText","nextSibling","nodes","matchCase","matchWord","useRegExp","searchText","test","substring","length","flags","regExp","RegExp","createRegExp","nodesBetween","node","pos","_parent","inlineContent","content","size","child","childPos","parent","i","posToDoc","isText","nodeSize","childCount","push","slice","map","t","join","index","shouldMatchWord","create","find","state","backward","matchCyclic","options","__rest","r","selection","findAll","replace","transaction","insertText","setSelection","replaceAll","replaceText","tr","notLetter","input","charBefore","charAt","charAfter","inputString","escaped"],"mappings":"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","sourcesContent":["import * as tslib_1 from \"tslib\";\nimport { TextSelection } from 'prosemirror-state';\nexport var findAt = function (doc, searchOptions, start, end, exit) {\n    var result = [], exec, text, from, to, childText, nextSibling;\n    var nodes = [];\n    var matchCase = searchOptions.matchCase, matchWord = searchOptions.matchWord, useRegExp = searchOptions.useRegExp;\n    var searchText = searchOptions.text;\n    if (useRegExp && (/^\\\\$/.test(searchText) || /[^\\\\]\\\\$/.test(searchText))) {\n        // lookbehind doesn't work in Edge -> /((?<!\\\\)\\\\)$/.test(searchText)\n        searchText = searchText.substring(0, searchText.length - 1);\n    }\n    if (!searchText) {\n        return result;\n    }\n    var flags = matchCase ? 'g' : 'gi';\n    var regExp = useRegExp ? new RegExp(searchText, flags) : createRegExp(searchText, flags);\n    doc.nodesBetween(start, end, function (node, pos, _parent) {\n        if (exit(result)) {\n            return false;\n        }\n        if (node.inlineContent && pos + node.content.size >= start) {\n            nodes.length = 0;\n            node.nodesBetween(0, node.content.size, function (child, childPos, parent, i) {\n                if (exit(result)) {\n                    return false;\n                }\n                var posToDoc = 1 + pos + childPos;\n                if (child.isText && posToDoc + child.nodeSize >= start) {\n                    childText = child.text || '';\n                    nextSibling = parent.childCount - 1 >= i + 1 && parent.child(i + 1);\n                    nodes.push(start <= posToDoc ?\n                        { text: childText, start: posToDoc } :\n                        { text: childText.slice(start - posToDoc), start: start });\n                    if (nextSibling && nextSibling.isText) {\n                        return;\n                    }\n                    text = nodes.map(function (t) { return t.text; }).join('');\n                    exec = regExp.exec(text);\n                    while (exec !== null) {\n                        from = nodes[0].start + exec.index;\n                        to = from + exec[0].length;\n                        if (start <= from && end >= to && shouldMatchWord(exec, matchWord)) {\n                            result.push(TextSelection.create(doc, from, to));\n                        }\n                        if (exit(result)) {\n                            break;\n                        }\n                        exec = regExp.exec(text);\n                    }\n                }\n                else {\n                    nodes.length = 0;\n                }\n            });\n        }\n    });\n    return result;\n};\nexport var find = function (state, searchOptions) {\n    var backward = searchOptions.backward, matchCyclic = searchOptions.matchCyclic, options = tslib_1.__rest(searchOptions, [\"backward\", \"matchCyclic\"]);\n    var exit = backward ? function () { return false; } : function (r) { return r.length > 0; };\n    var doc = state.doc, selection = state.selection;\n    var result = [];\n    if (backward) {\n        result = findAt(doc, options, 0, selection.from, exit);\n        if (!result.length && matchCyclic) {\n            result = findAt(doc, options, selection.from, doc.content.size, exit);\n        }\n    }\n    else {\n        result = findAt(doc, options, selection.to, doc.content.size, exit);\n        if (!result.length && matchCyclic) {\n            result = findAt(doc, options, 0, selection.to, exit);\n        }\n    }\n    return result.length ? result[result.length - 1] : null;\n};\nexport var findAll = function (doc, searchOptions) {\n    return findAt(doc, searchOptions, 0, doc.content.size, function () { return false; });\n};\nexport var replace = function (selection, text, transaction) {\n    var from = selection.from, to = selection.to;\n    transaction.insertText(text, from, to)\n        .setSelection(TextSelection.create(transaction.doc, from, from + text.length));\n    return transaction;\n};\nexport var replaceAll = function (state, replaceText, searchOptions) {\n    var result = findAll(state.doc, searchOptions);\n    if (result.length === 0) {\n        return null;\n    }\n    var transaction = state.tr;\n    for (var i = result.length - 1; i >= 0; i--) {\n        transaction.insertText(replaceText, result[i].from, result[i].to);\n    }\n    return transaction;\n};\nvar notLetter = /^[\\s0-9~`!@#$%\\^&*\\(\\)_\\-=+\\\\|\\[\\]{};:'\"\\?/.,<>]?$/;\nvar shouldMatchWord = function (exec, matchWord) {\n    if (!matchWord) {\n        return true;\n    }\n    else if (matchWord === true) {\n        var text = exec.input;\n        var charBefore = text.charAt(exec.index - 1);\n        var charAfter = text.charAt(exec.index + exec[0].length);\n        return notLetter.test(charBefore) && notLetter.test(charAfter);\n    }\n    else {\n        return matchWord(exec);\n    }\n};\nvar createRegExp = function (inputString, flags) {\n    var escaped = inputString\n        .replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&')\n        .replace(/-/g, '\\\\x2d')\n        .replace(/\\s/g, '\\\\s');\n    return new RegExp(escaped, flags);\n};\n"]},"metadata":{},"sourceType":"module"}