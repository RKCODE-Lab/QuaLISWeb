{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _toArray from \"@babel/runtime/helpers/toArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nimport uuid from \"../utils/uuid\";\nimport { defaultValue, isJsonLogic, shallowEqual, logger } from \"../utils/stuff\";\nimport { getFieldConfig, extendConfig, normalizeField } from \"../utils/configUtils\";\nimport { getWidgetForFieldOp } from \"../utils/ruleUtils\";\nimport { loadTree } from \"./tree\";\nimport { defaultConjunction, defaultGroupConjunction } from \"../utils/defaultUtils\";\nimport moment from \"moment\"; // http://jsonlogic.com/\n// helpers\n\nvar arrayUniq = function arrayUniq(arr) {\n  return Array.from(new Set(arr));\n};\n\nvar arrayToObject = function arrayToObject(arr) {\n  return arr.reduce(function (acc, _ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        f = _ref2[0],\n        fc = _ref2[1];\n\n    return _objectSpread(_objectSpread({}, acc), {}, _defineProperty({}, f, fc));\n  }, {});\n};\n\nexport var loadFromJsonLogic = function loadFromJsonLogic(logicTree, config) {\n  return _loadFromJsonLogic(logicTree, config, false);\n};\nexport var _loadFromJsonLogic = function _loadFromJsonLogic(logicTree, config) {\n  var returnErrors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true; //meta is mutable\n\n  var meta = {\n    errors: []\n  };\n  var extendedConfig = extendConfig(config);\n  var conv = buildConv(extendedConfig);\n  var jsTree = logicTree ? convertFromLogic(logicTree, conv, extendedConfig, \"rule\", meta) : undefined;\n\n  if (jsTree && jsTree.type != \"group\") {\n    jsTree = wrapInDefaultConj(jsTree, extendedConfig);\n  }\n\n  var immTree = jsTree ? loadTree(jsTree) : undefined;\n\n  if (returnErrors) {\n    return [immTree, meta.errors];\n  } else {\n    if (meta.errors.length) console.warn(\"Errors while importing from JsonLogic:\", meta.errors);\n    return immTree;\n  }\n};\n\nvar buildConv = function buildConv(config) {\n  var operators = {};\n\n  for (var opKey in config.operators) {\n    var opConfig = config.operators[opKey];\n\n    if (typeof opConfig.jsonLogic == \"string\") {\n      // example: \"</2\", \"#in/1\"\n      var opk = (opConfig._jsonLogicIsRevArgs ? \"#\" : \"\") + opConfig.jsonLogic + \"/\" + defaultValue(opConfig.cardinality, 1);\n      if (!operators[opk]) operators[opk] = [];\n      operators[opk].push(opKey);\n    } else if (typeof opConfig.jsonLogic2 == \"string\") {\n      // example: all-in/1\"\n      var _opk = opConfig.jsonLogic2 + \"/\" + defaultValue(opConfig.cardinality, 1);\n\n      if (!operators[_opk]) operators[_opk] = [];\n\n      operators[_opk].push(opKey);\n    }\n  }\n\n  var conjunctions = {};\n\n  for (var conjKey in config.conjunctions) {\n    var conjunctionDefinition = config.conjunctions[conjKey];\n    var ck = conjunctionDefinition.jsonLogicConj || conjKey.toLowerCase();\n    conjunctions[ck] = conjKey;\n  }\n\n  var funcs = {};\n\n  for (var funcKey in config.funcs) {\n    var funcConfig = config.funcs[funcKey];\n    var fk = void 0;\n\n    if (funcConfig.jsonLogicIsMethod) {\n      fk = \"#\" + funcConfig.jsonLogic;\n    } else if (typeof funcConfig.jsonLogic == \"string\") {\n      fk = funcConfig.jsonLogic;\n    }\n\n    if (fk) {\n      if (!funcs[fk]) funcs[fk] = [];\n      funcs[fk].push(funcKey);\n    }\n  }\n\n  var _config$settings$json = config.settings.jsonLogic,\n      groupVarKey = _config$settings$json.groupVarKey,\n      altVarKey = _config$settings$json.altVarKey;\n  return {\n    operators: operators,\n    conjunctions: conjunctions,\n    funcs: funcs,\n    varKeys: [\"var\", groupVarKey, altVarKey]\n  };\n};\n\nvar convertFromLogic = function convertFromLogic(logic, conv, config, expectedType, meta) {\n  var not = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  var fieldConfig = arguments.length > 6 ? arguments[6] : undefined;\n  var widget = arguments.length > 7 ? arguments[7] : undefined;\n  var parentField = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : null;\n\n  var _isLockedLogic = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : false;\n\n  var op, vals;\n\n  if (isJsonLogic(logic)) {\n    op = Object.keys(logic)[0];\n    vals = logic[op];\n    if (!Array.isArray(vals)) vals = [vals];\n  }\n\n  var ret;\n  var beforeErrorsCnt = meta.errors.length;\n  var lockedOp = config.settings.jsonLogic.lockedOp;\n  var isEmptyOp = op == \"!\" && vals.length == 1 && vals[0] && isJsonLogic(vals[0]) && conv.varKeys.includes(Object.keys(vals[0])[0]);\n  var isRev = op == \"!\" && !isEmptyOp;\n  var isLocked = lockedOp && op == lockedOp;\n\n  if (isLocked) {\n    ret = convertFromLogic(vals[0], conv, config, expectedType, meta, not, fieldConfig, widget, parentField, true);\n  } else if (isRev) {\n    // reverse with not\n    ret = convertFromLogic(vals[0], conv, config, expectedType, meta, !not, fieldConfig, widget, parentField);\n  } else if (expectedType == \"val\") {\n    // not is not used here\n    ret = convertField(op, vals, conv, config, not, meta, parentField) || convertFunc(op, vals, conv, config, not, fieldConfig, meta, parentField) || convertVal(logic, fieldConfig, widget, config, meta);\n  } else if (expectedType == \"rule\") {\n    ret = convertConj(op, vals, conv, config, not, meta, parentField, false) || convertOp(op, vals, conv, config, not, meta, parentField);\n  }\n\n  var afterErrorsCnt = meta.errors.length;\n\n  if (op != \"!\" && ret === undefined && afterErrorsCnt == beforeErrorsCnt) {\n    meta.errors.push(\"Can't parse logic \".concat(JSON.stringify(logic)));\n  }\n\n  if (isLocked) {\n    ret.properties.isLocked = true;\n  }\n\n  return ret;\n};\n\nvar convertVal = function convertVal(val, fieldConfig, widget, config, meta) {\n  if (val === undefined) return undefined;\n  var widgetConfig = config.widgets[widget || fieldConfig.mainWidget];\n\n  if (!widgetConfig) {\n    meta.errors.push(\"No widget for type \".concat(fieldConfig.type));\n    return undefined;\n  }\n\n  if (isJsonLogic(val)) {\n    meta.errors.push(\"Unexpected logic in value: \".concat(JSON.stringify(val)));\n    return undefined;\n  } // number of seconds -> time string\n\n\n  if (fieldConfig && fieldConfig.type == \"time\" && typeof val == \"number\") {\n    var h = Math.floor(val / 60 / 60) % 24,\n        m = Math.floor(val / 60) % 60,\n        s = val % 60;\n    var valueFormat = widgetConfig.valueFormat;\n\n    if (valueFormat) {\n      var dateVal = new Date(val);\n      dateVal.setMilliseconds(0);\n      dateVal.setHours(h);\n      dateVal.setMinutes(m);\n      dateVal.setSeconds(s);\n      val = moment(dateVal).format(valueFormat);\n    } else {\n      val = \"\".concat(h, \":\").concat(m, \":\").concat(s);\n    }\n  } // \"2020-01-08T22:00:00.000Z\" -> Date object\n\n\n  if (fieldConfig && [\"date\", \"datetime\"].includes(fieldConfig.type) && val && !(val instanceof Date)) {\n    try {\n      var _dateVal = new Date(val);\n\n      if (_dateVal instanceof Date && _dateVal.toISOString() === val) {\n        val = _dateVal;\n      }\n    } catch (e) {\n      meta.errors.push(\"Can't convert value \".concat(val, \" as Date\"));\n      val = undefined;\n    }\n  } // Date object -> formatted string\n\n\n  if (val instanceof Date && fieldConfig) {\n    var _valueFormat = widgetConfig.valueFormat;\n\n    if (_valueFormat) {\n      val = moment(val).format(_valueFormat);\n    }\n  }\n\n  var asyncListValues;\n\n  if (val && fieldConfig.fieldSettings && fieldConfig.fieldSettings.asyncFetch) {\n    var vals = Array.isArray(val) ? val : [val];\n    asyncListValues = vals;\n  }\n\n  return {\n    valueSrc: \"value\",\n    value: val,\n    valueType: widgetConfig.type,\n    asyncListValues: asyncListValues\n  };\n};\n\nvar convertField = function convertField(op, vals, conv, config, not, meta) {\n  var parentField = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n  var fieldSeparator = config.settings.fieldSeparator;\n\n  if (conv.varKeys.includes(op) && typeof vals[0] == \"string\") {\n    var field = vals[0];\n    if (parentField) field = [parentField, field].join(fieldSeparator);\n    field = normalizeField(config, field);\n    var fieldConfig = getFieldConfig(config, field);\n\n    if (!fieldConfig) {\n      meta.errors.push(\"No config for field \".concat(field));\n      return undefined;\n    }\n\n    return {\n      valueSrc: \"field\",\n      value: field,\n      valueType: fieldConfig.type\n    };\n  }\n\n  return undefined;\n};\n\nvar convertFunc = function convertFunc(op, vals, conv, config, not, fieldConfig, meta) {\n  var parentField = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;\n  if (!op) return undefined;\n  var func, argsArr, funcKey;\n  var jsonLogicIsMethod = op == \"method\";\n\n  if (jsonLogicIsMethod) {\n    var obj, opts;\n\n    var _vals = _toArray(vals);\n\n    obj = _vals[0];\n    func = _vals[1];\n    opts = _vals.slice(2);\n    argsArr = [obj].concat(_toConsumableArray(opts));\n  } else {\n    func = op;\n    argsArr = vals;\n  }\n\n  var fk = (jsonLogicIsMethod ? \"#\" : \"\") + func;\n  var funcKeys = (conv.funcs[fk] || []).filter(function (k) {\n    return fieldConfig ? config.funcs[k].returnType == fieldConfig.type : true;\n  });\n\n  if (funcKeys.length) {\n    funcKey = funcKeys[0];\n  } else {\n    var v = _defineProperty({}, op, vals);\n\n    for (var _i = 0, _Object$entries = Object.entries(config.funcs || {}); _i < _Object$entries.length; _i++) {\n      var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n          f = _Object$entries$_i[0],\n          fc = _Object$entries$_i[1];\n\n      if (fc.jsonLogicImport && fc.returnType == fieldConfig.type) {\n        var parsed = void 0;\n\n        try {\n          parsed = fc.jsonLogicImport(v);\n        } catch (_e) {// given expression `v` can't be parsed into function\n        }\n\n        if (parsed) {\n          funcKey = f;\n          argsArr = parsed;\n        }\n      }\n    }\n  }\n\n  if (!funcKey) return undefined;\n\n  if (funcKey) {\n    var funcConfig = config.funcs[funcKey];\n    var argKeys = Object.keys(funcConfig.args || {});\n    var args = argsArr.reduce(function (acc, val, ind) {\n      var argKey = argKeys[ind];\n      var argConfig = funcConfig.args[argKey];\n      var argVal = convertFromLogic(val, conv, config, \"val\", meta, false, argConfig, null, parentField);\n\n      if (argVal === undefined) {\n        argVal = argConfig.defaultValue;\n\n        if (argVal === undefined) {\n          meta.errors.push(\"No value for arg \".concat(argKey, \" of func \").concat(funcKey));\n          return undefined;\n        }\n      }\n\n      return _objectSpread(_objectSpread({}, acc), {}, _defineProperty({}, argKey, argVal));\n    }, {});\n    return {\n      valueSrc: \"func\",\n      value: {\n        func: funcKey,\n        args: args\n      },\n      valueType: funcConfig.returnType\n    };\n  }\n\n  return undefined;\n};\n\nvar convertConj = function convertConj(op, vals, conv, config, not, meta) {\n  var parentField = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n  var isRuleGroup = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;\n  var conjKey = conv.conjunctions[op];\n  var fieldSeparator = config.settings.fieldSeparator;\n  var parentFieldConfig = parentField ? getFieldConfig(config, parentField) : null;\n  var isParentGroup = (parentFieldConfig === null || parentFieldConfig === void 0 ? void 0 : parentFieldConfig.type) == \"!group\";\n\n  if (conjKey) {\n    var type = \"group\";\n    var children = vals.map(function (v) {\n      return convertFromLogic(v, conv, config, \"rule\", meta, false, null, null, parentField);\n    }).filter(function (r) {\n      return r !== undefined;\n    }).reduce(function (acc, r) {\n      return _objectSpread(_objectSpread({}, acc), {}, _defineProperty({}, r.id, r));\n    }, {});\n    var complexFields = Object.values(children).map(function (v) {\n      var _v$properties;\n\n      return v === null || v === void 0 ? void 0 : (_v$properties = v.properties) === null || _v$properties === void 0 ? void 0 : _v$properties.field;\n    }).filter(function (f) {\n      return f && f.includes(fieldSeparator);\n    });\n    var complexFieldsGroupAncestors = Object.fromEntries(arrayUniq(complexFields).map(function (f) {\n      var parts = f.split(fieldSeparator);\n      var ancs = Object.fromEntries(parts.slice(0, -1).map(function (f, i, parts) {\n        return [].concat(_toConsumableArray(parts.slice(0, i)), [f]);\n      }).map(function (fp) {\n        return [fp.join(fieldSeparator), getFieldConfig(config, fp)];\n      }).filter(function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 2),\n            _f = _ref4[0],\n            fc = _ref4[1];\n\n        return fc.type == \"!group\";\n      }));\n      return [f, Object.keys(ancs)];\n    }));\n    var childrenInRuleGroup = Object.values(children).map(function (v) {\n      var _v$properties2;\n\n      return v === null || v === void 0 ? void 0 : (_v$properties2 = v.properties) === null || _v$properties2 === void 0 ? void 0 : _v$properties2.field;\n    }).map(function (f) {\n      return complexFieldsGroupAncestors[f];\n    }).filter(function (ancs) {\n      return ancs && ancs.length;\n    });\n    var usedRuleGroups = arrayUniq(Object.values(complexFieldsGroupAncestors).flat());\n    var usedTopRuleGroups = topLevelFieldsFilter(usedRuleGroups);\n    var properties = {\n      conjunction: conjKey,\n      not: not\n    };\n    var id = uuid();\n    var children1 = {};\n    var groupToId = {};\n    Object.entries(children).map(function (_ref5) {\n      var _ref6 = _slicedToArray(_ref5, 2),\n          k = _ref6[0],\n          v = _ref6[1];\n\n      if (v.type == \"group\" || v.type == \"rule_group\") {\n        // put as-is\n        children1[k] = v;\n      } else {\n        var _v$properties3;\n\n        var field = v === null || v === void 0 ? void 0 : (_v$properties3 = v.properties) === null || _v$properties3 === void 0 ? void 0 : _v$properties3.field;\n        var groupAncestors = complexFieldsGroupAncestors[field];\n        var groupField = groupAncestors === null || groupAncestors === void 0 ? void 0 : groupAncestors.at(-1);\n\n        if (!groupField) {\n          // not in rule_group (can be simple field or in struct) - put as-is\n          children1[k] = v;\n        } else {\n          // wrap field in rule_group (with creating hierarchy if need)\n          var ch = children1;\n          var parentFieldParts = parentField ? parentField.split(fieldSeparator) : [];\n          var isInParent = shallowEqual(parentFieldParts, groupField.split(fieldSeparator).slice(0, parentFieldParts.length));\n          if (!isInParent) parentFieldParts = []; // should not be\n\n          var traverseGroupFields = groupField.split(fieldSeparator).slice(parentFieldParts.length).map(function (f, i, parts) {\n            return [].concat(_toConsumableArray(parentFieldParts), _toConsumableArray(parts.slice(0, i)), [f]).join(fieldSeparator);\n          }).map(function (f) {\n            return normalizeField(config, f);\n          }).map(function (f) {\n            return {\n              f: f,\n              fc: getFieldConfig(config, f) || {}\n            };\n          }).filter(function (_ref7) {\n            var fc = _ref7.fc;\n            return fc.type != \"!struct\";\n          });\n          traverseGroupFields.map(function (_ref8, i) {\n            var gf = _ref8.f,\n                gfc = _ref8.fc;\n            var groupId = groupToId[gf];\n\n            if (!groupId) {\n              groupId = uuid();\n              groupToId[gf] = groupId;\n              ch[groupId] = {\n                type: \"rule_group\",\n                id: groupId,\n                children1: {},\n                properties: {\n                  conjunction: conjKey,\n                  not: false,\n                  field: gf,\n                  mode: gfc.mode\n                }\n              };\n            }\n\n            ch = ch[groupId].children1;\n          });\n          ch[k] = v;\n        }\n      }\n    }); // tip: for isRuleGroup=true correct type and properties will be set out of this func\n\n    return {\n      type: type,\n      id: id,\n      children1: children1,\n      properties: properties\n    };\n  }\n\n  return undefined;\n};\n\nvar topLevelFieldsFilter = function topLevelFieldsFilter(fields) {\n  var arr = _toConsumableArray(fields).sort(function (a, b) {\n    return a.length - b.length;\n  });\n\n  for (var i = 0; i < arr.length; i++) {\n    for (var j = i + 1; j < arr.length; j++) {\n      if (arr[j].indexOf(arr[i]) == 0) {\n        // arr[j] is inside arr[i] (eg. \"a.b\" inside \"a\")\n        arr.splice(j, 1);\n        j--;\n      }\n    }\n  }\n\n  return arr;\n};\n\nvar wrapInDefaultConjRuleGroup = function wrapInDefaultConjRuleGroup(rule, parentField, parentFieldConfig, config, conj) {\n  if (!rule) return undefined;\n  return {\n    type: \"rule_group\",\n    id: uuid(),\n    children1: _defineProperty({}, rule.id, rule),\n    properties: {\n      conjunction: conj || defaultGroupConjunction(config, parentFieldConfig),\n      not: false,\n      field: parentField\n    }\n  };\n};\n\nvar wrapInDefaultConj = function wrapInDefaultConj(rule, config) {\n  var not = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  return {\n    type: \"group\",\n    id: uuid(),\n    children1: _defineProperty({}, rule.id, rule),\n    properties: {\n      conjunction: defaultConjunction(config),\n      not: not\n    }\n  };\n};\n\nvar parseRule = function parseRule(op, arity, vals, parentField, conv, config, meta) {\n  var errors = [];\n\n  var res = _parseRule(op, arity, vals, parentField, conv, config, errors, false) || _parseRule(op, arity, vals, parentField, conv, config, errors, true);\n\n  if (!res) {\n    meta.errors.push(errors.join(\"; \") || \"Unknown op \".concat(op, \"/\").concat(arity));\n    return undefined;\n  }\n\n  return res;\n};\n\nvar _parseRule = function _parseRule(op, arity, vals, parentField, conv, config, errors, isRevArgs) {\n  // config.settings.groupOperators are used for group count (cardinality = 0 is exception)\n  // but don't confuse with \"all-in\" or \"some-in\" for multiselect\n  var isAllOrSomeInForMultiselect = (op == \"all\" || op == \"some\") && isJsonLogic(vals[1]) && Object.keys(vals[1])[0] == \"in\";\n  var isGroup0 = !isAllOrSomeInForMultiselect && config.settings.groupOperators.includes(op);\n  var eqOps = [\"==\", \"!=\"];\n  var cardinality = isGroup0 ? 0 : arity - 1;\n  if (isGroup0) cardinality = 0;else if (eqOps.includes(op) && cardinality == 1 && vals[1] === null) cardinality = 0;\n  var opk = op + \"/\" + cardinality;\n  var fieldSeparator = config.settings.fieldSeparator;\n  var opKeys = conv.operators[(isRevArgs ? \"#\" : \"\") + opk];\n  if (!opKeys) return;\n  var jlField,\n      args = [];\n  var rangeOps = [\"<\", \"<=\", \">\", \">=\"];\n\n  if (rangeOps.includes(op) && arity == 3) {\n    jlField = vals[1];\n    args = [vals[0], vals[2]];\n  } else if (isRevArgs) {\n    jlField = vals[1];\n    args = [vals[0]];\n  } else {\n    var _vals2 = _toArray(vals);\n\n    jlField = _vals2[0];\n    args = _vals2.slice(1);\n  }\n\n  if (!isJsonLogic(jlField)) {\n    errors.push(\"Incorrect operands for \".concat(op, \": \").concat(JSON.stringify(vals)));\n    return;\n  }\n\n  var k = Object.keys(jlField)[0];\n  var v = Object.values(jlField)[0];\n  var field, having, isGroup;\n\n  if (conv.varKeys.includes(k) && typeof v == \"string\") {\n    field = v;\n  }\n\n  if (isGroup0) {\n    isGroup = true;\n    having = args[0];\n    args = [];\n  } // reduce/filter for group ext\n\n\n  if (k == \"reduce\" && Array.isArray(v) && v.length == 3) {\n    var _v2 = v,\n        _v3 = _slicedToArray(_v2, 3),\n        filter = _v3[0],\n        acc = _v3[1],\n        init = _v3[2];\n\n    if (isJsonLogic(filter) && init == 0 && isJsonLogic(acc) && Array.isArray(acc[\"+\"]) && acc[\"+\"][0] == 1 && isJsonLogic(acc[\"+\"][1]) && acc[\"+\"][1][\"var\"] == \"accumulator\") {\n      k = Object.keys(filter)[0];\n      v = Object.values(filter)[0];\n\n      if (k == \"filter\") {\n        var _v4 = v,\n            _v5 = _slicedToArray(_v4, 2),\n            group = _v5[0],\n            _filter = _v5[1];\n\n        if (isJsonLogic(group)) {\n          k = Object.keys(group)[0];\n          v = Object.values(group)[0];\n\n          if (conv.varKeys.includes(k) && typeof v == \"string\") {\n            field = v;\n            having = _filter;\n            isGroup = true;\n          }\n        }\n      } else if (conv.varKeys.includes(k) && typeof v == \"string\") {\n        field = v;\n        isGroup = true;\n      }\n    }\n  }\n\n  if (!field) {\n    errors.push(\"Unknown field \".concat(JSON.stringify(jlField)));\n    return;\n  }\n\n  if (parentField) field = [parentField, field].join(fieldSeparator);\n  field = normalizeField(config, field);\n  var fieldConfig = getFieldConfig(config, field);\n\n  if (!fieldConfig) {\n    errors.push(\"No config for field \".concat(field));\n    return;\n  }\n\n  var opKey = opKeys[0];\n\n  if (opKeys.length > 1 && fieldConfig && fieldConfig.operators) {\n    // eg. for \"equal\" and \"select_equals\"\n    opKeys = opKeys.filter(function (k) {\n      return fieldConfig.operators.includes(k);\n    });\n\n    if (opKeys.length == 0) {\n      errors.push(\"No corresponding ops for field \".concat(field));\n      return;\n    }\n\n    opKey = opKeys[0];\n  }\n\n  return {\n    field: field,\n    fieldConfig: fieldConfig,\n    opKey: opKey,\n    args: args,\n    having: having\n  };\n};\n\nvar convertOp = function convertOp(op, vals, conv, config, not, meta) {\n  var parentField = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n  if (!op) return undefined;\n  var arity = vals.length;\n\n  if ((op == \"all\" || op == \"some\") && isJsonLogic(vals[1])) {\n    // special case for \"all-in\" and \"some-in\"\n    var op2 = Object.keys(vals[1])[0];\n\n    if (op2 == \"in\") {\n      vals = [vals[0], vals[1][op2][1]];\n      op = op + \"-\" + op2; // \"all-in\" and \"some-in\"\n    }\n  }\n\n  var parseRes = parseRule(op, arity, vals, parentField, conv, config, meta);\n  if (!parseRes) return undefined;\n  var field = parseRes.field,\n      fieldConfig = parseRes.fieldConfig,\n      opKey = parseRes.opKey,\n      args = parseRes.args,\n      having = parseRes.having;\n  var opConfig = config.operators[opKey]; // Group component in array mode can show NOT checkbox, so do nothing in this case\n  // Otherwise try to revert\n\n  var showNot = fieldConfig.showNot !== undefined ? fieldConfig.showNot : config.settings.showNot;\n  var canRev = true; // if (fieldConfig.type == \"!group\" && fieldConfig.mode == \"array\" && showNot)\n  //   canRev = false;\n\n  var conj;\n  var havingVals;\n  var havingNot = false;\n\n  if (fieldConfig.type == \"!group\" && having) {\n    conj = Object.keys(having)[0];\n    havingVals = having[conj];\n    if (!Array.isArray(havingVals)) havingVals = [havingVals]; // Preprocess \"!\": Try to reverse op in single rule in having\n    // Eg. use `not_equal` instead of `not` `equal`\n\n    var isEmptyOp = conj == \"!\" && havingVals.length == 1 && havingVals[0] && isJsonLogic(havingVals[0]) && conv.varKeys.includes(Object.keys(havingVals[0])[0]);\n\n    if (conj == \"!\" && !isEmptyOp) {\n      havingNot = true;\n      having = having[\"!\"];\n      conj = Object.keys(having)[0];\n      havingVals = having[conj];\n      if (!Array.isArray(havingVals)) havingVals = [havingVals];\n    }\n  } // Use reversed op\n\n\n  if (not && canRev && opConfig.reversedOp) {\n    not = false;\n    opKey = opConfig.reversedOp;\n    opConfig = config.operators[opKey];\n  }\n\n  var widget = getWidgetForFieldOp(config, field, opKey);\n  var convertedArgs = args.map(function (v) {\n    return convertFromLogic(v, conv, config, \"val\", meta, false, fieldConfig, widget, parentField);\n  });\n\n  if (convertedArgs.filter(function (v) {\n    return v === undefined;\n  }).length) {\n    //meta.errors.push(`Undefined arg for field ${field} and op ${opKey}`);\n    return undefined;\n  }\n\n  var res;\n\n  if (fieldConfig.type == \"!group\" && having) {\n    if (conv.conjunctions[conj] !== undefined) {\n      // group\n      res = convertConj(conj, havingVals, conv, config, havingNot, meta, field, true);\n      havingNot = false;\n    } else {\n      // need to be wrapped in `rule_group`\n      var rule = convertOp(conj, havingVals, conv, config, havingNot, meta, field);\n      havingNot = false;\n      res = wrapInDefaultConjRuleGroup(rule, field, fieldConfig, config, conv.conjunctions[\"and\"]);\n    }\n\n    if (!res) return undefined;\n    res.type = \"rule_group\";\n    Object.assign(res.properties, {\n      field: field,\n      mode: fieldConfig.mode,\n      operator: opKey\n    });\n\n    if (fieldConfig.mode == \"array\") {\n      Object.assign(res.properties, {\n        value: convertedArgs.map(function (v) {\n          return v.value;\n        }),\n        valueSrc: convertedArgs.map(function (v) {\n          return v.valueSrc;\n        }),\n        valueType: convertedArgs.map(function (v) {\n          return v.valueType;\n        })\n      });\n    }\n\n    if (not) {\n      res = wrapInDefaultConj(res, config, not);\n    }\n  } else if (fieldConfig.type == \"!group\" && !having) {\n    res = {\n      type: \"rule_group\",\n      id: uuid(),\n      children1: {},\n      properties: {\n        conjunction: defaultGroupConjunction(config, fieldConfig),\n        not: not,\n        mode: fieldConfig.mode,\n        field: field,\n        operator: opKey\n      }\n    };\n\n    if (fieldConfig.mode == \"array\") {\n      Object.assign(res.properties, {\n        value: convertedArgs.map(function (v) {\n          return v.value;\n        }),\n        valueSrc: convertedArgs.map(function (v) {\n          return v.valueSrc;\n        }),\n        valueType: convertedArgs.map(function (v) {\n          return v.valueType;\n        })\n      });\n    }\n  } else {\n    var asyncListValuesArr = convertedArgs.map(function (v) {\n      return v.asyncListValues;\n    }).filter(function (v) {\n      return v != undefined;\n    });\n    var asyncListValues = asyncListValuesArr.length ? asyncListValuesArr[0] : undefined;\n    res = {\n      type: \"rule\",\n      id: uuid(),\n      properties: {\n        field: field,\n        operator: opKey,\n        value: convertedArgs.map(function (v) {\n          return v.value;\n        }),\n        valueSrc: convertedArgs.map(function (v) {\n          return v.valueSrc;\n        }),\n        valueType: convertedArgs.map(function (v) {\n          return v.valueType;\n        }),\n        asyncListValues: asyncListValues\n      }\n    };\n\n    if (not) {\n      //meta.errors.push(`No rev op for ${opKey}`);\n      res = wrapInDefaultConj(res, config, not);\n    }\n  }\n\n  return res;\n};","map":{"version":3,"sources":["D:/LIMSWFH/LIMSPOSTGRESQL/QuaLISWeb/node_modules/@react-awesome-query-builder/core/esm/import/jsonLogic.js"],"names":["_toConsumableArray","_toArray","_defineProperty","_slicedToArray","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","uuid","defaultValue","isJsonLogic","shallowEqual","logger","getFieldConfig","extendConfig","normalizeField","getWidgetForFieldOp","loadTree","defaultConjunction","defaultGroupConjunction","moment","arrayUniq","arr","Array","from","Set","arrayToObject","reduce","acc","_ref","_ref2","f","fc","loadFromJsonLogic","logicTree","config","_loadFromJsonLogic","returnErrors","undefined","meta","errors","extendedConfig","conv","buildConv","jsTree","convertFromLogic","type","wrapInDefaultConj","immTree","console","warn","operators","opKey","opConfig","jsonLogic","opk","_jsonLogicIsRevArgs","cardinality","jsonLogic2","_opk","conjunctions","conjKey","conjunctionDefinition","ck","jsonLogicConj","toLowerCase","funcs","funcKey","funcConfig","fk","jsonLogicIsMethod","_config$settings$json","settings","groupVarKey","altVarKey","varKeys","logic","expectedType","not","fieldConfig","widget","parentField","_isLockedLogic","op","vals","isArray","ret","beforeErrorsCnt","lockedOp","isEmptyOp","includes","isRev","isLocked","convertField","convertFunc","convertVal","convertConj","convertOp","afterErrorsCnt","concat","JSON","stringify","properties","val","widgetConfig","widgets","mainWidget","h","Math","floor","m","s","valueFormat","dateVal","Date","setMilliseconds","setHours","setMinutes","setSeconds","format","_dateVal","toISOString","e","_valueFormat","asyncListValues","fieldSettings","asyncFetch","valueSrc","value","valueType","fieldSeparator","field","join","func","argsArr","obj","opts","_vals","slice","funcKeys","k","returnType","v","_i","_Object$entries","entries","_Object$entries$_i","jsonLogicImport","parsed","_e","argKeys","args","ind","argKey","argConfig","argVal","isRuleGroup","parentFieldConfig","isParentGroup","children","map","r","id","complexFields","values","_v$properties","complexFieldsGroupAncestors","fromEntries","parts","split","ancs","fp","_ref3","_ref4","_f","childrenInRuleGroup","_v$properties2","usedRuleGroups","flat","usedTopRuleGroups","topLevelFieldsFilter","conjunction","children1","groupToId","_ref5","_ref6","_v$properties3","groupAncestors","groupField","at","ch","parentFieldParts","isInParent","traverseGroupFields","_ref7","_ref8","gf","gfc","groupId","mode","fields","sort","a","b","j","indexOf","splice","wrapInDefaultConjRuleGroup","rule","conj","parseRule","arity","res","_parseRule","isRevArgs","isAllOrSomeInForMultiselect","isGroup0","groupOperators","eqOps","opKeys","jlField","rangeOps","_vals2","having","isGroup","_v2","_v3","init","_v4","_v5","group","_filter","op2","parseRes","showNot","canRev","havingVals","havingNot","reversedOp","convertedArgs","assign","operator","asyncListValuesArr"],"mappings":"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","sourcesContent":["import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _toArray from \"@babel/runtime/helpers/toArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nimport uuid from \"../utils/uuid\";\nimport { defaultValue, isJsonLogic, shallowEqual, logger } from \"../utils/stuff\";\nimport { getFieldConfig, extendConfig, normalizeField } from \"../utils/configUtils\";\nimport { getWidgetForFieldOp } from \"../utils/ruleUtils\";\nimport { loadTree } from \"./tree\";\nimport { defaultConjunction, defaultGroupConjunction } from \"../utils/defaultUtils\";\nimport moment from \"moment\";\n\n// http://jsonlogic.com/\n\n// helpers\nvar arrayUniq = function arrayUniq(arr) {\n  return Array.from(new Set(arr));\n};\nvar arrayToObject = function arrayToObject(arr) {\n  return arr.reduce(function (acc, _ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n      f = _ref2[0],\n      fc = _ref2[1];\n    return _objectSpread(_objectSpread({}, acc), {}, _defineProperty({}, f, fc));\n  }, {});\n};\nexport var loadFromJsonLogic = function loadFromJsonLogic(logicTree, config) {\n  return _loadFromJsonLogic(logicTree, config, false);\n};\nexport var _loadFromJsonLogic = function _loadFromJsonLogic(logicTree, config) {\n  var returnErrors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  //meta is mutable\n  var meta = {\n    errors: []\n  };\n  var extendedConfig = extendConfig(config);\n  var conv = buildConv(extendedConfig);\n  var jsTree = logicTree ? convertFromLogic(logicTree, conv, extendedConfig, \"rule\", meta) : undefined;\n  if (jsTree && jsTree.type != \"group\") {\n    jsTree = wrapInDefaultConj(jsTree, extendedConfig);\n  }\n  var immTree = jsTree ? loadTree(jsTree) : undefined;\n  if (returnErrors) {\n    return [immTree, meta.errors];\n  } else {\n    if (meta.errors.length) console.warn(\"Errors while importing from JsonLogic:\", meta.errors);\n    return immTree;\n  }\n};\nvar buildConv = function buildConv(config) {\n  var operators = {};\n  for (var opKey in config.operators) {\n    var opConfig = config.operators[opKey];\n    if (typeof opConfig.jsonLogic == \"string\") {\n      // example: \"</2\", \"#in/1\"\n      var opk = (opConfig._jsonLogicIsRevArgs ? \"#\" : \"\") + opConfig.jsonLogic + \"/\" + defaultValue(opConfig.cardinality, 1);\n      if (!operators[opk]) operators[opk] = [];\n      operators[opk].push(opKey);\n    } else if (typeof opConfig.jsonLogic2 == \"string\") {\n      // example: all-in/1\"\n      var _opk = opConfig.jsonLogic2 + \"/\" + defaultValue(opConfig.cardinality, 1);\n      if (!operators[_opk]) operators[_opk] = [];\n      operators[_opk].push(opKey);\n    }\n  }\n  var conjunctions = {};\n  for (var conjKey in config.conjunctions) {\n    var conjunctionDefinition = config.conjunctions[conjKey];\n    var ck = conjunctionDefinition.jsonLogicConj || conjKey.toLowerCase();\n    conjunctions[ck] = conjKey;\n  }\n  var funcs = {};\n  for (var funcKey in config.funcs) {\n    var funcConfig = config.funcs[funcKey];\n    var fk = void 0;\n    if (funcConfig.jsonLogicIsMethod) {\n      fk = \"#\" + funcConfig.jsonLogic;\n    } else if (typeof funcConfig.jsonLogic == \"string\") {\n      fk = funcConfig.jsonLogic;\n    }\n    if (fk) {\n      if (!funcs[fk]) funcs[fk] = [];\n      funcs[fk].push(funcKey);\n    }\n  }\n  var _config$settings$json = config.settings.jsonLogic,\n    groupVarKey = _config$settings$json.groupVarKey,\n    altVarKey = _config$settings$json.altVarKey;\n  return {\n    operators: operators,\n    conjunctions: conjunctions,\n    funcs: funcs,\n    varKeys: [\"var\", groupVarKey, altVarKey]\n  };\n};\nvar convertFromLogic = function convertFromLogic(logic, conv, config, expectedType, meta) {\n  var not = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  var fieldConfig = arguments.length > 6 ? arguments[6] : undefined;\n  var widget = arguments.length > 7 ? arguments[7] : undefined;\n  var parentField = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : null;\n  var _isLockedLogic = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : false;\n  var op, vals;\n  if (isJsonLogic(logic)) {\n    op = Object.keys(logic)[0];\n    vals = logic[op];\n    if (!Array.isArray(vals)) vals = [vals];\n  }\n  var ret;\n  var beforeErrorsCnt = meta.errors.length;\n  var lockedOp = config.settings.jsonLogic.lockedOp;\n  var isEmptyOp = op == \"!\" && vals.length == 1 && vals[0] && isJsonLogic(vals[0]) && conv.varKeys.includes(Object.keys(vals[0])[0]);\n  var isRev = op == \"!\" && !isEmptyOp;\n  var isLocked = lockedOp && op == lockedOp;\n  if (isLocked) {\n    ret = convertFromLogic(vals[0], conv, config, expectedType, meta, not, fieldConfig, widget, parentField, true);\n  } else if (isRev) {\n    // reverse with not\n    ret = convertFromLogic(vals[0], conv, config, expectedType, meta, !not, fieldConfig, widget, parentField);\n  } else if (expectedType == \"val\") {\n    // not is not used here\n    ret = convertField(op, vals, conv, config, not, meta, parentField) || convertFunc(op, vals, conv, config, not, fieldConfig, meta, parentField) || convertVal(logic, fieldConfig, widget, config, meta);\n  } else if (expectedType == \"rule\") {\n    ret = convertConj(op, vals, conv, config, not, meta, parentField, false) || convertOp(op, vals, conv, config, not, meta, parentField);\n  }\n  var afterErrorsCnt = meta.errors.length;\n  if (op != \"!\" && ret === undefined && afterErrorsCnt == beforeErrorsCnt) {\n    meta.errors.push(\"Can't parse logic \".concat(JSON.stringify(logic)));\n  }\n  if (isLocked) {\n    ret.properties.isLocked = true;\n  }\n  return ret;\n};\nvar convertVal = function convertVal(val, fieldConfig, widget, config, meta) {\n  if (val === undefined) return undefined;\n  var widgetConfig = config.widgets[widget || fieldConfig.mainWidget];\n  if (!widgetConfig) {\n    meta.errors.push(\"No widget for type \".concat(fieldConfig.type));\n    return undefined;\n  }\n  if (isJsonLogic(val)) {\n    meta.errors.push(\"Unexpected logic in value: \".concat(JSON.stringify(val)));\n    return undefined;\n  }\n\n  // number of seconds -> time string\n  if (fieldConfig && fieldConfig.type == \"time\" && typeof val == \"number\") {\n    var h = Math.floor(val / 60 / 60) % 24,\n      m = Math.floor(val / 60) % 60,\n      s = val % 60;\n    var valueFormat = widgetConfig.valueFormat;\n    if (valueFormat) {\n      var dateVal = new Date(val);\n      dateVal.setMilliseconds(0);\n      dateVal.setHours(h);\n      dateVal.setMinutes(m);\n      dateVal.setSeconds(s);\n      val = moment(dateVal).format(valueFormat);\n    } else {\n      val = \"\".concat(h, \":\").concat(m, \":\").concat(s);\n    }\n  }\n\n  // \"2020-01-08T22:00:00.000Z\" -> Date object\n  if (fieldConfig && [\"date\", \"datetime\"].includes(fieldConfig.type) && val && !(val instanceof Date)) {\n    try {\n      var _dateVal = new Date(val);\n      if (_dateVal instanceof Date && _dateVal.toISOString() === val) {\n        val = _dateVal;\n      }\n    } catch (e) {\n      meta.errors.push(\"Can't convert value \".concat(val, \" as Date\"));\n      val = undefined;\n    }\n  }\n\n  // Date object -> formatted string\n  if (val instanceof Date && fieldConfig) {\n    var _valueFormat = widgetConfig.valueFormat;\n    if (_valueFormat) {\n      val = moment(val).format(_valueFormat);\n    }\n  }\n  var asyncListValues;\n  if (val && fieldConfig.fieldSettings && fieldConfig.fieldSettings.asyncFetch) {\n    var vals = Array.isArray(val) ? val : [val];\n    asyncListValues = vals;\n  }\n  return {\n    valueSrc: \"value\",\n    value: val,\n    valueType: widgetConfig.type,\n    asyncListValues: asyncListValues\n  };\n};\nvar convertField = function convertField(op, vals, conv, config, not, meta) {\n  var parentField = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n  var fieldSeparator = config.settings.fieldSeparator;\n  if (conv.varKeys.includes(op) && typeof vals[0] == \"string\") {\n    var field = vals[0];\n    if (parentField) field = [parentField, field].join(fieldSeparator);\n    field = normalizeField(config, field);\n    var fieldConfig = getFieldConfig(config, field);\n    if (!fieldConfig) {\n      meta.errors.push(\"No config for field \".concat(field));\n      return undefined;\n    }\n    return {\n      valueSrc: \"field\",\n      value: field,\n      valueType: fieldConfig.type\n    };\n  }\n  return undefined;\n};\nvar convertFunc = function convertFunc(op, vals, conv, config, not, fieldConfig, meta) {\n  var parentField = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;\n  if (!op) return undefined;\n  var func, argsArr, funcKey;\n  var jsonLogicIsMethod = op == \"method\";\n  if (jsonLogicIsMethod) {\n    var obj, opts;\n    var _vals = _toArray(vals);\n    obj = _vals[0];\n    func = _vals[1];\n    opts = _vals.slice(2);\n    argsArr = [obj].concat(_toConsumableArray(opts));\n  } else {\n    func = op;\n    argsArr = vals;\n  }\n  var fk = (jsonLogicIsMethod ? \"#\" : \"\") + func;\n  var funcKeys = (conv.funcs[fk] || []).filter(function (k) {\n    return fieldConfig ? config.funcs[k].returnType == fieldConfig.type : true;\n  });\n  if (funcKeys.length) {\n    funcKey = funcKeys[0];\n  } else {\n    var v = _defineProperty({}, op, vals);\n    for (var _i = 0, _Object$entries = Object.entries(config.funcs || {}); _i < _Object$entries.length; _i++) {\n      var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n        f = _Object$entries$_i[0],\n        fc = _Object$entries$_i[1];\n      if (fc.jsonLogicImport && fc.returnType == fieldConfig.type) {\n        var parsed = void 0;\n        try {\n          parsed = fc.jsonLogicImport(v);\n        } catch (_e) {\n          // given expression `v` can't be parsed into function\n        }\n        if (parsed) {\n          funcKey = f;\n          argsArr = parsed;\n        }\n      }\n    }\n  }\n  if (!funcKey) return undefined;\n  if (funcKey) {\n    var funcConfig = config.funcs[funcKey];\n    var argKeys = Object.keys(funcConfig.args || {});\n    var args = argsArr.reduce(function (acc, val, ind) {\n      var argKey = argKeys[ind];\n      var argConfig = funcConfig.args[argKey];\n      var argVal = convertFromLogic(val, conv, config, \"val\", meta, false, argConfig, null, parentField);\n      if (argVal === undefined) {\n        argVal = argConfig.defaultValue;\n        if (argVal === undefined) {\n          meta.errors.push(\"No value for arg \".concat(argKey, \" of func \").concat(funcKey));\n          return undefined;\n        }\n      }\n      return _objectSpread(_objectSpread({}, acc), {}, _defineProperty({}, argKey, argVal));\n    }, {});\n    return {\n      valueSrc: \"func\",\n      value: {\n        func: funcKey,\n        args: args\n      },\n      valueType: funcConfig.returnType\n    };\n  }\n  return undefined;\n};\nvar convertConj = function convertConj(op, vals, conv, config, not, meta) {\n  var parentField = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n  var isRuleGroup = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;\n  var conjKey = conv.conjunctions[op];\n  var fieldSeparator = config.settings.fieldSeparator;\n  var parentFieldConfig = parentField ? getFieldConfig(config, parentField) : null;\n  var isParentGroup = (parentFieldConfig === null || parentFieldConfig === void 0 ? void 0 : parentFieldConfig.type) == \"!group\";\n  if (conjKey) {\n    var type = \"group\";\n    var children = vals.map(function (v) {\n      return convertFromLogic(v, conv, config, \"rule\", meta, false, null, null, parentField);\n    }).filter(function (r) {\n      return r !== undefined;\n    }).reduce(function (acc, r) {\n      return _objectSpread(_objectSpread({}, acc), {}, _defineProperty({}, r.id, r));\n    }, {});\n    var complexFields = Object.values(children).map(function (v) {\n      var _v$properties;\n      return v === null || v === void 0 ? void 0 : (_v$properties = v.properties) === null || _v$properties === void 0 ? void 0 : _v$properties.field;\n    }).filter(function (f) {\n      return f && f.includes(fieldSeparator);\n    });\n    var complexFieldsGroupAncestors = Object.fromEntries(arrayUniq(complexFields).map(function (f) {\n      var parts = f.split(fieldSeparator);\n      var ancs = Object.fromEntries(parts.slice(0, -1).map(function (f, i, parts) {\n        return [].concat(_toConsumableArray(parts.slice(0, i)), [f]);\n      }).map(function (fp) {\n        return [fp.join(fieldSeparator), getFieldConfig(config, fp)];\n      }).filter(function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 2),\n          _f = _ref4[0],\n          fc = _ref4[1];\n        return fc.type == \"!group\";\n      }));\n      return [f, Object.keys(ancs)];\n    }));\n    var childrenInRuleGroup = Object.values(children).map(function (v) {\n      var _v$properties2;\n      return v === null || v === void 0 ? void 0 : (_v$properties2 = v.properties) === null || _v$properties2 === void 0 ? void 0 : _v$properties2.field;\n    }).map(function (f) {\n      return complexFieldsGroupAncestors[f];\n    }).filter(function (ancs) {\n      return ancs && ancs.length;\n    });\n    var usedRuleGroups = arrayUniq(Object.values(complexFieldsGroupAncestors).flat());\n    var usedTopRuleGroups = topLevelFieldsFilter(usedRuleGroups);\n    var properties = {\n      conjunction: conjKey,\n      not: not\n    };\n    var id = uuid();\n    var children1 = {};\n    var groupToId = {};\n    Object.entries(children).map(function (_ref5) {\n      var _ref6 = _slicedToArray(_ref5, 2),\n        k = _ref6[0],\n        v = _ref6[1];\n      if (v.type == \"group\" || v.type == \"rule_group\") {\n        // put as-is\n        children1[k] = v;\n      } else {\n        var _v$properties3;\n        var field = v === null || v === void 0 ? void 0 : (_v$properties3 = v.properties) === null || _v$properties3 === void 0 ? void 0 : _v$properties3.field;\n        var groupAncestors = complexFieldsGroupAncestors[field];\n        var groupField = groupAncestors === null || groupAncestors === void 0 ? void 0 : groupAncestors.at(-1);\n        if (!groupField) {\n          // not in rule_group (can be simple field or in struct) - put as-is\n          children1[k] = v;\n        } else {\n          // wrap field in rule_group (with creating hierarchy if need)\n          var ch = children1;\n          var parentFieldParts = parentField ? parentField.split(fieldSeparator) : [];\n          var isInParent = shallowEqual(parentFieldParts, groupField.split(fieldSeparator).slice(0, parentFieldParts.length));\n          if (!isInParent) parentFieldParts = []; // should not be\n          var traverseGroupFields = groupField.split(fieldSeparator).slice(parentFieldParts.length).map(function (f, i, parts) {\n            return [].concat(_toConsumableArray(parentFieldParts), _toConsumableArray(parts.slice(0, i)), [f]).join(fieldSeparator);\n          }).map(function (f) {\n            return normalizeField(config, f);\n          }).map(function (f) {\n            return {\n              f: f,\n              fc: getFieldConfig(config, f) || {}\n            };\n          }).filter(function (_ref7) {\n            var fc = _ref7.fc;\n            return fc.type != \"!struct\";\n          });\n          traverseGroupFields.map(function (_ref8, i) {\n            var gf = _ref8.f,\n              gfc = _ref8.fc;\n            var groupId = groupToId[gf];\n            if (!groupId) {\n              groupId = uuid();\n              groupToId[gf] = groupId;\n              ch[groupId] = {\n                type: \"rule_group\",\n                id: groupId,\n                children1: {},\n                properties: {\n                  conjunction: conjKey,\n                  not: false,\n                  field: gf,\n                  mode: gfc.mode\n                }\n              };\n            }\n            ch = ch[groupId].children1;\n          });\n          ch[k] = v;\n        }\n      }\n    });\n\n    // tip: for isRuleGroup=true correct type and properties will be set out of this func\n\n    return {\n      type: type,\n      id: id,\n      children1: children1,\n      properties: properties\n    };\n  }\n  return undefined;\n};\nvar topLevelFieldsFilter = function topLevelFieldsFilter(fields) {\n  var arr = _toConsumableArray(fields).sort(function (a, b) {\n    return a.length - b.length;\n  });\n  for (var i = 0; i < arr.length; i++) {\n    for (var j = i + 1; j < arr.length; j++) {\n      if (arr[j].indexOf(arr[i]) == 0) {\n        // arr[j] is inside arr[i] (eg. \"a.b\" inside \"a\")\n        arr.splice(j, 1);\n        j--;\n      }\n    }\n  }\n  return arr;\n};\nvar wrapInDefaultConjRuleGroup = function wrapInDefaultConjRuleGroup(rule, parentField, parentFieldConfig, config, conj) {\n  if (!rule) return undefined;\n  return {\n    type: \"rule_group\",\n    id: uuid(),\n    children1: _defineProperty({}, rule.id, rule),\n    properties: {\n      conjunction: conj || defaultGroupConjunction(config, parentFieldConfig),\n      not: false,\n      field: parentField\n    }\n  };\n};\nvar wrapInDefaultConj = function wrapInDefaultConj(rule, config) {\n  var not = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  return {\n    type: \"group\",\n    id: uuid(),\n    children1: _defineProperty({}, rule.id, rule),\n    properties: {\n      conjunction: defaultConjunction(config),\n      not: not\n    }\n  };\n};\nvar parseRule = function parseRule(op, arity, vals, parentField, conv, config, meta) {\n  var errors = [];\n  var res = _parseRule(op, arity, vals, parentField, conv, config, errors, false) || _parseRule(op, arity, vals, parentField, conv, config, errors, true);\n  if (!res) {\n    meta.errors.push(errors.join(\"; \") || \"Unknown op \".concat(op, \"/\").concat(arity));\n    return undefined;\n  }\n  return res;\n};\nvar _parseRule = function _parseRule(op, arity, vals, parentField, conv, config, errors, isRevArgs) {\n  // config.settings.groupOperators are used for group count (cardinality = 0 is exception)\n  // but don't confuse with \"all-in\" or \"some-in\" for multiselect\n  var isAllOrSomeInForMultiselect = (op == \"all\" || op == \"some\") && isJsonLogic(vals[1]) && Object.keys(vals[1])[0] == \"in\";\n  var isGroup0 = !isAllOrSomeInForMultiselect && config.settings.groupOperators.includes(op);\n  var eqOps = [\"==\", \"!=\"];\n  var cardinality = isGroup0 ? 0 : arity - 1;\n  if (isGroup0) cardinality = 0;else if (eqOps.includes(op) && cardinality == 1 && vals[1] === null) cardinality = 0;\n  var opk = op + \"/\" + cardinality;\n  var fieldSeparator = config.settings.fieldSeparator;\n  var opKeys = conv.operators[(isRevArgs ? \"#\" : \"\") + opk];\n  if (!opKeys) return;\n  var jlField,\n    args = [];\n  var rangeOps = [\"<\", \"<=\", \">\", \">=\"];\n  if (rangeOps.includes(op) && arity == 3) {\n    jlField = vals[1];\n    args = [vals[0], vals[2]];\n  } else if (isRevArgs) {\n    jlField = vals[1];\n    args = [vals[0]];\n  } else {\n    var _vals2 = _toArray(vals);\n    jlField = _vals2[0];\n    args = _vals2.slice(1);\n  }\n  if (!isJsonLogic(jlField)) {\n    errors.push(\"Incorrect operands for \".concat(op, \": \").concat(JSON.stringify(vals)));\n    return;\n  }\n  var k = Object.keys(jlField)[0];\n  var v = Object.values(jlField)[0];\n  var field, having, isGroup;\n  if (conv.varKeys.includes(k) && typeof v == \"string\") {\n    field = v;\n  }\n  if (isGroup0) {\n    isGroup = true;\n    having = args[0];\n    args = [];\n  }\n  // reduce/filter for group ext\n  if (k == \"reduce\" && Array.isArray(v) && v.length == 3) {\n    var _v2 = v,\n      _v3 = _slicedToArray(_v2, 3),\n      filter = _v3[0],\n      acc = _v3[1],\n      init = _v3[2];\n    if (isJsonLogic(filter) && init == 0 && isJsonLogic(acc) && Array.isArray(acc[\"+\"]) && acc[\"+\"][0] == 1 && isJsonLogic(acc[\"+\"][1]) && acc[\"+\"][1][\"var\"] == \"accumulator\") {\n      k = Object.keys(filter)[0];\n      v = Object.values(filter)[0];\n      if (k == \"filter\") {\n        var _v4 = v,\n          _v5 = _slicedToArray(_v4, 2),\n          group = _v5[0],\n          _filter = _v5[1];\n        if (isJsonLogic(group)) {\n          k = Object.keys(group)[0];\n          v = Object.values(group)[0];\n          if (conv.varKeys.includes(k) && typeof v == \"string\") {\n            field = v;\n            having = _filter;\n            isGroup = true;\n          }\n        }\n      } else if (conv.varKeys.includes(k) && typeof v == \"string\") {\n        field = v;\n        isGroup = true;\n      }\n    }\n  }\n  if (!field) {\n    errors.push(\"Unknown field \".concat(JSON.stringify(jlField)));\n    return;\n  }\n  if (parentField) field = [parentField, field].join(fieldSeparator);\n  field = normalizeField(config, field);\n  var fieldConfig = getFieldConfig(config, field);\n  if (!fieldConfig) {\n    errors.push(\"No config for field \".concat(field));\n    return;\n  }\n  var opKey = opKeys[0];\n  if (opKeys.length > 1 && fieldConfig && fieldConfig.operators) {\n    // eg. for \"equal\" and \"select_equals\"\n    opKeys = opKeys.filter(function (k) {\n      return fieldConfig.operators.includes(k);\n    });\n    if (opKeys.length == 0) {\n      errors.push(\"No corresponding ops for field \".concat(field));\n      return;\n    }\n    opKey = opKeys[0];\n  }\n  return {\n    field: field,\n    fieldConfig: fieldConfig,\n    opKey: opKey,\n    args: args,\n    having: having\n  };\n};\nvar convertOp = function convertOp(op, vals, conv, config, not, meta) {\n  var parentField = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n  if (!op) return undefined;\n  var arity = vals.length;\n  if ((op == \"all\" || op == \"some\") && isJsonLogic(vals[1])) {\n    // special case for \"all-in\" and \"some-in\"\n    var op2 = Object.keys(vals[1])[0];\n    if (op2 == \"in\") {\n      vals = [vals[0], vals[1][op2][1]];\n      op = op + \"-\" + op2; // \"all-in\" and \"some-in\"\n    }\n  }\n\n  var parseRes = parseRule(op, arity, vals, parentField, conv, config, meta);\n  if (!parseRes) return undefined;\n  var field = parseRes.field,\n    fieldConfig = parseRes.fieldConfig,\n    opKey = parseRes.opKey,\n    args = parseRes.args,\n    having = parseRes.having;\n  var opConfig = config.operators[opKey];\n\n  // Group component in array mode can show NOT checkbox, so do nothing in this case\n  // Otherwise try to revert\n  var showNot = fieldConfig.showNot !== undefined ? fieldConfig.showNot : config.settings.showNot;\n  var canRev = true;\n  // if (fieldConfig.type == \"!group\" && fieldConfig.mode == \"array\" && showNot)\n  //   canRev = false;\n\n  var conj;\n  var havingVals;\n  var havingNot = false;\n  if (fieldConfig.type == \"!group\" && having) {\n    conj = Object.keys(having)[0];\n    havingVals = having[conj];\n    if (!Array.isArray(havingVals)) havingVals = [havingVals];\n\n    // Preprocess \"!\": Try to reverse op in single rule in having\n    // Eg. use `not_equal` instead of `not` `equal`\n    var isEmptyOp = conj == \"!\" && havingVals.length == 1 && havingVals[0] && isJsonLogic(havingVals[0]) && conv.varKeys.includes(Object.keys(havingVals[0])[0]);\n    if (conj == \"!\" && !isEmptyOp) {\n      havingNot = true;\n      having = having[\"!\"];\n      conj = Object.keys(having)[0];\n      havingVals = having[conj];\n      if (!Array.isArray(havingVals)) havingVals = [havingVals];\n    }\n  }\n\n  // Use reversed op\n  if (not && canRev && opConfig.reversedOp) {\n    not = false;\n    opKey = opConfig.reversedOp;\n    opConfig = config.operators[opKey];\n  }\n  var widget = getWidgetForFieldOp(config, field, opKey);\n  var convertedArgs = args.map(function (v) {\n    return convertFromLogic(v, conv, config, \"val\", meta, false, fieldConfig, widget, parentField);\n  });\n  if (convertedArgs.filter(function (v) {\n    return v === undefined;\n  }).length) {\n    //meta.errors.push(`Undefined arg for field ${field} and op ${opKey}`);\n    return undefined;\n  }\n  var res;\n  if (fieldConfig.type == \"!group\" && having) {\n    if (conv.conjunctions[conj] !== undefined) {\n      // group\n      res = convertConj(conj, havingVals, conv, config, havingNot, meta, field, true);\n      havingNot = false;\n    } else {\n      // need to be wrapped in `rule_group`\n      var rule = convertOp(conj, havingVals, conv, config, havingNot, meta, field);\n      havingNot = false;\n      res = wrapInDefaultConjRuleGroup(rule, field, fieldConfig, config, conv.conjunctions[\"and\"]);\n    }\n    if (!res) return undefined;\n    res.type = \"rule_group\";\n    Object.assign(res.properties, {\n      field: field,\n      mode: fieldConfig.mode,\n      operator: opKey\n    });\n    if (fieldConfig.mode == \"array\") {\n      Object.assign(res.properties, {\n        value: convertedArgs.map(function (v) {\n          return v.value;\n        }),\n        valueSrc: convertedArgs.map(function (v) {\n          return v.valueSrc;\n        }),\n        valueType: convertedArgs.map(function (v) {\n          return v.valueType;\n        })\n      });\n    }\n    if (not) {\n      res = wrapInDefaultConj(res, config, not);\n    }\n  } else if (fieldConfig.type == \"!group\" && !having) {\n    res = {\n      type: \"rule_group\",\n      id: uuid(),\n      children1: {},\n      properties: {\n        conjunction: defaultGroupConjunction(config, fieldConfig),\n        not: not,\n        mode: fieldConfig.mode,\n        field: field,\n        operator: opKey\n      }\n    };\n    if (fieldConfig.mode == \"array\") {\n      Object.assign(res.properties, {\n        value: convertedArgs.map(function (v) {\n          return v.value;\n        }),\n        valueSrc: convertedArgs.map(function (v) {\n          return v.valueSrc;\n        }),\n        valueType: convertedArgs.map(function (v) {\n          return v.valueType;\n        })\n      });\n    }\n  } else {\n    var asyncListValuesArr = convertedArgs.map(function (v) {\n      return v.asyncListValues;\n    }).filter(function (v) {\n      return v != undefined;\n    });\n    var asyncListValues = asyncListValuesArr.length ? asyncListValuesArr[0] : undefined;\n    res = {\n      type: \"rule\",\n      id: uuid(),\n      properties: {\n        field: field,\n        operator: opKey,\n        value: convertedArgs.map(function (v) {\n          return v.value;\n        }),\n        valueSrc: convertedArgs.map(function (v) {\n          return v.valueSrc;\n        }),\n        valueType: convertedArgs.map(function (v) {\n          return v.valueType;\n        }),\n        asyncListValues: asyncListValues\n      }\n    };\n    if (not) {\n      //meta.errors.push(`No rev op for ${opKey}`);\n      res = wrapInDefaultConj(res, config, not);\n    }\n  }\n  return res;\n};"]},"metadata":{},"sourceType":"module"}