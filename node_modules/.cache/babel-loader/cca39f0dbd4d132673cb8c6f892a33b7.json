{"ast":null,"code":"import { toast } from 'react-toastify';\nimport Axios from 'axios';\nimport rsapi from '../rsapi';\nimport { initRequest } from './LoginAction';\nimport { DEFAULT_RETURN } from './LoginTypes';\nimport { sortData, getComboLabelValue, constructOptionList, formatInputDate, rearrangeDateFormat, formatDate } from '../components/CommonScript';\nimport { intl } from '../components/App';\nimport { transactionStatus } from '../components/Enumeration';\nexport function getSchedulerDetail(scheduler, userInfo, masterData, sscheduletype) {\n  return function (dispatch) {\n    dispatch(initRequest(true));\n    return rsapi.post(\"scheduler/getScheduler\", {\n      nschedulecode: scheduler.nschedulecode,\n      userinfo: userInfo,\n      sscheduletype: sscheduletype\n    }).then(response => {\n      masterData = { ...masterData,\n        ...response.data\n      };\n      sortData(masterData);\n      dispatch({\n        type: DEFAULT_RETURN,\n        payload: {\n          masterData,\n          operation: null,\n          modalName: undefined,\n          loading: false\n        }\n      });\n    }).catch(error => {\n      dispatch({\n        type: DEFAULT_RETURN,\n        payload: {\n          loading: false\n        }\n      });\n\n      if (error.response.status === 500) {\n        toast.error(error.message);\n      } else {\n        toast.warn(error.response.data);\n      }\n    });\n  };\n} // export function getSchedulerDetail (scheduler, userInfo, masterData) {\n//     return function (dispatch) {   \n//         const schedulerService = rsapi.post(\"scheduler/getScheduler\", {nschedulecode:scheduler.nschedulecode, userinfo:userInfo});\n//         const schedulerTypeService = rsapi.post(\"scheduler/getSchedulerType\", {userinfo:userInfo});\n//         let urlArray = [];\n//         urlArray = [schedulerService,schedulerTypeService];\n//     dispatch(initRequest(true));\n//     //return rsapi.post(\"scheduler/getScheduler\", {nschedulecode:scheduler.nschedulecode, userinfo:userInfo})\n//     Axios.all(urlArray)\n//    .then(response=>{     \n//         masterData = {...masterData, ...response[0].data};       \n//         sortData(masterData);\n//         const schedulerTypeMap = constructOptionList(response[1].data['SchedulerType'] || [], \"nschedulertypecode\",\n//                                           \"sschedulertypename\", undefined, undefined, false);  \n//         const schedulerTypeList = schedulerTypeMap.get(\"OptionList\");             \n//         dispatch({type: DEFAULT_RETURN, payload:{masterData,schedulerTypeList, operation:null, modalName:undefined, \n//              loading:false}});   \n//    })\n//    .catch(error=>{\n//         dispatch({type: DEFAULT_RETURN, payload: {loading:false}})\n//        if (error.response.status === 500){\n//            toast.error(error.message);\n//        } \n//        else{               \n//            toast.warn(error.response.data);\n//        }  \n//    })\n// }\n// }\n\nexport function getSchedulerComboService(inputParam) {\n  return function (dispatch) {\n    if (inputParam.operation === \"create\" || inputParam.operation === \"update\" && inputParam.masterData.SelectedScheduler.ntransactionstatus === transactionStatus.DRAFT) {\n      const schedulerTypeService = rsapi.post(\"scheduler/getSchedulerType\", {\n        userinfo: inputParam.userInfo\n      });\n      const srecurringTypeService = rsapi.post(\"scheduler/getSchedulerTypeRecurring\", {\n        userinfo: inputParam.userInfo\n      });\n      const srecurringMonthlyService = rsapi.post(\"scheduler/getSchedulerRecurringMonthlyPeriod\", {\n        userinfo: inputParam.userInfo\n      }); //const UTCtimeZoneService = rsapi.post(\"timezone/getLocalTimeByZone\", { userinfo: inputParam.userInfo });\n\n      let urlArray = [];\n\n      if (inputParam.operation === \"create\") {\n        urlArray = [schedulerTypeService, srecurringTypeService, srecurringMonthlyService]; //, UTCtimeZoneService\n      } else {\n        const schedulerById = rsapi.post(\"scheduler/getActiveSchedulerById\", {\n          [inputParam.primaryKeyName]: inputParam.masterData.SelectedScheduler[inputParam.primaryKeyName],\n          \"userinfo\": inputParam.userInfo\n        });\n        urlArray = [schedulerTypeService, srecurringTypeService, srecurringMonthlyService, schedulerById];\n      }\n\n      dispatch(initRequest(true));\n      Axios.all(urlArray).then(response => {\n        let gender = [];\n        const schedulerTypeMap = constructOptionList(response[0].data['SchedulerType'] || [], \"nschedulertypecode\", \"sschedulertypename\", undefined, undefined, false);\n        const recurringMap = constructOptionList(response[1].data['SchedulerTypeRecurring'] || [], \"ntyperecurringcode\", \"srecurringmodename\", undefined, undefined, false);\n        const recurringMonthlyMap = constructOptionList(response[2].data['SchedulerRecurringMonthlyPeriod'] || [], \"nrecurringperiodcode\", \"srecurrenceperiod\", undefined, undefined, false);\n        const schedulerTypeList = schedulerTypeMap.get(\"OptionList\");\n        const recurringList = recurringMap.get(\"OptionList\");\n        const monthlyTypeList = recurringMonthlyMap.get(\"OptionList\");\n        let selectedRecord = {};\n        let schedulertype = [];\n        let recurringtype = [];\n        let monthlytype = []; //const currentTime = rearrangeDateFormat(inputParam.userInfo, response[1].data);\n\n        if (inputParam.operation === \"update\") {\n          selectedRecord = response[3].data;\n\n          if (selectedRecord[\"sscheduletype\"] === \"O\") {\n            schedulertype.push({\n              \"value\": 1,\n              \"label\": \"One Time\"\n            });\n            selectedRecord[\"nschedulertypecode\"] = schedulertype[0];\n            recurringtype.push({\n              \"value\": 1,\n              \"label\": \"Daily\"\n            });\n            selectedRecord[\"ntyperecurringcode\"] = recurringtype[0];\n            monthlytype.push({\n              \"value\": 1,\n              \"label\": \"Exact Day\"\n            });\n            selectedRecord[\"nrecurringperiodcode\"] = monthlytype[0];\n          } else if (selectedRecord[\"sscheduletype\"] === \"D\") {\n            schedulertype.push({\n              \"value\": 2,\n              \"label\": \"Recurring\"\n            });\n            selectedRecord[\"nschedulertypecode\"] = schedulertype[0];\n            recurringtype.push({\n              \"value\": 1,\n              \"label\": \"Daily\"\n            });\n            selectedRecord[\"ntyperecurringcode\"] = recurringtype[0];\n            monthlytype.push({\n              \"value\": 1,\n              \"label\": \"Exact Day\"\n            });\n            selectedRecord[\"nrecurringperiodcode\"] = monthlytype[0]; //selectedRecord[\"sstartdate\"] = rearrangeDateFormat(inputParam.userInfo,selectedRecord[\"sstartdate\"]);\n\n            let date = selectedRecord[\"sstartdate\"];\n            date = date.substring(0, 10);\n            let time = selectedRecord[\"soccurencehourwiseinterval\"];\n            date = date + \" \" + time + \":00\";\n            selectedRecord[\"soccurencehourwiseinterval\"] = date;\n            selectedRecord[\"soccurencehourwiseinterval\"] = rearrangeDateFormat(inputParam.userInfo, selectedRecord[\"soccurencehourwiseinterval\"]);\n          } else if (selectedRecord[\"sscheduletype\"] === \"W\") {\n            schedulertype.push({\n              \"value\": 2,\n              \"label\": \"Recurring\"\n            });\n            selectedRecord[\"nschedulertypecode\"] = schedulertype[0];\n            recurringtype.push({\n              \"value\": 2,\n              \"label\": \"Weekly\"\n            });\n            selectedRecord[\"ntyperecurringcode\"] = recurringtype[0];\n            monthlytype.push({\n              \"value\": 1,\n              \"label\": \"Exact Day\"\n            });\n            selectedRecord[\"nrecurringperiodcode\"] = monthlytype[0];\n          } else if (selectedRecord[\"sscheduletype\"] === \"M\") {\n            schedulertype.push({\n              \"value\": 2,\n              \"label\": \"Recurring\"\n            });\n            selectedRecord[\"nschedulertypecode\"] = schedulertype[0];\n            recurringtype.push({\n              \"value\": 3,\n              \"label\": \"Monthly\"\n            });\n            selectedRecord[\"ntyperecurringcode\"] = recurringtype[0];\n\n            if (selectedRecord[\"nmonthlyoccurrencetype\"] === 1) {\n              monthlytype.push({\n                \"value\": 1,\n                \"label\": \"Exact Day\"\n              });\n              selectedRecord[\"nrecurringperiodcode\"] = monthlytype[0];\n            }\n\n            if (selectedRecord[\"nmonthlyoccurrencetype\"] === 2) {\n              monthlytype.push({\n                \"value\": 2,\n                \"label\": \"1st Week\"\n              });\n              selectedRecord[\"nrecurringperiodcode\"] = monthlytype[0];\n            }\n\n            if (selectedRecord[\"nmonthlyoccurrencetype\"] === 3) {\n              monthlytype.push({\n                \"value\": 3,\n                \"label\": \"2nd Week\"\n              });\n              selectedRecord[\"nrecurringperiodcode\"] = monthlytype[0];\n            }\n\n            if (selectedRecord[\"nmonthlyoccurrencetype\"] === 4) {\n              monthlytype.push({\n                \"value\": 4,\n                \"label\": \"3rd Week\"\n              });\n              selectedRecord[\"nrecurringperiodcode\"] = monthlytype[0];\n            }\n\n            if (selectedRecord[\"nmonthlyoccurrencetype\"] === 5) {\n              monthlytype.push({\n                \"value\": 5,\n                \"label\": \"4th Week\"\n              });\n              selectedRecord[\"nrecurringperiodcode\"] = monthlytype[0];\n            }\n          }\n\n          selectedRecord[\"sstartdate\"] = rearrangeDateFormat(inputParam.userInfo, selectedRecord[\"sstartdate\"]);\n          selectedRecord[\"sstarttime\"] = rearrangeDateFormat(inputParam.userInfo, selectedRecord[\"sstarttime\"]);\n          selectedRecord[\"senddate\"] = rearrangeDateFormat(inputParam.userInfo, selectedRecord[\"senddate\"]);\n          selectedRecord[\"sendtime\"] = rearrangeDateFormat(inputParam.userInfo, selectedRecord[\"sendtime\"]); //    let date= selectedRecord[\"sstartdate\"];\n          //    let time= selectedRecord[\"soccurencehourwiseinterval\"];\n          //    date=date.substring(0,10);\n          //    selectedRecord[\"soccurencehourwiseinterval\"]=date+\" \"+time;\n          // gender.push({\"value\" : response[1].data[\"ngendercode\"], \"label\" : response[1].data[\"sgendername\"]});\n          // selectedRecord[\"ngendercode\"] = gender[0];\n          // if (selectedRecord[\"ddob\"] !== null){\n          //     selectedRecord[\"ddob\"] = rearrangeDateFormat(inputParam.userInfo, selectedRecord[\"sdob\"]);\n          // }                                          \n        } else {\n          if (inputParam.nfilterScheduleType) {\n            selectedRecord[\"nschedulertypecode\"] = inputParam.nfilterScheduleType;\n          } else {\n            selectedRecord[\"nschedulertypecode\"] = schedulerTypeMap.get(\"DefaultValue\");\n          }\n\n          selectedRecord[\"ntyperecurringcode\"] = recurringMap.get(\"DefaultValue\");\n          selectedRecord[\"nrecurringperiodcode\"] = recurringMonthlyMap.get(\"DefaultValue\"); //selectedRecord[\"ddob\"] = rearrangeDateFormat(inputParam.userInfo, response[1].data);\n          //selectedRecord[\"sage\"]  = ageCalculate(selectedRecord[\"ddob\"])\n        }\n\n        dispatch({\n          type: DEFAULT_RETURN,\n          payload: {\n            schedulerTypeList,\n            recurringList,\n            monthlyTypeList,\n            operation: inputParam.operation,\n            screenName: inputParam.screenName,\n            selectedRecord,\n            openModal: true,\n            ncontrolCode: inputParam.ncontrolcode,\n            loading: false //currentTime\n\n          }\n        });\n      }).catch(error => {\n        dispatch({\n          type: DEFAULT_RETURN,\n          payload: {\n            loading: false\n          }\n        });\n\n        if (error.response.status === 500) {\n          toast.error(error.message);\n        } else {\n          toast.warn(error.response.data);\n        }\n      });\n    } else {\n      let message = \"IDS_SELECTDRAFTRECORDTOEDIT\";\n      toast.warn(intl.formatMessage({\n        id: message\n      }));\n    }\n  };\n}\nexport const changeScheduleTypeFilter = (inputParam, filterScheduleType) => {\n  return dispatch => {\n    dispatch(initRequest(true));\n    rsapi.post(\"/scheduler/get\" + inputParam.methodUrl, inputParam.inputData).then(response => {\n      const masterData = response.data;\n      sortData(masterData);\n      dispatch({\n        type: DEFAULT_RETURN,\n        payload: {\n          loading: false,\n          masterData: { ...masterData,\n            filterScheduleType,\n            nfilterScheduleType: inputParam.inputData.nfilterScheduleType\n          }\n        }\n      });\n    }).catch(error => {\n      dispatch({\n        type: DEFAULT_RETURN,\n        payload: {\n          loading: false\n        }\n      });\n      toast.error(error.message);\n    });\n  };\n};","map":{"version":3,"sources":["E:/WorkingFolder/React_Postgres/ALPD/branches/SOURCE-512/QuaLISWeb/src/actions/SchedulerAction.js"],"names":["toast","Axios","rsapi","initRequest","DEFAULT_RETURN","sortData","getComboLabelValue","constructOptionList","formatInputDate","rearrangeDateFormat","formatDate","intl","transactionStatus","getSchedulerDetail","scheduler","userInfo","masterData","sscheduletype","dispatch","post","nschedulecode","userinfo","then","response","data","type","payload","operation","modalName","undefined","loading","catch","error","status","message","warn","getSchedulerComboService","inputParam","SelectedScheduler","ntransactionstatus","DRAFT","schedulerTypeService","srecurringTypeService","srecurringMonthlyService","urlArray","schedulerById","primaryKeyName","all","gender","schedulerTypeMap","recurringMap","recurringMonthlyMap","schedulerTypeList","get","recurringList","monthlyTypeList","selectedRecord","schedulertype","recurringtype","monthlytype","push","date","substring","time","nfilterScheduleType","screenName","openModal","ncontrolCode","ncontrolcode","formatMessage","id","changeScheduleTypeFilter","filterScheduleType","methodUrl","inputData"],"mappings":"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","sourcesContent":["import { toast } from 'react-toastify';\r\nimport Axios from 'axios';\r\nimport rsapi from '../rsapi';\r\nimport { initRequest } from './LoginAction';\r\nimport {DEFAULT_RETURN} from './LoginTypes';\r\nimport {sortData, getComboLabelValue, constructOptionList,formatInputDate, rearrangeDateFormat, formatDate} from '../components/CommonScript';\r\nimport { intl } from '../components/App';\r\nimport {transactionStatus} from '../components/Enumeration';\r\n\r\nexport function getSchedulerDetail (scheduler, userInfo, masterData,sscheduletype) {\r\n    return function (dispatch) {   \r\n    dispatch(initRequest(true));\r\n    return rsapi.post(\"scheduler/getScheduler\", {nschedulecode:scheduler.nschedulecode, userinfo:userInfo,sscheduletype:sscheduletype})\r\n   .then(response=>{     \r\n        masterData = {...masterData, ...response.data};       \r\n        sortData(masterData);\r\n        dispatch({type: DEFAULT_RETURN, payload:{masterData, operation:null, modalName:undefined, \r\n             loading:false}});   \r\n   })\r\n   .catch(error=>{\r\n        dispatch({type: DEFAULT_RETURN, payload: {loading:false}})\r\n       if (error.response.status === 500){\r\n           toast.error(error.message);\r\n       } \r\n       else{               \r\n           toast.warn(error.response.data);\r\n       }  \r\n  \r\n   })\r\n}\r\n}\r\n// export function getSchedulerDetail (scheduler, userInfo, masterData) {\r\n//     return function (dispatch) {   \r\n//         const schedulerService = rsapi.post(\"scheduler/getScheduler\", {nschedulecode:scheduler.nschedulecode, userinfo:userInfo});\r\n//         const schedulerTypeService = rsapi.post(\"scheduler/getSchedulerType\", {userinfo:userInfo});\r\n//         let urlArray = [];\r\n//         urlArray = [schedulerService,schedulerTypeService];\r\n//     dispatch(initRequest(true));\r\n//     //return rsapi.post(\"scheduler/getScheduler\", {nschedulecode:scheduler.nschedulecode, userinfo:userInfo})\r\n//     Axios.all(urlArray)\r\n//    .then(response=>{     \r\n//         masterData = {...masterData, ...response[0].data};       \r\n//         sortData(masterData);\r\n//         const schedulerTypeMap = constructOptionList(response[1].data['SchedulerType'] || [], \"nschedulertypecode\",\r\n//                                           \"sschedulertypename\", undefined, undefined, false);  \r\n//         const schedulerTypeList = schedulerTypeMap.get(\"OptionList\");             \r\n//         dispatch({type: DEFAULT_RETURN, payload:{masterData,schedulerTypeList, operation:null, modalName:undefined, \r\n//              loading:false}});   \r\n//    })\r\n//    .catch(error=>{\r\n//         dispatch({type: DEFAULT_RETURN, payload: {loading:false}})\r\n//        if (error.response.status === 500){\r\n//            toast.error(error.message);\r\n//        } \r\n//        else{               \r\n//            toast.warn(error.response.data);\r\n//        }  \r\n  \r\n//    })\r\n// }\r\n// }\r\n\r\nexport function getSchedulerComboService(inputParam){ \r\n    return function (dispatch) {    \r\n        if (inputParam.operation === \"create\" || (inputParam.operation === \"update\" && inputParam.masterData.SelectedScheduler.ntransactionstatus === transactionStatus.DRAFT)) {\r\n            const schedulerTypeService = rsapi.post(\"scheduler/getSchedulerType\", {userinfo:inputParam.userInfo});\r\n            const srecurringTypeService = rsapi.post(\"scheduler/getSchedulerTypeRecurring\", {userinfo:inputParam.userInfo});\r\n            const srecurringMonthlyService = rsapi.post(\"scheduler/getSchedulerRecurringMonthlyPeriod\", {userinfo:inputParam.userInfo});\r\n            //const UTCtimeZoneService = rsapi.post(\"timezone/getLocalTimeByZone\", { userinfo: inputParam.userInfo });\r\n                    \r\n            let urlArray = [];\r\n            if (inputParam.operation === \"create\"){\r\n               urlArray = [schedulerTypeService,srecurringTypeService,srecurringMonthlyService];//, UTCtimeZoneService\r\n            }\r\n            else{                    \r\n                const schedulerById =  rsapi.post(\"scheduler/getActiveSchedulerById\", \r\n                                { [inputParam.primaryKeyName] :inputParam.masterData.SelectedScheduler[inputParam.primaryKeyName] , \r\n                                    \"userinfo\": inputParam.userInfo} );\r\n                \r\n                urlArray = [schedulerTypeService,srecurringTypeService,srecurringMonthlyService,schedulerById];\r\n            }\r\n            dispatch(initRequest(true));\r\n            Axios.all(urlArray)\r\n                .then(response=>{                   \r\n                    let gender =[];\r\n                 \r\n                    const schedulerTypeMap = constructOptionList(response[0].data['SchedulerType'] || [], \"nschedulertypecode\",\r\n                                          \"sschedulertypename\", undefined, undefined, false);               \r\n                    const recurringMap = constructOptionList(response[1].data['SchedulerTypeRecurring'] || [], \"ntyperecurringcode\",\r\n                                          \"srecurringmodename\", undefined, undefined, false);               \r\n                    const recurringMonthlyMap = constructOptionList(response[2].data['SchedulerRecurringMonthlyPeriod'] || [], \"nrecurringperiodcode\",\r\n                                          \"srecurrenceperiod\", undefined, undefined, false);               \r\n\r\n                    const schedulerTypeList = schedulerTypeMap.get(\"OptionList\");\r\n                    const recurringList = recurringMap.get(\"OptionList\");\r\n                    const monthlyTypeList = recurringMonthlyMap.get(\"OptionList\");\r\n                    \r\n                    let selectedRecord =  {};\r\n                    let schedulertype =[];\r\n                    let recurringtype =[];\r\n                    let monthlytype =[];\r\n                    //const currentTime = rearrangeDateFormat(inputParam.userInfo, response[1].data);\r\n                   \r\n                    if (inputParam.operation === \"update\"){\r\n                         selectedRecord = response[3].data;\r\n                         if(selectedRecord[\"sscheduletype\"]===\"O\")\r\n                         {\r\n                            schedulertype.push({\"value\": 1,\"label\": \"One Time\"});\r\n                            selectedRecord[\"nschedulertypecode\"]= schedulertype[0];\r\n                            recurringtype.push({\"value\": 1,\"label\": \"Daily\"})\r\n                            selectedRecord[\"ntyperecurringcode\"] = recurringtype[0]; \r\n                            monthlytype.push({\"value\": 1,\"label\": \"Exact Day\"});\r\n                            selectedRecord[\"nrecurringperiodcode\"] = monthlytype[0];\r\n                         }\r\n                         else if(selectedRecord[\"sscheduletype\"]===\"D\")\r\n                         {\r\n                            schedulertype.push({\"value\": 2,\"label\": \"Recurring\"});\r\n                            selectedRecord[\"nschedulertypecode\"]= schedulertype[0];\r\n                            recurringtype.push({\"value\": 1,\"label\": \"Daily\"})\r\n                            selectedRecord[\"ntyperecurringcode\"] = recurringtype[0]; \r\n                            monthlytype.push({\"value\": 1,\"label\": \"Exact Day\"});\r\n                            selectedRecord[\"nrecurringperiodcode\"] = monthlytype[0];\r\n                            //selectedRecord[\"sstartdate\"] = rearrangeDateFormat(inputParam.userInfo,selectedRecord[\"sstartdate\"]);\r\n                            let date=selectedRecord[\"sstartdate\"];\r\n                            date=date.substring(0,10);\r\n                            let time=selectedRecord[\"soccurencehourwiseinterval\"];\r\n                             \r\n                             date=date+\" \"+time+\":00\";\r\n                             selectedRecord[\"soccurencehourwiseinterval\"]=date;\r\n                             selectedRecord[\"soccurencehourwiseinterval\"]=rearrangeDateFormat(inputParam.userInfo,selectedRecord[\"soccurencehourwiseinterval\"]);\r\n                         }\r\n                         else if(selectedRecord[\"sscheduletype\"]===\"W\")\r\n                         {\r\n                            schedulertype.push({\"value\": 2,\"label\": \"Recurring\"});\r\n                            selectedRecord[\"nschedulertypecode\"]= schedulertype[0];\r\n                            recurringtype.push({\"value\": 2,\"label\": \"Weekly\"})\r\n                            selectedRecord[\"ntyperecurringcode\"] = recurringtype[0]; \r\n                            monthlytype.push({\"value\": 1,\"label\": \"Exact Day\"});\r\n                            selectedRecord[\"nrecurringperiodcode\"] = monthlytype[0];\r\n                         }\r\n                         else if(selectedRecord[\"sscheduletype\"]===\"M\")\r\n                         {\r\n                            schedulertype.push({\"value\": 2,\"label\": \"Recurring\"});\r\n                            selectedRecord[\"nschedulertypecode\"]= schedulertype[0];\r\n                            recurringtype.push({\"value\": 3,\"label\": \"Monthly\"})\r\n                            selectedRecord[\"ntyperecurringcode\"] = recurringtype[0]; \r\n                            \r\n                            if(selectedRecord[\"nmonthlyoccurrencetype\"]===1)\r\n                            {\r\n                                monthlytype.push({\"value\": 1,\"label\": \"Exact Day\"});\r\n                                selectedRecord[\"nrecurringperiodcode\"] = monthlytype[0];\r\n                            }\r\n                            if(selectedRecord[\"nmonthlyoccurrencetype\"]===2)\r\n                            {\r\n                                monthlytype.push({\"value\": 2,\"label\": \"1st Week\"});\r\n                                selectedRecord[\"nrecurringperiodcode\"] = monthlytype[0];\r\n                            }\r\n                            if(selectedRecord[\"nmonthlyoccurrencetype\"]===3)\r\n                            {\r\n                                monthlytype.push({\"value\": 3,\"label\": \"2nd Week\"});\r\n                                selectedRecord[\"nrecurringperiodcode\"] = monthlytype[0];\r\n                            }\r\n                            if(selectedRecord[\"nmonthlyoccurrencetype\"]===4)\r\n                            {\r\n                                monthlytype.push({\"value\": 4,\"label\": \"3rd Week\"});\r\n                                selectedRecord[\"nrecurringperiodcode\"] = monthlytype[0];\r\n                            }\r\n                            if(selectedRecord[\"nmonthlyoccurrencetype\"]===5)\r\n                            {\r\n                                monthlytype.push({\"value\": 5,\"label\": \"4th Week\"});\r\n                                selectedRecord[\"nrecurringperiodcode\"] = monthlytype[0];\r\n                            }\r\n                            \r\n                         }\r\n                         selectedRecord[\"sstartdate\"] = rearrangeDateFormat(inputParam.userInfo,selectedRecord[\"sstartdate\"]);\r\n                            selectedRecord[\"sstarttime\"] = rearrangeDateFormat(inputParam.userInfo,selectedRecord[\"sstarttime\"]);\r\n                            selectedRecord[\"senddate\"] = rearrangeDateFormat(inputParam.userInfo,selectedRecord[\"senddate\"]);\r\n                            selectedRecord[\"sendtime\"] = rearrangeDateFormat(inputParam.userInfo,selectedRecord[\"sendtime\"]);\r\n                        //    let date= selectedRecord[\"sstartdate\"];\r\n                        //    let time= selectedRecord[\"soccurencehourwiseinterval\"];\r\n                        //    date=date.substring(0,10);\r\n                        //    selectedRecord[\"soccurencehourwiseinterval\"]=date+\" \"+time;\r\n\r\n                        // gender.push({\"value\" : response[1].data[\"ngendercode\"], \"label\" : response[1].data[\"sgendername\"]});\r\n                                             \r\n                        // selectedRecord[\"ngendercode\"] = gender[0];\r\n\r\n                        // if (selectedRecord[\"ddob\"] !== null){\r\n                        //     selectedRecord[\"ddob\"] = rearrangeDateFormat(inputParam.userInfo, selectedRecord[\"sdob\"]);\r\n                        // }                                          \r\n                    }\r\n                    else{        \r\n                        if(inputParam.nfilterScheduleType)\r\n                        {\r\n                            selectedRecord[\"nschedulertypecode\"] = inputParam.nfilterScheduleType;  \r\n                        }\r\n                        else\r\n                        {\r\n                        selectedRecord[\"nschedulertypecode\"] = schedulerTypeMap.get(\"DefaultValue\");  \r\n                        }\r\n                        selectedRecord[\"ntyperecurringcode\"] = recurringMap.get(\"DefaultValue\");  \r\n                        selectedRecord[\"nrecurringperiodcode\"] = recurringMonthlyMap.get(\"DefaultValue\");  \r\n                        //selectedRecord[\"ddob\"] = rearrangeDateFormat(inputParam.userInfo, response[1].data);\r\n                        //selectedRecord[\"sage\"]  = ageCalculate(selectedRecord[\"ddob\"])\r\n                    }\r\n                  \r\n                    dispatch({type: DEFAULT_RETURN, payload:{schedulerTypeList,\r\n                                                            recurringList,\r\n                                                            monthlyTypeList,                         \r\n                                                            operation:inputParam.operation, \r\n                                                            screenName:inputParam.screenName,   \r\n                                                            selectedRecord,\r\n                                                            openModal : true,\r\n                                                            ncontrolCode:inputParam.ncontrolcode,\r\n                                                            loading:false,\r\n                                                            //currentTime\r\n                                                            }});\r\n                })\r\n                .catch(error=>{\r\n                    dispatch({type: DEFAULT_RETURN, payload: {loading:false}})\r\n                    if (error.response.status === 500){\r\n                        toast.error(error.message);\r\n                    } \r\n                    else{               \r\n                        toast.warn(error.response.data);\r\n                    }  \r\n                }) \r\n            }\r\n            else\r\n            {\r\n                let message = \"IDS_SELECTDRAFTRECORDTOEDIT\";\r\n            \r\n            toast.warn(intl.formatMessage({ id: message }));\r\n            }\r\n}\r\n}\r\n\r\nexport const changeScheduleTypeFilter = (inputParam, filterScheduleType) => {\r\n    return (dispatch) => {\r\n        dispatch(initRequest(true));\r\n        rsapi.post(\"/scheduler/get\" + inputParam.methodUrl, inputParam.inputData)\r\n            .then(response => {\r\n                const masterData = response.data\r\n                sortData(masterData);\r\n                dispatch({\r\n                    type: DEFAULT_RETURN,\r\n                    payload: {\r\n                        loading: false,\r\n                        masterData: {\r\n                            ...masterData,\r\n                            filterScheduleType,\r\n                            nfilterScheduleType: inputParam.inputData.nfilterScheduleType\r\n                        }\r\n                    }\r\n                });\r\n            })\r\n            .catch(error => {\r\n                dispatch({\r\n                    type: DEFAULT_RETURN,\r\n                    payload: {\r\n                        loading: false\r\n                    }\r\n                });\r\n                toast.error(error.message);\r\n            });\r\n    }\r\n}"]},"metadata":{},"sourceType":"module"}