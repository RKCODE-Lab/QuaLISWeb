{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getWidgetsForFieldOp = exports.getWidgetForFieldOp = exports.getValueSourcesForFieldOp = exports.getValueLabel = exports.getOperatorsForField = exports.getNewValueForFieldOp = exports.getFuncPathLabels = exports.getFirstOperator = exports.getFirstField = exports.getFieldPathLabels = exports.getFieldPath = exports.formatFieldName = exports.filterValueSourcesForField = void 0;\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _configUtils = require(\"./configUtils\");\n\nvar _stuff = require(\"../utils/stuff\");\n\nvar _immutable = _interopRequireDefault(require(\"immutable\"));\n\nvar _validation = require(\"../utils/validation\");\n\nvar _last = _interopRequireDefault(require(\"lodash/last\"));\n\nvar selectTypes = [\"select\", \"multiselect\", \"treeselect\", \"treemultiselect\"];\n/**\n * @param {object} config\n * @param {object} oldConfig\n * @param {Immutable.Map} current\n * @param {string} newField\n * @param {string} newOperator\n * @param {string} changedField\n * @return {object} - {canReuseValue, newValue, newValueSrc, newValueType, newValueError}\n */\n\nvar getNewValueForFieldOp = function getNewValueForFieldOp(config) {\n  var oldConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var current = arguments.length > 2 ? arguments[2] : undefined;\n  var newField = arguments.length > 3 ? arguments[3] : undefined;\n  var newOperator = arguments.length > 4 ? arguments[4] : undefined;\n  var changedField = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n  var canFix = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : true;\n  if (!oldConfig) oldConfig = config;\n  var currentField = current.get(\"field\");\n  var currentOperator = current.get(\"operator\");\n  var currentValue = current.get(\"value\");\n  var currentValueSrc = current.get(\"valueSrc\", new _immutable[\"default\"].List());\n  var currentValueType = current.get(\"valueType\", new _immutable[\"default\"].List());\n  var currentAsyncListValues = current.get(\"asyncListValues\"); //const isValidatingTree = (changedField === null);\n\n  var _config$settings = config.settings,\n      convertableWidgets = _config$settings.convertableWidgets,\n      clearValueOnChangeField = _config$settings.clearValueOnChangeField,\n      clearValueOnChangeOp = _config$settings.clearValueOnChangeOp,\n      showErrorMessage = _config$settings.showErrorMessage; //const currentOperatorConfig = getOperatorConfig(oldConfig, currentOperator, currentField);\n\n  var newOperatorConfig = (0, _configUtils.getOperatorConfig)(config, newOperator, newField); //const currentOperatorCardinality = currentOperator ? defaultValue(currentOperatorConfig.cardinality, 1) : null;\n\n  var operatorCardinality = newOperator ? (0, _stuff.defaultValue)(newOperatorConfig.cardinality, 1) : null;\n  var currentFieldConfig = (0, _configUtils.getFieldConfig)(oldConfig, currentField);\n  var newFieldConfig = (0, _configUtils.getFieldConfig)(config, newField);\n  var canReuseValue = currentField && currentOperator && newOperator && currentValue != undefined && (!changedField || changedField == \"field\" && !clearValueOnChangeField || changedField == \"operator\" && !clearValueOnChangeOp) && currentFieldConfig && newFieldConfig && currentFieldConfig.type == newFieldConfig.type;\n\n  if (canReuseValue && selectTypes.includes(currentFieldConfig.type) && changedField == \"field\") {\n    // different fields of select types has different listValues\n    canReuseValue = false;\n  } // compare old & new widgets\n\n\n  for (var i = 0; i < operatorCardinality; i++) {\n    var vs = currentValueSrc.get(i) || null;\n    var currentWidget = getWidgetForFieldOp(oldConfig, currentField, currentOperator, vs);\n    var newWidget = getWidgetForFieldOp(config, newField, newOperator, vs); // need to also check value widgets if we changed operator and current value source was 'field'\n    // cause for select type op '=' requires single value and op 'in' requires array value\n\n    var currentValueWidget = vs == \"value\" ? currentWidget : getWidgetForFieldOp(oldConfig, currentField, currentOperator, \"value\");\n    var newValueWidget = vs == \"value\" ? newWidget : getWidgetForFieldOp(config, newField, newOperator, \"value\");\n    var canReuseWidget = newValueWidget == currentValueWidget || (convertableWidgets[currentValueWidget] || []).includes(newValueWidget);\n    if (!canReuseWidget) canReuseValue = false;\n  }\n\n  if (currentOperator != newOperator && [currentOperator, newOperator].includes(\"proximity\")) canReuseValue = false;\n  var firstWidgetConfig = (0, _configUtils.getFieldWidgetConfig)(config, newField, newOperator, null, currentValueSrc.first());\n  var valueSources = getValueSourcesForFieldOp(config, newField, newOperator);\n  var valueFixes = {};\n  var valueErrors = Array.from({\n    length: operatorCardinality\n  }, function () {\n    return null;\n  });\n\n  if (canReuseValue) {\n    var _loop = function _loop(_i) {\n      var v = currentValue.get(_i);\n      var vType = currentValueType.get(_i) || null;\n      var vSrc = currentValueSrc.get(_i) || null;\n      var isValidSrc = valueSources.find(function (v) {\n        return v == vSrc;\n      }) != null;\n      if (!isValidSrc && _i > 0 && vSrc == null) isValidSrc = true; // make exception for range widgets (when changing op from '==' to 'between')\n\n      var isEndValue = !canFix;\n      var asyncListValues = currentAsyncListValues;\n\n      var _validateValue = (0, _validation.validateValue)(config, newField, newField, newOperator, v, vType, vSrc, asyncListValues, canFix, isEndValue),\n          _validateValue2 = (0, _slicedToArray2[\"default\"])(_validateValue, 2),\n          validateError = _validateValue2[0],\n          fixedValue = _validateValue2[1];\n\n      var isValid = !validateError;\n\n      if (!isValid && showErrorMessage && changedField != \"field\") {\n        // allow bad value\n        // but not on field change - in that case just drop bad value that can't be reused\n        // ? maybe we should also drop bad value on op change?\n        valueErrors[_i] = validateError;\n      } else if (!isValidSrc || !isValid) {\n        canReuseValue = false;\n        return \"break\";\n      } else if (canFix && fixedValue !== v) {\n        valueFixes[_i] = fixedValue;\n      }\n    };\n\n    for (var _i = 0; _i < operatorCardinality; _i++) {\n      var _ret = _loop(_i);\n\n      if (_ret === \"break\") break;\n    }\n  }\n\n  var newValue = null,\n      newValueSrc = null,\n      newValueType = null,\n      newValueError = null;\n  newValue = new _immutable[\"default\"].List(Array.from({\n    length: operatorCardinality\n  }, function (_ignore, i) {\n    var v = undefined;\n\n    if (canReuseValue) {\n      if (i < currentValue.size) {\n        v = currentValue.get(i);\n\n        if (valueFixes[i] !== undefined) {\n          v = valueFixes[i];\n        }\n      }\n    } else if (operatorCardinality == 1 && (firstWidgetConfig || newFieldConfig)) {\n      if (newFieldConfig.defaultValue !== undefined) v = newFieldConfig.defaultValue;else if (newFieldConfig.fieldSettings && newFieldConfig.fieldSettings.defaultValue !== undefined) v = newFieldConfig.fieldSettings.defaultValue;else if (firstWidgetConfig.defaultValue !== undefined) v = firstWidgetConfig.defaultValue;\n    }\n\n    return v;\n  }));\n  newValueSrc = new _immutable[\"default\"].List(Array.from({\n    length: operatorCardinality\n  }, function (_ignore, i) {\n    var vs = null;\n\n    if (canReuseValue) {\n      if (i < currentValueSrc.size) vs = currentValueSrc.get(i);\n    } else if (valueSources.length == 1) {\n      vs = valueSources[0];\n    } else if (valueSources.length > 1) {\n      vs = valueSources[0];\n    }\n\n    return vs;\n  }));\n\n  if (showErrorMessage) {\n    if (newOperatorConfig && newOperatorConfig.validateValues && newValueSrc.toJS().filter(function (vs) {\n      return vs == \"value\" || vs == null;\n    }).length == operatorCardinality) {\n      // last element in `valueError` list is for range validation error\n      var jsValues = firstWidgetConfig && firstWidgetConfig.toJS ? newValue.toJS().map(function (v) {\n        return firstWidgetConfig.toJS(v, firstWidgetConfig);\n      }) : newValue.toJS();\n      var rangeValidateError = newOperatorConfig.validateValues(jsValues);\n\n      if (showErrorMessage) {\n        valueErrors.push(rangeValidateError);\n      }\n    }\n\n    newValueError = new _immutable[\"default\"].List(valueErrors);\n  }\n\n  newValueType = new _immutable[\"default\"].List(Array.from({\n    length: operatorCardinality\n  }, function (_ignore, i) {\n    var vt = null;\n\n    if (canReuseValue) {\n      if (i < currentValueType.size) vt = currentValueType.get(i);\n    } else if (operatorCardinality == 1 && firstWidgetConfig && firstWidgetConfig.type !== undefined) {\n      vt = firstWidgetConfig.type;\n    } else if (operatorCardinality == 1 && newFieldConfig && newFieldConfig.type !== undefined) {\n      vt = newFieldConfig.type == \"!group\" ? \"number\" : newFieldConfig.type;\n    }\n\n    return vt;\n  }));\n  return {\n    canReuseValue: canReuseValue,\n    newValue: newValue,\n    newValueSrc: newValueSrc,\n    newValueType: newValueType,\n    newValueError: newValueError,\n    operatorCardinality: operatorCardinality\n  };\n};\n\nexports.getNewValueForFieldOp = getNewValueForFieldOp;\n\nvar getFirstField = function getFirstField(config) {\n  var parentRuleGroupPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var fieldSeparator = config.settings.fieldSeparator;\n  var parentPathArr = typeof parentRuleGroupPath == \"string\" ? parentRuleGroupPath.split(fieldSeparator) : parentRuleGroupPath;\n  var parentField = parentRuleGroupPath ? (0, _configUtils.getFieldRawConfig)(config, parentRuleGroupPath) : config;\n  var firstField = parentField,\n      key = null,\n      keysPath = [];\n\n  do {\n    var subfields = firstField === config ? config.fields : firstField.subfields;\n\n    if (!subfields || !Object.keys(subfields).length) {\n      firstField = key = null;\n      break;\n    }\n\n    key = Object.keys(subfields)[0];\n    keysPath.push(key);\n    firstField = subfields[key];\n  } while (firstField.type == \"!struct\" || firstField.type == \"!group\");\n\n  return (parentPathArr || []).concat(keysPath).join(fieldSeparator);\n};\n\nexports.getFirstField = getFirstField;\n\nvar getOperatorsForField = function getOperatorsForField(config, field) {\n  var fieldConfig = (0, _configUtils.getFieldConfig)(config, field);\n  var fieldOps = fieldConfig ? fieldConfig.operators : [];\n  return fieldOps;\n};\n\nexports.getOperatorsForField = getOperatorsForField;\n\nvar getFirstOperator = function getFirstOperator(config, field) {\n  var fieldOps = getOperatorsForField(config, field);\n  return fieldOps ? fieldOps[0] : null;\n};\n\nexports.getFirstOperator = getFirstOperator;\n\nvar getFieldPath = function getFieldPath(field, config) {\n  var onlyKeys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  if (!field) return null;\n  var fieldSeparator = config.settings.fieldSeparator;\n  var parts = Array.isArray(field) ? field : field.split(fieldSeparator);\n  if (onlyKeys) return parts;else return parts.map(function (_curr, ind, arr) {\n    return arr.slice(0, ind + 1);\n  }).map(function (parts) {\n    return parts.join(fieldSeparator);\n  });\n};\n\nexports.getFieldPath = getFieldPath;\n\nvar getFuncPathLabels = function getFuncPathLabels(field, config) {\n  var parentField = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  return getFieldPathLabels(field, config, parentField, \"funcs\", \"subfields\");\n};\n\nexports.getFuncPathLabels = getFuncPathLabels;\n\nvar getFieldPathLabels = function getFieldPathLabels(field, config) {\n  var parentField = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var fieldsKey = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"fields\";\n  var subfieldsKey = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : \"subfields\";\n  if (!field) return null;\n  var fieldSeparator = config.settings.fieldSeparator;\n  var parts = Array.isArray(field) ? field : field.split(fieldSeparator);\n  var parentParts = parentField ? Array.isArray(parentField) ? parentField : parentField.split(fieldSeparator) : [];\n  return parts.slice(parentParts.length).map(function (_curr, ind, arr) {\n    return arr.slice(0, ind + 1);\n  }).map(function (parts) {\n    return [].concat((0, _toConsumableArray2[\"default\"])(parentParts), (0, _toConsumableArray2[\"default\"])(parts)).join(fieldSeparator);\n  }).map(function (part) {\n    var cnf = (0, _configUtils.getFieldRawConfig)(config, part, fieldsKey, subfieldsKey);\n    return cnf && cnf.label || cnf && (0, _last[\"default\"])(part.split(fieldSeparator));\n  }).filter(function (label) {\n    return label != null;\n  });\n};\n\nexports.getFieldPathLabels = getFieldPathLabels;\n\nvar getValueLabel = function getValueLabel(config, field, operator, delta) {\n  var valueSrc = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  var isSpecialRange = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  var isFuncArg = (0, _typeof2[\"default\"])(field) == \"object\" && !!field.func && !!field.arg;\n  var showLabels = config.settings.showLabels;\n  var fieldConfig = (0, _configUtils.getFieldConfig)(config, field);\n  var fieldWidgetConfig = (0, _configUtils.getFieldWidgetConfig)(config, field, operator, null, valueSrc) || {};\n  var mergedOpConfig = (0, _configUtils.getOperatorConfig)(config, operator, field) || {};\n  var cardinality = isSpecialRange ? 1 : mergedOpConfig.cardinality;\n  var ret = null;\n\n  if (cardinality > 1) {\n    var valueLabels = fieldWidgetConfig.valueLabels || mergedOpConfig.valueLabels;\n    if (valueLabels) ret = valueLabels[delta];\n\n    if (ret && (0, _typeof2[\"default\"])(ret) != \"object\") {\n      ret = {\n        label: ret,\n        placeholder: ret\n      };\n    }\n\n    if (!ret) {\n      ret = {\n        label: config.settings.valueLabel + \" \" + (delta + 1),\n        placeholder: config.settings.valuePlaceholder + \" \" + (delta + 1)\n      };\n    }\n  } else {\n    var label = fieldWidgetConfig.valueLabel;\n    var placeholder = fieldWidgetConfig.valuePlaceholder;\n\n    if (isFuncArg) {\n      if (!label) label = fieldConfig.label || field.arg;\n      if (!placeholder && !showLabels) placeholder = fieldConfig.label || field.arg;\n    }\n\n    ret = {\n      label: label || config.settings.valueLabel,\n      placeholder: placeholder || config.settings.valuePlaceholder\n    };\n  }\n\n  return ret;\n};\n\nexports.getValueLabel = getValueLabel;\n\nfunction _getWidgetsAndSrcsForFieldOp(config, field) {\n  var operator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var valueSrc = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var widgets = [];\n  var valueSrcs = [];\n  if (!field) return {\n    widgets: widgets,\n    valueSrcs: valueSrcs\n  };\n\n  var isFuncArg = (0, _typeof2[\"default\"])(field) == \"object\" && (!!field.func && !!field.arg || field._isFuncArg);\n\n  var fieldConfig = (0, _configUtils.getFieldConfig)(config, field);\n  var opConfig = operator ? config.operators[operator] : null;\n\n  if (fieldConfig && fieldConfig.widgets) {\n    var _loop2 = function _loop2(widget) {\n      var widgetConfig = fieldConfig.widgets[widget]; // if (!config.widgets[widget]) {\n      //   continue;\n      // }\n\n      var widgetValueSrc = config.widgets[widget].valueSrc || \"value\";\n      var canAdd = true;\n\n      if (widget == \"field\") {\n        canAdd = canAdd && filterValueSourcesForField(config, [\"field\"], fieldConfig).length > 0;\n      }\n\n      if (widget == \"func\") {\n        canAdd = canAdd && filterValueSourcesForField(config, [\"func\"], fieldConfig).length > 0;\n      } // If can't check operators, don't add\n      // Func args don't have operators\n\n\n      if (valueSrc == \"value\" && !widgetConfig.operators && !isFuncArg) canAdd = false;\n      if (widgetConfig.operators && operator) canAdd = canAdd && widgetConfig.operators.indexOf(operator) != -1;\n      if (valueSrc && valueSrc != widgetValueSrc && valueSrc != \"const\") canAdd = false;\n      if (opConfig && opConfig.cardinality == 0 && widgetValueSrc != \"value\") canAdd = false;\n\n      if (canAdd) {\n        widgets.push(widget);\n        var canAddValueSrc = fieldConfig.valueSources && fieldConfig.valueSources.indexOf(widgetValueSrc) != -1;\n        if (opConfig && opConfig.valueSources && opConfig.valueSources.indexOf(widgetValueSrc) == -1) canAddValueSrc = false;\n        if (canAddValueSrc && !valueSrcs.find(function (v) {\n          return v == widgetValueSrc;\n        })) valueSrcs.push(widgetValueSrc);\n      }\n    };\n\n    for (var widget in fieldConfig.widgets) {\n      _loop2(widget);\n    }\n  }\n\n  var widgetWeight = function widgetWeight(w) {\n    var wg = 0;\n\n    if (fieldConfig.preferWidgets) {\n      if (fieldConfig.preferWidgets.includes(w)) wg += 10 - fieldConfig.preferWidgets.indexOf(w);\n    } else if (w == fieldConfig.mainWidget) {\n      wg += 100;\n    }\n\n    if (w == \"field\") {\n      wg -= 1;\n    }\n\n    if (w == \"func\") {\n      wg -= 2;\n    }\n\n    return wg;\n  };\n\n  widgets.sort(function (w1, w2) {\n    return widgetWeight(w2) - widgetWeight(w1);\n  });\n  return {\n    widgets: widgets,\n    valueSrcs: valueSrcs\n  };\n}\n\nvar getWidgetsForFieldOp = function getWidgetsForFieldOp(config, field, operator) {\n  var valueSrc = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n  var _getWidgetsAndSrcsFor = _getWidgetsAndSrcsForFieldOp(config, field, operator, valueSrc),\n      widgets = _getWidgetsAndSrcsFor.widgets;\n\n  return widgets;\n};\n\nexports.getWidgetsForFieldOp = getWidgetsForFieldOp;\n\nvar filterValueSourcesForField = function filterValueSourcesForField(config, valueSrcs, fieldDefinition) {\n  if (!fieldDefinition) return valueSrcs;\n  return valueSrcs.filter(function (vs) {\n    var canAdd = true;\n\n    if (vs == \"field\") {\n      if (config._fieldsCntByType) {\n        // tip: LHS field can be used as arg in RHS function\n        var minCnt = fieldDefinition._isFuncArg ? 0 : 1;\n        canAdd = canAdd && config._fieldsCntByType[fieldDefinition.type] > minCnt;\n      }\n    }\n\n    if (vs == \"func\") {\n      if (config._funcsCntByType) canAdd = canAdd && !!config._funcsCntByType[fieldDefinition.type];\n      if (fieldDefinition.funcs) canAdd = canAdd && fieldDefinition.funcs.length > 0;\n    }\n\n    return canAdd;\n  });\n};\n\nexports.filterValueSourcesForField = filterValueSourcesForField;\n\nvar getValueSourcesForFieldOp = function getValueSourcesForFieldOp(config, field, operator) {\n  var fieldDefinition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var leftFieldForFunc = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n\n  var _getWidgetsAndSrcsFor2 = _getWidgetsAndSrcsForFieldOp(config, field, operator, null),\n      valueSrcs = _getWidgetsAndSrcsFor2.valueSrcs;\n\n  var filteredValueSrcs = filterValueSourcesForField(config, valueSrcs, fieldDefinition);\n  return filteredValueSrcs;\n};\n\nexports.getValueSourcesForFieldOp = getValueSourcesForFieldOp;\n\nvar getWidgetForFieldOp = function getWidgetForFieldOp(config, field, operator) {\n  var valueSrc = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n  var _getWidgetsAndSrcsFor3 = _getWidgetsAndSrcsForFieldOp(config, field, operator, valueSrc),\n      widgets = _getWidgetsAndSrcsFor3.widgets;\n\n  var widget = null;\n  if (widgets.length) widget = widgets[0];\n  return widget;\n};\n\nexports.getWidgetForFieldOp = getWidgetForFieldOp;\n\nvar formatFieldName = function formatFieldName(field, config, meta) {\n  var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var fieldDef = (0, _configUtils.getFieldConfig)(config, field) || {};\n  var fieldSeparator = config.settings.fieldSeparator;\n  var fieldParts = Array.isArray(field) ? field : field.split(fieldSeparator);\n  var fieldName = Array.isArray(field) ? field.join(fieldSeparator) : field;\n\n  if (fieldDef.tableName) {\n    // legacy\n    var fieldPartsCopy = (0, _toConsumableArray2[\"default\"])(fieldParts);\n    fieldPartsCopy[0] = fieldDef.tableName;\n    fieldName = fieldPartsCopy.join(fieldSeparator);\n  }\n\n  if (fieldDef.fieldName) {\n    fieldName = fieldDef.fieldName;\n  }\n\n  if (parentField) {\n    var parentFieldDef = (0, _configUtils.getFieldConfig)(config, parentField) || {};\n    var parentFieldName = parentField;\n\n    if (parentFieldDef.fieldName) {\n      parentFieldName = parentFieldDef.fieldName;\n    }\n\n    if (fieldName.indexOf(parentFieldName + fieldSeparator) == 0) {\n      fieldName = fieldName.slice((parentFieldName + fieldSeparator).length);\n    } else {\n      meta.errors.push(\"Can't cut group \".concat(parentFieldName, \" from field \").concat(fieldName));\n    }\n  }\n\n  return fieldName;\n};\n\nexports.formatFieldName = formatFieldName;","map":{"version":3,"sources":["D:/LIMSWFH/LIMSPOSTGRESQL/QuaLISWeb/node_modules/react-awesome-query-builder/lib/utils/ruleUtils.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","getWidgetsForFieldOp","getWidgetForFieldOp","getValueSourcesForFieldOp","getValueLabel","getOperatorsForField","getNewValueForFieldOp","getFuncPathLabels","getFirstOperator","getFirstField","getFieldPathLabels","getFieldPath","formatFieldName","filterValueSourcesForField","_typeof2","_toConsumableArray2","_slicedToArray2","_configUtils","_stuff","_immutable","_validation","_last","selectTypes","config","oldConfig","arguments","length","undefined","current","newField","newOperator","changedField","canFix","currentField","get","currentOperator","currentValue","currentValueSrc","List","currentValueType","currentAsyncListValues","_config$settings","settings","convertableWidgets","clearValueOnChangeField","clearValueOnChangeOp","showErrorMessage","newOperatorConfig","getOperatorConfig","operatorCardinality","defaultValue","cardinality","currentFieldConfig","getFieldConfig","newFieldConfig","canReuseValue","type","includes","i","vs","currentWidget","newWidget","currentValueWidget","newValueWidget","canReuseWidget","firstWidgetConfig","getFieldWidgetConfig","first","valueSources","valueFixes","valueErrors","Array","from","_loop","_i","v","vType","vSrc","isValidSrc","find","isEndValue","asyncListValues","_validateValue","validateValue","_validateValue2","validateError","fixedValue","isValid","_ret","newValue","newValueSrc","newValueType","newValueError","_ignore","size","fieldSettings","validateValues","toJS","filter","jsValues","map","rangeValidateError","push","vt","parentRuleGroupPath","fieldSeparator","parentPathArr","split","parentField","getFieldRawConfig","firstField","key","keysPath","subfields","fields","keys","concat","join","field","fieldConfig","fieldOps","operators","onlyKeys","parts","isArray","_curr","ind","arr","slice","fieldsKey","subfieldsKey","parentParts","part","cnf","label","operator","delta","valueSrc","isSpecialRange","isFuncArg","func","arg","showLabels","fieldWidgetConfig","mergedOpConfig","ret","valueLabels","placeholder","valueLabel","valuePlaceholder","_getWidgetsAndSrcsForFieldOp","widgets","valueSrcs","_isFuncArg","opConfig","_loop2","widget","widgetConfig","widgetValueSrc","canAdd","indexOf","canAddValueSrc","widgetWeight","w","wg","preferWidgets","mainWidget","sort","w1","w2","_getWidgetsAndSrcsFor","fieldDefinition","_fieldsCntByType","minCnt","_funcsCntByType","funcs","leftFieldForFunc","_getWidgetsAndSrcsFor2","filteredValueSrcs","_getWidgetsAndSrcsFor3","meta","fieldDef","fieldParts","fieldName","tableName","fieldPartsCopy","parentFieldDef","parentFieldName","errors"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getWidgetsForFieldOp = exports.getWidgetForFieldOp = exports.getValueSourcesForFieldOp = exports.getValueLabel = exports.getOperatorsForField = exports.getNewValueForFieldOp = exports.getFuncPathLabels = exports.getFirstOperator = exports.getFirstField = exports.getFieldPathLabels = exports.getFieldPath = exports.formatFieldName = exports.filterValueSourcesForField = void 0;\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _configUtils = require(\"./configUtils\");\n\nvar _stuff = require(\"../utils/stuff\");\n\nvar _immutable = _interopRequireDefault(require(\"immutable\"));\n\nvar _validation = require(\"../utils/validation\");\n\nvar _last = _interopRequireDefault(require(\"lodash/last\"));\n\nvar selectTypes = [\"select\", \"multiselect\", \"treeselect\", \"treemultiselect\"];\n/**\n * @param {object} config\n * @param {object} oldConfig\n * @param {Immutable.Map} current\n * @param {string} newField\n * @param {string} newOperator\n * @param {string} changedField\n * @return {object} - {canReuseValue, newValue, newValueSrc, newValueType, newValueError}\n */\n\nvar getNewValueForFieldOp = function getNewValueForFieldOp(config) {\n  var oldConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var current = arguments.length > 2 ? arguments[2] : undefined;\n  var newField = arguments.length > 3 ? arguments[3] : undefined;\n  var newOperator = arguments.length > 4 ? arguments[4] : undefined;\n  var changedField = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n  var canFix = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : true;\n  if (!oldConfig) oldConfig = config;\n  var currentField = current.get(\"field\");\n  var currentOperator = current.get(\"operator\");\n  var currentValue = current.get(\"value\");\n  var currentValueSrc = current.get(\"valueSrc\", new _immutable[\"default\"].List());\n  var currentValueType = current.get(\"valueType\", new _immutable[\"default\"].List());\n  var currentAsyncListValues = current.get(\"asyncListValues\"); //const isValidatingTree = (changedField === null);\n\n  var _config$settings = config.settings,\n      convertableWidgets = _config$settings.convertableWidgets,\n      clearValueOnChangeField = _config$settings.clearValueOnChangeField,\n      clearValueOnChangeOp = _config$settings.clearValueOnChangeOp,\n      showErrorMessage = _config$settings.showErrorMessage; //const currentOperatorConfig = getOperatorConfig(oldConfig, currentOperator, currentField);\n\n  var newOperatorConfig = (0, _configUtils.getOperatorConfig)(config, newOperator, newField); //const currentOperatorCardinality = currentOperator ? defaultValue(currentOperatorConfig.cardinality, 1) : null;\n\n  var operatorCardinality = newOperator ? (0, _stuff.defaultValue)(newOperatorConfig.cardinality, 1) : null;\n  var currentFieldConfig = (0, _configUtils.getFieldConfig)(oldConfig, currentField);\n  var newFieldConfig = (0, _configUtils.getFieldConfig)(config, newField);\n  var canReuseValue = currentField && currentOperator && newOperator && currentValue != undefined && (!changedField || changedField == \"field\" && !clearValueOnChangeField || changedField == \"operator\" && !clearValueOnChangeOp) && currentFieldConfig && newFieldConfig && currentFieldConfig.type == newFieldConfig.type;\n\n  if (canReuseValue && selectTypes.includes(currentFieldConfig.type) && changedField == \"field\") {\n    // different fields of select types has different listValues\n    canReuseValue = false;\n  } // compare old & new widgets\n\n\n  for (var i = 0; i < operatorCardinality; i++) {\n    var vs = currentValueSrc.get(i) || null;\n    var currentWidget = getWidgetForFieldOp(oldConfig, currentField, currentOperator, vs);\n    var newWidget = getWidgetForFieldOp(config, newField, newOperator, vs); // need to also check value widgets if we changed operator and current value source was 'field'\n    // cause for select type op '=' requires single value and op 'in' requires array value\n\n    var currentValueWidget = vs == \"value\" ? currentWidget : getWidgetForFieldOp(oldConfig, currentField, currentOperator, \"value\");\n    var newValueWidget = vs == \"value\" ? newWidget : getWidgetForFieldOp(config, newField, newOperator, \"value\");\n    var canReuseWidget = newValueWidget == currentValueWidget || (convertableWidgets[currentValueWidget] || []).includes(newValueWidget);\n    if (!canReuseWidget) canReuseValue = false;\n  }\n\n  if (currentOperator != newOperator && [currentOperator, newOperator].includes(\"proximity\")) canReuseValue = false;\n  var firstWidgetConfig = (0, _configUtils.getFieldWidgetConfig)(config, newField, newOperator, null, currentValueSrc.first());\n  var valueSources = getValueSourcesForFieldOp(config, newField, newOperator);\n  var valueFixes = {};\n  var valueErrors = Array.from({\n    length: operatorCardinality\n  }, function () {\n    return null;\n  });\n\n  if (canReuseValue) {\n    var _loop = function _loop(_i) {\n      var v = currentValue.get(_i);\n      var vType = currentValueType.get(_i) || null;\n      var vSrc = currentValueSrc.get(_i) || null;\n      var isValidSrc = valueSources.find(function (v) {\n        return v == vSrc;\n      }) != null;\n      if (!isValidSrc && _i > 0 && vSrc == null) isValidSrc = true; // make exception for range widgets (when changing op from '==' to 'between')\n\n      var isEndValue = !canFix;\n      var asyncListValues = currentAsyncListValues;\n\n      var _validateValue = (0, _validation.validateValue)(config, newField, newField, newOperator, v, vType, vSrc, asyncListValues, canFix, isEndValue),\n          _validateValue2 = (0, _slicedToArray2[\"default\"])(_validateValue, 2),\n          validateError = _validateValue2[0],\n          fixedValue = _validateValue2[1];\n\n      var isValid = !validateError;\n\n      if (!isValid && showErrorMessage && changedField != \"field\") {\n        // allow bad value\n        // but not on field change - in that case just drop bad value that can't be reused\n        // ? maybe we should also drop bad value on op change?\n        valueErrors[_i] = validateError;\n      } else if (!isValidSrc || !isValid) {\n        canReuseValue = false;\n        return \"break\";\n      } else if (canFix && fixedValue !== v) {\n        valueFixes[_i] = fixedValue;\n      }\n    };\n\n    for (var _i = 0; _i < operatorCardinality; _i++) {\n      var _ret = _loop(_i);\n\n      if (_ret === \"break\") break;\n    }\n  }\n\n  var newValue = null,\n      newValueSrc = null,\n      newValueType = null,\n      newValueError = null;\n  newValue = new _immutable[\"default\"].List(Array.from({\n    length: operatorCardinality\n  }, function (_ignore, i) {\n    var v = undefined;\n\n    if (canReuseValue) {\n      if (i < currentValue.size) {\n        v = currentValue.get(i);\n\n        if (valueFixes[i] !== undefined) {\n          v = valueFixes[i];\n        }\n      }\n    } else if (operatorCardinality == 1 && (firstWidgetConfig || newFieldConfig)) {\n      if (newFieldConfig.defaultValue !== undefined) v = newFieldConfig.defaultValue;else if (newFieldConfig.fieldSettings && newFieldConfig.fieldSettings.defaultValue !== undefined) v = newFieldConfig.fieldSettings.defaultValue;else if (firstWidgetConfig.defaultValue !== undefined) v = firstWidgetConfig.defaultValue;\n    }\n\n    return v;\n  }));\n  newValueSrc = new _immutable[\"default\"].List(Array.from({\n    length: operatorCardinality\n  }, function (_ignore, i) {\n    var vs = null;\n\n    if (canReuseValue) {\n      if (i < currentValueSrc.size) vs = currentValueSrc.get(i);\n    } else if (valueSources.length == 1) {\n      vs = valueSources[0];\n    } else if (valueSources.length > 1) {\n      vs = valueSources[0];\n    }\n\n    return vs;\n  }));\n\n  if (showErrorMessage) {\n    if (newOperatorConfig && newOperatorConfig.validateValues && newValueSrc.toJS().filter(function (vs) {\n      return vs == \"value\" || vs == null;\n    }).length == operatorCardinality) {\n      // last element in `valueError` list is for range validation error\n      var jsValues = firstWidgetConfig && firstWidgetConfig.toJS ? newValue.toJS().map(function (v) {\n        return firstWidgetConfig.toJS(v, firstWidgetConfig);\n      }) : newValue.toJS();\n      var rangeValidateError = newOperatorConfig.validateValues(jsValues);\n\n      if (showErrorMessage) {\n        valueErrors.push(rangeValidateError);\n      }\n    }\n\n    newValueError = new _immutable[\"default\"].List(valueErrors);\n  }\n\n  newValueType = new _immutable[\"default\"].List(Array.from({\n    length: operatorCardinality\n  }, function (_ignore, i) {\n    var vt = null;\n\n    if (canReuseValue) {\n      if (i < currentValueType.size) vt = currentValueType.get(i);\n    } else if (operatorCardinality == 1 && firstWidgetConfig && firstWidgetConfig.type !== undefined) {\n      vt = firstWidgetConfig.type;\n    } else if (operatorCardinality == 1 && newFieldConfig && newFieldConfig.type !== undefined) {\n      vt = newFieldConfig.type == \"!group\" ? \"number\" : newFieldConfig.type;\n    }\n\n    return vt;\n  }));\n  return {\n    canReuseValue: canReuseValue,\n    newValue: newValue,\n    newValueSrc: newValueSrc,\n    newValueType: newValueType,\n    newValueError: newValueError,\n    operatorCardinality: operatorCardinality\n  };\n};\n\nexports.getNewValueForFieldOp = getNewValueForFieldOp;\n\nvar getFirstField = function getFirstField(config) {\n  var parentRuleGroupPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var fieldSeparator = config.settings.fieldSeparator;\n  var parentPathArr = typeof parentRuleGroupPath == \"string\" ? parentRuleGroupPath.split(fieldSeparator) : parentRuleGroupPath;\n  var parentField = parentRuleGroupPath ? (0, _configUtils.getFieldRawConfig)(config, parentRuleGroupPath) : config;\n  var firstField = parentField,\n      key = null,\n      keysPath = [];\n\n  do {\n    var subfields = firstField === config ? config.fields : firstField.subfields;\n\n    if (!subfields || !Object.keys(subfields).length) {\n      firstField = key = null;\n      break;\n    }\n\n    key = Object.keys(subfields)[0];\n    keysPath.push(key);\n    firstField = subfields[key];\n  } while (firstField.type == \"!struct\" || firstField.type == \"!group\");\n\n  return (parentPathArr || []).concat(keysPath).join(fieldSeparator);\n};\n\nexports.getFirstField = getFirstField;\n\nvar getOperatorsForField = function getOperatorsForField(config, field) {\n  var fieldConfig = (0, _configUtils.getFieldConfig)(config, field);\n  var fieldOps = fieldConfig ? fieldConfig.operators : [];\n  return fieldOps;\n};\n\nexports.getOperatorsForField = getOperatorsForField;\n\nvar getFirstOperator = function getFirstOperator(config, field) {\n  var fieldOps = getOperatorsForField(config, field);\n  return fieldOps ? fieldOps[0] : null;\n};\n\nexports.getFirstOperator = getFirstOperator;\n\nvar getFieldPath = function getFieldPath(field, config) {\n  var onlyKeys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  if (!field) return null;\n  var fieldSeparator = config.settings.fieldSeparator;\n  var parts = Array.isArray(field) ? field : field.split(fieldSeparator);\n  if (onlyKeys) return parts;else return parts.map(function (_curr, ind, arr) {\n    return arr.slice(0, ind + 1);\n  }).map(function (parts) {\n    return parts.join(fieldSeparator);\n  });\n};\n\nexports.getFieldPath = getFieldPath;\n\nvar getFuncPathLabels = function getFuncPathLabels(field, config) {\n  var parentField = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  return getFieldPathLabels(field, config, parentField, \"funcs\", \"subfields\");\n};\n\nexports.getFuncPathLabels = getFuncPathLabels;\n\nvar getFieldPathLabels = function getFieldPathLabels(field, config) {\n  var parentField = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var fieldsKey = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"fields\";\n  var subfieldsKey = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : \"subfields\";\n  if (!field) return null;\n  var fieldSeparator = config.settings.fieldSeparator;\n  var parts = Array.isArray(field) ? field : field.split(fieldSeparator);\n  var parentParts = parentField ? Array.isArray(parentField) ? parentField : parentField.split(fieldSeparator) : [];\n  return parts.slice(parentParts.length).map(function (_curr, ind, arr) {\n    return arr.slice(0, ind + 1);\n  }).map(function (parts) {\n    return [].concat((0, _toConsumableArray2[\"default\"])(parentParts), (0, _toConsumableArray2[\"default\"])(parts)).join(fieldSeparator);\n  }).map(function (part) {\n    var cnf = (0, _configUtils.getFieldRawConfig)(config, part, fieldsKey, subfieldsKey);\n    return cnf && cnf.label || cnf && (0, _last[\"default\"])(part.split(fieldSeparator));\n  }).filter(function (label) {\n    return label != null;\n  });\n};\n\nexports.getFieldPathLabels = getFieldPathLabels;\n\nvar getValueLabel = function getValueLabel(config, field, operator, delta) {\n  var valueSrc = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  var isSpecialRange = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  var isFuncArg = (0, _typeof2[\"default\"])(field) == \"object\" && !!field.func && !!field.arg;\n  var showLabels = config.settings.showLabels;\n  var fieldConfig = (0, _configUtils.getFieldConfig)(config, field);\n  var fieldWidgetConfig = (0, _configUtils.getFieldWidgetConfig)(config, field, operator, null, valueSrc) || {};\n  var mergedOpConfig = (0, _configUtils.getOperatorConfig)(config, operator, field) || {};\n  var cardinality = isSpecialRange ? 1 : mergedOpConfig.cardinality;\n  var ret = null;\n\n  if (cardinality > 1) {\n    var valueLabels = fieldWidgetConfig.valueLabels || mergedOpConfig.valueLabels;\n    if (valueLabels) ret = valueLabels[delta];\n\n    if (ret && (0, _typeof2[\"default\"])(ret) != \"object\") {\n      ret = {\n        label: ret,\n        placeholder: ret\n      };\n    }\n\n    if (!ret) {\n      ret = {\n        label: config.settings.valueLabel + \" \" + (delta + 1),\n        placeholder: config.settings.valuePlaceholder + \" \" + (delta + 1)\n      };\n    }\n  } else {\n    var label = fieldWidgetConfig.valueLabel;\n    var placeholder = fieldWidgetConfig.valuePlaceholder;\n\n    if (isFuncArg) {\n      if (!label) label = fieldConfig.label || field.arg;\n      if (!placeholder && !showLabels) placeholder = fieldConfig.label || field.arg;\n    }\n\n    ret = {\n      label: label || config.settings.valueLabel,\n      placeholder: placeholder || config.settings.valuePlaceholder\n    };\n  }\n\n  return ret;\n};\n\nexports.getValueLabel = getValueLabel;\n\nfunction _getWidgetsAndSrcsForFieldOp(config, field) {\n  var operator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var valueSrc = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var widgets = [];\n  var valueSrcs = [];\n  if (!field) return {\n    widgets: widgets,\n    valueSrcs: valueSrcs\n  };\n\n  var isFuncArg = (0, _typeof2[\"default\"])(field) == \"object\" && (!!field.func && !!field.arg || field._isFuncArg);\n\n  var fieldConfig = (0, _configUtils.getFieldConfig)(config, field);\n  var opConfig = operator ? config.operators[operator] : null;\n\n  if (fieldConfig && fieldConfig.widgets) {\n    var _loop2 = function _loop2(widget) {\n      var widgetConfig = fieldConfig.widgets[widget]; // if (!config.widgets[widget]) {\n      //   continue;\n      // }\n\n      var widgetValueSrc = config.widgets[widget].valueSrc || \"value\";\n      var canAdd = true;\n\n      if (widget == \"field\") {\n        canAdd = canAdd && filterValueSourcesForField(config, [\"field\"], fieldConfig).length > 0;\n      }\n\n      if (widget == \"func\") {\n        canAdd = canAdd && filterValueSourcesForField(config, [\"func\"], fieldConfig).length > 0;\n      } // If can't check operators, don't add\n      // Func args don't have operators\n\n\n      if (valueSrc == \"value\" && !widgetConfig.operators && !isFuncArg) canAdd = false;\n      if (widgetConfig.operators && operator) canAdd = canAdd && widgetConfig.operators.indexOf(operator) != -1;\n      if (valueSrc && valueSrc != widgetValueSrc && valueSrc != \"const\") canAdd = false;\n      if (opConfig && opConfig.cardinality == 0 && widgetValueSrc != \"value\") canAdd = false;\n\n      if (canAdd) {\n        widgets.push(widget);\n        var canAddValueSrc = fieldConfig.valueSources && fieldConfig.valueSources.indexOf(widgetValueSrc) != -1;\n        if (opConfig && opConfig.valueSources && opConfig.valueSources.indexOf(widgetValueSrc) == -1) canAddValueSrc = false;\n        if (canAddValueSrc && !valueSrcs.find(function (v) {\n          return v == widgetValueSrc;\n        })) valueSrcs.push(widgetValueSrc);\n      }\n    };\n\n    for (var widget in fieldConfig.widgets) {\n      _loop2(widget);\n    }\n  }\n\n  var widgetWeight = function widgetWeight(w) {\n    var wg = 0;\n\n    if (fieldConfig.preferWidgets) {\n      if (fieldConfig.preferWidgets.includes(w)) wg += 10 - fieldConfig.preferWidgets.indexOf(w);\n    } else if (w == fieldConfig.mainWidget) {\n      wg += 100;\n    }\n\n    if (w == \"field\") {\n      wg -= 1;\n    }\n\n    if (w == \"func\") {\n      wg -= 2;\n    }\n\n    return wg;\n  };\n\n  widgets.sort(function (w1, w2) {\n    return widgetWeight(w2) - widgetWeight(w1);\n  });\n  return {\n    widgets: widgets,\n    valueSrcs: valueSrcs\n  };\n}\n\nvar getWidgetsForFieldOp = function getWidgetsForFieldOp(config, field, operator) {\n  var valueSrc = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n  var _getWidgetsAndSrcsFor = _getWidgetsAndSrcsForFieldOp(config, field, operator, valueSrc),\n      widgets = _getWidgetsAndSrcsFor.widgets;\n\n  return widgets;\n};\n\nexports.getWidgetsForFieldOp = getWidgetsForFieldOp;\n\nvar filterValueSourcesForField = function filterValueSourcesForField(config, valueSrcs, fieldDefinition) {\n  if (!fieldDefinition) return valueSrcs;\n  return valueSrcs.filter(function (vs) {\n    var canAdd = true;\n\n    if (vs == \"field\") {\n      if (config._fieldsCntByType) {\n        // tip: LHS field can be used as arg in RHS function\n        var minCnt = fieldDefinition._isFuncArg ? 0 : 1;\n        canAdd = canAdd && config._fieldsCntByType[fieldDefinition.type] > minCnt;\n      }\n    }\n\n    if (vs == \"func\") {\n      if (config._funcsCntByType) canAdd = canAdd && !!config._funcsCntByType[fieldDefinition.type];\n      if (fieldDefinition.funcs) canAdd = canAdd && fieldDefinition.funcs.length > 0;\n    }\n\n    return canAdd;\n  });\n};\n\nexports.filterValueSourcesForField = filterValueSourcesForField;\n\nvar getValueSourcesForFieldOp = function getValueSourcesForFieldOp(config, field, operator) {\n  var fieldDefinition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var leftFieldForFunc = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n\n  var _getWidgetsAndSrcsFor2 = _getWidgetsAndSrcsForFieldOp(config, field, operator, null),\n      valueSrcs = _getWidgetsAndSrcsFor2.valueSrcs;\n\n  var filteredValueSrcs = filterValueSourcesForField(config, valueSrcs, fieldDefinition);\n  return filteredValueSrcs;\n};\n\nexports.getValueSourcesForFieldOp = getValueSourcesForFieldOp;\n\nvar getWidgetForFieldOp = function getWidgetForFieldOp(config, field, operator) {\n  var valueSrc = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n  var _getWidgetsAndSrcsFor3 = _getWidgetsAndSrcsForFieldOp(config, field, operator, valueSrc),\n      widgets = _getWidgetsAndSrcsFor3.widgets;\n\n  var widget = null;\n  if (widgets.length) widget = widgets[0];\n  return widget;\n};\n\nexports.getWidgetForFieldOp = getWidgetForFieldOp;\n\nvar formatFieldName = function formatFieldName(field, config, meta) {\n  var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var fieldDef = (0, _configUtils.getFieldConfig)(config, field) || {};\n  var fieldSeparator = config.settings.fieldSeparator;\n  var fieldParts = Array.isArray(field) ? field : field.split(fieldSeparator);\n  var fieldName = Array.isArray(field) ? field.join(fieldSeparator) : field;\n\n  if (fieldDef.tableName) {\n    // legacy\n    var fieldPartsCopy = (0, _toConsumableArray2[\"default\"])(fieldParts);\n    fieldPartsCopy[0] = fieldDef.tableName;\n    fieldName = fieldPartsCopy.join(fieldSeparator);\n  }\n\n  if (fieldDef.fieldName) {\n    fieldName = fieldDef.fieldName;\n  }\n\n  if (parentField) {\n    var parentFieldDef = (0, _configUtils.getFieldConfig)(config, parentField) || {};\n    var parentFieldName = parentField;\n\n    if (parentFieldDef.fieldName) {\n      parentFieldName = parentFieldDef.fieldName;\n    }\n\n    if (fieldName.indexOf(parentFieldName + fieldSeparator) == 0) {\n      fieldName = fieldName.slice((parentFieldName + fieldSeparator).length);\n    } else {\n      meta.errors.push(\"Can't cut group \".concat(parentFieldName, \" from field \").concat(fieldName));\n    }\n  }\n\n  return fieldName;\n};\n\nexports.formatFieldName = formatFieldName;"]},"metadata":{},"sourceType":"script"}