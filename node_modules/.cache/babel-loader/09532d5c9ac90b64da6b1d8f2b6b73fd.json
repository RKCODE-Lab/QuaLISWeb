{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport { changeStylesString } from './utils';\nimport { ReplaceAroundStep } from 'prosemirror-transform';\nimport { Fragment, Slice } from 'prosemirror-model';\nimport { NodeSelection } from 'prosemirror-state';\n/**\n * @hidden\n */\n\nvar canChangeType = function canChangeType(stateDoc, pos, type) {\n  var $pos = stateDoc.resolve(pos),\n      index = $pos.index();\n  return $pos.parent.canReplaceWith(index, index + 1, type);\n};\n/**\n * Changes the type or the attributes of the passed node.\n *\n * @example\n * See `cleanTextBlockFormatting` or `formatBlockElements` function.\n */\n\n\nexport var changeTextBlock = function changeTextBlock(tr, node, nodeType, attrs) {\n  if (!nodeType.isTextblock) {\n    return false;\n  }\n\n  var ranges = tr.selection.ranges;\n  ranges.forEach(function (range) {\n    var mapFrom = tr.steps.length;\n    var from = range.$from.pos;\n    var to = range.$to.pos;\n    tr.doc.nodesBetween(from, to, function (currNode, pos) {\n      if (currNode.eq(node) && currNode.isTextblock && !currNode.hasMarkup(nodeType, attrs) && canChangeType(tr.doc, tr.mapping.slice(mapFrom).map(pos), nodeType)) {\n        // Ensure all markup that isn't allowed in the new node type is cleared\n        tr.clearIncompatible(tr.mapping.slice(mapFrom).map(pos, 1), nodeType);\n        var mapping = tr.mapping.slice(mapFrom);\n        var startM = mapping.map(pos, 1),\n            endM = mapping.map(pos + currNode.nodeSize, 1);\n        var slice = new Slice(Fragment.from(nodeType.create(attrs, null, currNode.marks)), 0, 0);\n        tr.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1, slice, 1, true));\n        return false; // this will skip the node children\n      }\n    });\n  });\n};\n/**\n * Traverses the selection and returns the block nodes in it.\n *\n * @example\n * See `cleanTextBlockFormatting` function.\n */\n\nexport var blockNodes = function blockNodes(state, options) {\n  if (options === void 0) {\n    options = {\n      blocksInSelection: false\n    };\n  }\n\n  var doc = state.doc,\n      selection = state.selection;\n  var $from = selection.$from,\n      ranges = selection.ranges;\n  var blocksInSelection = options.blocksInSelection;\n  var result = [];\n  var selNode = selection instanceof NodeSelection ? selection.node : undefined;\n\n  if (selNode) {\n    if (selNode.isBlock) {\n      result.push(selNode);\n      selNode.nodesBetween(0, selNode.content.size, function (node) {\n        if (node.isBlock) {\n          result.push(node);\n        }\n      });\n    } else if (!blocksInSelection && $from.parent && $from.parent.isBlock) {\n      result.push($from.parent);\n    }\n  } else {\n    ranges.forEach(function (range) {\n      var from = range.$from.pos;\n      var to = range.$to.pos;\n      doc.nodesBetween(from, to, function (node, pos, _parent, _index) {\n        if (node.isBlock && (!blocksInSelection || pos >= from && pos + node.content.size + 2 <= to)) {\n          result.push(node);\n        }\n      });\n    });\n  }\n\n  return result;\n};\nexport var formatBlockElements = function formatBlockElements(value, commandName) {\n  return function (state, dispatch) {\n    var blocks = blockNodes(state);\n    var nodes = state.schema.nodes;\n    var tr = state.tr;\n    tr.setMeta('commandName', commandName);\n    tr.setMeta('args', {\n      value: value\n    });\n    blocks.forEach(function (node) {\n      if (node.type.isTextblock) {\n        if (value === 'p') {\n          var _a = node.attrs,\n              level = _a.level,\n              attrs = tslib_1.__rest(_a, [\"level\"]);\n\n          changeTextBlock(tr, node, nodes.paragraph, attrs);\n        } else if (/^h[1-6]$/i.test(value)) {\n          var level = parseInt(value.substr(1), 10);\n          changeTextBlock(tr, node, nodes.heading, tslib_1.__assign({}, node.attrs, {\n            level: level\n          }));\n        } else if (value === 'blockquote') {\n          var _b = node.attrs,\n              level = _b.level,\n              attrs = tslib_1.__rest(_b, [\"level\"]);\n\n          changeTextBlock(tr, node, nodes.blockquote, attrs);\n        }\n      }\n    });\n    var result = tr.docChanged;\n\n    if (result) {\n      dispatch(tr.scrollIntoView());\n    }\n\n    return result;\n  };\n};\n/**\n * Removes the style and class attributes of text block elements.\n * Requires to dispatch the transaction.\n *\n * @example\n * See `cleanFormatting` function.\n */\n\nexport var cleanTextBlockFormatting = function cleanTextBlockFormatting(tr, options) {\n  if (options === void 0) {\n    options = {\n      blocksInSelection: true\n    };\n  }\n\n  var doc = tr.doc,\n      selection = tr.selection;\n  var blocksInSelection = options.blocksInSelection,\n      blockNodeType = options.blockNodeType;\n  var nodes = blockNodes({\n    doc: doc,\n    selection: selection\n  }, {\n    blocksInSelection: blocksInSelection\n  });\n  var textBlocks = nodes.filter(function (node) {\n    return node.isTextblock;\n  });\n  textBlocks.forEach(function (node) {\n    var _a = node.attrs || {},\n        _b = _a.style,\n        style = _b === void 0 ? '' : _b,\n        _c = _a.class,\n        className = _c === void 0 ? '' : _c,\n        attrs = tslib_1.__rest(_a, [\"style\", \"class\"]);\n\n    var nodeType = blockNodeType || node.type;\n\n    if (style || className || nodeType !== node.type) {\n      changeTextBlock(tr, node, nodeType, attrs);\n    }\n  });\n};\nexport var getBlockFormats = function getBlockFormats(state) {\n  var blocks = blockNodes(state);\n  var nodes = state.schema.nodes;\n  var result = [];\n  blocks.forEach(function (node) {\n    if (node.type === nodes.paragraph) {\n      result.push('p');\n    } else if (node.type === nodes.heading) {\n      result.push(\"h\" + node.attrs.level);\n    } else if (node.type === nodes.blockquote) {\n      // In case the blockquote can have inline content.\n      // Will be removed once a blockquote command is implemented.\n      result.push('blockquote');\n    }\n  });\n  return result;\n};\nexport var addStyles = function addStyles(node, stylesToApply) {\n  var currentStyles = node.attrs.style,\n      changedStyleResult,\n      toChange;\n\n  if (currentStyles) {\n    stylesToApply.forEach(function (style) {\n      toChange = {\n        style: style.name,\n        value: /^.+$/,\n        newValue: style.value\n      };\n      changedStyleResult = changeStylesString(currentStyles, toChange);\n      currentStyles = changedStyleResult.changed ? changedStyleResult.style : currentStyles;\n    });\n  }\n\n  var reducer = function reducer(acc, curr) {\n    return (acc && curr.value ? acc + ' ' : '') + curr.value ? curr.name + \": \" + curr.value + \";\" : '';\n  };\n\n  currentStyles = currentStyles || stylesToApply.reduce(reducer, '');\n  return Object.assign({}, node.attrs, {\n    style: currentStyles || null\n  });\n};\nexport var hasNode = function hasNode(state, nodeType) {\n  var _a = state.selection,\n      from = _a.from,\n      to = _a.to;\n  var result = false;\n  state.doc.nodesBetween(from, to, function (node) {\n    result = result || node.type === nodeType;\n    return !result;\n  });\n  return result;\n};\nexport var parentBlockFormat = function parentBlockFormat(state) {\n  var formats = getBlockFormats(state);\n  return new Set(formats).size === 1 ? formats[0] : null;\n};\n/**\n * **Deprecated.** Use `parentBlockFormat` function instead.\n */\n\nexport var activeNode = function activeNode(state) {\n  return {\n    tag: parentBlockFormat(state) || ''\n  };\n};","map":{"version":3,"sources":["D:/LIMSWFH/LIMSPOSTGRESQL/QuaLISWeb/node_modules/@progress/kendo-editor-common/dist/es/blockNode.js"],"names":["tslib_1","changeStylesString","ReplaceAroundStep","Fragment","Slice","NodeSelection","canChangeType","stateDoc","pos","type","$pos","resolve","index","parent","canReplaceWith","changeTextBlock","tr","node","nodeType","attrs","isTextblock","ranges","selection","forEach","range","mapFrom","steps","length","from","$from","to","$to","doc","nodesBetween","currNode","eq","hasMarkup","mapping","slice","map","clearIncompatible","startM","endM","nodeSize","create","marks","step","blockNodes","state","options","blocksInSelection","result","selNode","undefined","isBlock","push","content","size","_parent","_index","formatBlockElements","value","commandName","dispatch","blocks","nodes","schema","setMeta","_a","level","__rest","paragraph","test","parseInt","substr","heading","__assign","_b","blockquote","docChanged","scrollIntoView","cleanTextBlockFormatting","blockNodeType","textBlocks","filter","style","_c","class","className","getBlockFormats","addStyles","stylesToApply","currentStyles","changedStyleResult","toChange","name","newValue","changed","reducer","acc","curr","reduce","Object","assign","hasNode","parentBlockFormat","formats","Set","activeNode","tag"],"mappings":"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","sourcesContent":["import * as tslib_1 from \"tslib\";\nimport { changeStylesString } from './utils';\nimport { ReplaceAroundStep } from 'prosemirror-transform';\nimport { Fragment, Slice } from 'prosemirror-model';\nimport { NodeSelection } from 'prosemirror-state';\n/**\n * @hidden\n */\nvar canChangeType = function (stateDoc, pos, type) {\n    var $pos = stateDoc.resolve(pos), index = $pos.index();\n    return $pos.parent.canReplaceWith(index, index + 1, type);\n};\n/**\n * Changes the type or the attributes of the passed node.\n *\n * @example\n * See `cleanTextBlockFormatting` or `formatBlockElements` function.\n */\nexport var changeTextBlock = function (tr, node, nodeType, attrs) {\n    if (!nodeType.isTextblock) {\n        return false;\n    }\n    var ranges = tr.selection.ranges;\n    ranges.forEach(function (range) {\n        var mapFrom = tr.steps.length;\n        var from = range.$from.pos;\n        var to = range.$to.pos;\n        tr.doc.nodesBetween(from, to, function (currNode, pos) {\n            if (currNode.eq(node) &&\n                currNode.isTextblock &&\n                !currNode.hasMarkup(nodeType, attrs) &&\n                canChangeType(tr.doc, tr.mapping.slice(mapFrom).map(pos), nodeType)) {\n                // Ensure all markup that isn't allowed in the new node type is cleared\n                tr.clearIncompatible(tr.mapping.slice(mapFrom).map(pos, 1), nodeType);\n                var mapping = tr.mapping.slice(mapFrom);\n                var startM = mapping.map(pos, 1), endM = mapping.map(pos + currNode.nodeSize, 1);\n                var slice = new Slice(Fragment.from(nodeType.create(attrs, null, currNode.marks)), 0, 0);\n                tr.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1, slice, 1, true));\n                return false; // this will skip the node children\n            }\n        });\n    });\n};\n/**\n * Traverses the selection and returns the block nodes in it.\n *\n * @example\n * See `cleanTextBlockFormatting` function.\n */\nexport var blockNodes = function (state, options) {\n    if (options === void 0) { options = { blocksInSelection: false }; }\n    var doc = state.doc, selection = state.selection;\n    var $from = selection.$from, ranges = selection.ranges;\n    var blocksInSelection = options.blocksInSelection;\n    var result = [];\n    var selNode = selection instanceof NodeSelection ? selection.node : undefined;\n    if (selNode) {\n        if (selNode.isBlock) {\n            result.push(selNode);\n            selNode.nodesBetween(0, selNode.content.size, function (node) {\n                if (node.isBlock) {\n                    result.push(node);\n                }\n            });\n        }\n        else if (!blocksInSelection && $from.parent && $from.parent.isBlock) {\n            result.push($from.parent);\n        }\n    }\n    else {\n        ranges.forEach(function (range) {\n            var from = range.$from.pos;\n            var to = range.$to.pos;\n            doc.nodesBetween(from, to, function (node, pos, _parent, _index) {\n                if (node.isBlock && (!blocksInSelection || (pos >= from && pos + node.content.size + 2 <= to))) {\n                    result.push(node);\n                }\n            });\n        });\n    }\n    return result;\n};\nexport var formatBlockElements = function (value, commandName) {\n    return function (state, dispatch) {\n        var blocks = blockNodes(state);\n        var nodes = state.schema.nodes;\n        var tr = state.tr;\n        tr.setMeta('commandName', commandName);\n        tr.setMeta('args', { value: value });\n        blocks.forEach(function (node) {\n            if (node.type.isTextblock) {\n                if (value === 'p') {\n                    var _a = node.attrs, level = _a.level, attrs = tslib_1.__rest(_a, [\"level\"]);\n                    changeTextBlock(tr, node, nodes.paragraph, attrs);\n                }\n                else if (/^h[1-6]$/i.test(value)) {\n                    var level = parseInt(value.substr(1), 10);\n                    changeTextBlock(tr, node, nodes.heading, tslib_1.__assign({}, node.attrs, { level: level }));\n                }\n                else if (value === 'blockquote') {\n                    var _b = node.attrs, level = _b.level, attrs = tslib_1.__rest(_b, [\"level\"]);\n                    changeTextBlock(tr, node, nodes.blockquote, attrs);\n                }\n            }\n        });\n        var result = tr.docChanged;\n        if (result) {\n            dispatch(tr.scrollIntoView());\n        }\n        return result;\n    };\n};\n/**\n * Removes the style and class attributes of text block elements.\n * Requires to dispatch the transaction.\n *\n * @example\n * See `cleanFormatting` function.\n */\nexport var cleanTextBlockFormatting = function (tr, options) {\n    if (options === void 0) { options = { blocksInSelection: true }; }\n    var doc = tr.doc, selection = tr.selection;\n    var blocksInSelection = options.blocksInSelection, blockNodeType = options.blockNodeType;\n    var nodes = blockNodes({ doc: doc, selection: selection }, { blocksInSelection: blocksInSelection });\n    var textBlocks = nodes.filter(function (node) { return node.isTextblock; });\n    textBlocks.forEach(function (node) {\n        var _a = node.attrs || {}, _b = _a.style, style = _b === void 0 ? '' : _b, _c = _a.class, className = _c === void 0 ? '' : _c, attrs = tslib_1.__rest(_a, [\"style\", \"class\"]);\n        var nodeType = blockNodeType || node.type;\n        if (style || className || nodeType !== node.type) {\n            changeTextBlock(tr, node, nodeType, attrs);\n        }\n    });\n};\nexport var getBlockFormats = function (state) {\n    var blocks = blockNodes(state);\n    var nodes = state.schema.nodes;\n    var result = [];\n    blocks.forEach(function (node) {\n        if (node.type === nodes.paragraph) {\n            result.push('p');\n        }\n        else if (node.type === nodes.heading) {\n            result.push(\"h\" + node.attrs.level);\n        }\n        else if (node.type === nodes.blockquote) {\n            // In case the blockquote can have inline content.\n            // Will be removed once a blockquote command is implemented.\n            result.push('blockquote');\n        }\n    });\n    return result;\n};\nexport var addStyles = function (node, stylesToApply) {\n    var currentStyles = node.attrs.style, changedStyleResult, toChange;\n    if (currentStyles) {\n        stylesToApply.forEach(function (style) {\n            toChange = { style: style.name, value: /^.+$/, newValue: style.value };\n            changedStyleResult = changeStylesString(currentStyles, toChange);\n            currentStyles = changedStyleResult.changed ? changedStyleResult.style : currentStyles;\n        });\n    }\n    var reducer = function (acc, curr) { return ((acc && curr.value ? acc + ' ' : '') + curr.value ? curr.name + \": \" + curr.value + \";\" : ''); };\n    currentStyles = currentStyles || stylesToApply.reduce(reducer, '');\n    return Object.assign({}, node.attrs, { style: currentStyles || null });\n};\nexport var hasNode = function (state, nodeType) {\n    var _a = state.selection, from = _a.from, to = _a.to;\n    var result = false;\n    state.doc.nodesBetween(from, to, function (node) {\n        result = result || node.type === nodeType;\n        return !result;\n    });\n    return result;\n};\nexport var parentBlockFormat = function (state) {\n    var formats = getBlockFormats(state);\n    return new Set(formats).size === 1 ? formats[0] : null;\n};\n/**\n * **Deprecated.** Use `parentBlockFormat` function instead.\n */\nexport var activeNode = function (state) {\n    return { tag: parentBlockFormat(state) || '' };\n};\n"]},"metadata":{},"sourceType":"module"}