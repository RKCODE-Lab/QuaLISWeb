{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.spelFormat = exports._spelFormat = void 0;\n\nvar _toArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toArray\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _configUtils = require(\"../utils/configUtils\");\n\nvar _ruleUtils = require(\"../utils/ruleUtils\");\n\nvar _omit = _interopRequireDefault(require(\"lodash/omit\"));\n\nvar _pick = _interopRequireDefault(require(\"lodash/pick\"));\n\nvar _stuff = require(\"../utils/stuff\");\n\nvar _defaultUtils = require(\"../utils/defaultUtils\");\n\nvar _default = require(\"../config/default\");\n\nvar _funcUtils = require(\"../utils/funcUtils\");\n\nvar _immutable = require(\"immutable\");\n\nvar _export = require(\"../utils/export\");\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      (0, _defineProperty2[\"default\"])(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nvar spelFormat = function spelFormat(tree, config) {\n  return _spelFormat(tree, config, false);\n};\n\nexports.spelFormat = spelFormat;\n\nvar _spelFormat = function _spelFormat(tree, config) {\n  var returnErrors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true; //meta is mutable\n\n  var meta = {\n    errors: []\n  };\n  var res = formatItem(tree, config, meta, null);\n\n  if (returnErrors) {\n    return [res, meta.errors];\n  } else {\n    if (meta.errors.length) console.warn(\"Errors while exporting to SpEL:\", meta.errors);\n    return res;\n  }\n};\n\nexports._spelFormat = _spelFormat;\n\nvar formatItem = function formatItem(item, config, meta) {\n  var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  if (!item) return undefined;\n  var type = item.get(\"type\");\n\n  if (type === \"group\" || type === \"rule_group\") {\n    return formatGroup(item, config, meta, parentField);\n  } else if (type === \"rule\") {\n    return formatRule(item, config, meta, parentField);\n  } else if (type == \"switch_group\") {\n    return formatSwitch(item, config, meta, parentField);\n  } else if (type == \"case_group\") {\n    return formatCase(item, config, meta, parentField);\n  }\n\n  return undefined;\n};\n\nvar formatCase = function formatCase(item, config, meta) {\n  var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var type = item.get(\"type\");\n\n  if (type != \"case_group\") {\n    meta.errors.push(\"Unexpected child of type \".concat(type, \" inside switch\"));\n    return undefined;\n  }\n\n  var properties = item.get(\"properties\") || new _immutable.Map();\n\n  var _formatItemValue = formatItemValue(config, properties, meta, null, parentField, \"!case_value\"),\n      _formatItemValue2 = (0, _slicedToArray2[\"default\"])(_formatItemValue, 3),\n      formattedValue = _formatItemValue2[0],\n      valueSrc = _formatItemValue2[1],\n      valueType = _formatItemValue2[2];\n\n  var cond = formatGroup(item, config, meta, parentField);\n  return [cond, formattedValue];\n};\n\nvar formatSwitch = function formatSwitch(item, config, meta) {\n  var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var properties = item.get(\"properties\") || new _immutable.Map();\n  var children = item.get(\"children1\");\n  if (!children) return undefined;\n  var cases = children.map(function (currentChild) {\n    return formatCase(currentChild, config, meta, null);\n  }).filter(function (currentChild) {\n    return typeof currentChild !== \"undefined\";\n  }).toArray();\n  if (!cases.length) return undefined;\n\n  if (cases.length == 1 && !cases[0][0]) {\n    // only 1 case without condition\n    return cases[0][1];\n  }\n\n  var filteredCases = [];\n\n  for (var i = 0; i < cases.length; i++) {\n    if (i != cases.length - 1 && !cases[i][0]) {\n      meta.errors.push(\"No condition for case \".concat(i));\n    } else {\n      filteredCases.push(cases[i]);\n\n      if (i == cases.length - 1 && cases[i][0]) {\n        // no default - add null as default\n        filteredCases.push([undefined, null]);\n      }\n    }\n  }\n\n  var left = \"\",\n      right = \"\";\n\n  for (var _i = 0; _i < filteredCases.length; _i++) {\n    var _filteredCases$_i = (0, _slicedToArray2[\"default\"])(filteredCases[_i], 2),\n        cond = _filteredCases$_i[0],\n        value = _filteredCases$_i[1];\n\n    if (value == undefined) value = \"null\";\n    if (cond == undefined) cond = \"true\";\n\n    if (_i != filteredCases.length - 1) {\n      left += \"(\".concat(cond, \" ? \").concat(value, \" : \");\n      right += \")\";\n    } else {\n      left += \"\".concat(value);\n    }\n  }\n\n  return left + right;\n};\n\nvar formatGroup = function formatGroup(item, config, meta) {\n  var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var type = item.get(\"type\");\n  var properties = item.get(\"properties\") || new _immutable.Map();\n  var mode = properties.get(\"mode\");\n  var children = item.get(\"children1\");\n  var field = properties.get(\"field\");\n  if (!children) return undefined;\n  var conjunction = properties.get(\"conjunction\");\n  if (!conjunction) conjunction = (0, _defaultUtils.defaultConjunction)(config);\n  var conjunctionDefinition = config.conjunctions[conjunction];\n  var not = properties.get(\"not\");\n  var isRuleGroup = type === \"rule_group\";\n  var isRuleGroupArray = isRuleGroup && mode != \"struct\";\n  var groupField = isRuleGroupArray ? field : parentField;\n  var groupFieldDef = (0, _configUtils.getFieldConfig)(config, groupField) || {};\n  var isSpelArray = groupFieldDef.isSpelArray; // check op for reverse\n\n  var groupOperator = properties.get(\"operator\");\n\n  if (!groupOperator && (!mode || mode == \"some\")) {\n    groupOperator = \"some\";\n  }\n\n  var realGroupOperator = checkOp(config, groupOperator, field);\n  var isGroupOpRev = realGroupOperator != groupOperator;\n  var realGroupOperatorDefinition = groupOperator && (0, _configUtils.getOperatorConfig)(config, realGroupOperator, field) || null;\n  var isGroup0 = isRuleGroup && (!realGroupOperator || realGroupOperatorDefinition.cardinality == 0); // build value for aggregation op\n\n  var _formatItemValue3 = formatItemValue(config, properties, meta, realGroupOperator, parentField, null),\n      _formatItemValue4 = (0, _slicedToArray2[\"default\"])(_formatItemValue3, 3),\n      formattedValue = _formatItemValue4[0],\n      valueSrc = _formatItemValue4[1],\n      valueType = _formatItemValue4[2]; // build filter in aggregation\n\n\n  var list = children.map(function (currentChild) {\n    return formatItem(currentChild, config, meta, groupField);\n  }).filter(function (currentChild) {\n    return typeof currentChild !== \"undefined\";\n  });\n\n  if (isRuleGroupArray && !isGroup0) {\n    // \"count\" rule can have no \"having\" children, but should have number value\n    if (formattedValue == undefined) return undefined;\n  } else {\n    if (!list.size) return undefined;\n  }\n\n  var omitBrackets = isRuleGroup;\n  var filter = list.size ? conjunctionDefinition.spelFormatConj(list, conjunction, not, omitBrackets) : null; // build result\n\n  var ret;\n\n  if (isRuleGroupArray) {\n    var formattedField = formatField(meta, config, field, parentField);\n    var getSize = isSpelArray ? \".length\" : \".size()\";\n    var fullSize = \"\".concat(formattedField).concat(getSize); // https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html#expressions-collection-selection\n\n    var filteredSize = filter ? \"\".concat(formattedField, \".?[\").concat(filter, \"]\").concat(getSize) : fullSize;\n    var groupValue = isGroup0 ? fullSize : formattedValue; // format expression\n\n    ret = formatExpression(meta, config, properties, filteredSize, groupValue, realGroupOperator, valueSrc, valueType, isGroupOpRev);\n  } else {\n    ret = filter;\n  }\n\n  return ret;\n};\n\nvar buildFnToFormatOp = function buildFnToFormatOp(operator, operatorDefinition) {\n  var spelOp = operatorDefinition.spelOp;\n  if (!spelOp) return undefined;\n  var objectIsFirstArg = spelOp[0] == \"$\";\n  var isMethod = spelOp[0] == \".\" || objectIsFirstArg;\n  var sop = isMethod ? spelOp.slice(1) : spelOp;\n  var fn;\n  var cardinality = (0, _stuff.defaultValue)(operatorDefinition.cardinality, 1);\n\n  if (cardinality == 0) {\n    fn = function fn(field, op, values, valueSrc, valueType, opDef, operatorOptions, fieldDef) {\n      if (isMethod) return \"\".concat(field, \".\").concat(sop, \"()\");else return \"\".concat(field, \" \").concat(sop);\n    };\n  } else if (cardinality == 1) {\n    fn = function fn(field, op, values, valueSrc, valueType, opDef, operatorOptions, fieldDef) {\n      if (objectIsFirstArg) return \"\".concat(values, \".\").concat(sop, \"(\").concat(field, \")\");else if (isMethod) return \"\".concat(field, \".\").concat(sop, \"(\").concat(values, \")\");else return \"\".concat(field, \" \").concat(sop, \" \").concat(values);\n    };\n  }\n\n  return fn;\n};\n\nvar formatExpression = function formatExpression(meta, config, properties, formattedField, formattedValue, operator, valueSrc, valueType) {\n  var isRev = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : false;\n  var field = properties.get(\"field\");\n  var opDef = (0, _configUtils.getOperatorConfig)(config, operator, field) || {};\n  var fieldDef = (0, _configUtils.getFieldConfig)(config, field) || {};\n  var operatorOptions = properties.get(\"operatorOptions\"); //find fn to format expr\n\n  var fn = opDef.spelFormatOp || buildFnToFormatOp(operator, opDef);\n\n  if (!fn) {\n    meta.errors.push(\"Operator \".concat(operator, \" is not supported\"));\n    return undefined;\n  } //format expr\n\n\n  var args = [formattedField, operator, formattedValue, valueSrc, valueType, (0, _omit[\"default\"])(opDef, [\"formatOp\", \"mongoFormatOp\", \"sqlFormatOp\", \"jsonLogic\", \"spelFormatOp\"]), operatorOptions, fieldDef];\n  var ret;\n  ret = fn.apply(void 0, args); //rev\n\n  if (isRev) {\n    ret = config.settings.spelFormatReverse(ret);\n  }\n\n  if (ret === undefined) {\n    meta.errors.push(\"Operator \".concat(operator, \" is not supported for value source \").concat(valueSrc));\n  }\n\n  return ret;\n};\n\nvar checkOp = function checkOp(config, operator, field) {\n  if (!operator) return undefined;\n  var opDef = (0, _configUtils.getOperatorConfig)(config, operator, field) || {};\n  var reversedOp = opDef.reversedOp;\n  var revOpDef = (0, _configUtils.getOperatorConfig)(config, reversedOp, field) || {};\n  var isRev = false;\n  var canFormatOp = opDef.spelOp || opDef.spelFormatOp;\n  var canFormatRevOp = revOpDef.spelOp || revOpDef.spelFormatOp;\n\n  if (!canFormatOp && !canFormatRevOp) {\n    return undefined;\n  }\n\n  if (!canFormatOp && canFormatRevOp) {\n    isRev = true;\n    var _ref = [reversedOp, operator];\n    operator = _ref[0];\n    reversedOp = _ref[1];\n    var _ref2 = [revOpDef, opDef];\n    opDef = _ref2[0];\n    revOpDef = _ref2[1];\n  }\n\n  return operator;\n};\n\nvar formatRule = function formatRule(item, config, meta) {\n  var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var properties = item.get(\"properties\") || new _immutable.Map();\n  var field = properties.get(\"field\");\n  var operator = properties.get(\"operator\");\n  if (field == null || operator == null) return undefined; // check op for reverse\n\n  var realOp = checkOp(config, operator, field);\n\n  if (!realOp) {\n    meta.errors.push(\"Operator \".concat(operator, \" is not supported\"));\n    return undefined;\n  }\n\n  var isRev = realOp != operator; //format value\n\n  var _formatItemValue5 = formatItemValue(config, properties, meta, realOp, parentField, null),\n      _formatItemValue6 = (0, _slicedToArray2[\"default\"])(_formatItemValue5, 3),\n      formattedValue = _formatItemValue6[0],\n      valueSrc = _formatItemValue6[1],\n      valueType = _formatItemValue6[2];\n\n  if (formattedValue === undefined) return undefined; //format field\n\n  var formattedField = formatField(meta, config, field, parentField); // format expression\n\n  var res = formatExpression(meta, config, properties, formattedField, formattedValue, realOp, valueSrc, valueType, isRev);\n  return res;\n};\n\nvar formatItemValue = function formatItemValue(config, properties, meta, operator, parentField) {\n  var expectedValueType = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n  var field = properties.get(\"field\");\n  var iValueSrc = properties.get(\"valueSrc\");\n  var iValueType = properties.get(\"valueType\");\n\n  if (expectedValueType == \"!case_value\" || iValueType && iValueType.get(0) == \"case_value\") {\n    field = \"!case_value\";\n  }\n\n  var fieldDef = (0, _configUtils.getFieldConfig)(config, field) || {};\n  var operatorDefinition = (0, _configUtils.getOperatorConfig)(config, operator, field) || {};\n  var cardinality = (0, _stuff.defaultValue)(operatorDefinition.cardinality, 1);\n  var iValue = properties.get(\"value\");\n  var asyncListValues = properties.get(\"asyncListValues\");\n  var valueSrcs = [];\n  var valueTypes = [];\n  var formattedValue;\n\n  if (iValue != undefined) {\n    var fvalue = iValue.map(function (currentValue, ind) {\n      var valueSrc = iValueSrc ? iValueSrc.get(ind) : null;\n      var valueType = iValueType ? iValueType.get(ind) : null;\n      var cValue = (0, _funcUtils.completeValue)(currentValue, valueSrc, config);\n      var widget = (0, _ruleUtils.getWidgetForFieldOp)(config, field, operator, valueSrc);\n      var fieldWidgetDef = (0, _omit[\"default\"])((0, _configUtils.getFieldWidgetConfig)(config, field, operator, widget, valueSrc), [\"factory\"]);\n      var fv = formatValue(meta, config, cValue, valueSrc, valueType, fieldWidgetDef, fieldDef, operator, operatorDefinition, parentField, asyncListValues);\n\n      if (fv !== undefined) {\n        valueSrcs.push(valueSrc);\n        valueTypes.push(valueType);\n      }\n\n      return fv;\n    });\n    var hasUndefinedValues = fvalue.filter(function (v) {\n      return v === undefined;\n    }).size > 0;\n\n    if (!(fvalue.size < cardinality || hasUndefinedValues)) {\n      formattedValue = cardinality > 1 ? fvalue.toArray() : cardinality == 1 ? fvalue.first() : null;\n    }\n  }\n\n  return [formattedValue, valueSrcs.length > 1 ? valueSrcs : valueSrcs[0], valueTypes.length > 1 ? valueTypes : valueTypes[0]];\n};\n\nvar formatValue = function formatValue(meta, config, currentValue, valueSrc, valueType, fieldWidgetDef, fieldDef, operator, operatorDef) {\n  var parentField = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : null;\n  var asyncListValues = arguments.length > 10 ? arguments[10] : undefined;\n  if (currentValue === undefined) return undefined;\n  var ret;\n\n  if (valueSrc == \"field\") {\n    ret = formatField(meta, config, currentValue, parentField);\n  } else if (valueSrc == \"func\") {\n    ret = formatFunc(meta, config, currentValue, parentField);\n  } else {\n    if (typeof fieldWidgetDef.spelFormatValue === \"function\") {\n      var fn = fieldWidgetDef.spelFormatValue;\n      var args = [currentValue, _objectSpread(_objectSpread({}, (0, _pick[\"default\"])(fieldDef, [\"fieldSettings\", \"listValues\"])), {}, {\n        asyncListValues: asyncListValues\n      }), //useful options: valueFormat for date/time\n      (0, _omit[\"default\"])(fieldWidgetDef, [\"formatValue\", \"mongoFormatValue\", \"sqlFormatValue\", \"jsonLogic\", \"elasticSearchFormatValue\", \"spelFormatValue\"])];\n\n      if (operator) {\n        args.push(operator);\n        args.push(operatorDef);\n      }\n\n      if (valueSrc == \"field\") {\n        var valFieldDefinition = (0, _configUtils.getFieldConfig)(config, currentValue) || {};\n        args.push(valFieldDefinition);\n      }\n\n      ret = fn.apply(void 0, args);\n    } else {\n      ret = (0, _export.spelEscape)(currentValue);\n    }\n  }\n\n  return ret;\n};\n\nvar formatField = function formatField(meta, config, field) {\n  var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  if (!field) return;\n  var fieldSeparator = config.settings.fieldSeparator;\n  var fieldDefinition = (0, _configUtils.getFieldConfig)(config, field) || {};\n  var fieldParts = Array.isArray(field) ? field : field.split(fieldSeparator);\n\n  var _fieldKeys = (0, _ruleUtils.getFieldPath)(field, config, parentField);\n\n  var fieldPartsConfigs = (0, _ruleUtils.getFieldPartsConfigs)(field, config, parentField);\n  var formatFieldFn = config.settings.formatSpelField;\n  var fieldName = (0, _ruleUtils.formatFieldName)(field, config, meta);\n\n  if (parentField) {\n    var parentFieldDef = (0, _configUtils.getFieldConfig)(config, parentField) || {};\n    var parentFieldName = parentField;\n\n    if (parentFieldDef.fieldName) {\n      parentFieldName = parentFieldDef.fieldName;\n    }\n\n    if (fieldName.indexOf(parentFieldName + fieldSeparator) == 0) {\n      fieldName = fieldName.slice((parentFieldName + fieldSeparator).length); // fieldName = \"#this.\" + fieldName;\n    } else {\n      meta.errors.push(\"Can't cut group \".concat(parentFieldName, \" from field \").concat(fieldName));\n    }\n  }\n\n  var fieldPartsMeta = fieldPartsConfigs.map(function (_ref3) {\n    var _ref4 = (0, _slicedToArray2[\"default\"])(_ref3, 3),\n        key = _ref4[0],\n        cnf = _ref4[1],\n        parentCnf = _ref4[2];\n\n    var parent;\n\n    if (parentCnf) {\n      if (parentCnf.type == \"!struct\" || parentCnf.type == \"!group\" && parentCnf.mode == \"struct\") parent = cnf.isSpelMap ? \"map\" : \"class\";else if (parentCnf.type == \"!group\") parent = cnf.isSpelItemMap ? \"[map]\" : \"[class]\";else parent = \"class\";\n    }\n\n    var isSpelVariable = cnf === null || cnf === void 0 ? void 0 : cnf.isSpelVariable;\n    return {\n      key: key,\n      parent: parent,\n      isSpelVariable: isSpelVariable\n    };\n  });\n  var formattedField = formatFieldFn(fieldName, parentField, fieldParts, fieldPartsMeta, fieldDefinition, config);\n  return formattedField;\n};\n\nvar formatFunc = function formatFunc(meta, config, currentValue) {\n  var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var funcKey = currentValue.get(\"func\");\n  var args = currentValue.get(\"args\");\n  var funcConfig = (0, _configUtils.getFuncConfig)(config, funcKey);\n  var funcName = funcConfig.spelFunc || funcKey;\n  var formattedArgs = {};\n\n  for (var argKey in funcConfig.args) {\n    var argConfig = funcConfig.args[argKey];\n    var fieldDef = (0, _configUtils.getFieldConfig)(config, argConfig);\n    var argVal = args ? args.get(argKey) : undefined;\n    var argValue = argVal ? argVal.get(\"value\") : undefined;\n    var argValueSrc = argVal ? argVal.get(\"valueSrc\") : undefined;\n    var argAsyncListValues = argVal ? argVal.get(\"asyncListValues\") : undefined;\n    var formattedArgVal = formatValue(meta, config, argValue, argValueSrc, argConfig.type, fieldDef, argConfig, null, null, parentField, argAsyncListValues);\n\n    if (argValue != undefined && formattedArgVal === undefined) {\n      meta.errors.push(\"Can't format value of arg \".concat(argKey, \" for func \").concat(funcKey));\n      return undefined;\n    }\n\n    if (formattedArgVal !== undefined) {\n      // skip optional in the end\n      formattedArgs[argKey] = formattedArgVal;\n    }\n  }\n\n  var ret;\n\n  if (typeof funcConfig.spelFormatFunc === \"function\") {\n    var fn = funcConfig.spelFormatFunc;\n    var _args = [formattedArgs];\n    ret = fn.apply(void 0, _args);\n  } else {\n    var _args2 = Object.entries(formattedArgs).map(function (_ref5) {\n      var _ref6 = (0, _slicedToArray2[\"default\"])(_ref5, 2),\n          k = _ref6[0],\n          v = _ref6[1];\n\n      return v;\n    });\n\n    if (funcName[0] == \".\" && _args2.length) {\n      var _args3 = (0, _toArray2[\"default\"])(_args2),\n          obj = _args3[0],\n          params = _args3.slice(1);\n\n      ret = \"\".concat(obj).concat(funcName, \"(\").concat(params.join(\", \"), \")\");\n    } else {\n      ret = \"\".concat(funcName, \"(\").concat(_args2.join(\", \"), \")\");\n    }\n  }\n\n  return ret;\n};","map":{"version":3,"sources":["D:/LIMSWFH/LIMSPOSTGRESQL/QuaLISWeb/node_modules/react-awesome-query-builder/lib/export/spel.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","spelFormat","_spelFormat","_toArray2","_defineProperty2","_slicedToArray2","_configUtils","_ruleUtils","_omit","_pick","_stuff","_defaultUtils","_default","_funcUtils","_immutable","_export","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","tree","config","returnErrors","undefined","meta","errors","res","formatItem","console","warn","item","parentField","type","get","formatGroup","formatRule","formatSwitch","formatCase","concat","properties","Map","_formatItemValue","formatItemValue","_formatItemValue2","formattedValue","valueSrc","valueType","cond","children","cases","map","currentChild","toArray","filteredCases","left","right","_i","_filteredCases$_i","mode","field","conjunction","defaultConjunction","conjunctionDefinition","conjunctions","not","isRuleGroup","isRuleGroupArray","groupField","groupFieldDef","getFieldConfig","isSpelArray","groupOperator","realGroupOperator","checkOp","isGroupOpRev","realGroupOperatorDefinition","getOperatorConfig","isGroup0","cardinality","_formatItemValue3","_formatItemValue4","list","size","omitBrackets","spelFormatConj","ret","formattedField","formatField","getSize","fullSize","filteredSize","groupValue","formatExpression","buildFnToFormatOp","operator","operatorDefinition","spelOp","objectIsFirstArg","isMethod","sop","slice","fn","defaultValue","op","values","opDef","operatorOptions","fieldDef","isRev","spelFormatOp","args","settings","spelFormatReverse","reversedOp","revOpDef","canFormatOp","canFormatRevOp","_ref","_ref2","realOp","_formatItemValue5","_formatItemValue6","expectedValueType","iValueSrc","iValueType","iValue","asyncListValues","valueSrcs","valueTypes","fvalue","currentValue","ind","cValue","completeValue","widget","getWidgetForFieldOp","fieldWidgetDef","getFieldWidgetConfig","fv","formatValue","hasUndefinedValues","v","first","operatorDef","formatFunc","spelFormatValue","valFieldDefinition","spelEscape","fieldSeparator","fieldDefinition","fieldParts","Array","isArray","split","_fieldKeys","getFieldPath","fieldPartsConfigs","getFieldPartsConfigs","formatFieldFn","formatSpelField","fieldName","formatFieldName","parentFieldDef","parentFieldName","indexOf","fieldPartsMeta","_ref3","_ref4","cnf","parentCnf","parent","isSpelMap","isSpelItemMap","isSpelVariable","funcKey","funcConfig","getFuncConfig","funcName","spelFunc","formattedArgs","argKey","argConfig","argVal","argValue","argValueSrc","argAsyncListValues","formattedArgVal","spelFormatFunc","_args","_args2","entries","_ref5","_ref6","k","_args3","obj","params","join"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.spelFormat = exports._spelFormat = void 0;\n\nvar _toArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toArray\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _configUtils = require(\"../utils/configUtils\");\n\nvar _ruleUtils = require(\"../utils/ruleUtils\");\n\nvar _omit = _interopRequireDefault(require(\"lodash/omit\"));\n\nvar _pick = _interopRequireDefault(require(\"lodash/pick\"));\n\nvar _stuff = require(\"../utils/stuff\");\n\nvar _defaultUtils = require(\"../utils/defaultUtils\");\n\nvar _default = require(\"../config/default\");\n\nvar _funcUtils = require(\"../utils/funcUtils\");\n\nvar _immutable = require(\"immutable\");\n\nvar _export = require(\"../utils/export\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2[\"default\"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nvar spelFormat = function spelFormat(tree, config) {\n  return _spelFormat(tree, config, false);\n};\n\nexports.spelFormat = spelFormat;\n\nvar _spelFormat = function _spelFormat(tree, config) {\n  var returnErrors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  //meta is mutable\n  var meta = {\n    errors: []\n  };\n  var res = formatItem(tree, config, meta, null);\n\n  if (returnErrors) {\n    return [res, meta.errors];\n  } else {\n    if (meta.errors.length) console.warn(\"Errors while exporting to SpEL:\", meta.errors);\n    return res;\n  }\n};\n\nexports._spelFormat = _spelFormat;\n\nvar formatItem = function formatItem(item, config, meta) {\n  var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  if (!item) return undefined;\n  var type = item.get(\"type\");\n\n  if (type === \"group\" || type === \"rule_group\") {\n    return formatGroup(item, config, meta, parentField);\n  } else if (type === \"rule\") {\n    return formatRule(item, config, meta, parentField);\n  } else if (type == \"switch_group\") {\n    return formatSwitch(item, config, meta, parentField);\n  } else if (type == \"case_group\") {\n    return formatCase(item, config, meta, parentField);\n  }\n\n  return undefined;\n};\n\nvar formatCase = function formatCase(item, config, meta) {\n  var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var type = item.get(\"type\");\n\n  if (type != \"case_group\") {\n    meta.errors.push(\"Unexpected child of type \".concat(type, \" inside switch\"));\n    return undefined;\n  }\n\n  var properties = item.get(\"properties\") || new _immutable.Map();\n\n  var _formatItemValue = formatItemValue(config, properties, meta, null, parentField, \"!case_value\"),\n      _formatItemValue2 = (0, _slicedToArray2[\"default\"])(_formatItemValue, 3),\n      formattedValue = _formatItemValue2[0],\n      valueSrc = _formatItemValue2[1],\n      valueType = _formatItemValue2[2];\n\n  var cond = formatGroup(item, config, meta, parentField);\n  return [cond, formattedValue];\n};\n\nvar formatSwitch = function formatSwitch(item, config, meta) {\n  var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var properties = item.get(\"properties\") || new _immutable.Map();\n  var children = item.get(\"children1\");\n  if (!children) return undefined;\n  var cases = children.map(function (currentChild) {\n    return formatCase(currentChild, config, meta, null);\n  }).filter(function (currentChild) {\n    return typeof currentChild !== \"undefined\";\n  }).toArray();\n  if (!cases.length) return undefined;\n\n  if (cases.length == 1 && !cases[0][0]) {\n    // only 1 case without condition\n    return cases[0][1];\n  }\n\n  var filteredCases = [];\n\n  for (var i = 0; i < cases.length; i++) {\n    if (i != cases.length - 1 && !cases[i][0]) {\n      meta.errors.push(\"No condition for case \".concat(i));\n    } else {\n      filteredCases.push(cases[i]);\n\n      if (i == cases.length - 1 && cases[i][0]) {\n        // no default - add null as default\n        filteredCases.push([undefined, null]);\n      }\n    }\n  }\n\n  var left = \"\",\n      right = \"\";\n\n  for (var _i = 0; _i < filteredCases.length; _i++) {\n    var _filteredCases$_i = (0, _slicedToArray2[\"default\"])(filteredCases[_i], 2),\n        cond = _filteredCases$_i[0],\n        value = _filteredCases$_i[1];\n\n    if (value == undefined) value = \"null\";\n    if (cond == undefined) cond = \"true\";\n\n    if (_i != filteredCases.length - 1) {\n      left += \"(\".concat(cond, \" ? \").concat(value, \" : \");\n      right += \")\";\n    } else {\n      left += \"\".concat(value);\n    }\n  }\n\n  return left + right;\n};\n\nvar formatGroup = function formatGroup(item, config, meta) {\n  var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var type = item.get(\"type\");\n  var properties = item.get(\"properties\") || new _immutable.Map();\n  var mode = properties.get(\"mode\");\n  var children = item.get(\"children1\");\n  var field = properties.get(\"field\");\n  if (!children) return undefined;\n  var conjunction = properties.get(\"conjunction\");\n  if (!conjunction) conjunction = (0, _defaultUtils.defaultConjunction)(config);\n  var conjunctionDefinition = config.conjunctions[conjunction];\n  var not = properties.get(\"not\");\n  var isRuleGroup = type === \"rule_group\";\n  var isRuleGroupArray = isRuleGroup && mode != \"struct\";\n  var groupField = isRuleGroupArray ? field : parentField;\n  var groupFieldDef = (0, _configUtils.getFieldConfig)(config, groupField) || {};\n  var isSpelArray = groupFieldDef.isSpelArray; // check op for reverse\n\n  var groupOperator = properties.get(\"operator\");\n\n  if (!groupOperator && (!mode || mode == \"some\")) {\n    groupOperator = \"some\";\n  }\n\n  var realGroupOperator = checkOp(config, groupOperator, field);\n  var isGroupOpRev = realGroupOperator != groupOperator;\n  var realGroupOperatorDefinition = groupOperator && (0, _configUtils.getOperatorConfig)(config, realGroupOperator, field) || null;\n  var isGroup0 = isRuleGroup && (!realGroupOperator || realGroupOperatorDefinition.cardinality == 0); // build value for aggregation op\n\n  var _formatItemValue3 = formatItemValue(config, properties, meta, realGroupOperator, parentField, null),\n      _formatItemValue4 = (0, _slicedToArray2[\"default\"])(_formatItemValue3, 3),\n      formattedValue = _formatItemValue4[0],\n      valueSrc = _formatItemValue4[1],\n      valueType = _formatItemValue4[2]; // build filter in aggregation\n\n\n  var list = children.map(function (currentChild) {\n    return formatItem(currentChild, config, meta, groupField);\n  }).filter(function (currentChild) {\n    return typeof currentChild !== \"undefined\";\n  });\n\n  if (isRuleGroupArray && !isGroup0) {\n    // \"count\" rule can have no \"having\" children, but should have number value\n    if (formattedValue == undefined) return undefined;\n  } else {\n    if (!list.size) return undefined;\n  }\n\n  var omitBrackets = isRuleGroup;\n  var filter = list.size ? conjunctionDefinition.spelFormatConj(list, conjunction, not, omitBrackets) : null; // build result\n\n  var ret;\n\n  if (isRuleGroupArray) {\n    var formattedField = formatField(meta, config, field, parentField);\n    var getSize = isSpelArray ? \".length\" : \".size()\";\n    var fullSize = \"\".concat(formattedField).concat(getSize); // https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html#expressions-collection-selection\n\n    var filteredSize = filter ? \"\".concat(formattedField, \".?[\").concat(filter, \"]\").concat(getSize) : fullSize;\n    var groupValue = isGroup0 ? fullSize : formattedValue; // format expression\n\n    ret = formatExpression(meta, config, properties, filteredSize, groupValue, realGroupOperator, valueSrc, valueType, isGroupOpRev);\n  } else {\n    ret = filter;\n  }\n\n  return ret;\n};\n\nvar buildFnToFormatOp = function buildFnToFormatOp(operator, operatorDefinition) {\n  var spelOp = operatorDefinition.spelOp;\n  if (!spelOp) return undefined;\n  var objectIsFirstArg = spelOp[0] == \"$\";\n  var isMethod = spelOp[0] == \".\" || objectIsFirstArg;\n  var sop = isMethod ? spelOp.slice(1) : spelOp;\n  var fn;\n  var cardinality = (0, _stuff.defaultValue)(operatorDefinition.cardinality, 1);\n\n  if (cardinality == 0) {\n    fn = function fn(field, op, values, valueSrc, valueType, opDef, operatorOptions, fieldDef) {\n      if (isMethod) return \"\".concat(field, \".\").concat(sop, \"()\");else return \"\".concat(field, \" \").concat(sop);\n    };\n  } else if (cardinality == 1) {\n    fn = function fn(field, op, values, valueSrc, valueType, opDef, operatorOptions, fieldDef) {\n      if (objectIsFirstArg) return \"\".concat(values, \".\").concat(sop, \"(\").concat(field, \")\");else if (isMethod) return \"\".concat(field, \".\").concat(sop, \"(\").concat(values, \")\");else return \"\".concat(field, \" \").concat(sop, \" \").concat(values);\n    };\n  }\n\n  return fn;\n};\n\nvar formatExpression = function formatExpression(meta, config, properties, formattedField, formattedValue, operator, valueSrc, valueType) {\n  var isRev = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : false;\n  var field = properties.get(\"field\");\n  var opDef = (0, _configUtils.getOperatorConfig)(config, operator, field) || {};\n  var fieldDef = (0, _configUtils.getFieldConfig)(config, field) || {};\n  var operatorOptions = properties.get(\"operatorOptions\"); //find fn to format expr\n\n  var fn = opDef.spelFormatOp || buildFnToFormatOp(operator, opDef);\n\n  if (!fn) {\n    meta.errors.push(\"Operator \".concat(operator, \" is not supported\"));\n    return undefined;\n  } //format expr\n\n\n  var args = [formattedField, operator, formattedValue, valueSrc, valueType, (0, _omit[\"default\"])(opDef, [\"formatOp\", \"mongoFormatOp\", \"sqlFormatOp\", \"jsonLogic\", \"spelFormatOp\"]), operatorOptions, fieldDef];\n  var ret;\n  ret = fn.apply(void 0, args); //rev\n\n  if (isRev) {\n    ret = config.settings.spelFormatReverse(ret);\n  }\n\n  if (ret === undefined) {\n    meta.errors.push(\"Operator \".concat(operator, \" is not supported for value source \").concat(valueSrc));\n  }\n\n  return ret;\n};\n\nvar checkOp = function checkOp(config, operator, field) {\n  if (!operator) return undefined;\n  var opDef = (0, _configUtils.getOperatorConfig)(config, operator, field) || {};\n  var reversedOp = opDef.reversedOp;\n  var revOpDef = (0, _configUtils.getOperatorConfig)(config, reversedOp, field) || {};\n  var isRev = false;\n  var canFormatOp = opDef.spelOp || opDef.spelFormatOp;\n  var canFormatRevOp = revOpDef.spelOp || revOpDef.spelFormatOp;\n\n  if (!canFormatOp && !canFormatRevOp) {\n    return undefined;\n  }\n\n  if (!canFormatOp && canFormatRevOp) {\n    isRev = true;\n    var _ref = [reversedOp, operator];\n    operator = _ref[0];\n    reversedOp = _ref[1];\n    var _ref2 = [revOpDef, opDef];\n    opDef = _ref2[0];\n    revOpDef = _ref2[1];\n  }\n\n  return operator;\n};\n\nvar formatRule = function formatRule(item, config, meta) {\n  var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var properties = item.get(\"properties\") || new _immutable.Map();\n  var field = properties.get(\"field\");\n  var operator = properties.get(\"operator\");\n  if (field == null || operator == null) return undefined; // check op for reverse\n\n  var realOp = checkOp(config, operator, field);\n\n  if (!realOp) {\n    meta.errors.push(\"Operator \".concat(operator, \" is not supported\"));\n    return undefined;\n  }\n\n  var isRev = realOp != operator; //format value\n\n  var _formatItemValue5 = formatItemValue(config, properties, meta, realOp, parentField, null),\n      _formatItemValue6 = (0, _slicedToArray2[\"default\"])(_formatItemValue5, 3),\n      formattedValue = _formatItemValue6[0],\n      valueSrc = _formatItemValue6[1],\n      valueType = _formatItemValue6[2];\n\n  if (formattedValue === undefined) return undefined; //format field\n\n  var formattedField = formatField(meta, config, field, parentField); // format expression\n\n  var res = formatExpression(meta, config, properties, formattedField, formattedValue, realOp, valueSrc, valueType, isRev);\n  return res;\n};\n\nvar formatItemValue = function formatItemValue(config, properties, meta, operator, parentField) {\n  var expectedValueType = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n  var field = properties.get(\"field\");\n  var iValueSrc = properties.get(\"valueSrc\");\n  var iValueType = properties.get(\"valueType\");\n\n  if (expectedValueType == \"!case_value\" || iValueType && iValueType.get(0) == \"case_value\") {\n    field = \"!case_value\";\n  }\n\n  var fieldDef = (0, _configUtils.getFieldConfig)(config, field) || {};\n  var operatorDefinition = (0, _configUtils.getOperatorConfig)(config, operator, field) || {};\n  var cardinality = (0, _stuff.defaultValue)(operatorDefinition.cardinality, 1);\n  var iValue = properties.get(\"value\");\n  var asyncListValues = properties.get(\"asyncListValues\");\n  var valueSrcs = [];\n  var valueTypes = [];\n  var formattedValue;\n\n  if (iValue != undefined) {\n    var fvalue = iValue.map(function (currentValue, ind) {\n      var valueSrc = iValueSrc ? iValueSrc.get(ind) : null;\n      var valueType = iValueType ? iValueType.get(ind) : null;\n      var cValue = (0, _funcUtils.completeValue)(currentValue, valueSrc, config);\n      var widget = (0, _ruleUtils.getWidgetForFieldOp)(config, field, operator, valueSrc);\n      var fieldWidgetDef = (0, _omit[\"default\"])((0, _configUtils.getFieldWidgetConfig)(config, field, operator, widget, valueSrc), [\"factory\"]);\n      var fv = formatValue(meta, config, cValue, valueSrc, valueType, fieldWidgetDef, fieldDef, operator, operatorDefinition, parentField, asyncListValues);\n\n      if (fv !== undefined) {\n        valueSrcs.push(valueSrc);\n        valueTypes.push(valueType);\n      }\n\n      return fv;\n    });\n    var hasUndefinedValues = fvalue.filter(function (v) {\n      return v === undefined;\n    }).size > 0;\n\n    if (!(fvalue.size < cardinality || hasUndefinedValues)) {\n      formattedValue = cardinality > 1 ? fvalue.toArray() : cardinality == 1 ? fvalue.first() : null;\n    }\n  }\n\n  return [formattedValue, valueSrcs.length > 1 ? valueSrcs : valueSrcs[0], valueTypes.length > 1 ? valueTypes : valueTypes[0]];\n};\n\nvar formatValue = function formatValue(meta, config, currentValue, valueSrc, valueType, fieldWidgetDef, fieldDef, operator, operatorDef) {\n  var parentField = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : null;\n  var asyncListValues = arguments.length > 10 ? arguments[10] : undefined;\n  if (currentValue === undefined) return undefined;\n  var ret;\n\n  if (valueSrc == \"field\") {\n    ret = formatField(meta, config, currentValue, parentField);\n  } else if (valueSrc == \"func\") {\n    ret = formatFunc(meta, config, currentValue, parentField);\n  } else {\n    if (typeof fieldWidgetDef.spelFormatValue === \"function\") {\n      var fn = fieldWidgetDef.spelFormatValue;\n      var args = [currentValue, _objectSpread(_objectSpread({}, (0, _pick[\"default\"])(fieldDef, [\"fieldSettings\", \"listValues\"])), {}, {\n        asyncListValues: asyncListValues\n      }), //useful options: valueFormat for date/time\n      (0, _omit[\"default\"])(fieldWidgetDef, [\"formatValue\", \"mongoFormatValue\", \"sqlFormatValue\", \"jsonLogic\", \"elasticSearchFormatValue\", \"spelFormatValue\"])];\n\n      if (operator) {\n        args.push(operator);\n        args.push(operatorDef);\n      }\n\n      if (valueSrc == \"field\") {\n        var valFieldDefinition = (0, _configUtils.getFieldConfig)(config, currentValue) || {};\n        args.push(valFieldDefinition);\n      }\n\n      ret = fn.apply(void 0, args);\n    } else {\n      ret = (0, _export.spelEscape)(currentValue);\n    }\n  }\n\n  return ret;\n};\n\nvar formatField = function formatField(meta, config, field) {\n  var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  if (!field) return;\n  var fieldSeparator = config.settings.fieldSeparator;\n  var fieldDefinition = (0, _configUtils.getFieldConfig)(config, field) || {};\n  var fieldParts = Array.isArray(field) ? field : field.split(fieldSeparator);\n\n  var _fieldKeys = (0, _ruleUtils.getFieldPath)(field, config, parentField);\n\n  var fieldPartsConfigs = (0, _ruleUtils.getFieldPartsConfigs)(field, config, parentField);\n  var formatFieldFn = config.settings.formatSpelField;\n  var fieldName = (0, _ruleUtils.formatFieldName)(field, config, meta);\n\n  if (parentField) {\n    var parentFieldDef = (0, _configUtils.getFieldConfig)(config, parentField) || {};\n    var parentFieldName = parentField;\n\n    if (parentFieldDef.fieldName) {\n      parentFieldName = parentFieldDef.fieldName;\n    }\n\n    if (fieldName.indexOf(parentFieldName + fieldSeparator) == 0) {\n      fieldName = fieldName.slice((parentFieldName + fieldSeparator).length); // fieldName = \"#this.\" + fieldName;\n    } else {\n      meta.errors.push(\"Can't cut group \".concat(parentFieldName, \" from field \").concat(fieldName));\n    }\n  }\n\n  var fieldPartsMeta = fieldPartsConfigs.map(function (_ref3) {\n    var _ref4 = (0, _slicedToArray2[\"default\"])(_ref3, 3),\n        key = _ref4[0],\n        cnf = _ref4[1],\n        parentCnf = _ref4[2];\n\n    var parent;\n\n    if (parentCnf) {\n      if (parentCnf.type == \"!struct\" || parentCnf.type == \"!group\" && parentCnf.mode == \"struct\") parent = cnf.isSpelMap ? \"map\" : \"class\";else if (parentCnf.type == \"!group\") parent = cnf.isSpelItemMap ? \"[map]\" : \"[class]\";else parent = \"class\";\n    }\n\n    var isSpelVariable = cnf === null || cnf === void 0 ? void 0 : cnf.isSpelVariable;\n    return {\n      key: key,\n      parent: parent,\n      isSpelVariable: isSpelVariable\n    };\n  });\n  var formattedField = formatFieldFn(fieldName, parentField, fieldParts, fieldPartsMeta, fieldDefinition, config);\n  return formattedField;\n};\n\nvar formatFunc = function formatFunc(meta, config, currentValue) {\n  var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var funcKey = currentValue.get(\"func\");\n  var args = currentValue.get(\"args\");\n  var funcConfig = (0, _configUtils.getFuncConfig)(config, funcKey);\n  var funcName = funcConfig.spelFunc || funcKey;\n  var formattedArgs = {};\n\n  for (var argKey in funcConfig.args) {\n    var argConfig = funcConfig.args[argKey];\n    var fieldDef = (0, _configUtils.getFieldConfig)(config, argConfig);\n    var argVal = args ? args.get(argKey) : undefined;\n    var argValue = argVal ? argVal.get(\"value\") : undefined;\n    var argValueSrc = argVal ? argVal.get(\"valueSrc\") : undefined;\n    var argAsyncListValues = argVal ? argVal.get(\"asyncListValues\") : undefined;\n    var formattedArgVal = formatValue(meta, config, argValue, argValueSrc, argConfig.type, fieldDef, argConfig, null, null, parentField, argAsyncListValues);\n\n    if (argValue != undefined && formattedArgVal === undefined) {\n      meta.errors.push(\"Can't format value of arg \".concat(argKey, \" for func \").concat(funcKey));\n      return undefined;\n    }\n\n    if (formattedArgVal !== undefined) {\n      // skip optional in the end\n      formattedArgs[argKey] = formattedArgVal;\n    }\n  }\n\n  var ret;\n\n  if (typeof funcConfig.spelFormatFunc === \"function\") {\n    var fn = funcConfig.spelFormatFunc;\n    var _args = [formattedArgs];\n    ret = fn.apply(void 0, _args);\n  } else {\n    var _args2 = Object.entries(formattedArgs).map(function (_ref5) {\n      var _ref6 = (0, _slicedToArray2[\"default\"])(_ref5, 2),\n          k = _ref6[0],\n          v = _ref6[1];\n\n      return v;\n    });\n\n    if (funcName[0] == \".\" && _args2.length) {\n      var _args3 = (0, _toArray2[\"default\"])(_args2),\n          obj = _args3[0],\n          params = _args3.slice(1);\n\n      ret = \"\".concat(obj).concat(funcName, \"(\").concat(params.join(\", \"), \")\");\n    } else {\n      ret = \"\".concat(funcName, \"(\").concat(_args2.join(\", \"), \")\");\n    }\n  }\n\n  return ret;\n};"]},"metadata":{},"sourceType":"script"}