{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _typeof = require(\"@babel/runtime/helpers/typeof\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime/helpers/assertThisInitialized\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _react = _interopRequireWildcard(require(\"react\"));\n\nvar _reactRedux = require(\"react-redux\");\n\nvar _treeUtils = require(\"../../utils/treeUtils\");\n\nvar _context = _interopRequireDefault(require(\"../../stores/context\"));\n\nvar constants = _interopRequireWildcard(require(\"../../constants\"));\n\nvar _clone = _interopRequireDefault(require(\"clone\"));\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar actions = _interopRequireWildcard(require(\"../../actions\"));\n\nvar _reactUtils = require(\"../../utils/reactUtils\");\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n    return {\n      \"default\": obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache(nodeInterop);\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj[\"default\"] = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = (0, _getPrototypeOf2[\"default\"])(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = (0, _getPrototypeOf2[\"default\"])(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return (0, _possibleConstructorReturn2[\"default\"])(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nvar isDev = function isDev() {\n  return process && process.env && process.env.NODE_ENV == \"development\";\n};\n\nvar createSortableContainer = function createSortableContainer(Builder) {\n  var _class, _temp;\n\n  var CanMoveFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  return _temp = _class = /*#__PURE__*/function (_Component) {\n    (0, _inherits2[\"default\"])(SortableContainer, _Component);\n\n    var _super = _createSuper(SortableContainer);\n\n    function SortableContainer(props) {\n      var _this;\n\n      (0, _classCallCheck2[\"default\"])(this, SortableContainer);\n      _this = _super.call(this, props);\n\n      _this._getEventTarget = function (e, dragStart) {\n        return e && e.__mocked_window || document.body || window;\n      };\n\n      _this.onDragStart = function (id, dom, e) {\n        var treeEl = dom.closest(\".query-builder\");\n        document.body.classList.add(\"qb-dragging\");\n        treeEl.classList.add(\"qb-dragging\");\n        var treeElContainer = treeEl.closest(\".query-builder-container\") || treeEl;\n        treeElContainer = _this._getScrollParent(treeElContainer) || document.body;\n        var scrollTop = treeElContainer.scrollTop;\n\n        var _dragEl = _this._getDraggableNodeEl(treeEl);\n\n        var _plhEl = _this._getPlaceholderNodeEl(treeEl);\n\n        var tmpAllGroups = treeEl.querySelectorAll(\".group--children\");\n        var anyGroup = tmpAllGroups.length ? tmpAllGroups[0] : null;\n        var groupPadding;\n\n        if (anyGroup) {\n          groupPadding = window.getComputedStyle(anyGroup, null).getPropertyValue(\"padding-left\");\n          groupPadding = parseInt(groupPadding);\n        }\n\n        var dragging = {\n          id: id,\n          x: dom.offsetLeft,\n          y: dom.offsetTop,\n          w: dom.offsetWidth,\n          h: dom.offsetHeight,\n          itemInfo: _this.tree.items[id],\n          paddingLeft: groupPadding\n        };\n        var dragStart = {\n          id: id,\n          x: dom.offsetLeft,\n          y: dom.offsetTop,\n          scrollTop: scrollTop,\n          clientX: e.clientX,\n          clientY: e.clientY,\n          itemInfo: (0, _clone[\"default\"])(_this.tree.items[id]),\n          treeEl: treeEl,\n          treeElContainer: treeElContainer\n        };\n        var mousePos = {\n          clientX: e.clientX,\n          clientY: e.clientY\n        };\n\n        var target = _this._getEventTarget(e, dragStart);\n\n        _this.eventTarget = target;\n        target.addEventListener(\"mousemove\", _this.onDrag);\n        target.addEventListener(\"mouseup\", _this.onDragEnd);\n\n        _this.props.setDragStart(dragStart, dragging, mousePos);\n      };\n\n      _this.onDrag = function (e) {\n        var doHandleDrag = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        var dragging = Object.assign({}, _this.props.dragging);\n        var startDragging = _this.props.dragStart;\n        var paddingLeft = dragging.paddingLeft; //this.props.paddingLeft;\n\n        var treeElContainer = startDragging.treeElContainer;\n        var scrollTop = treeElContainer.scrollTop;\n        dragging.itemInfo = _this.tree.items[dragging.id];\n\n        if (!dragging.itemInfo) {\n          return;\n        }\n\n        var mousePos = {\n          clientX: e.clientX,\n          clientY: e.clientY\n        };\n        var startMousePos = {\n          clientX: startDragging.clientX,\n          clientY: startDragging.clientY\n        };\n\n        if (e.__mock_dom) {\n          var treeEl = startDragging.treeEl;\n\n          var dragEl = _this._getDraggableNodeEl(treeEl);\n\n          var plhEl = _this._getPlaceholderNodeEl(treeEl);\n\n          e.__mock_dom({\n            treeEl: treeEl,\n            dragEl: dragEl,\n            plhEl: plhEl\n          });\n        } //first init plX/plY\n\n\n        if (!startDragging.plX) {\n          var _treeEl = startDragging.treeEl;\n\n          var _plhEl2 = _this._getPlaceholderNodeEl(_treeEl);\n\n          if (_plhEl2) {\n            startDragging.plX = _plhEl2.getBoundingClientRect().left + window.scrollX;\n            startDragging.plY = _plhEl2.getBoundingClientRect().top + window.scrollY;\n          }\n        }\n\n        var startX = startDragging.x;\n        var startY = startDragging.y;\n        var startClientX = startDragging.clientX;\n        var startClientY = startDragging.clientY;\n        var startScrollTop = startDragging.scrollTop;\n        var pos = {\n          x: startX + (e.clientX - startClientX),\n          y: startY + (e.clientY - startClientY) + (scrollTop - startScrollTop)\n        };\n        dragging.x = pos.x;\n        dragging.y = pos.y;\n        dragging.paddingLeft = paddingLeft;\n        dragging.mousePos = mousePos;\n        dragging.startMousePos = startMousePos;\n\n        _this.props.setDragProgress(mousePos, dragging);\n\n        var moved = doHandleDrag ? _this.handleDrag(dragging, e, CanMoveFn) : false;\n\n        if (!moved) {\n          if (e.preventDefault) e.preventDefault();\n        }\n      };\n\n      _this.onDragEnd = function () {\n        var treeEl = _this.props.dragStart.treeEl;\n\n        _this.props.setDragEnd();\n\n        treeEl.classList.remove(\"qb-dragging\");\n        document.body.classList.remove(\"qb-dragging\");\n        _this._cacheEls = {};\n\n        var target = _this.eventTarget || _this._getEventTarget();\n\n        target.removeEventListener(\"mousemove\", _this.onDrag);\n        target.removeEventListener(\"mouseup\", _this.onDragEnd);\n      };\n\n      (0, _reactUtils.useOnPropsChanged)((0, _assertThisInitialized2[\"default\"])(_this));\n\n      _this.onPropsChanged(props);\n\n      return _this;\n    }\n\n    (0, _createClass2[\"default\"])(SortableContainer, [{\n      key: \"onPropsChanged\",\n      value: function onPropsChanged(nextProps) {\n        this.tree = (0, _treeUtils.getFlatTree)(nextProps.tree);\n      }\n    }, {\n      key: \"shouldComponentUpdate\",\n      value: function shouldComponentUpdate(nextProps, nextState) {\n        var prevProps = this.props;\n        var prevState = this.state;\n        var should = (0, _reactUtils.pureShouldComponentUpdate)(this)(nextProps, nextState);\n\n        if (should) {\n          if (prevState == nextState && prevProps != nextProps) {\n            var chs = [];\n\n            for (var k in nextProps) {\n              var changed = nextProps[k] != prevProps[k];\n\n              if (changed) {\n                //don't render <Builder> on dragging - appropriate redux-connected components will do it\n                if (k != \"dragging\" && k != \"mousePos\") chs.push(k);\n              }\n            }\n\n            if (!chs.length) should = false;\n          }\n        }\n\n        return should;\n      }\n    }, {\n      key: \"componentDidUpdate\",\n      value: function componentDidUpdate(_prevProps, _prevState) {\n        var dragging = this.props.dragging;\n        var startDragging = this.props.dragStart;\n\n        if (startDragging && startDragging.id) {\n          dragging.itemInfo = this.tree.items[dragging.id];\n\n          if (dragging.itemInfo) {\n            if (dragging.itemInfo.index != startDragging.itemInfo.index || dragging.itemInfo.parent != startDragging.itemInfo.parent) {\n              var treeEl = startDragging.treeEl;\n              var treeElContainer = startDragging.treeElContainer;\n\n              var plhEl = this._getPlaceholderNodeEl(treeEl, true);\n\n              if (plhEl) {\n                var plX = plhEl.getBoundingClientRect().left + window.scrollX;\n                var plY = plhEl.getBoundingClientRect().top + window.scrollY;\n                var oldPlX = startDragging.plX;\n                var oldPlY = startDragging.plY;\n                var scrollTop = treeElContainer.scrollTop;\n                startDragging.plX = plX;\n                startDragging.plY = plY;\n                startDragging.itemInfo = (0, _clone[\"default\"])(dragging.itemInfo);\n                startDragging.y = plhEl.offsetTop;\n                startDragging.x = plhEl.offsetLeft;\n                startDragging.clientY += plY - oldPlY;\n                startDragging.clientX += plX - oldPlX;\n                if (treeElContainer != document.body) startDragging.scrollTop = scrollTop;\n                this.onDrag(this.props.mousePos, false);\n              }\n            }\n          }\n        }\n      }\n    }, {\n      key: \"_getNodeElById\",\n      value: function _getNodeElById(treeEl, indexId) {\n        var ignoreCache = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        if (indexId == null) return null;\n        if (!this._cacheEls) this._cacheEls = {};\n        var el = this._cacheEls[indexId];\n        if (el && document.contains(el) && !ignoreCache) return el;\n        el = treeEl.querySelector('.group-or-rule-container[data-id=\"' + indexId + '\"]');\n        this._cacheEls[indexId] = el;\n        return el;\n      }\n    }, {\n      key: \"_getDraggableNodeEl\",\n      value: function _getDraggableNodeEl(treeEl) {\n        var ignoreCache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        if (!this._cacheEls) this._cacheEls = {};\n        var el = this._cacheEls[\"draggable\"];\n        if (el && document.contains(el) && !ignoreCache) return el;\n        var els = treeEl.getElementsByClassName(\"qb-draggable\");\n        el = els.length ? els[0] : null;\n        this._cacheEls[\"draggable\"] = el;\n        return el;\n      }\n    }, {\n      key: \"_getPlaceholderNodeEl\",\n      value: function _getPlaceholderNodeEl(treeEl) {\n        var ignoreCache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        if (!this._cacheEls) this._cacheEls = {};\n        var el = this._cacheEls[\"placeholder\"];\n        if (el && document.contains(el) && !ignoreCache) return el;\n        var els = treeEl.getElementsByClassName(\"qb-placeholder\");\n        el = els.length ? els[0] : null;\n        this._cacheEls[\"placeholder\"] = el;\n        return el;\n      }\n    }, {\n      key: \"_isScrollable\",\n      value: function _isScrollable(node) {\n        var overflowY = window.getComputedStyle(node)[\"overflow-y\"];\n        return (overflowY === \"scroll\" || overflowY === \"auto\") && node.scrollHeight > node.offsetHeight;\n      }\n    }, {\n      key: \"_getScrollParent\",\n      value: function _getScrollParent(node) {\n        if (node == null) return null;\n\n        if (node === document.body || this._isScrollable(node)) {\n          return node;\n        } else {\n          return this._getScrollParent(node.parentNode);\n        }\n      }\n    }, {\n      key: \"handleDrag\",\n      value: function handleDrag(dragInfo, e, canMoveFn) {\n        var _this2 = this;\n\n        var canMoveBeforeAfterGroup = true;\n        var itemInfo = dragInfo.itemInfo;\n        var paddingLeft = dragInfo.paddingLeft;\n        var moveInfo = null;\n        var treeEl = this.props.dragStart.treeEl;\n        var dragId = dragInfo.id;\n\n        var dragEl = this._getDraggableNodeEl(treeEl);\n\n        var plhEl = this._getPlaceholderNodeEl(treeEl);\n\n        var dragRect, plhRect, hovRect, treeRect;\n\n        if (dragEl && plhEl) {\n          dragRect = dragEl.getBoundingClientRect();\n          plhRect = plhEl.getBoundingClientRect();\n\n          if (!plhRect.width) {\n            return;\n          }\n\n          var dragDirs = {\n            hrz: 0,\n            vrt: 0\n          };\n          if (dragRect.top < plhRect.top) dragDirs.vrt = -1; //up\n          else if (dragRect.bottom > plhRect.bottom) dragDirs.vrt = +1; //down\n\n          if (dragRect.left > plhRect.left) dragDirs.hrz = +1; //right\n          else if (dragRect.left < plhRect.left) dragDirs.hrz = -1; //left\n\n          treeRect = treeEl.getBoundingClientRect();\n          var trgCoord = {\n            x: treeRect.left + (treeRect.right - treeRect.left) / 2,\n            y: dragDirs.vrt >= 0 ? dragRect.bottom : dragRect.top\n          };\n          var hovCNodeEl;\n\n          if (e.__mocked_hov_container) {\n            hovCNodeEl = e.__mocked_hov_container;\n          } else {\n            var hovNodeEl = document.elementFromPoint(trgCoord.x, trgCoord.y - 1);\n            hovCNodeEl = hovNodeEl ? hovNodeEl.closest(\".group-or-rule-container\") : null;\n          }\n\n          if (!hovCNodeEl) {\n            console.log(\"out of tree bounds!\");\n          } else {\n            var isGroup = hovCNodeEl.classList.contains(\"group-container\");\n            var hovNodeId = hovCNodeEl.getAttribute(\"data-id\");\n            var hovEl = hovCNodeEl;\n            var doAppend = false;\n            var doPrepend = false;\n\n            if (hovEl) {\n              hovRect = hovEl.getBoundingClientRect();\n              var hovHeight = hovRect.bottom - hovRect.top;\n              var hovII = this.tree.items[hovNodeId];\n              var trgRect = null,\n                  trgEl = null,\n                  trgII = null,\n                  altII = null; //for canMoveBeforeAfterGroup\n\n              if (dragDirs.vrt == 0) {\n                trgII = itemInfo;\n                trgEl = plhEl;\n                if (trgEl) trgRect = trgEl.getBoundingClientRect();\n              } else {\n                if (isGroup) {\n                  if (dragDirs.vrt > 0) {\n                    //down\n                    //take group header (for prepend only)\n                    var hovInnerEl = hovCNodeEl.getElementsByClassName(\"group--header\");\n                    var hovEl2 = hovInnerEl.length ? hovInnerEl[0] : null;\n\n                    if (hovEl2) {\n                      var hovRect2 = hovEl2.getBoundingClientRect();\n                      var hovHeight2 = hovRect2.bottom - hovRect2.top;\n                      var isOverHover = dragRect.bottom - hovRect2.top > hovHeight2 * 3 / 4;\n\n                      if (isOverHover && hovII.top > dragInfo.itemInfo.top) {\n                        trgII = hovII;\n                        trgRect = hovRect2;\n                        trgEl = hovEl2;\n                        doPrepend = true;\n                      }\n                    }\n                  } else if (dragDirs.vrt < 0) {\n                    //up\n                    if (hovII.lev >= itemInfo.lev) {\n                      //take whole group\n                      var isClimbToHover = hovRect.bottom - dragRect.top >= 2;\n\n                      if (isClimbToHover && hovII.top < dragInfo.itemInfo.top) {\n                        trgII = hovII;\n                        trgRect = hovRect;\n                        trgEl = hovEl;\n                        doAppend = true;\n                      }\n                    }\n                  }\n\n                  if (!doPrepend && !doAppend || canMoveBeforeAfterGroup) {\n                    //take whole group and check if we can move before/after group\n                    var _isOverHover = dragDirs.vrt < 0 //up\n                    ? hovRect.bottom - dragRect.top > hovHeight - 5 : dragRect.bottom - hovRect.top > hovHeight - 5;\n\n                    if (_isOverHover) {\n                      if (!doPrepend && !doAppend) {\n                        trgII = hovII;\n                        trgRect = hovRect;\n                        trgEl = hovEl;\n                      }\n\n                      if (canMoveBeforeAfterGroup) {\n                        altII = hovII;\n                      }\n                    }\n                  }\n                } else {\n                  //check if we can move before/after group\n                  var _isOverHover2 = dragDirs.vrt < 0 //up\n                  ? hovRect.bottom - dragRect.top > hovHeight / 2 : dragRect.bottom - hovRect.top > hovHeight / 2;\n\n                  if (_isOverHover2) {\n                    trgII = hovII;\n                    trgRect = hovRect;\n                    trgEl = hovEl;\n                  }\n                }\n              }\n\n              var isSamePos = trgII && trgII.id == dragId;\n\n              if (trgRect) {\n                var dragLeftOffset = dragRect.left - treeRect.left;\n                var trgLeftOffset = trgRect.left - treeRect.left;\n\n                var _trgLev = trgLeftOffset / paddingLeft;\n\n                var dragLev = Math.max(0, Math.round(dragLeftOffset / paddingLeft)); //find all possible moves\n\n                var availMoves = [];\n                var altMoves = []; //alternatively can move after/before group, if can't move into it\n\n                if (isSamePos) {//do nothing\n                } else {\n                  if (isGroup) {\n                    if (doAppend) {\n                      availMoves.push([constants.PLACEMENT_APPEND, trgII, trgII.lev + 1]);\n                    } else if (doPrepend) {\n                      availMoves.push([constants.PLACEMENT_PREPEND, trgII, trgII.lev + 1]);\n                    } //alt\n\n\n                    if (canMoveBeforeAfterGroup && altII) {\n                      if (dragDirs.vrt > 0) {\n                        //down\n                        altMoves.push([constants.PLACEMENT_AFTER, altII, altII.lev]);\n                      } else if (dragDirs.vrt < 0) {\n                        //up\n                        altMoves.push([constants.PLACEMENT_BEFORE, altII, altII.lev]);\n                      }\n                    }\n                  }\n\n                  if (!doAppend && !doPrepend) {\n                    if (dragDirs.vrt < 0) {\n                      //up\n                      availMoves.push([constants.PLACEMENT_BEFORE, trgII, trgII.lev]);\n                    } else if (dragDirs.vrt > 0) {\n                      //down\n                      availMoves.push([constants.PLACEMENT_AFTER, trgII, trgII.lev]);\n                    }\n                  }\n                } //sanitize\n\n\n                availMoves = availMoves.filter(function (am) {\n                  var placement = am[0];\n                  var trg = am[1];\n                  if ((placement == constants.PLACEMENT_BEFORE || placement == constants.PLACEMENT_AFTER) && trg.parent == null) return false;\n                  if (trg.collapsed && (placement == constants.PLACEMENT_APPEND || placement == constants.PLACEMENT_PREPEND)) return false;\n                  var isInside = trg.id == itemInfo.id;\n\n                  if (!isInside) {\n                    var tmp = trg;\n\n                    while (tmp.parent) {\n                      tmp = _this2.tree.items[tmp.parent];\n\n                      if (tmp.id == itemInfo.id) {\n                        isInside = true;\n                        break;\n                      }\n                    }\n                  }\n\n                  return !isInside;\n                }).map(function (am) {\n                  var placement = am[0],\n                      toII = am[1];\n                  var toParentII = null;\n                  if (placement == constants.PLACEMENT_APPEND || placement == constants.PLACEMENT_PREPEND) toParentII = toII;else toParentII = _this2.tree.items[toII.parent];\n                  if (toParentII && toParentII.parent == null) toParentII = null;\n                  am[3] = toParentII;\n                  return am;\n                });\n                var bestMode = null;\n                var filteredMoves = availMoves.filter(function (am) {\n                  return _this2.canMove(itemInfo, am[1], am[0], am[3], canMoveFn);\n                });\n\n                if (canMoveBeforeAfterGroup && filteredMoves.length == 0 && altMoves.length > 0) {\n                  filteredMoves = altMoves.filter(function (am) {\n                    return _this2.canMove(itemInfo, am[1], am[0], am[3], canMoveFn);\n                  });\n                }\n\n                var levs = filteredMoves.map(function (am) {\n                  return am[2];\n                });\n                var curLev = itemInfo.lev;\n                var allLevs = levs.concat(curLev);\n                var closestDragLev = null;\n                if (allLevs.indexOf(dragLev) != -1) closestDragLev = dragLev;else if (dragLev > Math.max.apply(Math, (0, _toConsumableArray2[\"default\"])(allLevs))) closestDragLev = Math.max.apply(Math, (0, _toConsumableArray2[\"default\"])(allLevs));else if (dragLev < Math.min.apply(Math, (0, _toConsumableArray2[\"default\"])(allLevs))) closestDragLev = Math.min.apply(Math, (0, _toConsumableArray2[\"default\"])(allLevs));\n                bestMode = filteredMoves.find(function (am) {\n                  return am[2] == closestDragLev;\n                });\n                if (!isSamePos && !bestMode && filteredMoves.length) bestMode = filteredMoves[0];\n                moveInfo = bestMode;\n              }\n            }\n          }\n        }\n\n        if (moveInfo) {\n          this.move(itemInfo, moveInfo[1], moveInfo[0], moveInfo[3]); // if (isDev())  console.log(\"DRAG-N-DROP\", JSON.stringify({\n          //   dragRect,\n          //   plhRect,\n          //   treeRect,\n          //   hovRect,\n          //   startMousePos: dragInfo.startMousePos,\n          //   mousePos: dragInfo.mousePos,\n          // }));\n\n          return true;\n        }\n\n        return false;\n      }\n    }, {\n      key: \"canMove\",\n      value: function canMove(fromII, toII, placement, toParentII, canMoveFn) {\n        if (!fromII || !toII) return false;\n        if (fromII.id === toII.id) return false;\n        var canRegroup = this.props.config.settings.canRegroup;\n        var maxNesting = this.props.config.settings.maxNesting;\n        var newLev = toParentII ? toParentII.lev : 0;\n        var isPend = placement == constants.PLACEMENT_PREPEND || placement == constants.PLACEMENT_APPEND;\n        var isParentChange = fromII.parent != toII.parent;\n        var isStructChange = isPend || isParentChange;\n        var isForbiddenStructChange = fromII.parentType == \"rule_group\" || toII.type == \"rule_group\" || toII.parentType == \"rule_group\";\n        var isLockedChange = toII.isLocked || fromII.isLocked || toParentII && toParentII.isLocked;\n        if (maxNesting && newLev + 1 > maxNesting) return false;\n        if (isStructChange && (!canRegroup || isForbiddenStructChange || isLockedChange)) return false;\n        var res = true;\n        if (canMoveFn) res = canMoveFn(fromII.node.toJS(), toII.node.toJS(), placement, toParentII ? toParentII.node.toJS() : null);\n        return res;\n      }\n    }, {\n      key: \"move\",\n      value: function move(fromII, toII, placement, toParentII) {\n        //if (isDev())  console.log(\"move\", fromII, toII, placement, toParentII);\n        this.props.actions.moveItem(fromII.path, toII.path, placement);\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        return /*#__PURE__*/_react[\"default\"].createElement(Builder, (0, _extends2[\"default\"])({}, this.props, {\n          onDragStart: this.onDragStart\n        }));\n      }\n    }]);\n    return SortableContainer;\n  }(_react.Component), _class.propTypes = {\n    tree: _propTypes[\"default\"].any.isRequired,\n    //instanceOf(Immutable.Map)\n    actions: _propTypes[\"default\"].object.isRequired // {moveItem: Function, ..}\n    //... see Builder\n\n  }, _temp;\n};\n\nvar _default = function _default(Builder) {\n  var CanMoveFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var ConnectedSortableContainer = (0, _reactRedux.connect)(function (state) {\n    return {\n      dragging: state.dragging,\n      dragStart: state.dragStart,\n      mousePos: state.mousePos\n    };\n  }, {\n    setDragStart: actions.drag.setDragStart,\n    setDragProgress: actions.drag.setDragProgress,\n    setDragEnd: actions.drag.setDragEnd\n  }, null, {\n    context: _context[\"default\"]\n  })(createSortableContainer(Builder, CanMoveFn));\n  ConnectedSortableContainer.displayName = \"ConnectedSortableContainer\";\n  return ConnectedSortableContainer;\n};\n\nexports[\"default\"] = _default;","map":{"version":3,"sources":["D:/Postgres_workingFolder/QuaLISWeb/node_modules/react-awesome-query-builder/lib/components/containers/SortableContainer.js"],"names":["_interopRequireDefault","require","_typeof","Object","defineProperty","exports","value","_extends2","_toConsumableArray2","_classCallCheck2","_createClass2","_assertThisInitialized2","_inherits2","_possibleConstructorReturn2","_getPrototypeOf2","_react","_interopRequireWildcard","_reactRedux","_treeUtils","_context","constants","_clone","_propTypes","actions","_reactUtils","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","obj","__esModule","cache","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","_createSuper","Derived","hasNativeReflectConstruct","_isNativeReflectConstruct","_createSuperInternal","Super","result","NewTarget","constructor","Reflect","construct","arguments","apply","sham","Proxy","Boolean","valueOf","e","isDev","process","env","NODE_ENV","createSortableContainer","Builder","_class","_temp","CanMoveFn","length","undefined","_Component","SortableContainer","_super","props","_this","_getEventTarget","dragStart","__mocked_window","document","body","window","onDragStart","id","dom","treeEl","closest","classList","add","treeElContainer","_getScrollParent","scrollTop","_dragEl","_getDraggableNodeEl","_plhEl","_getPlaceholderNodeEl","tmpAllGroups","querySelectorAll","anyGroup","groupPadding","getComputedStyle","getPropertyValue","parseInt","dragging","x","offsetLeft","y","offsetTop","w","offsetWidth","h","offsetHeight","itemInfo","tree","items","paddingLeft","clientX","clientY","mousePos","target","eventTarget","addEventListener","onDrag","onDragEnd","setDragStart","doHandleDrag","assign","startDragging","startMousePos","__mock_dom","dragEl","plhEl","plX","_treeEl","_plhEl2","getBoundingClientRect","left","scrollX","plY","top","scrollY","startX","startY","startClientX","startClientY","startScrollTop","pos","setDragProgress","moved","handleDrag","preventDefault","setDragEnd","remove","_cacheEls","removeEventListener","useOnPropsChanged","onPropsChanged","nextProps","getFlatTree","shouldComponentUpdate","nextState","prevProps","prevState","state","should","pureShouldComponentUpdate","chs","k","changed","push","componentDidUpdate","_prevProps","_prevState","index","parent","oldPlX","oldPlY","_getNodeElById","indexId","ignoreCache","el","contains","querySelector","els","getElementsByClassName","_isScrollable","node","overflowY","scrollHeight","parentNode","dragInfo","canMoveFn","_this2","canMoveBeforeAfterGroup","moveInfo","dragId","dragRect","plhRect","hovRect","treeRect","width","dragDirs","hrz","vrt","bottom","trgCoord","right","hovCNodeEl","__mocked_hov_container","hovNodeEl","elementFromPoint","console","log","isGroup","hovNodeId","getAttribute","hovEl","doAppend","doPrepend","hovHeight","hovII","trgRect","trgEl","trgII","altII","hovInnerEl","hovEl2","hovRect2","hovHeight2","isOverHover","lev","isClimbToHover","_isOverHover","_isOverHover2","isSamePos","dragLeftOffset","trgLeftOffset","_trgLev","dragLev","Math","max","round","availMoves","altMoves","PLACEMENT_APPEND","PLACEMENT_PREPEND","PLACEMENT_AFTER","PLACEMENT_BEFORE","filter","am","placement","trg","collapsed","isInside","tmp","map","toII","toParentII","bestMode","filteredMoves","canMove","levs","curLev","allLevs","concat","closestDragLev","indexOf","min","find","move","fromII","canRegroup","config","settings","maxNesting","newLev","isPend","isParentChange","isStructChange","isForbiddenStructChange","parentType","type","isLockedChange","isLocked","res","toJS","moveItem","path","render","createElement","Component","propTypes","any","isRequired","object","_default","ConnectedSortableContainer","connect","drag","context","displayName"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _typeof = require(\"@babel/runtime/helpers/typeof\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime/helpers/assertThisInitialized\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _react = _interopRequireWildcard(require(\"react\"));\n\nvar _reactRedux = require(\"react-redux\");\n\nvar _treeUtils = require(\"../../utils/treeUtils\");\n\nvar _context = _interopRequireDefault(require(\"../../stores/context\"));\n\nvar constants = _interopRequireWildcard(require(\"../../constants\"));\n\nvar _clone = _interopRequireDefault(require(\"clone\"));\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar actions = _interopRequireWildcard(require(\"../../actions\"));\n\nvar _reactUtils = require(\"../../utils/reactUtils\");\n\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\n\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") { return { \"default\": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj[\"default\"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2[\"default\"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2[\"default\"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2[\"default\"])(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nvar isDev = function isDev() {\n  return process && process.env && process.env.NODE_ENV == \"development\";\n};\n\nvar createSortableContainer = function createSortableContainer(Builder) {\n  var _class, _temp;\n\n  var CanMoveFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  return _temp = _class = /*#__PURE__*/function (_Component) {\n    (0, _inherits2[\"default\"])(SortableContainer, _Component);\n\n    var _super = _createSuper(SortableContainer);\n\n    function SortableContainer(props) {\n      var _this;\n\n      (0, _classCallCheck2[\"default\"])(this, SortableContainer);\n      _this = _super.call(this, props);\n\n      _this._getEventTarget = function (e, dragStart) {\n        return e && e.__mocked_window || document.body || window;\n      };\n\n      _this.onDragStart = function (id, dom, e) {\n        var treeEl = dom.closest(\".query-builder\");\n        document.body.classList.add(\"qb-dragging\");\n        treeEl.classList.add(\"qb-dragging\");\n        var treeElContainer = treeEl.closest(\".query-builder-container\") || treeEl;\n        treeElContainer = _this._getScrollParent(treeElContainer) || document.body;\n        var scrollTop = treeElContainer.scrollTop;\n\n        var _dragEl = _this._getDraggableNodeEl(treeEl);\n\n        var _plhEl = _this._getPlaceholderNodeEl(treeEl);\n\n        var tmpAllGroups = treeEl.querySelectorAll(\".group--children\");\n        var anyGroup = tmpAllGroups.length ? tmpAllGroups[0] : null;\n        var groupPadding;\n\n        if (anyGroup) {\n          groupPadding = window.getComputedStyle(anyGroup, null).getPropertyValue(\"padding-left\");\n          groupPadding = parseInt(groupPadding);\n        }\n\n        var dragging = {\n          id: id,\n          x: dom.offsetLeft,\n          y: dom.offsetTop,\n          w: dom.offsetWidth,\n          h: dom.offsetHeight,\n          itemInfo: _this.tree.items[id],\n          paddingLeft: groupPadding\n        };\n        var dragStart = {\n          id: id,\n          x: dom.offsetLeft,\n          y: dom.offsetTop,\n          scrollTop: scrollTop,\n          clientX: e.clientX,\n          clientY: e.clientY,\n          itemInfo: (0, _clone[\"default\"])(_this.tree.items[id]),\n          treeEl: treeEl,\n          treeElContainer: treeElContainer\n        };\n        var mousePos = {\n          clientX: e.clientX,\n          clientY: e.clientY\n        };\n\n        var target = _this._getEventTarget(e, dragStart);\n\n        _this.eventTarget = target;\n        target.addEventListener(\"mousemove\", _this.onDrag);\n        target.addEventListener(\"mouseup\", _this.onDragEnd);\n\n        _this.props.setDragStart(dragStart, dragging, mousePos);\n      };\n\n      _this.onDrag = function (e) {\n        var doHandleDrag = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        var dragging = Object.assign({}, _this.props.dragging);\n        var startDragging = _this.props.dragStart;\n        var paddingLeft = dragging.paddingLeft; //this.props.paddingLeft;\n\n        var treeElContainer = startDragging.treeElContainer;\n        var scrollTop = treeElContainer.scrollTop;\n        dragging.itemInfo = _this.tree.items[dragging.id];\n\n        if (!dragging.itemInfo) {\n          return;\n        }\n\n        var mousePos = {\n          clientX: e.clientX,\n          clientY: e.clientY\n        };\n        var startMousePos = {\n          clientX: startDragging.clientX,\n          clientY: startDragging.clientY\n        };\n\n        if (e.__mock_dom) {\n          var treeEl = startDragging.treeEl;\n\n          var dragEl = _this._getDraggableNodeEl(treeEl);\n\n          var plhEl = _this._getPlaceholderNodeEl(treeEl);\n\n          e.__mock_dom({\n            treeEl: treeEl,\n            dragEl: dragEl,\n            plhEl: plhEl\n          });\n        } //first init plX/plY\n\n\n        if (!startDragging.plX) {\n          var _treeEl = startDragging.treeEl;\n\n          var _plhEl2 = _this._getPlaceholderNodeEl(_treeEl);\n\n          if (_plhEl2) {\n            startDragging.plX = _plhEl2.getBoundingClientRect().left + window.scrollX;\n            startDragging.plY = _plhEl2.getBoundingClientRect().top + window.scrollY;\n          }\n        }\n\n        var startX = startDragging.x;\n        var startY = startDragging.y;\n        var startClientX = startDragging.clientX;\n        var startClientY = startDragging.clientY;\n        var startScrollTop = startDragging.scrollTop;\n        var pos = {\n          x: startX + (e.clientX - startClientX),\n          y: startY + (e.clientY - startClientY) + (scrollTop - startScrollTop)\n        };\n        dragging.x = pos.x;\n        dragging.y = pos.y;\n        dragging.paddingLeft = paddingLeft;\n        dragging.mousePos = mousePos;\n        dragging.startMousePos = startMousePos;\n\n        _this.props.setDragProgress(mousePos, dragging);\n\n        var moved = doHandleDrag ? _this.handleDrag(dragging, e, CanMoveFn) : false;\n\n        if (!moved) {\n          if (e.preventDefault) e.preventDefault();\n        }\n      };\n\n      _this.onDragEnd = function () {\n        var treeEl = _this.props.dragStart.treeEl;\n\n        _this.props.setDragEnd();\n\n        treeEl.classList.remove(\"qb-dragging\");\n        document.body.classList.remove(\"qb-dragging\");\n        _this._cacheEls = {};\n\n        var target = _this.eventTarget || _this._getEventTarget();\n\n        target.removeEventListener(\"mousemove\", _this.onDrag);\n        target.removeEventListener(\"mouseup\", _this.onDragEnd);\n      };\n\n      (0, _reactUtils.useOnPropsChanged)((0, _assertThisInitialized2[\"default\"])(_this));\n\n      _this.onPropsChanged(props);\n\n      return _this;\n    }\n\n    (0, _createClass2[\"default\"])(SortableContainer, [{\n      key: \"onPropsChanged\",\n      value: function onPropsChanged(nextProps) {\n        this.tree = (0, _treeUtils.getFlatTree)(nextProps.tree);\n      }\n    }, {\n      key: \"shouldComponentUpdate\",\n      value: function shouldComponentUpdate(nextProps, nextState) {\n        var prevProps = this.props;\n        var prevState = this.state;\n        var should = (0, _reactUtils.pureShouldComponentUpdate)(this)(nextProps, nextState);\n\n        if (should) {\n          if (prevState == nextState && prevProps != nextProps) {\n            var chs = [];\n\n            for (var k in nextProps) {\n              var changed = nextProps[k] != prevProps[k];\n\n              if (changed) {\n                //don't render <Builder> on dragging - appropriate redux-connected components will do it\n                if (k != \"dragging\" && k != \"mousePos\") chs.push(k);\n              }\n            }\n\n            if (!chs.length) should = false;\n          }\n        }\n\n        return should;\n      }\n    }, {\n      key: \"componentDidUpdate\",\n      value: function componentDidUpdate(_prevProps, _prevState) {\n        var dragging = this.props.dragging;\n        var startDragging = this.props.dragStart;\n\n        if (startDragging && startDragging.id) {\n          dragging.itemInfo = this.tree.items[dragging.id];\n\n          if (dragging.itemInfo) {\n            if (dragging.itemInfo.index != startDragging.itemInfo.index || dragging.itemInfo.parent != startDragging.itemInfo.parent) {\n              var treeEl = startDragging.treeEl;\n              var treeElContainer = startDragging.treeElContainer;\n\n              var plhEl = this._getPlaceholderNodeEl(treeEl, true);\n\n              if (plhEl) {\n                var plX = plhEl.getBoundingClientRect().left + window.scrollX;\n                var plY = plhEl.getBoundingClientRect().top + window.scrollY;\n                var oldPlX = startDragging.plX;\n                var oldPlY = startDragging.plY;\n                var scrollTop = treeElContainer.scrollTop;\n                startDragging.plX = plX;\n                startDragging.plY = plY;\n                startDragging.itemInfo = (0, _clone[\"default\"])(dragging.itemInfo);\n                startDragging.y = plhEl.offsetTop;\n                startDragging.x = plhEl.offsetLeft;\n                startDragging.clientY += plY - oldPlY;\n                startDragging.clientX += plX - oldPlX;\n                if (treeElContainer != document.body) startDragging.scrollTop = scrollTop;\n                this.onDrag(this.props.mousePos, false);\n              }\n            }\n          }\n        }\n      }\n    }, {\n      key: \"_getNodeElById\",\n      value: function _getNodeElById(treeEl, indexId) {\n        var ignoreCache = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        if (indexId == null) return null;\n        if (!this._cacheEls) this._cacheEls = {};\n        var el = this._cacheEls[indexId];\n        if (el && document.contains(el) && !ignoreCache) return el;\n        el = treeEl.querySelector('.group-or-rule-container[data-id=\"' + indexId + '\"]');\n        this._cacheEls[indexId] = el;\n        return el;\n      }\n    }, {\n      key: \"_getDraggableNodeEl\",\n      value: function _getDraggableNodeEl(treeEl) {\n        var ignoreCache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        if (!this._cacheEls) this._cacheEls = {};\n        var el = this._cacheEls[\"draggable\"];\n        if (el && document.contains(el) && !ignoreCache) return el;\n        var els = treeEl.getElementsByClassName(\"qb-draggable\");\n        el = els.length ? els[0] : null;\n        this._cacheEls[\"draggable\"] = el;\n        return el;\n      }\n    }, {\n      key: \"_getPlaceholderNodeEl\",\n      value: function _getPlaceholderNodeEl(treeEl) {\n        var ignoreCache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        if (!this._cacheEls) this._cacheEls = {};\n        var el = this._cacheEls[\"placeholder\"];\n        if (el && document.contains(el) && !ignoreCache) return el;\n        var els = treeEl.getElementsByClassName(\"qb-placeholder\");\n        el = els.length ? els[0] : null;\n        this._cacheEls[\"placeholder\"] = el;\n        return el;\n      }\n    }, {\n      key: \"_isScrollable\",\n      value: function _isScrollable(node) {\n        var overflowY = window.getComputedStyle(node)[\"overflow-y\"];\n        return (overflowY === \"scroll\" || overflowY === \"auto\") && node.scrollHeight > node.offsetHeight;\n      }\n    }, {\n      key: \"_getScrollParent\",\n      value: function _getScrollParent(node) {\n        if (node == null) return null;\n\n        if (node === document.body || this._isScrollable(node)) {\n          return node;\n        } else {\n          return this._getScrollParent(node.parentNode);\n        }\n      }\n    }, {\n      key: \"handleDrag\",\n      value: function handleDrag(dragInfo, e, canMoveFn) {\n        var _this2 = this;\n\n        var canMoveBeforeAfterGroup = true;\n        var itemInfo = dragInfo.itemInfo;\n        var paddingLeft = dragInfo.paddingLeft;\n        var moveInfo = null;\n        var treeEl = this.props.dragStart.treeEl;\n        var dragId = dragInfo.id;\n\n        var dragEl = this._getDraggableNodeEl(treeEl);\n\n        var plhEl = this._getPlaceholderNodeEl(treeEl);\n\n        var dragRect, plhRect, hovRect, treeRect;\n\n        if (dragEl && plhEl) {\n          dragRect = dragEl.getBoundingClientRect();\n          plhRect = plhEl.getBoundingClientRect();\n\n          if (!plhRect.width) {\n            return;\n          }\n\n          var dragDirs = {\n            hrz: 0,\n            vrt: 0\n          };\n          if (dragRect.top < plhRect.top) dragDirs.vrt = -1; //up\n          else if (dragRect.bottom > plhRect.bottom) dragDirs.vrt = +1; //down\n\n          if (dragRect.left > plhRect.left) dragDirs.hrz = +1; //right\n          else if (dragRect.left < plhRect.left) dragDirs.hrz = -1; //left\n\n          treeRect = treeEl.getBoundingClientRect();\n          var trgCoord = {\n            x: treeRect.left + (treeRect.right - treeRect.left) / 2,\n            y: dragDirs.vrt >= 0 ? dragRect.bottom : dragRect.top\n          };\n          var hovCNodeEl;\n\n          if (e.__mocked_hov_container) {\n            hovCNodeEl = e.__mocked_hov_container;\n          } else {\n            var hovNodeEl = document.elementFromPoint(trgCoord.x, trgCoord.y - 1);\n            hovCNodeEl = hovNodeEl ? hovNodeEl.closest(\".group-or-rule-container\") : null;\n          }\n\n          if (!hovCNodeEl) {\n            console.log(\"out of tree bounds!\");\n          } else {\n            var isGroup = hovCNodeEl.classList.contains(\"group-container\");\n            var hovNodeId = hovCNodeEl.getAttribute(\"data-id\");\n            var hovEl = hovCNodeEl;\n            var doAppend = false;\n            var doPrepend = false;\n\n            if (hovEl) {\n              hovRect = hovEl.getBoundingClientRect();\n              var hovHeight = hovRect.bottom - hovRect.top;\n              var hovII = this.tree.items[hovNodeId];\n              var trgRect = null,\n                  trgEl = null,\n                  trgII = null,\n                  altII = null; //for canMoveBeforeAfterGroup\n\n              if (dragDirs.vrt == 0) {\n                trgII = itemInfo;\n                trgEl = plhEl;\n                if (trgEl) trgRect = trgEl.getBoundingClientRect();\n              } else {\n                if (isGroup) {\n                  if (dragDirs.vrt > 0) {\n                    //down\n                    //take group header (for prepend only)\n                    var hovInnerEl = hovCNodeEl.getElementsByClassName(\"group--header\");\n                    var hovEl2 = hovInnerEl.length ? hovInnerEl[0] : null;\n\n                    if (hovEl2) {\n                      var hovRect2 = hovEl2.getBoundingClientRect();\n                      var hovHeight2 = hovRect2.bottom - hovRect2.top;\n                      var isOverHover = dragRect.bottom - hovRect2.top > hovHeight2 * 3 / 4;\n\n                      if (isOverHover && hovII.top > dragInfo.itemInfo.top) {\n                        trgII = hovII;\n                        trgRect = hovRect2;\n                        trgEl = hovEl2;\n                        doPrepend = true;\n                      }\n                    }\n                  } else if (dragDirs.vrt < 0) {\n                    //up\n                    if (hovII.lev >= itemInfo.lev) {\n                      //take whole group\n                      var isClimbToHover = hovRect.bottom - dragRect.top >= 2;\n\n                      if (isClimbToHover && hovII.top < dragInfo.itemInfo.top) {\n                        trgII = hovII;\n                        trgRect = hovRect;\n                        trgEl = hovEl;\n                        doAppend = true;\n                      }\n                    }\n                  }\n\n                  if (!doPrepend && !doAppend || canMoveBeforeAfterGroup) {\n                    //take whole group and check if we can move before/after group\n                    var _isOverHover = dragDirs.vrt < 0 //up\n                    ? hovRect.bottom - dragRect.top > hovHeight - 5 : dragRect.bottom - hovRect.top > hovHeight - 5;\n\n                    if (_isOverHover) {\n                      if (!doPrepend && !doAppend) {\n                        trgII = hovII;\n                        trgRect = hovRect;\n                        trgEl = hovEl;\n                      }\n\n                      if (canMoveBeforeAfterGroup) {\n                        altII = hovII;\n                      }\n                    }\n                  }\n                } else {\n                  //check if we can move before/after group\n                  var _isOverHover2 = dragDirs.vrt < 0 //up\n                  ? hovRect.bottom - dragRect.top > hovHeight / 2 : dragRect.bottom - hovRect.top > hovHeight / 2;\n\n                  if (_isOverHover2) {\n                    trgII = hovII;\n                    trgRect = hovRect;\n                    trgEl = hovEl;\n                  }\n                }\n              }\n\n              var isSamePos = trgII && trgII.id == dragId;\n\n              if (trgRect) {\n                var dragLeftOffset = dragRect.left - treeRect.left;\n                var trgLeftOffset = trgRect.left - treeRect.left;\n\n                var _trgLev = trgLeftOffset / paddingLeft;\n\n                var dragLev = Math.max(0, Math.round(dragLeftOffset / paddingLeft)); //find all possible moves\n\n                var availMoves = [];\n                var altMoves = []; //alternatively can move after/before group, if can't move into it\n\n                if (isSamePos) {//do nothing\n                } else {\n                  if (isGroup) {\n                    if (doAppend) {\n                      availMoves.push([constants.PLACEMENT_APPEND, trgII, trgII.lev + 1]);\n                    } else if (doPrepend) {\n                      availMoves.push([constants.PLACEMENT_PREPEND, trgII, trgII.lev + 1]);\n                    } //alt\n\n\n                    if (canMoveBeforeAfterGroup && altII) {\n                      if (dragDirs.vrt > 0) {\n                        //down\n                        altMoves.push([constants.PLACEMENT_AFTER, altII, altII.lev]);\n                      } else if (dragDirs.vrt < 0) {\n                        //up\n                        altMoves.push([constants.PLACEMENT_BEFORE, altII, altII.lev]);\n                      }\n                    }\n                  }\n\n                  if (!doAppend && !doPrepend) {\n                    if (dragDirs.vrt < 0) {\n                      //up\n                      availMoves.push([constants.PLACEMENT_BEFORE, trgII, trgII.lev]);\n                    } else if (dragDirs.vrt > 0) {\n                      //down\n                      availMoves.push([constants.PLACEMENT_AFTER, trgII, trgII.lev]);\n                    }\n                  }\n                } //sanitize\n\n\n                availMoves = availMoves.filter(function (am) {\n                  var placement = am[0];\n                  var trg = am[1];\n                  if ((placement == constants.PLACEMENT_BEFORE || placement == constants.PLACEMENT_AFTER) && trg.parent == null) return false;\n                  if (trg.collapsed && (placement == constants.PLACEMENT_APPEND || placement == constants.PLACEMENT_PREPEND)) return false;\n                  var isInside = trg.id == itemInfo.id;\n\n                  if (!isInside) {\n                    var tmp = trg;\n\n                    while (tmp.parent) {\n                      tmp = _this2.tree.items[tmp.parent];\n\n                      if (tmp.id == itemInfo.id) {\n                        isInside = true;\n                        break;\n                      }\n                    }\n                  }\n\n                  return !isInside;\n                }).map(function (am) {\n                  var placement = am[0],\n                      toII = am[1];\n                  var toParentII = null;\n                  if (placement == constants.PLACEMENT_APPEND || placement == constants.PLACEMENT_PREPEND) toParentII = toII;else toParentII = _this2.tree.items[toII.parent];\n                  if (toParentII && toParentII.parent == null) toParentII = null;\n                  am[3] = toParentII;\n                  return am;\n                });\n                var bestMode = null;\n                var filteredMoves = availMoves.filter(function (am) {\n                  return _this2.canMove(itemInfo, am[1], am[0], am[3], canMoveFn);\n                });\n\n                if (canMoveBeforeAfterGroup && filteredMoves.length == 0 && altMoves.length > 0) {\n                  filteredMoves = altMoves.filter(function (am) {\n                    return _this2.canMove(itemInfo, am[1], am[0], am[3], canMoveFn);\n                  });\n                }\n\n                var levs = filteredMoves.map(function (am) {\n                  return am[2];\n                });\n                var curLev = itemInfo.lev;\n                var allLevs = levs.concat(curLev);\n                var closestDragLev = null;\n                if (allLevs.indexOf(dragLev) != -1) closestDragLev = dragLev;else if (dragLev > Math.max.apply(Math, (0, _toConsumableArray2[\"default\"])(allLevs))) closestDragLev = Math.max.apply(Math, (0, _toConsumableArray2[\"default\"])(allLevs));else if (dragLev < Math.min.apply(Math, (0, _toConsumableArray2[\"default\"])(allLevs))) closestDragLev = Math.min.apply(Math, (0, _toConsumableArray2[\"default\"])(allLevs));\n                bestMode = filteredMoves.find(function (am) {\n                  return am[2] == closestDragLev;\n                });\n                if (!isSamePos && !bestMode && filteredMoves.length) bestMode = filteredMoves[0];\n                moveInfo = bestMode;\n              }\n            }\n          }\n        }\n\n        if (moveInfo) {\n          this.move(itemInfo, moveInfo[1], moveInfo[0], moveInfo[3]); // if (isDev())  console.log(\"DRAG-N-DROP\", JSON.stringify({\n          //   dragRect,\n          //   plhRect,\n          //   treeRect,\n          //   hovRect,\n          //   startMousePos: dragInfo.startMousePos,\n          //   mousePos: dragInfo.mousePos,\n          // }));\n\n          return true;\n        }\n\n        return false;\n      }\n    }, {\n      key: \"canMove\",\n      value: function canMove(fromII, toII, placement, toParentII, canMoveFn) {\n        if (!fromII || !toII) return false;\n        if (fromII.id === toII.id) return false;\n        var canRegroup = this.props.config.settings.canRegroup;\n        var maxNesting = this.props.config.settings.maxNesting;\n        var newLev = toParentII ? toParentII.lev : 0;\n        var isPend = placement == constants.PLACEMENT_PREPEND || placement == constants.PLACEMENT_APPEND;\n        var isParentChange = fromII.parent != toII.parent;\n        var isStructChange = isPend || isParentChange;\n        var isForbiddenStructChange = fromII.parentType == \"rule_group\" || toII.type == \"rule_group\" || toII.parentType == \"rule_group\";\n        var isLockedChange = toII.isLocked || fromII.isLocked || toParentII && toParentII.isLocked;\n        if (maxNesting && newLev + 1 > maxNesting) return false;\n        if (isStructChange && (!canRegroup || isForbiddenStructChange || isLockedChange)) return false;\n        var res = true;\n        if (canMoveFn) res = canMoveFn(fromII.node.toJS(), toII.node.toJS(), placement, toParentII ? toParentII.node.toJS() : null);\n        return res;\n      }\n    }, {\n      key: \"move\",\n      value: function move(fromII, toII, placement, toParentII) {\n        //if (isDev())  console.log(\"move\", fromII, toII, placement, toParentII);\n        this.props.actions.moveItem(fromII.path, toII.path, placement);\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        return /*#__PURE__*/_react[\"default\"].createElement(Builder, (0, _extends2[\"default\"])({}, this.props, {\n          onDragStart: this.onDragStart\n        }));\n      }\n    }]);\n    return SortableContainer;\n  }(_react.Component), _class.propTypes = {\n    tree: _propTypes[\"default\"].any.isRequired,\n    //instanceOf(Immutable.Map)\n    actions: _propTypes[\"default\"].object.isRequired // {moveItem: Function, ..}\n    //... see Builder\n\n  }, _temp;\n};\n\nvar _default = function _default(Builder) {\n  var CanMoveFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var ConnectedSortableContainer = (0, _reactRedux.connect)(function (state) {\n    return {\n      dragging: state.dragging,\n      dragStart: state.dragStart,\n      mousePos: state.mousePos\n    };\n  }, {\n    setDragStart: actions.drag.setDragStart,\n    setDragProgress: actions.drag.setDragProgress,\n    setDragEnd: actions.drag.setDragEnd\n  }, null, {\n    context: _context[\"default\"]\n  })(createSortableContainer(Builder, CanMoveFn));\n  ConnectedSortableContainer.displayName = \"ConnectedSortableContainer\";\n  return ConnectedSortableContainer;\n};\n\nexports[\"default\"] = _default;"]},"metadata":{},"sourceType":"script"}