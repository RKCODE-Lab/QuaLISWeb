{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.loadFromSpel = exports._loadFromSpel = void 0;\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _spel2js = require(\"spel2js\");\n\nvar _uuid = _interopRequireDefault(require(\"../utils/uuid\"));\n\nvar _configUtils = require(\"../utils/configUtils\");\n\nvar _ruleUtils = require(\"../utils/ruleUtils\");\n\nvar _tree = require(\"./tree\");\n\nvar _defaultUtils = require(\"../utils/defaultUtils\");\n\nvar _stuff = require(\"../utils/stuff\");\n\nvar _moment = _interopRequireDefault(require(\"moment\"));\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      (0, _defineProperty2[\"default\"])(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nvar loadFromSpel = function loadFromSpel(logicTree, config) {\n  return _loadFromSpel(logicTree, config, true);\n};\n\nexports.loadFromSpel = loadFromSpel;\n\nvar _loadFromSpel = function _loadFromSpel(spelStr, config) {\n  var returnErrors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true; //meta is mutable\n\n  var meta = {\n    errors: []\n  };\n  var extendedConfig = (0, _configUtils.extendConfig)(config);\n  var conv = buildConv(extendedConfig);\n  var compiledExpression;\n  var convertedObj;\n  var jsTree = undefined;\n\n  try {\n    var compileRes = _spel2js.SpelExpressionEvaluator.compile(spelStr);\n\n    compiledExpression = compileRes._compiledExpression;\n  } catch (e) {\n    meta.errors.push(e);\n  }\n\n  if (compiledExpression) {\n    _stuff.logger.debug(\"compiledExpression:\", compiledExpression);\n\n    convertedObj = convertCompiled(compiledExpression, meta);\n\n    _stuff.logger.debug(\"convertedObj:\", convertedObj, meta);\n\n    jsTree = convertToTree(convertedObj, conv, extendedConfig, meta);\n\n    if (jsTree && jsTree.type != \"group\" && jsTree.type != \"switch_group\") {\n      jsTree = wrapInDefaultConj(jsTree, extendedConfig);\n    }\n\n    _stuff.logger.debug(\"jsTree:\", jsTree);\n  }\n\n  var immTree = jsTree ? (0, _tree.loadTree)(jsTree) : undefined;\n\n  if (returnErrors) {\n    return [immTree, meta.errors];\n  } else {\n    if (meta.errors.length) console.warn(\"Errors while importing from SpEL:\", meta.errors);\n    return immTree;\n  }\n};\n\nexports._loadFromSpel = _loadFromSpel;\n\nvar convertCompiled = function convertCompiled(expr, meta) {\n  var parentExpr = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var type = expr.getType();\n  var children = expr.getChildren().map(function (child) {\n    return convertCompiled(child, meta, expr);\n  }); // flatize OR/AND\n\n  if (type == \"op-or\" || type == \"op-and\") {\n    children = children.reduce(function (acc, child) {\n      var canFlatize = child.type == type && !child.not;\n      var flat = canFlatize ? child.children : [child];\n      return [].concat((0, _toConsumableArray2[\"default\"])(acc), (0, _toConsumableArray2[\"default\"])(flat));\n    }, []);\n  } // unwrap NOT\n\n\n  if (type == \"op-not\") {\n    if (children.length != 1) {\n      meta.errors.push(\"Operator NOT should have 1 child, but got \".concat(children.length, \"}\"));\n    }\n\n    return _objectSpread(_objectSpread({}, children[0]), {}, {\n      not: !(children[0].not || false)\n    });\n  }\n\n  if (type == \"compound\") {\n    // remove `.?[true]`\n    children = children.filter(function (child) {\n      var isListFix = child.type == \"selection\" && child.children.length == 1 && child.children[0].type == \"boolean\" && child.children[0].val == true;\n      return !isListFix;\n    }); // aggregation\n    // eg. `results.?[product == 'abc'].length`\n\n    var selection = children.find(function (child) {\n      return child.type == \"selection\";\n    });\n\n    if (selection && selection.children.length != 1) {\n      meta.errors.push(\"Selection should have 1 child, but got \".concat(selection.children.length));\n    }\n\n    var filter = selection ? selection.children[0] : null;\n    var lastChild = children[children.length - 1];\n    var isSize = lastChild.type == \"method\" && lastChild.val.methodName == \"size\" || lastChild.type == \"!func\" && lastChild.methodName == \"size\";\n    var isLength = lastChild.type == \"property\" && lastChild.val == \"length\";\n    var sourceParts = children.filter(function (child) {\n      return child !== selection && child !== lastChild;\n    });\n    var source = {\n      type: \"compound\",\n      children: sourceParts\n    };\n\n    if (isSize || isLength) {\n      return {\n        type: \"!aggr\",\n        filter: filter,\n        source: source\n      };\n    } // remove `#this`, `#root`\n\n\n    children = children.filter(function (child) {\n      var isThis = child.type == \"variable\" && child.val == \"this\";\n      var isRoot = child.type == \"variable\" && child.val == \"root\";\n      return !(isThis || isRoot);\n    }); // indexer\n\n    children = children.map(function (child) {\n      if (child.type == \"indexer\" && child.children.length == 1) {\n        return {\n          type: \"indexer\",\n          val: child.children[0].val,\n          itype: child.children[0].type\n        };\n      } else {\n        return child;\n      }\n    }); // method\n\n    if (lastChild.type == \"method\") {\n      var obj = children.filter(function (child) {\n        return child !== lastChild;\n      });\n      return {\n        type: \"!func\",\n        obj: obj,\n        methodName: lastChild.val.methodName,\n        args: lastChild.val.args\n      };\n    } // !func\n\n\n    if (lastChild.type == \"!func\") {\n      var _obj = children.filter(function (child) {\n        return child !== lastChild;\n      });\n\n      return _objectSpread(_objectSpread({}, lastChild), {}, {\n        obj: _obj\n      });\n    }\n  } // getRaw || getValue\n\n\n  var val;\n\n  try {\n    if (expr.getRaw) {\n      // use my fork\n      val = expr.getRaw();\n    } else if (expr.getValue.length == 0) {\n      // getValue not requires context arg -> can use\n      val = expr.getValue();\n    }\n  } catch (e) {\n    _stuff.logger.error(\"[spel2js] Error in getValue()\", e);\n  } // ternary\n\n\n  if (type == \"ternary\") {\n    val = flatizeTernary(children);\n  } // convert method/function args\n\n\n  if ((0, _typeof2[\"default\"])(val) === \"object\" && val !== null) {\n    if (val.methodName || val.functionName) {\n      val.args = val.args.map(function (child) {\n        return convertCompiled(child, meta, expr);\n      });\n    }\n  } // convert list\n\n\n  if (type == \"list\") {\n    val = val.map(function (item) {\n      return convertCompiled(item, meta, expr);\n    }); // fix whole expression wrapped in `{}`\n\n    if (!parentExpr && val.length == 1) {\n      return val[0];\n    }\n  } // convert constructor\n\n\n  if (type == \"constructorref\") {\n    var qid = children.find(function (child) {\n      return child.type == \"qualifiedidentifier\";\n    });\n    var cls = qid === null || qid === void 0 ? void 0 : qid.val;\n\n    if (!cls) {\n      meta.errors.push(\"Can't find qualifiedidentifier in constructorref children: \".concat(JSON.stringify(children)));\n      return undefined;\n    }\n\n    var args = children.filter(function (child) {\n      return child.type != \"qualifiedidentifier\";\n    });\n    return {\n      type: \"!new\",\n      cls: cls,\n      args: args\n    };\n  } // convert type\n\n\n  if (type == \"typeref\") {\n    var _qid = children.find(function (child) {\n      return child.type == \"qualifiedidentifier\";\n    });\n\n    var _cls = _qid === null || _qid === void 0 ? void 0 : _qid.val;\n\n    if (!_cls) {\n      meta.errors.push(\"Can't find qualifiedidentifier in typeref children: \".concat(JSON.stringify(children)));\n      return undefined;\n    }\n\n    var _args = children.filter(function (child) {\n      return child.type != \"qualifiedidentifier\";\n    });\n\n    return {\n      type: \"!type\",\n      cls: _cls\n    };\n  } // convert function/method\n\n\n  if (type == \"function\" || type == \"method\") {\n    // `foo()` is method, `#foo()` is function\n    // let's use common property `methodName` and just add `isVar` for function\n    var _val = val,\n        functionName = _val.functionName,\n        methodName = _val.methodName,\n        _args2 = _val.args;\n    return {\n      type: \"!func\",\n      methodName: functionName || methodName,\n      isVar: type == \"function\",\n      args: _args2\n    };\n  }\n\n  return {\n    type: type,\n    children: children,\n    val: val\n  };\n};\n\nvar flatizeTernary = function flatizeTernary(children) {\n  var flat = [];\n\n  function _processTernaryChildren(tern) {\n    var _tern = (0, _slicedToArray2[\"default\"])(tern, 3),\n        cond = _tern[0],\n        if_val = _tern[1],\n        else_val = _tern[2];\n\n    flat.push([cond, if_val]);\n\n    if ((else_val === null || else_val === void 0 ? void 0 : else_val.type) == \"ternary\") {\n      _processTernaryChildren(else_val.children);\n    } else {\n      flat.push([undefined, else_val]);\n    }\n  }\n\n  _processTernaryChildren(children);\n\n  return flat;\n};\n\nvar buildConv = function buildConv(config) {\n  var operators = {};\n\n  var _loop = function _loop(opKey) {\n    var opConfig = config.operators[opKey];\n\n    if (opConfig.spelOps) {\n      // examples: \"==\", \"eq\", \".contains\", \"matches\" (can be used for starts_with, ends_with)\n      opConfig.spelOps.forEach(function (spelOp) {\n        var opk = spelOp; // + \"/\" + defaultValue(opConfig.cardinality, 1);\n\n        if (!operators[opk]) operators[opk] = [];\n        operators[opk].push(opKey);\n      });\n    } else if (opConfig.spelOp) {\n      var opk = opConfig.spelOp; // + \"/\" + defaultValue(opConfig.cardinality, 1);\n\n      if (!operators[opk]) operators[opk] = [];\n      operators[opk].push(opKey);\n    } else {\n      _stuff.logger.log(\"[spel] No spelOp for operator \".concat(opKey));\n    }\n  };\n\n  for (var opKey in config.operators) {\n    _loop(opKey);\n  }\n\n  var conjunctions = {};\n\n  for (var conjKey in config.conjunctions) {\n    var conjunctionDefinition = config.conjunctions[conjKey];\n    var ck = conjunctionDefinition.spelConj || conjKey.toLowerCase();\n    conjunctions[ck] = conjKey;\n  }\n\n  var funcs = {};\n\n  for (var funcKey in config.funcs) {\n    var funcConfig = config.funcs[funcKey];\n    var fk = void 0;\n\n    if (typeof funcConfig.spelFunc == \"string\") {\n      fk = funcConfig.spelFunc;\n    }\n\n    if (fk) {\n      if (!funcs[fk]) funcs[fk] = [];\n      funcs[fk].push(funcKey);\n    }\n  }\n\n  return {\n    operators: operators,\n    conjunctions: conjunctions,\n    funcs: funcs\n  };\n};\n\nvar convertPath = function convertPath(parts, meta) {\n  var isError = false;\n  var res = parts.map(function (c) {\n    if (c.type == \"variable\" || c.type == \"property\" || c.type == \"indexer\" && c.itype == \"string\") {\n      return c.val;\n    } else {\n      isError = true;\n      meta.errors.push(\"Unexpected item in compound: \".concat(JSON.stringify(c)));\n    }\n  });\n  return !isError ? res : undefined;\n};\n\nvar convertArg = function convertArg(spel, conv, config, meta, parentSpel) {\n  if (spel == undefined) return undefined;\n  var fieldSeparator = config.settings.fieldSeparator;\n  var literalTypes = {\n    number: \"number\",\n    string: \"text\",\n    \"boolean\": \"boolean\",\n    \"null\": \"null\" // should not be\n\n  };\n  var groupFieldParts = parentSpel !== null && parentSpel !== void 0 && parentSpel._groupField ? [parentSpel === null || parentSpel === void 0 ? void 0 : parentSpel._groupField] : [];\n\n  if (spel.type == \"compound\") {\n    var _spel$children, _spel$children$; // complex field\n\n\n    var parts = convertPath(spel.children, meta);\n\n    if (!parts) {\n      return undefined;\n    }\n\n    var fullParts = [].concat(groupFieldParts, (0, _toConsumableArray2[\"default\"])(parts));\n    var isVariable = ((_spel$children = spel.children) === null || _spel$children === void 0 ? void 0 : (_spel$children$ = _spel$children[0]) === null || _spel$children$ === void 0 ? void 0 : _spel$children$.type) == \"variable\";\n    return {\n      valueSrc: \"field\",\n      //valueType: todo\n      isVariable: isVariable,\n      value: fullParts.join(fieldSeparator)\n    };\n  } else if (spel.type == \"variable\" || spel.type == \"property\") {\n    // normal field\n    var _fullParts = [].concat(groupFieldParts, [spel.val]);\n\n    var _isVariable = spel.type == \"variable\";\n\n    return {\n      valueSrc: \"field\",\n      //valueType: todo\n      isVariable: _isVariable,\n      value: _fullParts.join(fieldSeparator)\n    };\n  } else if (literalTypes[spel.type]) {\n    var value = spel.val;\n    var valueType = literalTypes[spel.type];\n\n    if (parentSpel !== null && parentSpel !== void 0 && parentSpel.isUnary) {\n      value = -value;\n    }\n\n    return {\n      valueSrc: \"value\",\n      valueType: valueType,\n      value: value\n    };\n  } else if (spel.type == \"list\") {\n    var _values$;\n\n    var values = spel.val.map(function (v) {\n      return convertArg(v, conv, config, meta, spel);\n    });\n\n    var _itemType = values.length ? (_values$ = values[0]) === null || _values$ === void 0 ? void 0 : _values$.valueType : null;\n\n    var _value = values.map(function (v) {\n      return v === null || v === void 0 ? void 0 : v.value;\n    });\n\n    var _valueType = \"multiselect\";\n    return {\n      valueSrc: \"value\",\n      valueType: _valueType,\n      value: _value\n    };\n  } else if (spel.type == \"!func\") {\n    var _funcToOpMap;\n\n    var obj = spel.obj,\n        methodName = spel.methodName,\n        args = spel.args,\n        isVar = spel.isVar; // todo: get from conv\n\n    var funcToOpMap = (_funcToOpMap = {}, (0, _defineProperty2[\"default\"])(_funcToOpMap, \".contains\", \"like\"), (0, _defineProperty2[\"default\"])(_funcToOpMap, \".startsWith\", \"starts_with\"), (0, _defineProperty2[\"default\"])(_funcToOpMap, \".endsWith\", \"ends_with\"), (0, _defineProperty2[\"default\"])(_funcToOpMap, \"$contains\", \"select_any_in\"), _funcToOpMap);\n    var convertedArgs = args.map(function (v) {\n      return convertArg(v, conv, config, meta, _objectSpread(_objectSpread({}, spel), {}, {\n        _groupField: parentSpel === null || parentSpel === void 0 ? void 0 : parentSpel._groupField\n      }));\n    }); //todo: make dynamic: use funcToOpMap and check obj type in basic config\n\n    if (methodName == \"contains\" && obj && obj[0].type == \"list\") {\n      var convertedObj = obj.map(function (v) {\n        return convertArg(v, conv, config, meta, spel);\n      }); // {'yellow', 'green'}.?[true].contains(color)\n\n      if (!(convertedArgs.length == 1 && convertedArgs[0].valueSrc == \"field\")) {\n        meta.errors.push(\"Expected arg to method \".concat(methodName, \" to be field but got: \").concat(JSON.stringify(convertedArgs)));\n        return undefined;\n      }\n\n      var field = convertedArgs[0].value;\n\n      if (!(convertedObj.length == 1 && convertedObj[0].valueType == \"multiselect\")) {\n        meta.errors.push(\"Expected object of method \".concat(methodName, \" to be inline list but got: \").concat(JSON.stringify(convertedObj)));\n        return undefined;\n      }\n\n      var opKey = funcToOpMap[\"$\" + methodName];\n      var list = convertedObj[0];\n      return buildRule(config, meta, field, opKey, [list]);\n    } else if (funcToOpMap[\".\" + methodName]) {\n      // user.login.startsWith('gg')\n      var _opKey = funcToOpMap[\".\" + methodName];\n\n      var _parts = convertPath(obj, meta);\n\n      if (_parts && convertedArgs.length == 1) {\n        var _fullParts2 = [].concat(groupFieldParts, (0, _toConsumableArray2[\"default\"])(_parts));\n\n        var _field = _fullParts2.join(fieldSeparator);\n\n        return buildRule(config, meta, _field, _opKey, convertedArgs);\n      }\n    } else if (methodName == \"parse\" && obj && obj[0].type == \"!new\" && obj[0].cls.at(-1) == \"SimpleDateFormat\") {\n      // new java.text.SimpleDateFormat('yyyy-MM-dd').parse('2022-01-15')\n      var _args3 = obj[0].args.map(function (v) {\n        return convertArg(v, conv, config, meta, _objectSpread(_objectSpread({}, spel), {}, {\n          _groupField: parentSpel === null || parentSpel === void 0 ? void 0 : parentSpel._groupField\n        }));\n      });\n\n      if (!(_args3.length == 1 && _args3[0].valueType == \"text\")) {\n        meta.errors.push(\"Expected args of \".concat(obj[0].cls.join(\".\"), \".\").concat(methodName, \" to be 1 string but got: \").concat(JSON.stringify(_args3)));\n        return undefined;\n      }\n\n      if (!(convertedArgs.length == 1 && convertedArgs[0].valueType == \"text\")) {\n        meta.errors.push(\"Expected args of \".concat(obj[0].cls.join(\".\"), \" to be 1 string but got: \").concat(JSON.stringify(convertedArgs)));\n        return undefined;\n      }\n\n      var dateFormat = _args3[0].value;\n      var dateString = convertedArgs[0].value;\n\n      var _valueType2 = dateFormat.includes(\" \") ? \"datetime\" : \"date\";\n\n      var _field2 = null; // todo\n\n      var widget = _valueType2;\n      var fieldConfig = (0, _configUtils.getFieldConfig)(config, _field2);\n      var widgetConfig = config.widgets[widget || (fieldConfig === null || fieldConfig === void 0 ? void 0 : fieldConfig.mainWidget)];\n      var valueFormat = widgetConfig.valueFormat;\n      var dateVal = (0, _moment[\"default\"])(dateString, _moment[\"default\"].ISO_8601);\n\n      var _value2 = dateVal.isValid() ? dateVal.format(valueFormat) : undefined;\n\n      return {\n        valueSrc: \"value\",\n        valueType: _valueType2,\n        value: _value2\n      };\n    } else if (methodName == \"parse\" && obj && obj[0].type == \"!type\" && obj[0].cls.at(-1) == \"LocalTime\") {\n      // time == T(java.time.LocalTime).parse('02:03:00')\n      if (!(convertedArgs.length == 1 && convertedArgs[0].valueType == \"text\")) {\n        meta.errors.push(\"Expected args of \".concat(obj[0].cls.join(\".\"), \" to be 1 string but got: \").concat(JSON.stringify(convertedArgs)));\n        return undefined;\n      }\n\n      var timeString = convertedArgs[0].value;\n      var _valueType3 = \"time\";\n      var _field3 = null; // todo\n\n      var _widget = _valueType3;\n\n      var _fieldConfig = (0, _configUtils.getFieldConfig)(config, _field3);\n\n      var _widgetConfig = config.widgets[_widget || (_fieldConfig === null || _fieldConfig === void 0 ? void 0 : _fieldConfig.mainWidget)];\n      var _valueFormat = _widgetConfig.valueFormat;\n\n      var _dateVal = (0, _moment[\"default\"])(timeString, \"HH:mm:ss\");\n\n      var _value3 = _dateVal.isValid() ? _dateVal.format(_valueFormat) : undefined;\n\n      return {\n        valueSrc: \"value\",\n        valueType: _valueType3,\n        value: _value3\n      };\n    } else {\n      // todo: conv.funcs\n      meta.errors.push(\"Unsupported method \".concat(methodName));\n    }\n  } else if (spel.type == \"op-plus\" && (parentSpel === null || parentSpel === void 0 ? void 0 : parentSpel.type) == \"ternary\") {\n    return buildCaseValueConcat(spel, conv, config, meta);\n  } else {\n    meta.errors.push(\"Can't convert arg of type \".concat(spel.type));\n  }\n\n  return undefined;\n};\n\nvar buildRule = function buildRule(config, meta, field, opKey, convertedArgs) {\n  if (convertedArgs.filter(function (v) {\n    return v === undefined;\n  }).length) {\n    return undefined;\n  }\n\n  var fieldConfig = (0, _configUtils.getFieldConfig)(config, field);\n\n  if (!fieldConfig) {\n    meta.errors.push(\"No config for field \".concat(field));\n    return undefined;\n  }\n\n  var widget = (0, _ruleUtils.getWidgetForFieldOp)(config, field, opKey);\n  var widgetConfig = config.widgets[widget || fieldConfig.mainWidget];\n  var asyncListValuesArr = convertedArgs.map(function (v) {\n    return v.asyncListValues;\n  }).filter(function (v) {\n    return v != undefined;\n  });\n  var asyncListValues = asyncListValuesArr.length ? asyncListValuesArr[0] : undefined;\n  var res = {\n    type: \"rule\",\n    id: (0, _uuid[\"default\"])(),\n    properties: {\n      field: field,\n      operator: opKey,\n      value: convertedArgs.map(function (v) {\n        return v.value;\n      }),\n      valueSrc: convertedArgs.map(function (v) {\n        return v.valueSrc;\n      }),\n      valueType: convertedArgs.map(function (v) {\n        if (v.valueSrc == \"value\") {\n          return (widgetConfig === null || widgetConfig === void 0 ? void 0 : widgetConfig.type) || (fieldConfig === null || fieldConfig === void 0 ? void 0 : fieldConfig.type) || v.valueType;\n        }\n\n        return v.valueType;\n      }),\n      asyncListValues: asyncListValues\n    }\n  };\n  return res;\n};\n\nvar buildRuleGroup = function buildRuleGroup(_ref, opKey, convertedArgs, config, meta) {\n  var groupFilter = _ref.groupFilter,\n      groupFieldValue = _ref.groupFieldValue;\n  if (groupFieldValue.valueSrc != \"field\") throw \"Bad groupFieldValue: \".concat(JSON.stringify(groupFieldValue));\n  var groupField = groupFieldValue.value;\n  var groupOpRule = buildRule(config, meta, groupField, opKey, convertedArgs);\n  if (!groupOpRule) return undefined;\n  var fieldConfig = (0, _configUtils.getFieldConfig)(config, groupField);\n  var mode = fieldConfig === null || fieldConfig === void 0 ? void 0 : fieldConfig.mode;\n\n  var res = _objectSpread(_objectSpread({}, groupFilter || {}), {}, {\n    type: \"rule_group\",\n    properties: _objectSpread(_objectSpread(_objectSpread({}, groupOpRule.properties), (groupFilter === null || groupFilter === void 0 ? void 0 : groupFilter.properties) || {}), {}, {\n      mode: mode\n    })\n  });\n\n  if (!res.id) res.id = (0, _uuid[\"default\"])();\n  return res;\n};\n\nvar compareArgs = function compareArgs(left, right, spel, conv, config, meta) {\n  var parentSpel = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n\n  if (left.type == right.type) {\n    if (left.type == \"!aggr\") {\n      var _map = [left.source, right.source].map(function (v) {\n        return convertArg(v, conv, config, meta, _objectSpread(_objectSpread({}, spel), {}, {\n          _groupField: parentSpel === null || parentSpel === void 0 ? void 0 : parentSpel._groupField\n        }));\n      }),\n          _map2 = (0, _slicedToArray2[\"default\"])(_map, 2),\n          leftSource = _map2[0],\n          rightSource = _map2[1]; //todo: check same filter\n\n\n      return leftSource.value == rightSource.value;\n    } else {\n      var _map3 = [left, right].map(function (v) {\n        return convertArg(v, conv, config, meta, _objectSpread(_objectSpread({}, spel), {}, {\n          _groupField: parentSpel === null || parentSpel === void 0 ? void 0 : parentSpel._groupField\n        }));\n      }),\n          _map4 = (0, _slicedToArray2[\"default\"])(_map3, 2),\n          leftVal = _map4[0],\n          rightVal = _map4[1];\n\n      return leftVal.value == rightVal.value;\n    }\n  }\n\n  return false;\n};\n\nvar convertToTree = function convertToTree(spel, conv, config, meta) {\n  var parentSpel = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  if (!spel) return undefined;\n  var res;\n\n  if (spel.type.indexOf(\"op-\") == 0) {\n    var op = spel.type.slice(\"op-\".length); // unary\n\n    var isUnary = (op == \"minus\" || op == \"plus\") && spel.children.length == 1;\n\n    if (isUnary) {\n      spel.isUnary = true;\n      return convertToTree(spel.children[0], conv, config, meta, spel);\n    } // between\n\n\n    var isBetweenNormal = op == \"and\" && spel.children.length == 2 && spel.children[0].type == \"op-ge\" && spel.children[1].type == \"op-le\";\n    var isBetweenRev = op == \"or\" && spel.children.length == 2 && spel.children[0].type == \"op-lt\" && spel.children[1].type == \"op-gt\";\n    var isBetween = isBetweenNormal || isBetweenRev;\n\n    if (isBetween) {\n      var _spel$children$0$chil = (0, _slicedToArray2[\"default\"])(spel.children[0].children, 2),\n          left = _spel$children$0$chil[0],\n          from = _spel$children$0$chil[1];\n\n      var _spel$children$1$chil = (0, _slicedToArray2[\"default\"])(spel.children[1].children, 2),\n          right = _spel$children$1$chil[0],\n          to = _spel$children$1$chil[1];\n\n      var isNumbers = from.type == \"number\" && to.type == \"number\";\n      var isSameSource = compareArgs(left, right, spel, conv, config, meta, parentSpel);\n\n      if (isNumbers && isSameSource) {\n        var _fromValue = from.val;\n        var _toValue = to.val;\n        var oneSpel = {\n          type: \"op-between\",\n          children: [left, from, to]\n        };\n        return convertToTree(oneSpel, conv, config, meta, parentSpel);\n      }\n    } // find op\n\n\n    var opKeys = conv.operators[op];\n    var opKey; // todo: make dynamic, use basic config\n\n    if (op == \"eq\" && spel.children[1].type == \"null\") {\n      opKey = \"is_null\";\n    } else if (op == \"ne\" && spel.children[1].type == \"null\") {\n      opKey = \"is_not_null\";\n    } else if (op == \"le\" && spel.children[1].type == \"string\" && spel.children[1].val == \"\") {\n      opKey = \"is_empty\";\n    } else if (op == \"gt\" && spel.children[1].type == \"string\" && spel.children[1].val == \"\") {\n      opKey = \"is_not_empty\";\n    } else if (op == \"between\") {\n      opKey = \"between\";\n      opKeys = [\"between\"];\n    } // convert children\n\n\n    var convertChildren = function convertChildren() {\n      return spel.children.map(function (child) {\n        return convertToTree(child, conv, config, meta, _objectSpread(_objectSpread({}, spel), {}, {\n          _groupField: parentSpel === null || parentSpel === void 0 ? void 0 : parentSpel._groupField\n        }));\n      });\n    };\n\n    if (op == \"and\" || op == \"or\") {\n      var children1 = {};\n      var vals = convertChildren();\n      vals.forEach(function (v) {\n        if (v) {\n          var id = (0, _uuid[\"default\"])();\n          v.id = id;\n\n          if (v.type != undefined) {\n            children1[id] = v;\n          } else {\n            meta.errors.push(\"Bad item in AND/OR: \".concat(JSON.stringify(v)));\n          }\n        }\n      });\n      res = {\n        type: \"group\",\n        id: (0, _uuid[\"default\"])(),\n        children1: children1,\n        properties: {\n          conjunction: conv.conjunctions[op],\n          not: spel.not\n        }\n      };\n    } else if (opKeys) {\n      var _vals = convertChildren();\n\n      var fieldObj = _vals[0];\n\n      var convertedArgs = _vals.slice(1);\n\n      opKey = opKeys[0];\n\n      if (!fieldObj) {// LHS can't be parsed\n      } else if (fieldObj.groupFieldValue) {\n        // 1. group\n        if (fieldObj.groupFieldValue.valueSrc != \"field\") {\n          meta.errors.push(\"Expected group field \".concat(JSON.stringify(fieldObj)));\n        }\n\n        var groupField = fieldObj.groupFieldValue.value; // some/all/none\n\n        var opArg = convertedArgs[0];\n\n        if (opArg && opArg.groupFieldValue && opArg.groupFieldValue.valueSrc == \"field\" && opArg.groupFieldValue.value == groupField) {\n          // group.?[...].size() == group.size()\n          opKey = \"all\";\n          convertedArgs = [];\n        } else if (opKey == \"equal\" && opArg.valueSrc == \"value\" && opArg.valueType == \"number\" && opArg.value == 0) {\n          opKey = \"none\";\n          convertedArgs = [];\n        } else if (opKey == \"greater\" && opArg.valueSrc == \"value\" && opArg.valueType == \"number\" && opArg.value == 0) {\n          opKey = \"some\";\n          convertedArgs = [];\n        }\n\n        res = buildRuleGroup(fieldObj, opKey, convertedArgs, config, meta);\n      } else {\n        // 2. not group\n        if (fieldObj.valueSrc != \"field\") {\n          meta.errors.push(\"Expected field \".concat(JSON.stringify(fieldObj)));\n        }\n\n        var field = fieldObj.value;\n\n        if (opKeys.length > 1) {\n          _stuff.logger.warn(\"[spel] Spel operator \".concat(op, \" can be mapped to \").concat(opKeys)); //todo: it's naive\n\n\n          var widgets = opKeys.map(function (op) {\n            return {\n              op: op,\n              widget: (0, _ruleUtils.getWidgetForFieldOp)(config, field, op)\n            };\n          });\n\n          if (op == \"eq\") {\n            var ws = widgets.find(function (_ref2) {\n              var op = _ref2.op,\n                  widget = _ref2.widget;\n              return widget != \"field\";\n            });\n            opKey = ws.op;\n          }\n        }\n\n        res = buildRule(config, meta, field, opKey, convertedArgs);\n      }\n    } else {\n      if (!parentSpel) {\n        // try to parse whole `\"str\" + prop + #var` as ternary\n        res = buildSimpleSwitch(spel, conv, config, meta);\n      }\n\n      if (!res) {\n        meta.errors.push(\"Can't convert op \".concat(op));\n      }\n    }\n  } else if (spel.type == \"!aggr\") {\n    var _groupFilter;\n\n    var groupFieldValue = convertToTree(spel.source, conv, config, meta, _objectSpread(_objectSpread({}, spel), {}, {\n      _groupField: parentSpel === null || parentSpel === void 0 ? void 0 : parentSpel._groupField\n    }));\n    var groupFilter = convertToTree(spel.filter, conv, config, meta, _objectSpread(_objectSpread({}, spel), {}, {\n      _groupField: groupFieldValue === null || groupFieldValue === void 0 ? void 0 : groupFieldValue.value\n    }));\n\n    if (((_groupFilter = groupFilter) === null || _groupFilter === void 0 ? void 0 : _groupFilter.type) == \"rule\") {\n      groupFilter = wrapInDefaultConj(groupFilter, config);\n    }\n\n    res = {\n      groupFilter: groupFilter,\n      groupFieldValue: groupFieldValue\n    };\n\n    if (!parentSpel) {\n      // !aggr can't be in root, it should be compared with something\n      res = undefined;\n      meta.errors.push(\"Unexpected !aggr in root\");\n    }\n  } else if (spel.type == \"ternary\") {\n    var _children = {};\n    spel.val.forEach(function (v) {\n      var _v = (0, _slicedToArray2[\"default\"])(v, 2),\n          cond = _v[0],\n          val = _v[1];\n\n      var caseI = buildCase(cond, val, conv, config, meta, spel);\n\n      if (caseI) {\n        _children[caseI.id] = caseI;\n      }\n    });\n    res = {\n      type: \"switch_group\",\n      id: (0, _uuid[\"default\"])(),\n      children1: _children,\n      properties: {}\n    };\n  } else {\n    res = convertArg(spel, conv, config, meta, parentSpel);\n\n    if (res && !res.type && !parentSpel) {\n      // try to parse whole `\"1\"` as ternary\n      var sw = buildSimpleSwitch(spel, conv, config, meta);\n\n      if (sw) {\n        res = sw;\n      } else {\n        res = undefined;\n        meta.errors.push(\"Can't convert rule of type \".concat(spel.type, \", it looks like var/literal\"));\n      }\n    }\n  }\n\n  return res;\n};\n\nvar buildSimpleSwitch = function buildSimpleSwitch(val, conv, config, meta) {\n  var children1 = {};\n  var cond = null;\n  var caseI = buildCase(cond, val, conv, config, meta);\n\n  if (caseI) {\n    children1[caseI.id] = caseI;\n  }\n\n  var res = {\n    type: \"switch_group\",\n    id: (0, _uuid[\"default\"])(),\n    children1: children1,\n    properties: {}\n  };\n  return res;\n};\n\nvar buildCase = function buildCase(cond, val, conv, config, meta) {\n  var spel = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n  var valProperties = buildCaseValProperties(config, meta, conv, val, spel);\n  var caseI;\n\n  if (cond) {\n    caseI = convertToTree(cond, conv, config, meta, spel);\n\n    if (caseI && caseI.type) {\n      if (caseI.type != \"group\") {\n        caseI = wrapInDefaultConj(caseI, config);\n      }\n\n      caseI.type = \"case_group\";\n    } else {\n      meta.errors.push(\"Unexpected case: \".concat(JSON.stringify(caseI)));\n      caseI = undefined;\n    }\n  } else {\n    caseI = {\n      id: (0, _uuid[\"default\"])(),\n      type: \"case_group\",\n      properties: {}\n    };\n  }\n\n  if (caseI) {\n    caseI.properties = _objectSpread(_objectSpread({}, caseI.properties), valProperties);\n  }\n\n  return caseI;\n};\n\nvar buildCaseValueConcat = function buildCaseValueConcat(spel, conv, config, meta) {\n  var flat = [];\n\n  function _processConcatChildren(children) {\n    children.map(function (child) {\n      if (child.type == \"op-plus\") {\n        _processConcatChildren(child.children);\n      } else {\n        var convertedChild = convertArg(child, conv, config, meta, spel);\n\n        if (convertedChild) {\n          flat.push(convertedChild);\n        } else {\n          meta.errors.push(\"Can't convert \".concat(child.type, \" in concatenation\"));\n        }\n      }\n    });\n  }\n\n  _processConcatChildren(spel.children);\n\n  return {\n    valueSrc: \"value\",\n    valueType: \"case_value\",\n    value: flat\n  };\n};\n\nvar buildCaseValProperties = function buildCaseValProperties(config, meta, conv, val) {\n  var spel = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  var valProperties = {};\n  var convVal;\n\n  if ((val === null || val === void 0 ? void 0 : val.type) == \"op-plus\") {\n    convVal = buildCaseValueConcat(val, conv, config, meta);\n  } else {\n    convVal = convertArg(val, conv, config, meta, spel);\n  }\n\n  var widgetDef = config.widgets[\"case_value\"];\n  var importCaseValue = widgetDef === null || widgetDef === void 0 ? void 0 : widgetDef.spelImportValue;\n\n  if (importCaseValue) {\n    var _importCaseValue = importCaseValue(convVal),\n        _importCaseValue2 = (0, _slicedToArray2[\"default\"])(_importCaseValue, 2),\n        normVal = _importCaseValue2[0],\n        normErrors = _importCaseValue2[1];\n\n    normErrors.map(function (e) {\n      return meta.errors.push(e);\n    });\n\n    if (normVal) {\n      valProperties = {\n        value: [normVal],\n        valueSrc: [\"value\"],\n        valueType: [\"case_value\"]\n      };\n    }\n  } else {\n    meta.errors.push(\"No fucntion to import case value\");\n  }\n\n  return valProperties;\n};\n\nvar wrapInDefaultConjRuleGroup = function wrapInDefaultConjRuleGroup(rule, parentField, parentFieldConfig, config, conj) {\n  if (!rule) return undefined;\n  return {\n    type: \"rule_group\",\n    id: (0, _uuid[\"default\"])(),\n    children1: (0, _defineProperty2[\"default\"])({}, rule.id, rule),\n    properties: {\n      conjunction: conj || (0, _defaultUtils.defaultGroupConjunction)(config, parentFieldConfig),\n      not: false,\n      field: parentField\n    }\n  };\n};\n\nvar wrapInDefaultConj = function wrapInDefaultConj(rule, config) {\n  var not = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  return {\n    type: \"group\",\n    id: (0, _uuid[\"default\"])(),\n    children1: (0, _defineProperty2[\"default\"])({}, rule.id, rule),\n    properties: {\n      conjunction: (0, _defaultUtils.defaultConjunction)(config),\n      not: not\n    }\n  };\n};","map":{"version":3,"sources":["D:/LIMSWFH/LIMSPOSTGRESQL/QuaLISWeb/node_modules/react-awesome-query-builder/lib/import/spel.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","loadFromSpel","_loadFromSpel","_slicedToArray2","_typeof2","_defineProperty2","_toConsumableArray2","_spel2js","_uuid","_configUtils","_ruleUtils","_tree","_defaultUtils","_stuff","_moment","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","logicTree","config","spelStr","returnErrors","undefined","meta","errors","extendedConfig","extendConfig","conv","buildConv","compiledExpression","convertedObj","jsTree","compileRes","SpelExpressionEvaluator","compile","_compiledExpression","e","logger","debug","convertCompiled","convertToTree","type","wrapInDefaultConj","immTree","loadTree","console","warn","expr","parentExpr","getType","children","getChildren","map","child","reduce","acc","canFlatize","not","flat","concat","isListFix","val","selection","find","lastChild","isSize","methodName","isLength","sourceParts","isThis","isRoot","itype","obj","args","_obj","getRaw","getValue","error","flatizeTernary","functionName","item","qid","cls","JSON","stringify","_qid","_cls","_args","_val","_args2","isVar","_processTernaryChildren","tern","_tern","cond","if_val","else_val","operators","_loop","opKey","opConfig","spelOps","spelOp","opk","log","conjunctions","conjKey","conjunctionDefinition","ck","spelConj","toLowerCase","funcs","funcKey","funcConfig","fk","spelFunc","convertPath","parts","isError","res","c","convertArg","spel","parentSpel","fieldSeparator","settings","literalTypes","number","string","groupFieldParts","_groupField","_spel$children","_spel$children$","fullParts","isVariable","valueSrc","join","_fullParts","_isVariable","valueType","isUnary","_values$","values","v","_itemType","_value","_valueType","_funcToOpMap","funcToOpMap","convertedArgs","field","list","buildRule","_opKey","_parts","_fullParts2","_field","at","_args3","dateFormat","dateString","_valueType2","includes","_field2","widget","fieldConfig","getFieldConfig","widgetConfig","widgets","mainWidget","valueFormat","dateVal","ISO_8601","_value2","isValid","format","timeString","_valueType3","_field3","_widget","_fieldConfig","_widgetConfig","_valueFormat","_dateVal","_value3","buildCaseValueConcat","getWidgetForFieldOp","asyncListValuesArr","asyncListValues","id","properties","operator","buildRuleGroup","_ref","groupFilter","groupFieldValue","groupField","groupOpRule","mode","compareArgs","left","right","_map","_map2","leftSource","rightSource","_map3","_map4","leftVal","rightVal","indexOf","op","slice","isBetweenNormal","isBetweenRev","isBetween","_spel$children$0$chil","from","_spel$children$1$chil","to","isNumbers","isSameSource","_fromValue","_toValue","oneSpel","opKeys","convertChildren","children1","vals","conjunction","_vals","fieldObj","opArg","ws","_ref2","buildSimpleSwitch","_groupFilter","_children","_v","caseI","buildCase","sw","valProperties","buildCaseValProperties","_processConcatChildren","convertedChild","convVal","widgetDef","importCaseValue","spelImportValue","_importCaseValue","_importCaseValue2","normVal","normErrors","wrapInDefaultConjRuleGroup","rule","parentField","parentFieldConfig","conj","defaultGroupConjunction","defaultConjunction"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.loadFromSpel = exports._loadFromSpel = void 0;\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _spel2js = require(\"spel2js\");\n\nvar _uuid = _interopRequireDefault(require(\"../utils/uuid\"));\n\nvar _configUtils = require(\"../utils/configUtils\");\n\nvar _ruleUtils = require(\"../utils/ruleUtils\");\n\nvar _tree = require(\"./tree\");\n\nvar _defaultUtils = require(\"../utils/defaultUtils\");\n\nvar _stuff = require(\"../utils/stuff\");\n\nvar _moment = _interopRequireDefault(require(\"moment\"));\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2[\"default\"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nvar loadFromSpel = function loadFromSpel(logicTree, config) {\n  return _loadFromSpel(logicTree, config, true);\n};\n\nexports.loadFromSpel = loadFromSpel;\n\nvar _loadFromSpel = function _loadFromSpel(spelStr, config) {\n  var returnErrors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  //meta is mutable\n  var meta = {\n    errors: []\n  };\n  var extendedConfig = (0, _configUtils.extendConfig)(config);\n  var conv = buildConv(extendedConfig);\n  var compiledExpression;\n  var convertedObj;\n  var jsTree = undefined;\n\n  try {\n    var compileRes = _spel2js.SpelExpressionEvaluator.compile(spelStr);\n\n    compiledExpression = compileRes._compiledExpression;\n  } catch (e) {\n    meta.errors.push(e);\n  }\n\n  if (compiledExpression) {\n    _stuff.logger.debug(\"compiledExpression:\", compiledExpression);\n\n    convertedObj = convertCompiled(compiledExpression, meta);\n\n    _stuff.logger.debug(\"convertedObj:\", convertedObj, meta);\n\n    jsTree = convertToTree(convertedObj, conv, extendedConfig, meta);\n\n    if (jsTree && jsTree.type != \"group\" && jsTree.type != \"switch_group\") {\n      jsTree = wrapInDefaultConj(jsTree, extendedConfig);\n    }\n\n    _stuff.logger.debug(\"jsTree:\", jsTree);\n  }\n\n  var immTree = jsTree ? (0, _tree.loadTree)(jsTree) : undefined;\n\n  if (returnErrors) {\n    return [immTree, meta.errors];\n  } else {\n    if (meta.errors.length) console.warn(\"Errors while importing from SpEL:\", meta.errors);\n    return immTree;\n  }\n};\n\nexports._loadFromSpel = _loadFromSpel;\n\nvar convertCompiled = function convertCompiled(expr, meta) {\n  var parentExpr = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var type = expr.getType();\n  var children = expr.getChildren().map(function (child) {\n    return convertCompiled(child, meta, expr);\n  }); // flatize OR/AND\n\n  if (type == \"op-or\" || type == \"op-and\") {\n    children = children.reduce(function (acc, child) {\n      var canFlatize = child.type == type && !child.not;\n      var flat = canFlatize ? child.children : [child];\n      return [].concat((0, _toConsumableArray2[\"default\"])(acc), (0, _toConsumableArray2[\"default\"])(flat));\n    }, []);\n  } // unwrap NOT\n\n\n  if (type == \"op-not\") {\n    if (children.length != 1) {\n      meta.errors.push(\"Operator NOT should have 1 child, but got \".concat(children.length, \"}\"));\n    }\n\n    return _objectSpread(_objectSpread({}, children[0]), {}, {\n      not: !(children[0].not || false)\n    });\n  }\n\n  if (type == \"compound\") {\n    // remove `.?[true]`\n    children = children.filter(function (child) {\n      var isListFix = child.type == \"selection\" && child.children.length == 1 && child.children[0].type == \"boolean\" && child.children[0].val == true;\n      return !isListFix;\n    }); // aggregation\n    // eg. `results.?[product == 'abc'].length`\n\n    var selection = children.find(function (child) {\n      return child.type == \"selection\";\n    });\n\n    if (selection && selection.children.length != 1) {\n      meta.errors.push(\"Selection should have 1 child, but got \".concat(selection.children.length));\n    }\n\n    var filter = selection ? selection.children[0] : null;\n    var lastChild = children[children.length - 1];\n    var isSize = lastChild.type == \"method\" && lastChild.val.methodName == \"size\" || lastChild.type == \"!func\" && lastChild.methodName == \"size\";\n    var isLength = lastChild.type == \"property\" && lastChild.val == \"length\";\n    var sourceParts = children.filter(function (child) {\n      return child !== selection && child !== lastChild;\n    });\n    var source = {\n      type: \"compound\",\n      children: sourceParts\n    };\n\n    if (isSize || isLength) {\n      return {\n        type: \"!aggr\",\n        filter: filter,\n        source: source\n      };\n    } // remove `#this`, `#root`\n\n\n    children = children.filter(function (child) {\n      var isThis = child.type == \"variable\" && child.val == \"this\";\n      var isRoot = child.type == \"variable\" && child.val == \"root\";\n      return !(isThis || isRoot);\n    }); // indexer\n\n    children = children.map(function (child) {\n      if (child.type == \"indexer\" && child.children.length == 1) {\n        return {\n          type: \"indexer\",\n          val: child.children[0].val,\n          itype: child.children[0].type\n        };\n      } else {\n        return child;\n      }\n    }); // method\n\n    if (lastChild.type == \"method\") {\n      var obj = children.filter(function (child) {\n        return child !== lastChild;\n      });\n      return {\n        type: \"!func\",\n        obj: obj,\n        methodName: lastChild.val.methodName,\n        args: lastChild.val.args\n      };\n    } // !func\n\n\n    if (lastChild.type == \"!func\") {\n      var _obj = children.filter(function (child) {\n        return child !== lastChild;\n      });\n\n      return _objectSpread(_objectSpread({}, lastChild), {}, {\n        obj: _obj\n      });\n    }\n  } // getRaw || getValue\n\n\n  var val;\n\n  try {\n    if (expr.getRaw) {\n      // use my fork\n      val = expr.getRaw();\n    } else if (expr.getValue.length == 0) {\n      // getValue not requires context arg -> can use\n      val = expr.getValue();\n    }\n  } catch (e) {\n    _stuff.logger.error(\"[spel2js] Error in getValue()\", e);\n  } // ternary\n\n\n  if (type == \"ternary\") {\n    val = flatizeTernary(children);\n  } // convert method/function args\n\n\n  if ((0, _typeof2[\"default\"])(val) === \"object\" && val !== null) {\n    if (val.methodName || val.functionName) {\n      val.args = val.args.map(function (child) {\n        return convertCompiled(child, meta, expr);\n      });\n    }\n  } // convert list\n\n\n  if (type == \"list\") {\n    val = val.map(function (item) {\n      return convertCompiled(item, meta, expr);\n    }); // fix whole expression wrapped in `{}`\n\n    if (!parentExpr && val.length == 1) {\n      return val[0];\n    }\n  } // convert constructor\n\n\n  if (type == \"constructorref\") {\n    var qid = children.find(function (child) {\n      return child.type == \"qualifiedidentifier\";\n    });\n    var cls = qid === null || qid === void 0 ? void 0 : qid.val;\n\n    if (!cls) {\n      meta.errors.push(\"Can't find qualifiedidentifier in constructorref children: \".concat(JSON.stringify(children)));\n      return undefined;\n    }\n\n    var args = children.filter(function (child) {\n      return child.type != \"qualifiedidentifier\";\n    });\n    return {\n      type: \"!new\",\n      cls: cls,\n      args: args\n    };\n  } // convert type\n\n\n  if (type == \"typeref\") {\n    var _qid = children.find(function (child) {\n      return child.type == \"qualifiedidentifier\";\n    });\n\n    var _cls = _qid === null || _qid === void 0 ? void 0 : _qid.val;\n\n    if (!_cls) {\n      meta.errors.push(\"Can't find qualifiedidentifier in typeref children: \".concat(JSON.stringify(children)));\n      return undefined;\n    }\n\n    var _args = children.filter(function (child) {\n      return child.type != \"qualifiedidentifier\";\n    });\n\n    return {\n      type: \"!type\",\n      cls: _cls\n    };\n  } // convert function/method\n\n\n  if (type == \"function\" || type == \"method\") {\n    // `foo()` is method, `#foo()` is function\n    // let's use common property `methodName` and just add `isVar` for function\n    var _val = val,\n        functionName = _val.functionName,\n        methodName = _val.methodName,\n        _args2 = _val.args;\n    return {\n      type: \"!func\",\n      methodName: functionName || methodName,\n      isVar: type == \"function\",\n      args: _args2\n    };\n  }\n\n  return {\n    type: type,\n    children: children,\n    val: val\n  };\n};\n\nvar flatizeTernary = function flatizeTernary(children) {\n  var flat = [];\n\n  function _processTernaryChildren(tern) {\n    var _tern = (0, _slicedToArray2[\"default\"])(tern, 3),\n        cond = _tern[0],\n        if_val = _tern[1],\n        else_val = _tern[2];\n\n    flat.push([cond, if_val]);\n\n    if ((else_val === null || else_val === void 0 ? void 0 : else_val.type) == \"ternary\") {\n      _processTernaryChildren(else_val.children);\n    } else {\n      flat.push([undefined, else_val]);\n    }\n  }\n\n  _processTernaryChildren(children);\n\n  return flat;\n};\n\nvar buildConv = function buildConv(config) {\n  var operators = {};\n\n  var _loop = function _loop(opKey) {\n    var opConfig = config.operators[opKey];\n\n    if (opConfig.spelOps) {\n      // examples: \"==\", \"eq\", \".contains\", \"matches\" (can be used for starts_with, ends_with)\n      opConfig.spelOps.forEach(function (spelOp) {\n        var opk = spelOp; // + \"/\" + defaultValue(opConfig.cardinality, 1);\n\n        if (!operators[opk]) operators[opk] = [];\n        operators[opk].push(opKey);\n      });\n    } else if (opConfig.spelOp) {\n      var opk = opConfig.spelOp; // + \"/\" + defaultValue(opConfig.cardinality, 1);\n\n      if (!operators[opk]) operators[opk] = [];\n      operators[opk].push(opKey);\n    } else {\n      _stuff.logger.log(\"[spel] No spelOp for operator \".concat(opKey));\n    }\n  };\n\n  for (var opKey in config.operators) {\n    _loop(opKey);\n  }\n\n  var conjunctions = {};\n\n  for (var conjKey in config.conjunctions) {\n    var conjunctionDefinition = config.conjunctions[conjKey];\n    var ck = conjunctionDefinition.spelConj || conjKey.toLowerCase();\n    conjunctions[ck] = conjKey;\n  }\n\n  var funcs = {};\n\n  for (var funcKey in config.funcs) {\n    var funcConfig = config.funcs[funcKey];\n    var fk = void 0;\n\n    if (typeof funcConfig.spelFunc == \"string\") {\n      fk = funcConfig.spelFunc;\n    }\n\n    if (fk) {\n      if (!funcs[fk]) funcs[fk] = [];\n      funcs[fk].push(funcKey);\n    }\n  }\n\n  return {\n    operators: operators,\n    conjunctions: conjunctions,\n    funcs: funcs\n  };\n};\n\nvar convertPath = function convertPath(parts, meta) {\n  var isError = false;\n  var res = parts.map(function (c) {\n    if (c.type == \"variable\" || c.type == \"property\" || c.type == \"indexer\" && c.itype == \"string\") {\n      return c.val;\n    } else {\n      isError = true;\n      meta.errors.push(\"Unexpected item in compound: \".concat(JSON.stringify(c)));\n    }\n  });\n  return !isError ? res : undefined;\n};\n\nvar convertArg = function convertArg(spel, conv, config, meta, parentSpel) {\n  if (spel == undefined) return undefined;\n  var fieldSeparator = config.settings.fieldSeparator;\n  var literalTypes = {\n    number: \"number\",\n    string: \"text\",\n    \"boolean\": \"boolean\",\n    \"null\": \"null\" // should not be\n\n  };\n  var groupFieldParts = parentSpel !== null && parentSpel !== void 0 && parentSpel._groupField ? [parentSpel === null || parentSpel === void 0 ? void 0 : parentSpel._groupField] : [];\n\n  if (spel.type == \"compound\") {\n    var _spel$children, _spel$children$;\n\n    // complex field\n    var parts = convertPath(spel.children, meta);\n\n    if (!parts) {\n      return undefined;\n    }\n\n    var fullParts = [].concat(groupFieldParts, (0, _toConsumableArray2[\"default\"])(parts));\n    var isVariable = ((_spel$children = spel.children) === null || _spel$children === void 0 ? void 0 : (_spel$children$ = _spel$children[0]) === null || _spel$children$ === void 0 ? void 0 : _spel$children$.type) == \"variable\";\n    return {\n      valueSrc: \"field\",\n      //valueType: todo\n      isVariable: isVariable,\n      value: fullParts.join(fieldSeparator)\n    };\n  } else if (spel.type == \"variable\" || spel.type == \"property\") {\n    // normal field\n    var _fullParts = [].concat(groupFieldParts, [spel.val]);\n\n    var _isVariable = spel.type == \"variable\";\n\n    return {\n      valueSrc: \"field\",\n      //valueType: todo\n      isVariable: _isVariable,\n      value: _fullParts.join(fieldSeparator)\n    };\n  } else if (literalTypes[spel.type]) {\n    var value = spel.val;\n    var valueType = literalTypes[spel.type];\n\n    if (parentSpel !== null && parentSpel !== void 0 && parentSpel.isUnary) {\n      value = -value;\n    }\n\n    return {\n      valueSrc: \"value\",\n      valueType: valueType,\n      value: value\n    };\n  } else if (spel.type == \"list\") {\n    var _values$;\n\n    var values = spel.val.map(function (v) {\n      return convertArg(v, conv, config, meta, spel);\n    });\n\n    var _itemType = values.length ? (_values$ = values[0]) === null || _values$ === void 0 ? void 0 : _values$.valueType : null;\n\n    var _value = values.map(function (v) {\n      return v === null || v === void 0 ? void 0 : v.value;\n    });\n\n    var _valueType = \"multiselect\";\n    return {\n      valueSrc: \"value\",\n      valueType: _valueType,\n      value: _value\n    };\n  } else if (spel.type == \"!func\") {\n    var _funcToOpMap;\n\n    var obj = spel.obj,\n        methodName = spel.methodName,\n        args = spel.args,\n        isVar = spel.isVar; // todo: get from conv\n\n    var funcToOpMap = (_funcToOpMap = {}, (0, _defineProperty2[\"default\"])(_funcToOpMap, \".contains\", \"like\"), (0, _defineProperty2[\"default\"])(_funcToOpMap, \".startsWith\", \"starts_with\"), (0, _defineProperty2[\"default\"])(_funcToOpMap, \".endsWith\", \"ends_with\"), (0, _defineProperty2[\"default\"])(_funcToOpMap, \"$contains\", \"select_any_in\"), _funcToOpMap);\n    var convertedArgs = args.map(function (v) {\n      return convertArg(v, conv, config, meta, _objectSpread(_objectSpread({}, spel), {}, {\n        _groupField: parentSpel === null || parentSpel === void 0 ? void 0 : parentSpel._groupField\n      }));\n    }); //todo: make dynamic: use funcToOpMap and check obj type in basic config\n\n    if (methodName == \"contains\" && obj && obj[0].type == \"list\") {\n      var convertedObj = obj.map(function (v) {\n        return convertArg(v, conv, config, meta, spel);\n      }); // {'yellow', 'green'}.?[true].contains(color)\n\n      if (!(convertedArgs.length == 1 && convertedArgs[0].valueSrc == \"field\")) {\n        meta.errors.push(\"Expected arg to method \".concat(methodName, \" to be field but got: \").concat(JSON.stringify(convertedArgs)));\n        return undefined;\n      }\n\n      var field = convertedArgs[0].value;\n\n      if (!(convertedObj.length == 1 && convertedObj[0].valueType == \"multiselect\")) {\n        meta.errors.push(\"Expected object of method \".concat(methodName, \" to be inline list but got: \").concat(JSON.stringify(convertedObj)));\n        return undefined;\n      }\n\n      var opKey = funcToOpMap[\"$\" + methodName];\n      var list = convertedObj[0];\n      return buildRule(config, meta, field, opKey, [list]);\n    } else if (funcToOpMap[\".\" + methodName]) {\n      // user.login.startsWith('gg')\n      var _opKey = funcToOpMap[\".\" + methodName];\n\n      var _parts = convertPath(obj, meta);\n\n      if (_parts && convertedArgs.length == 1) {\n        var _fullParts2 = [].concat(groupFieldParts, (0, _toConsumableArray2[\"default\"])(_parts));\n\n        var _field = _fullParts2.join(fieldSeparator);\n\n        return buildRule(config, meta, _field, _opKey, convertedArgs);\n      }\n    } else if (methodName == \"parse\" && obj && obj[0].type == \"!new\" && obj[0].cls.at(-1) == \"SimpleDateFormat\") {\n      // new java.text.SimpleDateFormat('yyyy-MM-dd').parse('2022-01-15')\n      var _args3 = obj[0].args.map(function (v) {\n        return convertArg(v, conv, config, meta, _objectSpread(_objectSpread({}, spel), {}, {\n          _groupField: parentSpel === null || parentSpel === void 0 ? void 0 : parentSpel._groupField\n        }));\n      });\n\n      if (!(_args3.length == 1 && _args3[0].valueType == \"text\")) {\n        meta.errors.push(\"Expected args of \".concat(obj[0].cls.join(\".\"), \".\").concat(methodName, \" to be 1 string but got: \").concat(JSON.stringify(_args3)));\n        return undefined;\n      }\n\n      if (!(convertedArgs.length == 1 && convertedArgs[0].valueType == \"text\")) {\n        meta.errors.push(\"Expected args of \".concat(obj[0].cls.join(\".\"), \" to be 1 string but got: \").concat(JSON.stringify(convertedArgs)));\n        return undefined;\n      }\n\n      var dateFormat = _args3[0].value;\n      var dateString = convertedArgs[0].value;\n\n      var _valueType2 = dateFormat.includes(\" \") ? \"datetime\" : \"date\";\n\n      var _field2 = null; // todo\n\n      var widget = _valueType2;\n      var fieldConfig = (0, _configUtils.getFieldConfig)(config, _field2);\n      var widgetConfig = config.widgets[widget || (fieldConfig === null || fieldConfig === void 0 ? void 0 : fieldConfig.mainWidget)];\n      var valueFormat = widgetConfig.valueFormat;\n      var dateVal = (0, _moment[\"default\"])(dateString, _moment[\"default\"].ISO_8601);\n\n      var _value2 = dateVal.isValid() ? dateVal.format(valueFormat) : undefined;\n\n      return {\n        valueSrc: \"value\",\n        valueType: _valueType2,\n        value: _value2\n      };\n    } else if (methodName == \"parse\" && obj && obj[0].type == \"!type\" && obj[0].cls.at(-1) == \"LocalTime\") {\n      // time == T(java.time.LocalTime).parse('02:03:00')\n      if (!(convertedArgs.length == 1 && convertedArgs[0].valueType == \"text\")) {\n        meta.errors.push(\"Expected args of \".concat(obj[0].cls.join(\".\"), \" to be 1 string but got: \").concat(JSON.stringify(convertedArgs)));\n        return undefined;\n      }\n\n      var timeString = convertedArgs[0].value;\n      var _valueType3 = \"time\";\n      var _field3 = null; // todo\n\n      var _widget = _valueType3;\n\n      var _fieldConfig = (0, _configUtils.getFieldConfig)(config, _field3);\n\n      var _widgetConfig = config.widgets[_widget || (_fieldConfig === null || _fieldConfig === void 0 ? void 0 : _fieldConfig.mainWidget)];\n      var _valueFormat = _widgetConfig.valueFormat;\n\n      var _dateVal = (0, _moment[\"default\"])(timeString, \"HH:mm:ss\");\n\n      var _value3 = _dateVal.isValid() ? _dateVal.format(_valueFormat) : undefined;\n\n      return {\n        valueSrc: \"value\",\n        valueType: _valueType3,\n        value: _value3\n      };\n    } else {\n      // todo: conv.funcs\n      meta.errors.push(\"Unsupported method \".concat(methodName));\n    }\n  } else if (spel.type == \"op-plus\" && (parentSpel === null || parentSpel === void 0 ? void 0 : parentSpel.type) == \"ternary\") {\n    return buildCaseValueConcat(spel, conv, config, meta);\n  } else {\n    meta.errors.push(\"Can't convert arg of type \".concat(spel.type));\n  }\n\n  return undefined;\n};\n\nvar buildRule = function buildRule(config, meta, field, opKey, convertedArgs) {\n  if (convertedArgs.filter(function (v) {\n    return v === undefined;\n  }).length) {\n    return undefined;\n  }\n\n  var fieldConfig = (0, _configUtils.getFieldConfig)(config, field);\n\n  if (!fieldConfig) {\n    meta.errors.push(\"No config for field \".concat(field));\n    return undefined;\n  }\n\n  var widget = (0, _ruleUtils.getWidgetForFieldOp)(config, field, opKey);\n  var widgetConfig = config.widgets[widget || fieldConfig.mainWidget];\n  var asyncListValuesArr = convertedArgs.map(function (v) {\n    return v.asyncListValues;\n  }).filter(function (v) {\n    return v != undefined;\n  });\n  var asyncListValues = asyncListValuesArr.length ? asyncListValuesArr[0] : undefined;\n  var res = {\n    type: \"rule\",\n    id: (0, _uuid[\"default\"])(),\n    properties: {\n      field: field,\n      operator: opKey,\n      value: convertedArgs.map(function (v) {\n        return v.value;\n      }),\n      valueSrc: convertedArgs.map(function (v) {\n        return v.valueSrc;\n      }),\n      valueType: convertedArgs.map(function (v) {\n        if (v.valueSrc == \"value\") {\n          return (widgetConfig === null || widgetConfig === void 0 ? void 0 : widgetConfig.type) || (fieldConfig === null || fieldConfig === void 0 ? void 0 : fieldConfig.type) || v.valueType;\n        }\n\n        return v.valueType;\n      }),\n      asyncListValues: asyncListValues\n    }\n  };\n  return res;\n};\n\nvar buildRuleGroup = function buildRuleGroup(_ref, opKey, convertedArgs, config, meta) {\n  var groupFilter = _ref.groupFilter,\n      groupFieldValue = _ref.groupFieldValue;\n  if (groupFieldValue.valueSrc != \"field\") throw \"Bad groupFieldValue: \".concat(JSON.stringify(groupFieldValue));\n  var groupField = groupFieldValue.value;\n  var groupOpRule = buildRule(config, meta, groupField, opKey, convertedArgs);\n  if (!groupOpRule) return undefined;\n  var fieldConfig = (0, _configUtils.getFieldConfig)(config, groupField);\n  var mode = fieldConfig === null || fieldConfig === void 0 ? void 0 : fieldConfig.mode;\n\n  var res = _objectSpread(_objectSpread({}, groupFilter || {}), {}, {\n    type: \"rule_group\",\n    properties: _objectSpread(_objectSpread(_objectSpread({}, groupOpRule.properties), (groupFilter === null || groupFilter === void 0 ? void 0 : groupFilter.properties) || {}), {}, {\n      mode: mode\n    })\n  });\n\n  if (!res.id) res.id = (0, _uuid[\"default\"])();\n  return res;\n};\n\nvar compareArgs = function compareArgs(left, right, spel, conv, config, meta) {\n  var parentSpel = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n\n  if (left.type == right.type) {\n    if (left.type == \"!aggr\") {\n      var _map = [left.source, right.source].map(function (v) {\n        return convertArg(v, conv, config, meta, _objectSpread(_objectSpread({}, spel), {}, {\n          _groupField: parentSpel === null || parentSpel === void 0 ? void 0 : parentSpel._groupField\n        }));\n      }),\n          _map2 = (0, _slicedToArray2[\"default\"])(_map, 2),\n          leftSource = _map2[0],\n          rightSource = _map2[1]; //todo: check same filter\n\n\n      return leftSource.value == rightSource.value;\n    } else {\n      var _map3 = [left, right].map(function (v) {\n        return convertArg(v, conv, config, meta, _objectSpread(_objectSpread({}, spel), {}, {\n          _groupField: parentSpel === null || parentSpel === void 0 ? void 0 : parentSpel._groupField\n        }));\n      }),\n          _map4 = (0, _slicedToArray2[\"default\"])(_map3, 2),\n          leftVal = _map4[0],\n          rightVal = _map4[1];\n\n      return leftVal.value == rightVal.value;\n    }\n  }\n\n  return false;\n};\n\nvar convertToTree = function convertToTree(spel, conv, config, meta) {\n  var parentSpel = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  if (!spel) return undefined;\n  var res;\n\n  if (spel.type.indexOf(\"op-\") == 0) {\n    var op = spel.type.slice(\"op-\".length); // unary\n\n    var isUnary = (op == \"minus\" || op == \"plus\") && spel.children.length == 1;\n\n    if (isUnary) {\n      spel.isUnary = true;\n      return convertToTree(spel.children[0], conv, config, meta, spel);\n    } // between\n\n\n    var isBetweenNormal = op == \"and\" && spel.children.length == 2 && spel.children[0].type == \"op-ge\" && spel.children[1].type == \"op-le\";\n    var isBetweenRev = op == \"or\" && spel.children.length == 2 && spel.children[0].type == \"op-lt\" && spel.children[1].type == \"op-gt\";\n    var isBetween = isBetweenNormal || isBetweenRev;\n\n    if (isBetween) {\n      var _spel$children$0$chil = (0, _slicedToArray2[\"default\"])(spel.children[0].children, 2),\n          left = _spel$children$0$chil[0],\n          from = _spel$children$0$chil[1];\n\n      var _spel$children$1$chil = (0, _slicedToArray2[\"default\"])(spel.children[1].children, 2),\n          right = _spel$children$1$chil[0],\n          to = _spel$children$1$chil[1];\n\n      var isNumbers = from.type == \"number\" && to.type == \"number\";\n      var isSameSource = compareArgs(left, right, spel, conv, config, meta, parentSpel);\n\n      if (isNumbers && isSameSource) {\n        var _fromValue = from.val;\n        var _toValue = to.val;\n        var oneSpel = {\n          type: \"op-between\",\n          children: [left, from, to]\n        };\n        return convertToTree(oneSpel, conv, config, meta, parentSpel);\n      }\n    } // find op\n\n\n    var opKeys = conv.operators[op];\n    var opKey; // todo: make dynamic, use basic config\n\n    if (op == \"eq\" && spel.children[1].type == \"null\") {\n      opKey = \"is_null\";\n    } else if (op == \"ne\" && spel.children[1].type == \"null\") {\n      opKey = \"is_not_null\";\n    } else if (op == \"le\" && spel.children[1].type == \"string\" && spel.children[1].val == \"\") {\n      opKey = \"is_empty\";\n    } else if (op == \"gt\" && spel.children[1].type == \"string\" && spel.children[1].val == \"\") {\n      opKey = \"is_not_empty\";\n    } else if (op == \"between\") {\n      opKey = \"between\";\n      opKeys = [\"between\"];\n    } // convert children\n\n\n    var convertChildren = function convertChildren() {\n      return spel.children.map(function (child) {\n        return convertToTree(child, conv, config, meta, _objectSpread(_objectSpread({}, spel), {}, {\n          _groupField: parentSpel === null || parentSpel === void 0 ? void 0 : parentSpel._groupField\n        }));\n      });\n    };\n\n    if (op == \"and\" || op == \"or\") {\n      var children1 = {};\n      var vals = convertChildren();\n      vals.forEach(function (v) {\n        if (v) {\n          var id = (0, _uuid[\"default\"])();\n          v.id = id;\n\n          if (v.type != undefined) {\n            children1[id] = v;\n          } else {\n            meta.errors.push(\"Bad item in AND/OR: \".concat(JSON.stringify(v)));\n          }\n        }\n      });\n      res = {\n        type: \"group\",\n        id: (0, _uuid[\"default\"])(),\n        children1: children1,\n        properties: {\n          conjunction: conv.conjunctions[op],\n          not: spel.not\n        }\n      };\n    } else if (opKeys) {\n      var _vals = convertChildren();\n\n      var fieldObj = _vals[0];\n\n      var convertedArgs = _vals.slice(1);\n\n      opKey = opKeys[0];\n\n      if (!fieldObj) {// LHS can't be parsed\n      } else if (fieldObj.groupFieldValue) {\n        // 1. group\n        if (fieldObj.groupFieldValue.valueSrc != \"field\") {\n          meta.errors.push(\"Expected group field \".concat(JSON.stringify(fieldObj)));\n        }\n\n        var groupField = fieldObj.groupFieldValue.value; // some/all/none\n\n        var opArg = convertedArgs[0];\n\n        if (opArg && opArg.groupFieldValue && opArg.groupFieldValue.valueSrc == \"field\" && opArg.groupFieldValue.value == groupField) {\n          // group.?[...].size() == group.size()\n          opKey = \"all\";\n          convertedArgs = [];\n        } else if (opKey == \"equal\" && opArg.valueSrc == \"value\" && opArg.valueType == \"number\" && opArg.value == 0) {\n          opKey = \"none\";\n          convertedArgs = [];\n        } else if (opKey == \"greater\" && opArg.valueSrc == \"value\" && opArg.valueType == \"number\" && opArg.value == 0) {\n          opKey = \"some\";\n          convertedArgs = [];\n        }\n\n        res = buildRuleGroup(fieldObj, opKey, convertedArgs, config, meta);\n      } else {\n        // 2. not group\n        if (fieldObj.valueSrc != \"field\") {\n          meta.errors.push(\"Expected field \".concat(JSON.stringify(fieldObj)));\n        }\n\n        var field = fieldObj.value;\n\n        if (opKeys.length > 1) {\n          _stuff.logger.warn(\"[spel] Spel operator \".concat(op, \" can be mapped to \").concat(opKeys)); //todo: it's naive\n\n\n          var widgets = opKeys.map(function (op) {\n            return {\n              op: op,\n              widget: (0, _ruleUtils.getWidgetForFieldOp)(config, field, op)\n            };\n          });\n\n          if (op == \"eq\") {\n            var ws = widgets.find(function (_ref2) {\n              var op = _ref2.op,\n                  widget = _ref2.widget;\n              return widget != \"field\";\n            });\n            opKey = ws.op;\n          }\n        }\n\n        res = buildRule(config, meta, field, opKey, convertedArgs);\n      }\n    } else {\n      if (!parentSpel) {\n        // try to parse whole `\"str\" + prop + #var` as ternary\n        res = buildSimpleSwitch(spel, conv, config, meta);\n      }\n\n      if (!res) {\n        meta.errors.push(\"Can't convert op \".concat(op));\n      }\n    }\n  } else if (spel.type == \"!aggr\") {\n    var _groupFilter;\n\n    var groupFieldValue = convertToTree(spel.source, conv, config, meta, _objectSpread(_objectSpread({}, spel), {}, {\n      _groupField: parentSpel === null || parentSpel === void 0 ? void 0 : parentSpel._groupField\n    }));\n    var groupFilter = convertToTree(spel.filter, conv, config, meta, _objectSpread(_objectSpread({}, spel), {}, {\n      _groupField: groupFieldValue === null || groupFieldValue === void 0 ? void 0 : groupFieldValue.value\n    }));\n\n    if (((_groupFilter = groupFilter) === null || _groupFilter === void 0 ? void 0 : _groupFilter.type) == \"rule\") {\n      groupFilter = wrapInDefaultConj(groupFilter, config);\n    }\n\n    res = {\n      groupFilter: groupFilter,\n      groupFieldValue: groupFieldValue\n    };\n\n    if (!parentSpel) {\n      // !aggr can't be in root, it should be compared with something\n      res = undefined;\n      meta.errors.push(\"Unexpected !aggr in root\");\n    }\n  } else if (spel.type == \"ternary\") {\n    var _children = {};\n    spel.val.forEach(function (v) {\n      var _v = (0, _slicedToArray2[\"default\"])(v, 2),\n          cond = _v[0],\n          val = _v[1];\n\n      var caseI = buildCase(cond, val, conv, config, meta, spel);\n\n      if (caseI) {\n        _children[caseI.id] = caseI;\n      }\n    });\n    res = {\n      type: \"switch_group\",\n      id: (0, _uuid[\"default\"])(),\n      children1: _children,\n      properties: {}\n    };\n  } else {\n    res = convertArg(spel, conv, config, meta, parentSpel);\n\n    if (res && !res.type && !parentSpel) {\n      // try to parse whole `\"1\"` as ternary\n      var sw = buildSimpleSwitch(spel, conv, config, meta);\n\n      if (sw) {\n        res = sw;\n      } else {\n        res = undefined;\n        meta.errors.push(\"Can't convert rule of type \".concat(spel.type, \", it looks like var/literal\"));\n      }\n    }\n  }\n\n  return res;\n};\n\nvar buildSimpleSwitch = function buildSimpleSwitch(val, conv, config, meta) {\n  var children1 = {};\n  var cond = null;\n  var caseI = buildCase(cond, val, conv, config, meta);\n\n  if (caseI) {\n    children1[caseI.id] = caseI;\n  }\n\n  var res = {\n    type: \"switch_group\",\n    id: (0, _uuid[\"default\"])(),\n    children1: children1,\n    properties: {}\n  };\n  return res;\n};\n\nvar buildCase = function buildCase(cond, val, conv, config, meta) {\n  var spel = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n  var valProperties = buildCaseValProperties(config, meta, conv, val, spel);\n  var caseI;\n\n  if (cond) {\n    caseI = convertToTree(cond, conv, config, meta, spel);\n\n    if (caseI && caseI.type) {\n      if (caseI.type != \"group\") {\n        caseI = wrapInDefaultConj(caseI, config);\n      }\n\n      caseI.type = \"case_group\";\n    } else {\n      meta.errors.push(\"Unexpected case: \".concat(JSON.stringify(caseI)));\n      caseI = undefined;\n    }\n  } else {\n    caseI = {\n      id: (0, _uuid[\"default\"])(),\n      type: \"case_group\",\n      properties: {}\n    };\n  }\n\n  if (caseI) {\n    caseI.properties = _objectSpread(_objectSpread({}, caseI.properties), valProperties);\n  }\n\n  return caseI;\n};\n\nvar buildCaseValueConcat = function buildCaseValueConcat(spel, conv, config, meta) {\n  var flat = [];\n\n  function _processConcatChildren(children) {\n    children.map(function (child) {\n      if (child.type == \"op-plus\") {\n        _processConcatChildren(child.children);\n      } else {\n        var convertedChild = convertArg(child, conv, config, meta, spel);\n\n        if (convertedChild) {\n          flat.push(convertedChild);\n        } else {\n          meta.errors.push(\"Can't convert \".concat(child.type, \" in concatenation\"));\n        }\n      }\n    });\n  }\n\n  _processConcatChildren(spel.children);\n\n  return {\n    valueSrc: \"value\",\n    valueType: \"case_value\",\n    value: flat\n  };\n};\n\nvar buildCaseValProperties = function buildCaseValProperties(config, meta, conv, val) {\n  var spel = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  var valProperties = {};\n  var convVal;\n\n  if ((val === null || val === void 0 ? void 0 : val.type) == \"op-plus\") {\n    convVal = buildCaseValueConcat(val, conv, config, meta);\n  } else {\n    convVal = convertArg(val, conv, config, meta, spel);\n  }\n\n  var widgetDef = config.widgets[\"case_value\"];\n  var importCaseValue = widgetDef === null || widgetDef === void 0 ? void 0 : widgetDef.spelImportValue;\n\n  if (importCaseValue) {\n    var _importCaseValue = importCaseValue(convVal),\n        _importCaseValue2 = (0, _slicedToArray2[\"default\"])(_importCaseValue, 2),\n        normVal = _importCaseValue2[0],\n        normErrors = _importCaseValue2[1];\n\n    normErrors.map(function (e) {\n      return meta.errors.push(e);\n    });\n\n    if (normVal) {\n      valProperties = {\n        value: [normVal],\n        valueSrc: [\"value\"],\n        valueType: [\"case_value\"]\n      };\n    }\n  } else {\n    meta.errors.push(\"No fucntion to import case value\");\n  }\n\n  return valProperties;\n};\n\nvar wrapInDefaultConjRuleGroup = function wrapInDefaultConjRuleGroup(rule, parentField, parentFieldConfig, config, conj) {\n  if (!rule) return undefined;\n  return {\n    type: \"rule_group\",\n    id: (0, _uuid[\"default\"])(),\n    children1: (0, _defineProperty2[\"default\"])({}, rule.id, rule),\n    properties: {\n      conjunction: conj || (0, _defaultUtils.defaultGroupConjunction)(config, parentFieldConfig),\n      not: false,\n      field: parentField\n    }\n  };\n};\n\nvar wrapInDefaultConj = function wrapInDefaultConj(rule, config) {\n  var not = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  return {\n    type: \"group\",\n    id: (0, _uuid[\"default\"])(),\n    children1: (0, _defineProperty2[\"default\"])({}, rule.id, rule),\n    properties: {\n      conjunction: (0, _defaultUtils.defaultConjunction)(config),\n      not: not\n    }\n  };\n};"]},"metadata":{},"sourceType":"script"}