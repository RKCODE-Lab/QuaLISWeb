{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n  if (!it) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nimport { defaultValue } from \"../utils/stuff\";\nimport { getFieldConfig, getOperatorConfig, getFieldWidgetConfig, getFuncConfig } from \"../utils/configUtils\";\nimport { getWidgetForFieldOp } from \"../utils/ruleUtils\";\nimport { defaultConjunction } from \"../utils/defaultUtils\";\nimport { completeValue } from \"../utils/funcUtils\";\nimport { List, Map } from \"immutable\";\nimport omit from \"lodash/omit\";\nimport pick from \"lodash/pick\"; // http://jsonlogic.com/\n\nexport var jsonLogicFormat = function jsonLogicFormat(item, config) {\n  //meta is mutable\n  var meta = {\n    usedFields: [],\n    errors: []\n  };\n  var logic = formatItem(item, config, meta, true); // build empty data\n\n  var errors = meta.errors,\n      usedFields = meta.usedFields;\n  var fieldSeparator = config.settings.fieldSeparator;\n  var data = {};\n\n  var _iterator = _createForOfIteratorHelper(usedFields),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var ff = _step.value;\n      var def = getFieldConfig(config, ff) || {};\n      var parts = ff.split(fieldSeparator);\n      var tmp = data;\n\n      for (var i = 0; i < parts.length; i++) {\n        var p = parts[i];\n        var pdef = getFieldConfig(config, parts.slice(0, i + 1)) || {};\n\n        if (i != parts.length - 1) {\n          if (pdef.type == \"!group\" && pdef.mode != \"struct\") {\n            if (!tmp[p]) tmp[p] = [{}];\n            tmp = tmp[p][0];\n          } else {\n            if (!tmp[p]) tmp[p] = {};\n            tmp = tmp[p];\n          }\n        } else {\n          if (!tmp[p]) tmp[p] = null; // can use def.type for sample values\n        }\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return {\n    errors: errors,\n    logic: logic,\n    data: data\n  };\n};\n\nvar formatItem = function formatItem(item, config, meta, isRoot) {\n  var parentField = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  if (!item) return undefined;\n  var type = item.get(\"type\");\n  var properties = item.get(\"properties\") || new Map();\n  var isLocked = properties.get(\"isLocked\");\n  var lockedOp = config.settings.jsonLogic.lockedOp;\n  var ret;\n\n  if (type === \"group\" || type === \"rule_group\") {\n    ret = formatGroup(item, config, meta, isRoot, parentField);\n  } else if (type === \"rule\") {\n    ret = formatRule(item, config, meta, parentField);\n  }\n\n  if (isLocked && ret && lockedOp) {\n    ret = _defineProperty({}, lockedOp, ret);\n  }\n\n  return ret;\n};\n\nvar formatGroup = function formatGroup(item, config, meta, isRoot) {\n  var parentField = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  var type = item.get(\"type\");\n  var properties = item.get(\"properties\") || new Map();\n  var mode = properties.get(\"mode\");\n  var children = item.get(\"children1\") || new List();\n  var field = properties.get(\"field\");\n  var conjunction = properties.get(\"conjunction\");\n  if (!conjunction) conjunction = defaultConjunction(config);\n  var conjunctionDefinition = config.conjunctions[conjunction];\n  var conj = conjunctionDefinition.jsonLogicConj || conjunction.toLowerCase();\n  var not = properties.get(\"not\");\n\n  if (conj != \"and\" && conj != \"or\") {\n    meta.errors.push(\"Conjunction \".concat(conj, \" is not supported\"));\n    return undefined;\n  }\n\n  var isRuleGroup = type === \"rule_group\" && !isRoot;\n  var groupField = isRuleGroup && mode != \"struct\" ? field : parentField;\n  var groupOperator = properties.get(\"operator\");\n  var groupOperatorDefinition = groupOperator && getOperatorConfig(config, groupOperator, field) || null;\n  var formattedValue = formatItemValue(config, properties, meta, groupOperator, parentField);\n  var isGroup0 = isRuleGroup && (!groupOperator || groupOperatorDefinition.cardinality == 0);\n  var list = children.map(function (currentChild) {\n    return formatItem(currentChild, config, meta, false, groupField);\n  }).filter(function (currentChild) {\n    return typeof currentChild !== \"undefined\";\n  });\n\n  if (isRuleGroup && mode != \"struct\" && !isGroup0) {\n    // \"count\" rule can have no \"having\" children, but should have number value\n    if (formattedValue == undefined) return undefined;\n  } else {\n    if (!list.size) return undefined;\n  }\n\n  var resultQuery = {};\n  if (list.size == 1 && !isRoot) resultQuery = list.first();else resultQuery[conj] = list.toList().toJS(); // revert\n\n  if (not) {\n    resultQuery = {\n      \"!\": resultQuery\n    };\n  } // rule_group (issue #246)\n\n\n  if (isRuleGroup && mode != \"struct\") {\n    var formattedField = formatField(meta, config, field, parentField);\n\n    if (isGroup0) {\n      // config.settings.groupOperators\n      var op = groupOperator || \"some\";\n      resultQuery = _defineProperty({}, op, [formattedField, resultQuery]);\n    } else {\n      // there is rule for count\n      var filter = !list.size ? formattedField : {\n        \"filter\": [formattedField, resultQuery]\n      };\n      var count = {\n        \"reduce\": [filter, {\n          \"+\": [1, {\n            \"var\": \"accumulator\"\n          }]\n        }, 0]\n      };\n      resultQuery = formatLogic(config, properties, count, formattedValue, groupOperator);\n    }\n  }\n\n  return resultQuery;\n};\n\nvar formatRule = function formatRule(item, config, meta) {\n  var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var properties = item.get(\"properties\") || new Map();\n  var field = properties.get(\"field\");\n  var operator = properties.get(\"operator\");\n  var operatorOptions = properties.get(\"operatorOptions\");\n  operatorOptions = operatorOptions ? operatorOptions.toJS() : null;\n  if (operatorOptions && !Object.keys(operatorOptions).length) operatorOptions = null;\n  if (field == null || operator == null) return undefined;\n  var fieldDefinition = getFieldConfig(config, field) || {};\n  var operatorDefinition = getOperatorConfig(config, operator, field) || {};\n  var reversedOp = operatorDefinition.reversedOp;\n  var revOperatorDefinition = getOperatorConfig(config, reversedOp, field) || {}; // check op\n\n  var isRev = false;\n\n  if (!operatorDefinition.jsonLogic && !revOperatorDefinition.jsonLogic) {\n    meta.errors.push(\"Operator \".concat(operator, \" is not supported\"));\n    return undefined;\n  }\n\n  if (!operatorDefinition.jsonLogic && revOperatorDefinition.jsonLogic) {\n    isRev = true;\n    var _ref = [reversedOp, operator];\n    operator = _ref[0];\n    reversedOp = _ref[1];\n    var _ref2 = [revOperatorDefinition, operatorDefinition];\n    operatorDefinition = _ref2[0];\n    revOperatorDefinition = _ref2[1];\n  }\n\n  var formattedValue = formatItemValue(config, properties, meta, operator, parentField);\n  if (formattedValue === undefined) return undefined;\n  var formattedField = formatField(meta, config, field, parentField);\n  return formatLogic(config, properties, formattedField, formattedValue, operator, operatorOptions, fieldDefinition, isRev);\n};\n\nvar formatItemValue = function formatItemValue(config, properties, meta, operator, parentField) {\n  var field = properties.get(\"field\");\n  var iValueSrc = properties.get(\"valueSrc\");\n  var iValueType = properties.get(\"valueType\");\n  var fieldDefinition = getFieldConfig(config, field) || {};\n  var operatorDefinition = getOperatorConfig(config, operator, field) || {};\n  var cardinality = defaultValue(operatorDefinition.cardinality, 1);\n  var iValue = properties.get(\"value\");\n  var asyncListValues = properties.get(\"asyncListValues\");\n  if (iValue == undefined) return undefined;\n  var valueSrcs = [];\n  var valueTypes = [];\n  var oldUsedFields = meta.usedFields;\n  var fvalue = iValue.map(function (currentValue, ind) {\n    var valueSrc = iValueSrc ? iValueSrc.get(ind) : null;\n    var valueType = iValueType ? iValueType.get(ind) : null;\n    var cValue = completeValue(currentValue, valueSrc, config);\n    var widget = getWidgetForFieldOp(config, field, operator, valueSrc);\n    var fieldWidgetDef = omit(getFieldWidgetConfig(config, field, operator, widget, valueSrc), [\"factory\"]);\n    var fv = formatValue(meta, config, cValue, valueSrc, valueType, fieldWidgetDef, fieldDefinition, operator, operatorDefinition, parentField, asyncListValues);\n\n    if (fv !== undefined) {\n      valueSrcs.push(valueSrc);\n      valueTypes.push(valueType);\n    }\n\n    return fv;\n  });\n  var hasUndefinedValues = fvalue.filter(function (v) {\n    return v === undefined;\n  }).size > 0;\n\n  if (fvalue.size < cardinality || hasUndefinedValues) {\n    meta.usedFields = oldUsedFields; // restore\n\n    return undefined;\n  }\n\n  return cardinality > 1 ? fvalue.toArray() : cardinality == 1 ? fvalue.first() : null;\n};\n\nvar formatValue = function formatValue(meta, config, currentValue, valueSrc, valueType, fieldWidgetDef, fieldDef, operator, operatorDef) {\n  var parentField = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : null;\n  var asyncListValues = arguments.length > 10 ? arguments[10] : undefined;\n  if (currentValue === undefined) return undefined;\n  var ret;\n\n  if (valueSrc == \"field\") {\n    ret = formatField(meta, config, currentValue, parentField);\n  } else if (valueSrc == \"func\") {\n    ret = formatFunc(meta, config, currentValue, parentField);\n  } else if (typeof fieldWidgetDef.jsonLogic === \"function\") {\n    var fn = fieldWidgetDef.jsonLogic;\n    var args = [currentValue, _objectSpread(_objectSpread({}, pick(fieldDef, [\"fieldSettings\", \"listValues\"])), {}, {\n      asyncListValues: asyncListValues\n    }), //useful options: valueFormat for date/time\n    omit(fieldWidgetDef, [\"formatValue\", \"mongoFormatValue\", \"sqlFormatValue\", \"jsonLogic\", \"elasticSearchFormatValue\", \"spelFormatValue\"])];\n\n    if (operator) {\n      args.push(operator);\n      args.push(operatorDef);\n    }\n\n    ret = fn.apply(void 0, args);\n  } else {\n    ret = currentValue;\n  }\n\n  return ret;\n};\n\nvar formatFunc = function formatFunc(meta, config, currentValue) {\n  var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var funcKey = currentValue.get(\"func\");\n  var args = currentValue.get(\"args\");\n  var funcConfig = getFuncConfig(config, funcKey);\n\n  if (!funcConfig.jsonLogic) {\n    meta.errors.push(\"Func \".concat(funcKey, \" is not supported\"));\n    return undefined;\n  }\n\n  var formattedArgs = {};\n\n  for (var argKey in funcConfig.args) {\n    var argConfig = funcConfig.args[argKey];\n    var fieldDef = getFieldConfig(config, argConfig);\n    var argVal = args ? args.get(argKey) : undefined;\n    var argValue = argVal ? argVal.get(\"value\") : undefined;\n    var argValueSrc = argVal ? argVal.get(\"valueSrc\") : undefined;\n    var formattedArgVal = formatValue(meta, config, argValue, argValueSrc, argConfig.type, fieldDef, argConfig, null, null, parentField);\n\n    if (argValue != undefined && formattedArgVal === undefined) {\n      meta.errors.push(\"Can't format value of arg \".concat(argKey, \" for func \").concat(funcKey));\n      return undefined;\n    }\n\n    if (formattedArgVal !== undefined) {\n      // skip optional in the end\n      formattedArgs[argKey] = formattedArgVal;\n    }\n  }\n\n  var formattedArgsArr = Object.values(formattedArgs);\n  var ret;\n\n  if (typeof funcConfig.jsonLogic === \"function\") {\n    var fn = funcConfig.jsonLogic;\n    var _args = [formattedArgs];\n    ret = fn.apply(void 0, _args);\n  } else {\n    var funcName = funcConfig.jsonLogic || funcKey;\n    var isMethod = !!funcConfig.jsonLogicIsMethod;\n\n    if (isMethod) {\n      var obj = formattedArgsArr[0],\n          params = formattedArgsArr.slice(1);\n\n      if (params.length) {\n        ret = {\n          \"method\": [obj, funcName, params]\n        };\n      } else {\n        ret = {\n          \"method\": [obj, funcName]\n        };\n      }\n    } else {\n      ret = _defineProperty({}, funcName, formattedArgsArr);\n    }\n  }\n\n  return ret;\n};\n\nvar formatField = function formatField(meta, config, field) {\n  var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var _config$settings = config.settings,\n      fieldSeparator = _config$settings.fieldSeparator,\n      jsonLogic = _config$settings.jsonLogic;\n  var ret;\n\n  if (field) {\n    if (Array.isArray(field)) field = field.join(fieldSeparator);\n    var fieldDef = getFieldConfig(config, field) || {};\n    var fieldName = field;\n\n    if (fieldDef.fieldName) {\n      fieldName = fieldDef.fieldName;\n    }\n\n    if (parentField) {\n      var parentFieldDef = getFieldConfig(config, parentField) || {};\n      var parentFieldName = parentField;\n\n      if (parentFieldDef.fieldName) {\n        parentFieldName = parentFieldDef.fieldName;\n      }\n\n      if (fieldName.indexOf(parentFieldName + fieldSeparator) == 0) {\n        fieldName = fieldName.slice((parentFieldName + fieldSeparator).length);\n      } else {\n        meta.errors.push(\"Can't cut group \".concat(parentFieldName, \" from field \").concat(fieldName));\n      }\n    }\n\n    var varName = fieldDef.jsonLogicVar || (fieldDef.type == \"!group\" ? jsonLogic.groupVarKey : \"var\");\n    ret = _defineProperty({}, varName, fieldName);\n    if (meta.usedFields.indexOf(field) == -1) meta.usedFields.push(field);\n  }\n\n  return ret;\n};\n\nvar buildFnToFormatOp = function buildFnToFormatOp(operator, operatorDefinition, formattedField, formattedValue) {\n  var formatteOp = operator;\n  var cardinality = defaultValue(operatorDefinition.cardinality, 1);\n  var isReverseArgs = defaultValue(operatorDefinition._jsonLogicIsRevArgs, false);\n  if (typeof operatorDefinition.jsonLogic == \"string\") formatteOp = operatorDefinition.jsonLogic;\n  var rangeOps = [\"<\", \"<=\", \">\", \">=\"];\n  var eqOps = [\"==\", \"!=\"];\n\n  var fn = function fn(field, op, val, opDef, opOpts) {\n    if (cardinality == 0 && eqOps.includes(formatteOp)) return _defineProperty({}, formatteOp, [formattedField, null]);else if (cardinality == 0) return _defineProperty({}, formatteOp, formattedField);else if (cardinality == 1 && isReverseArgs) return _defineProperty({}, formatteOp, [formattedValue, formattedField]);else if (cardinality == 1) return _defineProperty({}, formatteOp, [formattedField, formattedValue]);else if (cardinality == 2 && rangeOps.includes(formatteOp)) return _defineProperty({}, formatteOp, [formattedValue[0], formattedField, formattedValue[1]]);else return _defineProperty({}, formatteOp, [formattedField].concat(_toConsumableArray(formattedValue)));\n  };\n\n  return fn;\n};\n\nvar formatLogic = function formatLogic(config, properties, formattedField, formattedValue, operator) {\n  var operatorOptions = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n  var fieldDefinition = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n  var isRev = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;\n  var field = properties.get(\"field\");\n  var operatorDefinition = getOperatorConfig(config, operator, field) || {};\n  var fn = typeof operatorDefinition.jsonLogic == \"function\" ? operatorDefinition.jsonLogic : buildFnToFormatOp(operator, operatorDefinition, formattedField, formattedValue);\n  var args = [formattedField, operator, formattedValue, omit(operatorDefinition, [\"formatOp\", \"mongoFormatOp\", \"sqlFormatOp\", \"jsonLogic\", \"spelFormatOp\"]), operatorOptions, fieldDefinition];\n  var ruleQuery = fn.apply(void 0, args);\n\n  if (isRev) {\n    ruleQuery = {\n      \"!\": ruleQuery\n    };\n  }\n\n  return ruleQuery;\n};","map":{"version":3,"sources":["D:/LIMSWFH/LIMSPOSTGRESQL/QuaLISWeb/node_modules/@react-awesome-query-builder/core/esm/export/jsonLogic.js"],"names":["_toConsumableArray","_defineProperty","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","_createForOfIteratorHelper","o","allowArrayLike","it","Symbol","iterator","Array","isArray","_unsupportedIterableToArray","F","s","n","done","value","e","_e","f","TypeError","normalCompletion","didErr","err","call","step","next","_e2","minLen","_arrayLikeToArray","prototype","toString","slice","constructor","name","from","test","arr","len","arr2","defaultValue","getFieldConfig","getOperatorConfig","getFieldWidgetConfig","getFuncConfig","getWidgetForFieldOp","defaultConjunction","completeValue","List","Map","omit","pick","jsonLogicFormat","item","config","meta","usedFields","errors","logic","formatItem","fieldSeparator","settings","data","_iterator","_step","ff","def","parts","split","tmp","p","pdef","type","mode","isRoot","parentField","undefined","get","properties","isLocked","lockedOp","jsonLogic","ret","formatGroup","formatRule","children","field","conjunction","conjunctionDefinition","conjunctions","conj","jsonLogicConj","toLowerCase","not","concat","isRuleGroup","groupField","groupOperator","groupOperatorDefinition","formattedValue","formatItemValue","isGroup0","cardinality","list","map","currentChild","size","resultQuery","first","toList","toJS","formattedField","formatField","op","count","formatLogic","operator","operatorOptions","fieldDefinition","operatorDefinition","reversedOp","revOperatorDefinition","isRev","_ref","_ref2","iValueSrc","iValueType","iValue","asyncListValues","valueSrcs","valueTypes","oldUsedFields","fvalue","currentValue","ind","valueSrc","valueType","cValue","widget","fieldWidgetDef","fv","formatValue","hasUndefinedValues","v","toArray","fieldDef","operatorDef","formatFunc","fn","args","funcKey","funcConfig","formattedArgs","argKey","argConfig","argVal","argValue","argValueSrc","formattedArgVal","formattedArgsArr","values","_args","funcName","isMethod","jsonLogicIsMethod","obj","params","_config$settings","join","fieldName","parentFieldDef","parentFieldName","indexOf","varName","jsonLogicVar","groupVarKey","buildFnToFormatOp","formatteOp","isReverseArgs","_jsonLogicIsRevArgs","rangeOps","eqOps","val","opDef","opOpts","includes","ruleQuery"],"mappings":"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","sourcesContent":["import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nimport { defaultValue } from \"../utils/stuff\";\nimport { getFieldConfig, getOperatorConfig, getFieldWidgetConfig, getFuncConfig } from \"../utils/configUtils\";\nimport { getWidgetForFieldOp } from \"../utils/ruleUtils\";\nimport { defaultConjunction } from \"../utils/defaultUtils\";\nimport { completeValue } from \"../utils/funcUtils\";\nimport { List, Map } from \"immutable\";\nimport omit from \"lodash/omit\";\nimport pick from \"lodash/pick\";\n\n// http://jsonlogic.com/\n\nexport var jsonLogicFormat = function jsonLogicFormat(item, config) {\n  //meta is mutable\n  var meta = {\n    usedFields: [],\n    errors: []\n  };\n  var logic = formatItem(item, config, meta, true);\n\n  // build empty data\n  var errors = meta.errors,\n    usedFields = meta.usedFields;\n  var fieldSeparator = config.settings.fieldSeparator;\n  var data = {};\n  var _iterator = _createForOfIteratorHelper(usedFields),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var ff = _step.value;\n      var def = getFieldConfig(config, ff) || {};\n      var parts = ff.split(fieldSeparator);\n      var tmp = data;\n      for (var i = 0; i < parts.length; i++) {\n        var p = parts[i];\n        var pdef = getFieldConfig(config, parts.slice(0, i + 1)) || {};\n        if (i != parts.length - 1) {\n          if (pdef.type == \"!group\" && pdef.mode != \"struct\") {\n            if (!tmp[p]) tmp[p] = [{}];\n            tmp = tmp[p][0];\n          } else {\n            if (!tmp[p]) tmp[p] = {};\n            tmp = tmp[p];\n          }\n        } else {\n          if (!tmp[p]) tmp[p] = null; // can use def.type for sample values\n        }\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return {\n    errors: errors,\n    logic: logic,\n    data: data\n  };\n};\nvar formatItem = function formatItem(item, config, meta, isRoot) {\n  var parentField = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  if (!item) return undefined;\n  var type = item.get(\"type\");\n  var properties = item.get(\"properties\") || new Map();\n  var isLocked = properties.get(\"isLocked\");\n  var lockedOp = config.settings.jsonLogic.lockedOp;\n  var ret;\n  if (type === \"group\" || type === \"rule_group\") {\n    ret = formatGroup(item, config, meta, isRoot, parentField);\n  } else if (type === \"rule\") {\n    ret = formatRule(item, config, meta, parentField);\n  }\n  if (isLocked && ret && lockedOp) {\n    ret = _defineProperty({}, lockedOp, ret);\n  }\n  return ret;\n};\nvar formatGroup = function formatGroup(item, config, meta, isRoot) {\n  var parentField = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  var type = item.get(\"type\");\n  var properties = item.get(\"properties\") || new Map();\n  var mode = properties.get(\"mode\");\n  var children = item.get(\"children1\") || new List();\n  var field = properties.get(\"field\");\n  var conjunction = properties.get(\"conjunction\");\n  if (!conjunction) conjunction = defaultConjunction(config);\n  var conjunctionDefinition = config.conjunctions[conjunction];\n  var conj = conjunctionDefinition.jsonLogicConj || conjunction.toLowerCase();\n  var not = properties.get(\"not\");\n  if (conj != \"and\" && conj != \"or\") {\n    meta.errors.push(\"Conjunction \".concat(conj, \" is not supported\"));\n    return undefined;\n  }\n  var isRuleGroup = type === \"rule_group\" && !isRoot;\n  var groupField = isRuleGroup && mode != \"struct\" ? field : parentField;\n  var groupOperator = properties.get(\"operator\");\n  var groupOperatorDefinition = groupOperator && getOperatorConfig(config, groupOperator, field) || null;\n  var formattedValue = formatItemValue(config, properties, meta, groupOperator, parentField);\n  var isGroup0 = isRuleGroup && (!groupOperator || groupOperatorDefinition.cardinality == 0);\n  var list = children.map(function (currentChild) {\n    return formatItem(currentChild, config, meta, false, groupField);\n  }).filter(function (currentChild) {\n    return typeof currentChild !== \"undefined\";\n  });\n  if (isRuleGroup && mode != \"struct\" && !isGroup0) {\n    // \"count\" rule can have no \"having\" children, but should have number value\n    if (formattedValue == undefined) return undefined;\n  } else {\n    if (!list.size) return undefined;\n  }\n  var resultQuery = {};\n  if (list.size == 1 && !isRoot) resultQuery = list.first();else resultQuery[conj] = list.toList().toJS();\n\n  // revert\n  if (not) {\n    resultQuery = {\n      \"!\": resultQuery\n    };\n  }\n\n  // rule_group (issue #246)\n  if (isRuleGroup && mode != \"struct\") {\n    var formattedField = formatField(meta, config, field, parentField);\n    if (isGroup0) {\n      // config.settings.groupOperators\n      var op = groupOperator || \"some\";\n      resultQuery = _defineProperty({}, op, [formattedField, resultQuery]);\n    } else {\n      // there is rule for count\n      var filter = !list.size ? formattedField : {\n        \"filter\": [formattedField, resultQuery]\n      };\n      var count = {\n        \"reduce\": [filter, {\n          \"+\": [1, {\n            \"var\": \"accumulator\"\n          }]\n        }, 0]\n      };\n      resultQuery = formatLogic(config, properties, count, formattedValue, groupOperator);\n    }\n  }\n  return resultQuery;\n};\nvar formatRule = function formatRule(item, config, meta) {\n  var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var properties = item.get(\"properties\") || new Map();\n  var field = properties.get(\"field\");\n  var operator = properties.get(\"operator\");\n  var operatorOptions = properties.get(\"operatorOptions\");\n  operatorOptions = operatorOptions ? operatorOptions.toJS() : null;\n  if (operatorOptions && !Object.keys(operatorOptions).length) operatorOptions = null;\n  if (field == null || operator == null) return undefined;\n  var fieldDefinition = getFieldConfig(config, field) || {};\n  var operatorDefinition = getOperatorConfig(config, operator, field) || {};\n  var reversedOp = operatorDefinition.reversedOp;\n  var revOperatorDefinition = getOperatorConfig(config, reversedOp, field) || {};\n\n  // check op\n  var isRev = false;\n  if (!operatorDefinition.jsonLogic && !revOperatorDefinition.jsonLogic) {\n    meta.errors.push(\"Operator \".concat(operator, \" is not supported\"));\n    return undefined;\n  }\n  if (!operatorDefinition.jsonLogic && revOperatorDefinition.jsonLogic) {\n    isRev = true;\n    var _ref = [reversedOp, operator];\n    operator = _ref[0];\n    reversedOp = _ref[1];\n    var _ref2 = [revOperatorDefinition, operatorDefinition];\n    operatorDefinition = _ref2[0];\n    revOperatorDefinition = _ref2[1];\n  }\n  var formattedValue = formatItemValue(config, properties, meta, operator, parentField);\n  if (formattedValue === undefined) return undefined;\n  var formattedField = formatField(meta, config, field, parentField);\n  return formatLogic(config, properties, formattedField, formattedValue, operator, operatorOptions, fieldDefinition, isRev);\n};\nvar formatItemValue = function formatItemValue(config, properties, meta, operator, parentField) {\n  var field = properties.get(\"field\");\n  var iValueSrc = properties.get(\"valueSrc\");\n  var iValueType = properties.get(\"valueType\");\n  var fieldDefinition = getFieldConfig(config, field) || {};\n  var operatorDefinition = getOperatorConfig(config, operator, field) || {};\n  var cardinality = defaultValue(operatorDefinition.cardinality, 1);\n  var iValue = properties.get(\"value\");\n  var asyncListValues = properties.get(\"asyncListValues\");\n  if (iValue == undefined) return undefined;\n  var valueSrcs = [];\n  var valueTypes = [];\n  var oldUsedFields = meta.usedFields;\n  var fvalue = iValue.map(function (currentValue, ind) {\n    var valueSrc = iValueSrc ? iValueSrc.get(ind) : null;\n    var valueType = iValueType ? iValueType.get(ind) : null;\n    var cValue = completeValue(currentValue, valueSrc, config);\n    var widget = getWidgetForFieldOp(config, field, operator, valueSrc);\n    var fieldWidgetDef = omit(getFieldWidgetConfig(config, field, operator, widget, valueSrc), [\"factory\"]);\n    var fv = formatValue(meta, config, cValue, valueSrc, valueType, fieldWidgetDef, fieldDefinition, operator, operatorDefinition, parentField, asyncListValues);\n    if (fv !== undefined) {\n      valueSrcs.push(valueSrc);\n      valueTypes.push(valueType);\n    }\n    return fv;\n  });\n  var hasUndefinedValues = fvalue.filter(function (v) {\n    return v === undefined;\n  }).size > 0;\n  if (fvalue.size < cardinality || hasUndefinedValues) {\n    meta.usedFields = oldUsedFields; // restore\n    return undefined;\n  }\n  return cardinality > 1 ? fvalue.toArray() : cardinality == 1 ? fvalue.first() : null;\n};\nvar formatValue = function formatValue(meta, config, currentValue, valueSrc, valueType, fieldWidgetDef, fieldDef, operator, operatorDef) {\n  var parentField = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : null;\n  var asyncListValues = arguments.length > 10 ? arguments[10] : undefined;\n  if (currentValue === undefined) return undefined;\n  var ret;\n  if (valueSrc == \"field\") {\n    ret = formatField(meta, config, currentValue, parentField);\n  } else if (valueSrc == \"func\") {\n    ret = formatFunc(meta, config, currentValue, parentField);\n  } else if (typeof fieldWidgetDef.jsonLogic === \"function\") {\n    var fn = fieldWidgetDef.jsonLogic;\n    var args = [currentValue, _objectSpread(_objectSpread({}, pick(fieldDef, [\"fieldSettings\", \"listValues\"])), {}, {\n      asyncListValues: asyncListValues\n    }),\n    //useful options: valueFormat for date/time\n    omit(fieldWidgetDef, [\"formatValue\", \"mongoFormatValue\", \"sqlFormatValue\", \"jsonLogic\", \"elasticSearchFormatValue\", \"spelFormatValue\"])];\n    if (operator) {\n      args.push(operator);\n      args.push(operatorDef);\n    }\n    ret = fn.apply(void 0, args);\n  } else {\n    ret = currentValue;\n  }\n  return ret;\n};\nvar formatFunc = function formatFunc(meta, config, currentValue) {\n  var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var funcKey = currentValue.get(\"func\");\n  var args = currentValue.get(\"args\");\n  var funcConfig = getFuncConfig(config, funcKey);\n  if (!funcConfig.jsonLogic) {\n    meta.errors.push(\"Func \".concat(funcKey, \" is not supported\"));\n    return undefined;\n  }\n  var formattedArgs = {};\n  for (var argKey in funcConfig.args) {\n    var argConfig = funcConfig.args[argKey];\n    var fieldDef = getFieldConfig(config, argConfig);\n    var argVal = args ? args.get(argKey) : undefined;\n    var argValue = argVal ? argVal.get(\"value\") : undefined;\n    var argValueSrc = argVal ? argVal.get(\"valueSrc\") : undefined;\n    var formattedArgVal = formatValue(meta, config, argValue, argValueSrc, argConfig.type, fieldDef, argConfig, null, null, parentField);\n    if (argValue != undefined && formattedArgVal === undefined) {\n      meta.errors.push(\"Can't format value of arg \".concat(argKey, \" for func \").concat(funcKey));\n      return undefined;\n    }\n    if (formattedArgVal !== undefined) {\n      // skip optional in the end\n      formattedArgs[argKey] = formattedArgVal;\n    }\n  }\n  var formattedArgsArr = Object.values(formattedArgs);\n  var ret;\n  if (typeof funcConfig.jsonLogic === \"function\") {\n    var fn = funcConfig.jsonLogic;\n    var _args = [formattedArgs];\n    ret = fn.apply(void 0, _args);\n  } else {\n    var funcName = funcConfig.jsonLogic || funcKey;\n    var isMethod = !!funcConfig.jsonLogicIsMethod;\n    if (isMethod) {\n      var obj = formattedArgsArr[0],\n        params = formattedArgsArr.slice(1);\n      if (params.length) {\n        ret = {\n          \"method\": [obj, funcName, params]\n        };\n      } else {\n        ret = {\n          \"method\": [obj, funcName]\n        };\n      }\n    } else {\n      ret = _defineProperty({}, funcName, formattedArgsArr);\n    }\n  }\n  return ret;\n};\nvar formatField = function formatField(meta, config, field) {\n  var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var _config$settings = config.settings,\n    fieldSeparator = _config$settings.fieldSeparator,\n    jsonLogic = _config$settings.jsonLogic;\n  var ret;\n  if (field) {\n    if (Array.isArray(field)) field = field.join(fieldSeparator);\n    var fieldDef = getFieldConfig(config, field) || {};\n    var fieldName = field;\n    if (fieldDef.fieldName) {\n      fieldName = fieldDef.fieldName;\n    }\n    if (parentField) {\n      var parentFieldDef = getFieldConfig(config, parentField) || {};\n      var parentFieldName = parentField;\n      if (parentFieldDef.fieldName) {\n        parentFieldName = parentFieldDef.fieldName;\n      }\n      if (fieldName.indexOf(parentFieldName + fieldSeparator) == 0) {\n        fieldName = fieldName.slice((parentFieldName + fieldSeparator).length);\n      } else {\n        meta.errors.push(\"Can't cut group \".concat(parentFieldName, \" from field \").concat(fieldName));\n      }\n    }\n    var varName = fieldDef.jsonLogicVar || (fieldDef.type == \"!group\" ? jsonLogic.groupVarKey : \"var\");\n    ret = _defineProperty({}, varName, fieldName);\n    if (meta.usedFields.indexOf(field) == -1) meta.usedFields.push(field);\n  }\n  return ret;\n};\nvar buildFnToFormatOp = function buildFnToFormatOp(operator, operatorDefinition, formattedField, formattedValue) {\n  var formatteOp = operator;\n  var cardinality = defaultValue(operatorDefinition.cardinality, 1);\n  var isReverseArgs = defaultValue(operatorDefinition._jsonLogicIsRevArgs, false);\n  if (typeof operatorDefinition.jsonLogic == \"string\") formatteOp = operatorDefinition.jsonLogic;\n  var rangeOps = [\"<\", \"<=\", \">\", \">=\"];\n  var eqOps = [\"==\", \"!=\"];\n  var fn = function fn(field, op, val, opDef, opOpts) {\n    if (cardinality == 0 && eqOps.includes(formatteOp)) return _defineProperty({}, formatteOp, [formattedField, null]);else if (cardinality == 0) return _defineProperty({}, formatteOp, formattedField);else if (cardinality == 1 && isReverseArgs) return _defineProperty({}, formatteOp, [formattedValue, formattedField]);else if (cardinality == 1) return _defineProperty({}, formatteOp, [formattedField, formattedValue]);else if (cardinality == 2 && rangeOps.includes(formatteOp)) return _defineProperty({}, formatteOp, [formattedValue[0], formattedField, formattedValue[1]]);else return _defineProperty({}, formatteOp, [formattedField].concat(_toConsumableArray(formattedValue)));\n  };\n  return fn;\n};\nvar formatLogic = function formatLogic(config, properties, formattedField, formattedValue, operator) {\n  var operatorOptions = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n  var fieldDefinition = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n  var isRev = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;\n  var field = properties.get(\"field\");\n  var operatorDefinition = getOperatorConfig(config, operator, field) || {};\n  var fn = typeof operatorDefinition.jsonLogic == \"function\" ? operatorDefinition.jsonLogic : buildFnToFormatOp(operator, operatorDefinition, formattedField, formattedValue);\n  var args = [formattedField, operator, formattedValue, omit(operatorDefinition, [\"formatOp\", \"mongoFormatOp\", \"sqlFormatOp\", \"jsonLogic\", \"spelFormatOp\"]), operatorOptions, fieldDefinition];\n  var ruleQuery = fn.apply(void 0, args);\n  if (isRev) {\n    ruleQuery = {\n      \"!\": ruleQuery\n    };\n  }\n  return ruleQuery;\n};"]},"metadata":{},"sourceType":"module"}