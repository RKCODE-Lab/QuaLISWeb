{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.loadFromJsonLogic = exports._loadFromJsonLogic = void 0;\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _toArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toArray\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _uuid = _interopRequireDefault(require(\"../utils/uuid\"));\n\nvar _stuff = require(\"../utils/stuff\");\n\nvar _configUtils = require(\"../utils/configUtils\");\n\nvar _ruleUtils = require(\"../utils/ruleUtils\");\n\nvar _tree = require(\"./tree\");\n\nvar _defaultUtils = require(\"../utils/defaultUtils\");\n\nvar _moment = _interopRequireDefault(require(\"moment\"));\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      (0, _defineProperty2[\"default\"])(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n} // http://jsonlogic.com/\n// helpers\n\n\nvar arrayUniq = function arrayUniq(arr) {\n  return Array.from(new Set(arr));\n};\n\nvar arrayToObject = function arrayToObject(arr) {\n  return arr.reduce(function (acc, _ref) {\n    var _ref2 = (0, _slicedToArray2[\"default\"])(_ref, 2),\n        f = _ref2[0],\n        fc = _ref2[1];\n\n    return _objectSpread(_objectSpread({}, acc), {}, (0, _defineProperty2[\"default\"])({}, f, fc));\n  }, {});\n};\n\nvar loadFromJsonLogic = function loadFromJsonLogic(logicTree, config) {\n  return _loadFromJsonLogic(logicTree, config, false);\n};\n\nexports.loadFromJsonLogic = loadFromJsonLogic;\n\nvar _loadFromJsonLogic = function _loadFromJsonLogic(logicTree, config) {\n  var returnErrors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true; //meta is mutable\n\n  var meta = {\n    errors: []\n  };\n  var extendedConfig = (0, _configUtils.extendConfig)(config);\n  var conv = buildConv(extendedConfig);\n  var jsTree = logicTree ? convertFromLogic(logicTree, conv, extendedConfig, \"rule\", meta) : undefined;\n\n  if (jsTree && jsTree.type != \"group\") {\n    jsTree = wrapInDefaultConj(jsTree, extendedConfig);\n  }\n\n  var immTree = jsTree ? (0, _tree.loadTree)(jsTree) : undefined;\n\n  if (returnErrors) {\n    return [immTree, meta.errors];\n  } else {\n    if (meta.errors.length) console.warn(\"Errors while importing from JsonLogic:\", meta.errors);\n    return immTree;\n  }\n};\n\nexports._loadFromJsonLogic = _loadFromJsonLogic;\n\nvar buildConv = function buildConv(config) {\n  var operators = {};\n\n  for (var opKey in config.operators) {\n    var opConfig = config.operators[opKey];\n\n    if (typeof opConfig.jsonLogic == \"string\") {\n      // example: \"</2\", \"#in/1\"\n      var opk = (opConfig._jsonLogicIsRevArgs ? \"#\" : \"\") + opConfig.jsonLogic + \"/\" + (0, _stuff.defaultValue)(opConfig.cardinality, 1);\n      if (!operators[opk]) operators[opk] = [];\n      operators[opk].push(opKey);\n    } else if (typeof opConfig.jsonLogic2 == \"string\") {\n      // example: all-in/1\"\n      var _opk = opConfig.jsonLogic2 + \"/\" + (0, _stuff.defaultValue)(opConfig.cardinality, 1);\n\n      if (!operators[_opk]) operators[_opk] = [];\n\n      operators[_opk].push(opKey);\n    }\n  }\n\n  var conjunctions = {};\n\n  for (var conjKey in config.conjunctions) {\n    var conjunctionDefinition = config.conjunctions[conjKey];\n    var ck = conjunctionDefinition.jsonLogicConj || conjKey.toLowerCase();\n    conjunctions[ck] = conjKey;\n  }\n\n  var funcs = {};\n\n  for (var funcKey in config.funcs) {\n    var funcConfig = config.funcs[funcKey];\n    var fk = void 0;\n\n    if (funcConfig.jsonLogicIsMethod) {\n      fk = \"#\" + funcConfig.jsonLogic;\n    } else if (typeof funcConfig.jsonLogic == \"string\") {\n      fk = funcConfig.jsonLogic;\n    }\n\n    if (fk) {\n      if (!funcs[fk]) funcs[fk] = [];\n      funcs[fk].push(funcKey);\n    }\n  }\n\n  var _config$settings$json = config.settings.jsonLogic,\n      groupVarKey = _config$settings$json.groupVarKey,\n      altVarKey = _config$settings$json.altVarKey;\n  return {\n    operators: operators,\n    conjunctions: conjunctions,\n    funcs: funcs,\n    varKeys: [\"var\", groupVarKey, altVarKey]\n  };\n};\n\nvar convertFromLogic = function convertFromLogic(logic, conv, config, expectedType, meta) {\n  var not = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  var fieldConfig = arguments.length > 6 ? arguments[6] : undefined;\n  var widget = arguments.length > 7 ? arguments[7] : undefined;\n  var parentField = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : null;\n\n  var _isLockedLogic = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : false;\n\n  var op, vals;\n\n  if ((0, _stuff.isJsonLogic)(logic)) {\n    op = Object.keys(logic)[0];\n    vals = logic[op];\n    if (!Array.isArray(vals)) vals = [vals];\n  }\n\n  var ret;\n  var beforeErrorsCnt = meta.errors.length;\n  var lockedOp = config.settings.jsonLogic.lockedOp;\n  var isEmptyOp = op == \"!\" && vals.length == 1 && vals[0] && (0, _stuff.isJsonLogic)(vals[0]) && conv.varKeys.includes(Object.keys(vals[0])[0]);\n  var isRev = op == \"!\" && !isEmptyOp;\n  var isLocked = lockedOp && op == lockedOp;\n\n  if (isLocked) {\n    ret = convertFromLogic(vals[0], conv, config, expectedType, meta, not, fieldConfig, widget, parentField, true);\n  } else if (isRev) {\n    // reverse with not\n    ret = convertFromLogic(vals[0], conv, config, expectedType, meta, !not, fieldConfig, widget, parentField);\n  } else if (expectedType == \"val\") {\n    // not is not used here\n    ret = convertField(op, vals, conv, config, not, meta, parentField) || convertFunc(op, vals, conv, config, not, fieldConfig, meta, parentField) || convertVal(logic, fieldConfig, widget, config, meta);\n  } else if (expectedType == \"rule\") {\n    ret = convertConj(op, vals, conv, config, not, meta, parentField, false) || convertOp(op, vals, conv, config, not, meta, parentField);\n  }\n\n  var afterErrorsCnt = meta.errors.length;\n\n  if (op != \"!\" && ret === undefined && afterErrorsCnt == beforeErrorsCnt) {\n    meta.errors.push(\"Can't parse logic \".concat(JSON.stringify(logic)));\n  }\n\n  if (isLocked) {\n    ret.properties.isLocked = true;\n  }\n\n  return ret;\n};\n\nvar convertVal = function convertVal(val, fieldConfig, widget, config, meta) {\n  if (val === undefined) return undefined;\n  var widgetConfig = config.widgets[widget || fieldConfig.mainWidget];\n\n  if (!widgetConfig) {\n    meta.errors.push(\"No widget for type \".concat(fieldConfig.type));\n    return undefined;\n  }\n\n  if ((0, _stuff.isJsonLogic)(val)) {\n    meta.errors.push(\"Unexpected logic in value: \".concat(JSON.stringify(val)));\n    return undefined;\n  } // number of seconds -> time string\n\n\n  if (fieldConfig && fieldConfig.type == \"time\" && typeof val == \"number\") {\n    var h = Math.floor(val / 60 / 60) % 24,\n        m = Math.floor(val / 60) % 60,\n        s = val % 60;\n    var valueFormat = widgetConfig.valueFormat;\n\n    if (valueFormat) {\n      var dateVal = new Date(val);\n      dateVal.setMilliseconds(0);\n      dateVal.setHours(h);\n      dateVal.setMinutes(m);\n      dateVal.setSeconds(s);\n      val = (0, _moment[\"default\"])(dateVal).format(valueFormat);\n    } else {\n      val = \"\".concat(h, \":\").concat(m, \":\").concat(s);\n    }\n  } // \"2020-01-08T22:00:00.000Z\" -> Date object\n\n\n  if (fieldConfig && [\"date\", \"datetime\"].includes(fieldConfig.type) && val && !(val instanceof Date)) {\n    try {\n      var _dateVal = new Date(val);\n\n      if (_dateVal instanceof Date && _dateVal.toISOString() === val) {\n        val = _dateVal;\n      }\n    } catch (e) {\n      meta.errors.push(\"Can't convert value \".concat(val, \" as Date\"));\n      val = undefined;\n    }\n  } // Date object -> formatted string\n\n\n  if (val instanceof Date && fieldConfig) {\n    var _valueFormat = widgetConfig.valueFormat;\n\n    if (_valueFormat) {\n      val = (0, _moment[\"default\"])(val).format(_valueFormat);\n    }\n  }\n\n  var asyncListValues;\n\n  if (val && fieldConfig.fieldSettings && fieldConfig.fieldSettings.asyncFetch) {\n    var vals = Array.isArray(val) ? val : [val];\n    asyncListValues = vals;\n  }\n\n  return {\n    valueSrc: \"value\",\n    value: val,\n    valueType: widgetConfig.type,\n    asyncListValues: asyncListValues\n  };\n};\n\nvar convertField = function convertField(op, vals, conv, config, not, meta) {\n  var parentField = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n  var fieldSeparator = config.settings.fieldSeparator;\n\n  if (conv.varKeys.includes(op) && typeof vals[0] == \"string\") {\n    var field = vals[0];\n    if (parentField) field = [parentField, field].join(fieldSeparator);\n    field = (0, _configUtils.normalizeField)(config, field);\n    var fieldConfig = (0, _configUtils.getFieldConfig)(config, field);\n\n    if (!fieldConfig) {\n      meta.errors.push(\"No config for field \".concat(field));\n      return undefined;\n    }\n\n    return {\n      valueSrc: \"field\",\n      value: field,\n      valueType: fieldConfig.type\n    };\n  }\n\n  return undefined;\n};\n\nvar convertFunc = function convertFunc(op, vals, conv, config, not, fieldConfig, meta) {\n  var parentField = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;\n  if (!op) return undefined;\n  var func, argsArr, funcKey;\n  var jsonLogicIsMethod = op == \"method\";\n\n  if (jsonLogicIsMethod) {\n    var obj, opts;\n\n    var _vals = (0, _toArray2[\"default\"])(vals);\n\n    obj = _vals[0];\n    func = _vals[1];\n    opts = _vals.slice(2);\n    argsArr = [obj].concat((0, _toConsumableArray2[\"default\"])(opts));\n  } else {\n    func = op;\n    argsArr = vals;\n  }\n\n  var fk = (jsonLogicIsMethod ? \"#\" : \"\") + func;\n  var funcKeys = (conv.funcs[fk] || []).filter(function (k) {\n    return fieldConfig ? config.funcs[k].returnType == fieldConfig.type : true;\n  });\n\n  if (funcKeys.length) {\n    funcKey = funcKeys[0];\n  } else {\n    var v = (0, _defineProperty2[\"default\"])({}, op, vals);\n\n    for (var _i = 0, _Object$entries = Object.entries(config.funcs || {}); _i < _Object$entries.length; _i++) {\n      var _Object$entries$_i = (0, _slicedToArray2[\"default\"])(_Object$entries[_i], 2),\n          f = _Object$entries$_i[0],\n          fc = _Object$entries$_i[1];\n\n      if (fc.jsonLogicImport && fc.returnType == fieldConfig.type) {\n        var parsed = void 0;\n\n        try {\n          parsed = fc.jsonLogicImport(v);\n        } catch (_e) {// given expression `v` can't be parsed into function\n        }\n\n        if (parsed) {\n          funcKey = f;\n          argsArr = parsed;\n        }\n      }\n    }\n  }\n\n  if (!funcKey) return undefined;\n\n  if (funcKey) {\n    var funcConfig = config.funcs[funcKey];\n    var argKeys = Object.keys(funcConfig.args || {});\n    var args = argsArr.reduce(function (acc, val, ind) {\n      var argKey = argKeys[ind];\n      var argConfig = funcConfig.args[argKey];\n      var argVal = convertFromLogic(val, conv, config, \"val\", meta, false, argConfig, null, parentField);\n\n      if (argVal === undefined) {\n        argVal = argConfig.defaultValue;\n\n        if (argVal === undefined) {\n          meta.errors.push(\"No value for arg \".concat(argKey, \" of func \").concat(funcKey));\n          return undefined;\n        }\n      }\n\n      return _objectSpread(_objectSpread({}, acc), {}, (0, _defineProperty2[\"default\"])({}, argKey, argVal));\n    }, {});\n    return {\n      valueSrc: \"func\",\n      value: {\n        func: funcKey,\n        args: args\n      },\n      valueType: funcConfig.returnType\n    };\n  }\n\n  return undefined;\n};\n\nvar convertConj = function convertConj(op, vals, conv, config, not, meta) {\n  var parentField = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n  var isRuleGroup = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;\n  var conjKey = conv.conjunctions[op];\n  var fieldSeparator = config.settings.fieldSeparator;\n  var parentFieldConfig = parentField ? (0, _configUtils.getFieldConfig)(config, parentField) : null;\n  var isParentGroup = (parentFieldConfig === null || parentFieldConfig === void 0 ? void 0 : parentFieldConfig.type) == \"!group\";\n\n  if (conjKey) {\n    var type = \"group\";\n    var children = vals.map(function (v) {\n      return convertFromLogic(v, conv, config, \"rule\", meta, false, null, null, parentField);\n    }).filter(function (r) {\n      return r !== undefined;\n    }).reduce(function (acc, r) {\n      return _objectSpread(_objectSpread({}, acc), {}, (0, _defineProperty2[\"default\"])({}, r.id, r));\n    }, {});\n    var complexFields = Object.values(children).map(function (v) {\n      var _v$properties;\n\n      return v === null || v === void 0 ? void 0 : (_v$properties = v.properties) === null || _v$properties === void 0 ? void 0 : _v$properties.field;\n    }).filter(function (f) {\n      return f && f.includes(fieldSeparator);\n    });\n    var complexFieldsGroupAncestors = Object.fromEntries(arrayUniq(complexFields).map(function (f) {\n      var parts = f.split(fieldSeparator);\n      var ancs = Object.fromEntries(parts.slice(0, -1).map(function (f, i, parts) {\n        return [].concat((0, _toConsumableArray2[\"default\"])(parts.slice(0, i)), [f]);\n      }).map(function (fp) {\n        return [fp.join(fieldSeparator), (0, _configUtils.getFieldConfig)(config, fp)];\n      }).filter(function (_ref3) {\n        var _ref4 = (0, _slicedToArray2[\"default\"])(_ref3, 2),\n            _f = _ref4[0],\n            fc = _ref4[1];\n\n        return fc.type == \"!group\";\n      }));\n      return [f, Object.keys(ancs)];\n    }));\n    var childrenInRuleGroup = Object.values(children).map(function (v) {\n      var _v$properties2;\n\n      return v === null || v === void 0 ? void 0 : (_v$properties2 = v.properties) === null || _v$properties2 === void 0 ? void 0 : _v$properties2.field;\n    }).map(function (f) {\n      return complexFieldsGroupAncestors[f];\n    }).filter(function (ancs) {\n      return ancs && ancs.length;\n    });\n    var usedRuleGroups = arrayUniq(Object.values(complexFieldsGroupAncestors).flat());\n    var usedTopRuleGroups = topLevelFieldsFilter(usedRuleGroups);\n    var properties = {\n      conjunction: conjKey,\n      not: not\n    };\n    var id = (0, _uuid[\"default\"])();\n    var children1 = {};\n    var groupToId = {};\n    Object.entries(children).map(function (_ref5) {\n      var _ref6 = (0, _slicedToArray2[\"default\"])(_ref5, 2),\n          k = _ref6[0],\n          v = _ref6[1];\n\n      if (v.type == \"group\" || v.type == \"rule_group\") {\n        // put as-is\n        children1[k] = v;\n      } else {\n        var _v$properties3;\n\n        var field = v === null || v === void 0 ? void 0 : (_v$properties3 = v.properties) === null || _v$properties3 === void 0 ? void 0 : _v$properties3.field;\n        var groupAncestors = complexFieldsGroupAncestors[field];\n        var groupField = groupAncestors === null || groupAncestors === void 0 ? void 0 : groupAncestors.at(-1);\n\n        if (!groupField) {\n          // not in rule_group (can be simple field or in struct) - put as-is\n          children1[k] = v;\n        } else {\n          // wrap field in rule_group (with creating hierarchy if need)\n          var ch = children1;\n          var parentFieldParts = parentField ? parentField.split(fieldSeparator) : [];\n          var isInParent = (0, _stuff.shallowEqual)(parentFieldParts, groupField.split(fieldSeparator).slice(0, parentFieldParts.length));\n          if (!isInParent) parentFieldParts = []; // should not be\n\n          var traverseGroupFields = groupField.split(fieldSeparator).slice(parentFieldParts.length).map(function (f, i, parts) {\n            return [].concat((0, _toConsumableArray2[\"default\"])(parentFieldParts), (0, _toConsumableArray2[\"default\"])(parts.slice(0, i)), [f]).join(fieldSeparator);\n          }).map(function (f) {\n            return (0, _configUtils.normalizeField)(config, f);\n          }).map(function (f) {\n            return {\n              f: f,\n              fc: (0, _configUtils.getFieldConfig)(config, f) || {}\n            };\n          }).filter(function (_ref7) {\n            var fc = _ref7.fc;\n            return fc.type != \"!struct\";\n          });\n          traverseGroupFields.map(function (_ref8, i) {\n            var gf = _ref8.f,\n                gfc = _ref8.fc;\n            var groupId = groupToId[gf];\n\n            if (!groupId) {\n              groupId = (0, _uuid[\"default\"])();\n              groupToId[gf] = groupId;\n              ch[groupId] = {\n                type: \"rule_group\",\n                id: groupId,\n                children1: {},\n                properties: {\n                  conjunction: conjKey,\n                  not: false,\n                  field: gf,\n                  mode: gfc.mode\n                }\n              };\n            }\n\n            ch = ch[groupId].children1;\n          });\n          ch[k] = v;\n        }\n      }\n    }); // tip: for isRuleGroup=true correct type and properties will be set out of this func\n\n    return {\n      type: type,\n      id: id,\n      children1: children1,\n      properties: properties\n    };\n  }\n\n  return undefined;\n};\n\nvar topLevelFieldsFilter = function topLevelFieldsFilter(fields) {\n  var arr = (0, _toConsumableArray2[\"default\"])(fields).sort(function (a, b) {\n    return a.length - b.length;\n  });\n\n  for (var i = 0; i < arr.length; i++) {\n    for (var j = i + 1; j < arr.length; j++) {\n      if (arr[j].indexOf(arr[i]) == 0) {\n        // arr[j] is inside arr[i] (eg. \"a.b\" inside \"a\")\n        arr.splice(j, 1);\n        j--;\n      }\n    }\n  }\n\n  return arr;\n};\n\nvar wrapInDefaultConjRuleGroup = function wrapInDefaultConjRuleGroup(rule, parentField, parentFieldConfig, config, conj) {\n  if (!rule) return undefined;\n  return {\n    type: \"rule_group\",\n    id: (0, _uuid[\"default\"])(),\n    children1: (0, _defineProperty2[\"default\"])({}, rule.id, rule),\n    properties: {\n      conjunction: conj || (0, _defaultUtils.defaultGroupConjunction)(config, parentFieldConfig),\n      not: false,\n      field: parentField\n    }\n  };\n};\n\nvar wrapInDefaultConj = function wrapInDefaultConj(rule, config) {\n  var not = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  return {\n    type: \"group\",\n    id: (0, _uuid[\"default\"])(),\n    children1: (0, _defineProperty2[\"default\"])({}, rule.id, rule),\n    properties: {\n      conjunction: (0, _defaultUtils.defaultConjunction)(config),\n      not: not\n    }\n  };\n};\n\nvar parseRule = function parseRule(op, arity, vals, parentField, conv, config, meta) {\n  var errors = [];\n\n  var res = _parseRule(op, arity, vals, parentField, conv, config, errors, false) || _parseRule(op, arity, vals, parentField, conv, config, errors, true);\n\n  if (!res) {\n    meta.errors.push(errors.join(\"; \") || \"Unknown op \".concat(op, \"/\").concat(arity));\n    return undefined;\n  }\n\n  return res;\n};\n\nvar _parseRule = function _parseRule(op, arity, vals, parentField, conv, config, errors, isRevArgs) {\n  // config.settings.groupOperators are used for group count (cardinality = 0 is exception)\n  // but don't confuse with \"all-in\" for multiselect\n  var isAllInForMultiselect = op == \"all\" && (0, _stuff.isJsonLogic)(vals[1]) && Object.keys(vals[1])[0] == \"in\";\n  var isGroup0 = !isAllInForMultiselect && config.settings.groupOperators.includes(op);\n  var eqOps = [\"==\", \"!=\"];\n  var cardinality = isGroup0 ? 0 : arity - 1;\n  if (isGroup0) cardinality = 0;else if (eqOps.includes(op) && cardinality == 1 && vals[1] === null) cardinality = 0;\n  var opk = op + \"/\" + cardinality;\n  var fieldSeparator = config.settings.fieldSeparator;\n  var opKeys = conv.operators[(isRevArgs ? \"#\" : \"\") + opk];\n  if (!opKeys) return;\n  var jlField,\n      args = [];\n  var rangeOps = [\"<\", \"<=\", \">\", \">=\"];\n\n  if (rangeOps.includes(op) && arity == 3) {\n    jlField = vals[1];\n    args = [vals[0], vals[2]];\n  } else if (isRevArgs) {\n    jlField = vals[1];\n    args = [vals[0]];\n  } else {\n    var _vals2 = (0, _toArray2[\"default\"])(vals);\n\n    jlField = _vals2[0];\n    args = _vals2.slice(1);\n  }\n\n  if (!(0, _stuff.isJsonLogic)(jlField)) {\n    errors.push(\"Incorrect operands for \".concat(op, \": \").concat(JSON.stringify(vals)));\n    return;\n  }\n\n  var k = Object.keys(jlField)[0];\n  var v = Object.values(jlField)[0];\n  var field, having, isGroup;\n\n  if (conv.varKeys.includes(k) && typeof v == \"string\") {\n    field = v;\n  }\n\n  if (isGroup0) {\n    isGroup = true;\n    having = args[0];\n    args = [];\n  } // reduce/filter for group ext\n\n\n  if (k == \"reduce\" && Array.isArray(v) && v.length == 3) {\n    var _v2 = v,\n        _v3 = (0, _slicedToArray2[\"default\"])(_v2, 3),\n        filter = _v3[0],\n        acc = _v3[1],\n        init = _v3[2];\n\n    if ((0, _stuff.isJsonLogic)(filter) && init == 0 && (0, _stuff.isJsonLogic)(acc) && Array.isArray(acc[\"+\"]) && acc[\"+\"][0] == 1 && (0, _stuff.isJsonLogic)(acc[\"+\"][1]) && acc[\"+\"][1][\"var\"] == \"accumulator\") {\n      k = Object.keys(filter)[0];\n      v = Object.values(filter)[0];\n\n      if (k == \"filter\") {\n        var _v4 = v,\n            _v5 = (0, _slicedToArray2[\"default\"])(_v4, 2),\n            group = _v5[0],\n            _filter = _v5[1];\n\n        if ((0, _stuff.isJsonLogic)(group)) {\n          k = Object.keys(group)[0];\n          v = Object.values(group)[0];\n\n          if (conv.varKeys.includes(k) && typeof v == \"string\") {\n            field = v;\n            having = _filter;\n            isGroup = true;\n          }\n        }\n      } else if (conv.varKeys.includes(k) && typeof v == \"string\") {\n        field = v;\n        isGroup = true;\n      }\n    }\n  }\n\n  if (!field) {\n    errors.push(\"Unknown field \".concat(JSON.stringify(jlField)));\n    return;\n  }\n\n  if (parentField) field = [parentField, field].join(fieldSeparator);\n  field = (0, _configUtils.normalizeField)(config, field);\n  var fieldConfig = (0, _configUtils.getFieldConfig)(config, field);\n\n  if (!fieldConfig) {\n    errors.push(\"No config for field \".concat(field));\n    return;\n  }\n\n  var opKey = opKeys[0];\n\n  if (opKeys.length > 1 && fieldConfig && fieldConfig.operators) {\n    // eg. for \"equal\" and \"select_equals\"\n    opKeys = opKeys.filter(function (k) {\n      return fieldConfig.operators.includes(k);\n    });\n\n    if (opKeys.length == 0) {\n      errors.push(\"No corresponding ops for field \".concat(field));\n      return;\n    }\n\n    opKey = opKeys[0];\n  }\n\n  return {\n    field: field,\n    fieldConfig: fieldConfig,\n    opKey: opKey,\n    args: args,\n    having: having\n  };\n};\n\nvar convertOp = function convertOp(op, vals, conv, config, not, meta) {\n  var parentField = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n  if (!op) return undefined;\n  var arity = vals.length;\n\n  if (op == \"all\" && (0, _stuff.isJsonLogic)(vals[1])) {\n    // special case for \"all-in\"\n    var op2 = Object.keys(vals[1])[0];\n\n    if (op2 == \"in\") {\n      vals = [vals[0], vals[1][op2][1]];\n      op = op + \"-\" + op2; // \"all-in\"\n    }\n  }\n\n  var parseRes = parseRule(op, arity, vals, parentField, conv, config, meta);\n  if (!parseRes) return undefined;\n  var field = parseRes.field,\n      fieldConfig = parseRes.fieldConfig,\n      opKey = parseRes.opKey,\n      args = parseRes.args,\n      having = parseRes.having;\n  var opConfig = config.operators[opKey]; // Group component in array mode can show NOT checkbox, so do nothing in this case\n  // Otherwise try to revert\n\n  var showNot = fieldConfig.showNot !== undefined ? fieldConfig.showNot : config.settings.showNot;\n  var canRev = true; // if (fieldConfig.type == \"!group\" && fieldConfig.mode == \"array\" && showNot)\n  //   canRev = false;\n\n  var conj;\n  var havingVals;\n\n  if (fieldConfig.type == \"!group\" && having) {\n    conj = Object.keys(having)[0];\n    havingVals = having[conj];\n    if (!Array.isArray(havingVals)) havingVals = [havingVals]; // Preprocess \"!\": Try to reverse op in single rule in having\n    // Eg. use `not_equal` instead of `not` `equal`\n\n    var isEmptyOp = conj == \"!\" && havingVals.length == 1 && havingVals[0] && (0, _stuff.isJsonLogic)(havingVals[0]) && conv.varKeys.includes(Object.keys(havingVals[0])[0]);\n\n    if (conj == \"!\" && !isEmptyOp) {\n      not = !not;\n      having = having[\"!\"];\n      conj = Object.keys(having)[0];\n      havingVals = having[conj];\n      if (!Array.isArray(havingVals)) havingVals = [havingVals];\n    }\n  } // Use reversed op\n\n\n  if (not && canRev && opConfig.reversedOp) {\n    not = false;\n    opKey = opConfig.reversedOp;\n    opConfig = config.operators[opKey];\n  }\n\n  var widget = (0, _ruleUtils.getWidgetForFieldOp)(config, field, opKey);\n  var convertedArgs = args.map(function (v) {\n    return convertFromLogic(v, conv, config, \"val\", meta, false, fieldConfig, widget, parentField);\n  });\n\n  if (convertedArgs.filter(function (v) {\n    return v === undefined;\n  }).length) {\n    //meta.errors.push(`Undefined arg for field ${field} and op ${opKey}`);\n    return undefined;\n  }\n\n  var res;\n\n  if (fieldConfig.type == \"!group\" && having) {\n    if (conv.conjunctions[conj] !== undefined) {\n      res = convertConj(conj, havingVals, conv, config, not, meta, field, true);\n      not = false; // not was applied to group\n    } else {\n      var _rule$properties; // need to be wrapped in `rule_group`\n\n\n      var rule = convertOp(conj, havingVals, conv, config, not && canRev, meta, field);\n\n      if (not && canRev && !(rule !== null && rule !== void 0 && (_rule$properties = rule.properties) !== null && _rule$properties !== void 0 && _rule$properties.not)) {\n        not = false; // op was reversed in rule\n      }\n\n      res = wrapInDefaultConjRuleGroup(rule, field, fieldConfig, config, conv.conjunctions[\"and\"]);\n    }\n\n    if (!res) return undefined;\n    res.type = \"rule_group\";\n\n    if (not) {\n      Object.assign(res.properties, {\n        not: not\n      });\n    }\n\n    Object.assign(res.properties, {\n      field: field,\n      mode: fieldConfig.mode,\n      operator: opKey\n    });\n\n    if (fieldConfig.mode == \"array\") {\n      Object.assign(res.properties, {\n        value: convertedArgs.map(function (v) {\n          return v.value;\n        }),\n        valueSrc: convertedArgs.map(function (v) {\n          return v.valueSrc;\n        }),\n        valueType: convertedArgs.map(function (v) {\n          return v.valueType;\n        })\n      });\n    }\n  } else if (fieldConfig.type == \"!group\" && !having) {\n    res = {\n      type: \"rule_group\",\n      id: (0, _uuid[\"default\"])(),\n      children1: {},\n      properties: {\n        conjunction: (0, _defaultUtils.defaultGroupConjunction)(config, fieldConfig),\n        not: not,\n        mode: fieldConfig.mode,\n        field: field,\n        operator: opKey\n      }\n    };\n\n    if (fieldConfig.mode == \"array\") {\n      Object.assign(res.properties, {\n        value: convertedArgs.map(function (v) {\n          return v.value;\n        }),\n        valueSrc: convertedArgs.map(function (v) {\n          return v.valueSrc;\n        }),\n        valueType: convertedArgs.map(function (v) {\n          return v.valueType;\n        })\n      });\n    }\n  } else {\n    var asyncListValuesArr = convertedArgs.map(function (v) {\n      return v.asyncListValues;\n    }).filter(function (v) {\n      return v != undefined;\n    });\n    var asyncListValues = asyncListValuesArr.length ? asyncListValuesArr[0] : undefined;\n    res = {\n      type: \"rule\",\n      id: (0, _uuid[\"default\"])(),\n      properties: {\n        field: field,\n        operator: opKey,\n        value: convertedArgs.map(function (v) {\n          return v.value;\n        }),\n        valueSrc: convertedArgs.map(function (v) {\n          return v.valueSrc;\n        }),\n        valueType: convertedArgs.map(function (v) {\n          return v.valueType;\n        }),\n        asyncListValues: asyncListValues\n      }\n    };\n\n    if (not) {\n      //meta.errors.push(`No rev op for ${opKey}`);\n      res = wrapInDefaultConj(res, config, not);\n    }\n  }\n\n  return res;\n};","map":{"version":3,"sources":["D:/LIMSWFH/LIMSPOSTGRESQL/QuaLISWeb/node_modules/react-awesome-query-builder/lib/import/jsonLogic.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","loadFromJsonLogic","_loadFromJsonLogic","_toConsumableArray2","_toArray2","_defineProperty2","_slicedToArray2","_uuid","_stuff","_configUtils","_ruleUtils","_tree","_defaultUtils","_moment","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","arrayUniq","arr","Array","from","Set","arrayToObject","reduce","acc","_ref","_ref2","f","fc","logicTree","config","returnErrors","undefined","meta","errors","extendedConfig","extendConfig","conv","buildConv","jsTree","convertFromLogic","type","wrapInDefaultConj","immTree","loadTree","console","warn","operators","opKey","opConfig","jsonLogic","opk","_jsonLogicIsRevArgs","defaultValue","cardinality","jsonLogic2","_opk","conjunctions","conjKey","conjunctionDefinition","ck","jsonLogicConj","toLowerCase","funcs","funcKey","funcConfig","fk","jsonLogicIsMethod","_config$settings$json","settings","groupVarKey","altVarKey","varKeys","logic","expectedType","not","fieldConfig","widget","parentField","_isLockedLogic","op","vals","isJsonLogic","isArray","ret","beforeErrorsCnt","lockedOp","isEmptyOp","includes","isRev","isLocked","convertField","convertFunc","convertVal","convertConj","convertOp","afterErrorsCnt","concat","JSON","stringify","properties","val","widgetConfig","widgets","mainWidget","h","Math","floor","m","s","valueFormat","dateVal","Date","setMilliseconds","setHours","setMinutes","setSeconds","format","_dateVal","toISOString","e","_valueFormat","asyncListValues","fieldSettings","asyncFetch","valueSrc","valueType","fieldSeparator","field","join","normalizeField","getFieldConfig","func","argsArr","obj","opts","_vals","slice","funcKeys","k","returnType","v","_i","_Object$entries","entries","_Object$entries$_i","jsonLogicImport","parsed","_e","argKeys","args","ind","argKey","argConfig","argVal","isRuleGroup","parentFieldConfig","isParentGroup","children","map","r","id","complexFields","values","_v$properties","complexFieldsGroupAncestors","fromEntries","parts","split","ancs","fp","_ref3","_ref4","_f","childrenInRuleGroup","_v$properties2","usedRuleGroups","flat","usedTopRuleGroups","topLevelFieldsFilter","conjunction","children1","groupToId","_ref5","_ref6","_v$properties3","groupAncestors","groupField","at","ch","parentFieldParts","isInParent","shallowEqual","traverseGroupFields","_ref7","_ref8","gf","gfc","groupId","mode","fields","sort","a","b","j","indexOf","splice","wrapInDefaultConjRuleGroup","rule","conj","defaultGroupConjunction","defaultConjunction","parseRule","arity","res","_parseRule","isRevArgs","isAllInForMultiselect","isGroup0","groupOperators","eqOps","opKeys","jlField","rangeOps","_vals2","having","isGroup","_v2","_v3","init","_v4","_v5","group","_filter","op2","parseRes","showNot","canRev","havingVals","reversedOp","getWidgetForFieldOp","convertedArgs","_rule$properties","assign","operator","asyncListValuesArr"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.loadFromJsonLogic = exports._loadFromJsonLogic = void 0;\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _toArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toArray\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _uuid = _interopRequireDefault(require(\"../utils/uuid\"));\n\nvar _stuff = require(\"../utils/stuff\");\n\nvar _configUtils = require(\"../utils/configUtils\");\n\nvar _ruleUtils = require(\"../utils/ruleUtils\");\n\nvar _tree = require(\"./tree\");\n\nvar _defaultUtils = require(\"../utils/defaultUtils\");\n\nvar _moment = _interopRequireDefault(require(\"moment\"));\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2[\"default\"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\n// http://jsonlogic.com/\n// helpers\nvar arrayUniq = function arrayUniq(arr) {\n  return Array.from(new Set(arr));\n};\n\nvar arrayToObject = function arrayToObject(arr) {\n  return arr.reduce(function (acc, _ref) {\n    var _ref2 = (0, _slicedToArray2[\"default\"])(_ref, 2),\n        f = _ref2[0],\n        fc = _ref2[1];\n\n    return _objectSpread(_objectSpread({}, acc), {}, (0, _defineProperty2[\"default\"])({}, f, fc));\n  }, {});\n};\n\nvar loadFromJsonLogic = function loadFromJsonLogic(logicTree, config) {\n  return _loadFromJsonLogic(logicTree, config, false);\n};\n\nexports.loadFromJsonLogic = loadFromJsonLogic;\n\nvar _loadFromJsonLogic = function _loadFromJsonLogic(logicTree, config) {\n  var returnErrors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  //meta is mutable\n  var meta = {\n    errors: []\n  };\n  var extendedConfig = (0, _configUtils.extendConfig)(config);\n  var conv = buildConv(extendedConfig);\n  var jsTree = logicTree ? convertFromLogic(logicTree, conv, extendedConfig, \"rule\", meta) : undefined;\n\n  if (jsTree && jsTree.type != \"group\") {\n    jsTree = wrapInDefaultConj(jsTree, extendedConfig);\n  }\n\n  var immTree = jsTree ? (0, _tree.loadTree)(jsTree) : undefined;\n\n  if (returnErrors) {\n    return [immTree, meta.errors];\n  } else {\n    if (meta.errors.length) console.warn(\"Errors while importing from JsonLogic:\", meta.errors);\n    return immTree;\n  }\n};\n\nexports._loadFromJsonLogic = _loadFromJsonLogic;\n\nvar buildConv = function buildConv(config) {\n  var operators = {};\n\n  for (var opKey in config.operators) {\n    var opConfig = config.operators[opKey];\n\n    if (typeof opConfig.jsonLogic == \"string\") {\n      // example: \"</2\", \"#in/1\"\n      var opk = (opConfig._jsonLogicIsRevArgs ? \"#\" : \"\") + opConfig.jsonLogic + \"/\" + (0, _stuff.defaultValue)(opConfig.cardinality, 1);\n      if (!operators[opk]) operators[opk] = [];\n      operators[opk].push(opKey);\n    } else if (typeof opConfig.jsonLogic2 == \"string\") {\n      // example: all-in/1\"\n      var _opk = opConfig.jsonLogic2 + \"/\" + (0, _stuff.defaultValue)(opConfig.cardinality, 1);\n\n      if (!operators[_opk]) operators[_opk] = [];\n\n      operators[_opk].push(opKey);\n    }\n  }\n\n  var conjunctions = {};\n\n  for (var conjKey in config.conjunctions) {\n    var conjunctionDefinition = config.conjunctions[conjKey];\n    var ck = conjunctionDefinition.jsonLogicConj || conjKey.toLowerCase();\n    conjunctions[ck] = conjKey;\n  }\n\n  var funcs = {};\n\n  for (var funcKey in config.funcs) {\n    var funcConfig = config.funcs[funcKey];\n    var fk = void 0;\n\n    if (funcConfig.jsonLogicIsMethod) {\n      fk = \"#\" + funcConfig.jsonLogic;\n    } else if (typeof funcConfig.jsonLogic == \"string\") {\n      fk = funcConfig.jsonLogic;\n    }\n\n    if (fk) {\n      if (!funcs[fk]) funcs[fk] = [];\n      funcs[fk].push(funcKey);\n    }\n  }\n\n  var _config$settings$json = config.settings.jsonLogic,\n      groupVarKey = _config$settings$json.groupVarKey,\n      altVarKey = _config$settings$json.altVarKey;\n  return {\n    operators: operators,\n    conjunctions: conjunctions,\n    funcs: funcs,\n    varKeys: [\"var\", groupVarKey, altVarKey]\n  };\n};\n\nvar convertFromLogic = function convertFromLogic(logic, conv, config, expectedType, meta) {\n  var not = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  var fieldConfig = arguments.length > 6 ? arguments[6] : undefined;\n  var widget = arguments.length > 7 ? arguments[7] : undefined;\n  var parentField = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : null;\n\n  var _isLockedLogic = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : false;\n\n  var op, vals;\n\n  if ((0, _stuff.isJsonLogic)(logic)) {\n    op = Object.keys(logic)[0];\n    vals = logic[op];\n    if (!Array.isArray(vals)) vals = [vals];\n  }\n\n  var ret;\n  var beforeErrorsCnt = meta.errors.length;\n  var lockedOp = config.settings.jsonLogic.lockedOp;\n  var isEmptyOp = op == \"!\" && vals.length == 1 && vals[0] && (0, _stuff.isJsonLogic)(vals[0]) && conv.varKeys.includes(Object.keys(vals[0])[0]);\n  var isRev = op == \"!\" && !isEmptyOp;\n  var isLocked = lockedOp && op == lockedOp;\n\n  if (isLocked) {\n    ret = convertFromLogic(vals[0], conv, config, expectedType, meta, not, fieldConfig, widget, parentField, true);\n  } else if (isRev) {\n    // reverse with not\n    ret = convertFromLogic(vals[0], conv, config, expectedType, meta, !not, fieldConfig, widget, parentField);\n  } else if (expectedType == \"val\") {\n    // not is not used here\n    ret = convertField(op, vals, conv, config, not, meta, parentField) || convertFunc(op, vals, conv, config, not, fieldConfig, meta, parentField) || convertVal(logic, fieldConfig, widget, config, meta);\n  } else if (expectedType == \"rule\") {\n    ret = convertConj(op, vals, conv, config, not, meta, parentField, false) || convertOp(op, vals, conv, config, not, meta, parentField);\n  }\n\n  var afterErrorsCnt = meta.errors.length;\n\n  if (op != \"!\" && ret === undefined && afterErrorsCnt == beforeErrorsCnt) {\n    meta.errors.push(\"Can't parse logic \".concat(JSON.stringify(logic)));\n  }\n\n  if (isLocked) {\n    ret.properties.isLocked = true;\n  }\n\n  return ret;\n};\n\nvar convertVal = function convertVal(val, fieldConfig, widget, config, meta) {\n  if (val === undefined) return undefined;\n  var widgetConfig = config.widgets[widget || fieldConfig.mainWidget];\n\n  if (!widgetConfig) {\n    meta.errors.push(\"No widget for type \".concat(fieldConfig.type));\n    return undefined;\n  }\n\n  if ((0, _stuff.isJsonLogic)(val)) {\n    meta.errors.push(\"Unexpected logic in value: \".concat(JSON.stringify(val)));\n    return undefined;\n  } // number of seconds -> time string\n\n\n  if (fieldConfig && fieldConfig.type == \"time\" && typeof val == \"number\") {\n    var h = Math.floor(val / 60 / 60) % 24,\n        m = Math.floor(val / 60) % 60,\n        s = val % 60;\n    var valueFormat = widgetConfig.valueFormat;\n\n    if (valueFormat) {\n      var dateVal = new Date(val);\n      dateVal.setMilliseconds(0);\n      dateVal.setHours(h);\n      dateVal.setMinutes(m);\n      dateVal.setSeconds(s);\n      val = (0, _moment[\"default\"])(dateVal).format(valueFormat);\n    } else {\n      val = \"\".concat(h, \":\").concat(m, \":\").concat(s);\n    }\n  } // \"2020-01-08T22:00:00.000Z\" -> Date object\n\n\n  if (fieldConfig && [\"date\", \"datetime\"].includes(fieldConfig.type) && val && !(val instanceof Date)) {\n    try {\n      var _dateVal = new Date(val);\n\n      if (_dateVal instanceof Date && _dateVal.toISOString() === val) {\n        val = _dateVal;\n      }\n    } catch (e) {\n      meta.errors.push(\"Can't convert value \".concat(val, \" as Date\"));\n      val = undefined;\n    }\n  } // Date object -> formatted string\n\n\n  if (val instanceof Date && fieldConfig) {\n    var _valueFormat = widgetConfig.valueFormat;\n\n    if (_valueFormat) {\n      val = (0, _moment[\"default\"])(val).format(_valueFormat);\n    }\n  }\n\n  var asyncListValues;\n\n  if (val && fieldConfig.fieldSettings && fieldConfig.fieldSettings.asyncFetch) {\n    var vals = Array.isArray(val) ? val : [val];\n    asyncListValues = vals;\n  }\n\n  return {\n    valueSrc: \"value\",\n    value: val,\n    valueType: widgetConfig.type,\n    asyncListValues: asyncListValues\n  };\n};\n\nvar convertField = function convertField(op, vals, conv, config, not, meta) {\n  var parentField = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n  var fieldSeparator = config.settings.fieldSeparator;\n\n  if (conv.varKeys.includes(op) && typeof vals[0] == \"string\") {\n    var field = vals[0];\n    if (parentField) field = [parentField, field].join(fieldSeparator);\n    field = (0, _configUtils.normalizeField)(config, field);\n    var fieldConfig = (0, _configUtils.getFieldConfig)(config, field);\n\n    if (!fieldConfig) {\n      meta.errors.push(\"No config for field \".concat(field));\n      return undefined;\n    }\n\n    return {\n      valueSrc: \"field\",\n      value: field,\n      valueType: fieldConfig.type\n    };\n  }\n\n  return undefined;\n};\n\nvar convertFunc = function convertFunc(op, vals, conv, config, not, fieldConfig, meta) {\n  var parentField = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;\n  if (!op) return undefined;\n  var func, argsArr, funcKey;\n  var jsonLogicIsMethod = op == \"method\";\n\n  if (jsonLogicIsMethod) {\n    var obj, opts;\n\n    var _vals = (0, _toArray2[\"default\"])(vals);\n\n    obj = _vals[0];\n    func = _vals[1];\n    opts = _vals.slice(2);\n    argsArr = [obj].concat((0, _toConsumableArray2[\"default\"])(opts));\n  } else {\n    func = op;\n    argsArr = vals;\n  }\n\n  var fk = (jsonLogicIsMethod ? \"#\" : \"\") + func;\n  var funcKeys = (conv.funcs[fk] || []).filter(function (k) {\n    return fieldConfig ? config.funcs[k].returnType == fieldConfig.type : true;\n  });\n\n  if (funcKeys.length) {\n    funcKey = funcKeys[0];\n  } else {\n    var v = (0, _defineProperty2[\"default\"])({}, op, vals);\n\n    for (var _i = 0, _Object$entries = Object.entries(config.funcs || {}); _i < _Object$entries.length; _i++) {\n      var _Object$entries$_i = (0, _slicedToArray2[\"default\"])(_Object$entries[_i], 2),\n          f = _Object$entries$_i[0],\n          fc = _Object$entries$_i[1];\n\n      if (fc.jsonLogicImport && fc.returnType == fieldConfig.type) {\n        var parsed = void 0;\n\n        try {\n          parsed = fc.jsonLogicImport(v);\n        } catch (_e) {// given expression `v` can't be parsed into function\n        }\n\n        if (parsed) {\n          funcKey = f;\n          argsArr = parsed;\n        }\n      }\n    }\n  }\n\n  if (!funcKey) return undefined;\n\n  if (funcKey) {\n    var funcConfig = config.funcs[funcKey];\n    var argKeys = Object.keys(funcConfig.args || {});\n    var args = argsArr.reduce(function (acc, val, ind) {\n      var argKey = argKeys[ind];\n      var argConfig = funcConfig.args[argKey];\n      var argVal = convertFromLogic(val, conv, config, \"val\", meta, false, argConfig, null, parentField);\n\n      if (argVal === undefined) {\n        argVal = argConfig.defaultValue;\n\n        if (argVal === undefined) {\n          meta.errors.push(\"No value for arg \".concat(argKey, \" of func \").concat(funcKey));\n          return undefined;\n        }\n      }\n\n      return _objectSpread(_objectSpread({}, acc), {}, (0, _defineProperty2[\"default\"])({}, argKey, argVal));\n    }, {});\n    return {\n      valueSrc: \"func\",\n      value: {\n        func: funcKey,\n        args: args\n      },\n      valueType: funcConfig.returnType\n    };\n  }\n\n  return undefined;\n};\n\nvar convertConj = function convertConj(op, vals, conv, config, not, meta) {\n  var parentField = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n  var isRuleGroup = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;\n  var conjKey = conv.conjunctions[op];\n  var fieldSeparator = config.settings.fieldSeparator;\n  var parentFieldConfig = parentField ? (0, _configUtils.getFieldConfig)(config, parentField) : null;\n  var isParentGroup = (parentFieldConfig === null || parentFieldConfig === void 0 ? void 0 : parentFieldConfig.type) == \"!group\";\n\n  if (conjKey) {\n    var type = \"group\";\n    var children = vals.map(function (v) {\n      return convertFromLogic(v, conv, config, \"rule\", meta, false, null, null, parentField);\n    }).filter(function (r) {\n      return r !== undefined;\n    }).reduce(function (acc, r) {\n      return _objectSpread(_objectSpread({}, acc), {}, (0, _defineProperty2[\"default\"])({}, r.id, r));\n    }, {});\n    var complexFields = Object.values(children).map(function (v) {\n      var _v$properties;\n\n      return v === null || v === void 0 ? void 0 : (_v$properties = v.properties) === null || _v$properties === void 0 ? void 0 : _v$properties.field;\n    }).filter(function (f) {\n      return f && f.includes(fieldSeparator);\n    });\n    var complexFieldsGroupAncestors = Object.fromEntries(arrayUniq(complexFields).map(function (f) {\n      var parts = f.split(fieldSeparator);\n      var ancs = Object.fromEntries(parts.slice(0, -1).map(function (f, i, parts) {\n        return [].concat((0, _toConsumableArray2[\"default\"])(parts.slice(0, i)), [f]);\n      }).map(function (fp) {\n        return [fp.join(fieldSeparator), (0, _configUtils.getFieldConfig)(config, fp)];\n      }).filter(function (_ref3) {\n        var _ref4 = (0, _slicedToArray2[\"default\"])(_ref3, 2),\n            _f = _ref4[0],\n            fc = _ref4[1];\n\n        return fc.type == \"!group\";\n      }));\n      return [f, Object.keys(ancs)];\n    }));\n    var childrenInRuleGroup = Object.values(children).map(function (v) {\n      var _v$properties2;\n\n      return v === null || v === void 0 ? void 0 : (_v$properties2 = v.properties) === null || _v$properties2 === void 0 ? void 0 : _v$properties2.field;\n    }).map(function (f) {\n      return complexFieldsGroupAncestors[f];\n    }).filter(function (ancs) {\n      return ancs && ancs.length;\n    });\n    var usedRuleGroups = arrayUniq(Object.values(complexFieldsGroupAncestors).flat());\n    var usedTopRuleGroups = topLevelFieldsFilter(usedRuleGroups);\n    var properties = {\n      conjunction: conjKey,\n      not: not\n    };\n    var id = (0, _uuid[\"default\"])();\n    var children1 = {};\n    var groupToId = {};\n    Object.entries(children).map(function (_ref5) {\n      var _ref6 = (0, _slicedToArray2[\"default\"])(_ref5, 2),\n          k = _ref6[0],\n          v = _ref6[1];\n\n      if (v.type == \"group\" || v.type == \"rule_group\") {\n        // put as-is\n        children1[k] = v;\n      } else {\n        var _v$properties3;\n\n        var field = v === null || v === void 0 ? void 0 : (_v$properties3 = v.properties) === null || _v$properties3 === void 0 ? void 0 : _v$properties3.field;\n        var groupAncestors = complexFieldsGroupAncestors[field];\n        var groupField = groupAncestors === null || groupAncestors === void 0 ? void 0 : groupAncestors.at(-1);\n\n        if (!groupField) {\n          // not in rule_group (can be simple field or in struct) - put as-is\n          children1[k] = v;\n        } else {\n          // wrap field in rule_group (with creating hierarchy if need)\n          var ch = children1;\n          var parentFieldParts = parentField ? parentField.split(fieldSeparator) : [];\n          var isInParent = (0, _stuff.shallowEqual)(parentFieldParts, groupField.split(fieldSeparator).slice(0, parentFieldParts.length));\n          if (!isInParent) parentFieldParts = []; // should not be\n\n          var traverseGroupFields = groupField.split(fieldSeparator).slice(parentFieldParts.length).map(function (f, i, parts) {\n            return [].concat((0, _toConsumableArray2[\"default\"])(parentFieldParts), (0, _toConsumableArray2[\"default\"])(parts.slice(0, i)), [f]).join(fieldSeparator);\n          }).map(function (f) {\n            return (0, _configUtils.normalizeField)(config, f);\n          }).map(function (f) {\n            return {\n              f: f,\n              fc: (0, _configUtils.getFieldConfig)(config, f) || {}\n            };\n          }).filter(function (_ref7) {\n            var fc = _ref7.fc;\n            return fc.type != \"!struct\";\n          });\n          traverseGroupFields.map(function (_ref8, i) {\n            var gf = _ref8.f,\n                gfc = _ref8.fc;\n            var groupId = groupToId[gf];\n\n            if (!groupId) {\n              groupId = (0, _uuid[\"default\"])();\n              groupToId[gf] = groupId;\n              ch[groupId] = {\n                type: \"rule_group\",\n                id: groupId,\n                children1: {},\n                properties: {\n                  conjunction: conjKey,\n                  not: false,\n                  field: gf,\n                  mode: gfc.mode\n                }\n              };\n            }\n\n            ch = ch[groupId].children1;\n          });\n          ch[k] = v;\n        }\n      }\n    }); // tip: for isRuleGroup=true correct type and properties will be set out of this func\n\n    return {\n      type: type,\n      id: id,\n      children1: children1,\n      properties: properties\n    };\n  }\n\n  return undefined;\n};\n\nvar topLevelFieldsFilter = function topLevelFieldsFilter(fields) {\n  var arr = (0, _toConsumableArray2[\"default\"])(fields).sort(function (a, b) {\n    return a.length - b.length;\n  });\n\n  for (var i = 0; i < arr.length; i++) {\n    for (var j = i + 1; j < arr.length; j++) {\n      if (arr[j].indexOf(arr[i]) == 0) {\n        // arr[j] is inside arr[i] (eg. \"a.b\" inside \"a\")\n        arr.splice(j, 1);\n        j--;\n      }\n    }\n  }\n\n  return arr;\n};\n\nvar wrapInDefaultConjRuleGroup = function wrapInDefaultConjRuleGroup(rule, parentField, parentFieldConfig, config, conj) {\n  if (!rule) return undefined;\n  return {\n    type: \"rule_group\",\n    id: (0, _uuid[\"default\"])(),\n    children1: (0, _defineProperty2[\"default\"])({}, rule.id, rule),\n    properties: {\n      conjunction: conj || (0, _defaultUtils.defaultGroupConjunction)(config, parentFieldConfig),\n      not: false,\n      field: parentField\n    }\n  };\n};\n\nvar wrapInDefaultConj = function wrapInDefaultConj(rule, config) {\n  var not = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  return {\n    type: \"group\",\n    id: (0, _uuid[\"default\"])(),\n    children1: (0, _defineProperty2[\"default\"])({}, rule.id, rule),\n    properties: {\n      conjunction: (0, _defaultUtils.defaultConjunction)(config),\n      not: not\n    }\n  };\n};\n\nvar parseRule = function parseRule(op, arity, vals, parentField, conv, config, meta) {\n  var errors = [];\n\n  var res = _parseRule(op, arity, vals, parentField, conv, config, errors, false) || _parseRule(op, arity, vals, parentField, conv, config, errors, true);\n\n  if (!res) {\n    meta.errors.push(errors.join(\"; \") || \"Unknown op \".concat(op, \"/\").concat(arity));\n    return undefined;\n  }\n\n  return res;\n};\n\nvar _parseRule = function _parseRule(op, arity, vals, parentField, conv, config, errors, isRevArgs) {\n  // config.settings.groupOperators are used for group count (cardinality = 0 is exception)\n  // but don't confuse with \"all-in\" for multiselect\n  var isAllInForMultiselect = op == \"all\" && (0, _stuff.isJsonLogic)(vals[1]) && Object.keys(vals[1])[0] == \"in\";\n  var isGroup0 = !isAllInForMultiselect && config.settings.groupOperators.includes(op);\n  var eqOps = [\"==\", \"!=\"];\n  var cardinality = isGroup0 ? 0 : arity - 1;\n  if (isGroup0) cardinality = 0;else if (eqOps.includes(op) && cardinality == 1 && vals[1] === null) cardinality = 0;\n  var opk = op + \"/\" + cardinality;\n  var fieldSeparator = config.settings.fieldSeparator;\n  var opKeys = conv.operators[(isRevArgs ? \"#\" : \"\") + opk];\n  if (!opKeys) return;\n  var jlField,\n      args = [];\n  var rangeOps = [\"<\", \"<=\", \">\", \">=\"];\n\n  if (rangeOps.includes(op) && arity == 3) {\n    jlField = vals[1];\n    args = [vals[0], vals[2]];\n  } else if (isRevArgs) {\n    jlField = vals[1];\n    args = [vals[0]];\n  } else {\n    var _vals2 = (0, _toArray2[\"default\"])(vals);\n\n    jlField = _vals2[0];\n    args = _vals2.slice(1);\n  }\n\n  if (!(0, _stuff.isJsonLogic)(jlField)) {\n    errors.push(\"Incorrect operands for \".concat(op, \": \").concat(JSON.stringify(vals)));\n    return;\n  }\n\n  var k = Object.keys(jlField)[0];\n  var v = Object.values(jlField)[0];\n  var field, having, isGroup;\n\n  if (conv.varKeys.includes(k) && typeof v == \"string\") {\n    field = v;\n  }\n\n  if (isGroup0) {\n    isGroup = true;\n    having = args[0];\n    args = [];\n  } // reduce/filter for group ext\n\n\n  if (k == \"reduce\" && Array.isArray(v) && v.length == 3) {\n    var _v2 = v,\n        _v3 = (0, _slicedToArray2[\"default\"])(_v2, 3),\n        filter = _v3[0],\n        acc = _v3[1],\n        init = _v3[2];\n\n    if ((0, _stuff.isJsonLogic)(filter) && init == 0 && (0, _stuff.isJsonLogic)(acc) && Array.isArray(acc[\"+\"]) && acc[\"+\"][0] == 1 && (0, _stuff.isJsonLogic)(acc[\"+\"][1]) && acc[\"+\"][1][\"var\"] == \"accumulator\") {\n      k = Object.keys(filter)[0];\n      v = Object.values(filter)[0];\n\n      if (k == \"filter\") {\n        var _v4 = v,\n            _v5 = (0, _slicedToArray2[\"default\"])(_v4, 2),\n            group = _v5[0],\n            _filter = _v5[1];\n\n        if ((0, _stuff.isJsonLogic)(group)) {\n          k = Object.keys(group)[0];\n          v = Object.values(group)[0];\n\n          if (conv.varKeys.includes(k) && typeof v == \"string\") {\n            field = v;\n            having = _filter;\n            isGroup = true;\n          }\n        }\n      } else if (conv.varKeys.includes(k) && typeof v == \"string\") {\n        field = v;\n        isGroup = true;\n      }\n    }\n  }\n\n  if (!field) {\n    errors.push(\"Unknown field \".concat(JSON.stringify(jlField)));\n    return;\n  }\n\n  if (parentField) field = [parentField, field].join(fieldSeparator);\n  field = (0, _configUtils.normalizeField)(config, field);\n  var fieldConfig = (0, _configUtils.getFieldConfig)(config, field);\n\n  if (!fieldConfig) {\n    errors.push(\"No config for field \".concat(field));\n    return;\n  }\n\n  var opKey = opKeys[0];\n\n  if (opKeys.length > 1 && fieldConfig && fieldConfig.operators) {\n    // eg. for \"equal\" and \"select_equals\"\n    opKeys = opKeys.filter(function (k) {\n      return fieldConfig.operators.includes(k);\n    });\n\n    if (opKeys.length == 0) {\n      errors.push(\"No corresponding ops for field \".concat(field));\n      return;\n    }\n\n    opKey = opKeys[0];\n  }\n\n  return {\n    field: field,\n    fieldConfig: fieldConfig,\n    opKey: opKey,\n    args: args,\n    having: having\n  };\n};\n\nvar convertOp = function convertOp(op, vals, conv, config, not, meta) {\n  var parentField = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n  if (!op) return undefined;\n  var arity = vals.length;\n\n  if (op == \"all\" && (0, _stuff.isJsonLogic)(vals[1])) {\n    // special case for \"all-in\"\n    var op2 = Object.keys(vals[1])[0];\n\n    if (op2 == \"in\") {\n      vals = [vals[0], vals[1][op2][1]];\n      op = op + \"-\" + op2; // \"all-in\"\n    }\n  }\n\n  var parseRes = parseRule(op, arity, vals, parentField, conv, config, meta);\n  if (!parseRes) return undefined;\n  var field = parseRes.field,\n      fieldConfig = parseRes.fieldConfig,\n      opKey = parseRes.opKey,\n      args = parseRes.args,\n      having = parseRes.having;\n  var opConfig = config.operators[opKey]; // Group component in array mode can show NOT checkbox, so do nothing in this case\n  // Otherwise try to revert\n\n  var showNot = fieldConfig.showNot !== undefined ? fieldConfig.showNot : config.settings.showNot;\n  var canRev = true; // if (fieldConfig.type == \"!group\" && fieldConfig.mode == \"array\" && showNot)\n  //   canRev = false;\n\n  var conj;\n  var havingVals;\n\n  if (fieldConfig.type == \"!group\" && having) {\n    conj = Object.keys(having)[0];\n    havingVals = having[conj];\n    if (!Array.isArray(havingVals)) havingVals = [havingVals]; // Preprocess \"!\": Try to reverse op in single rule in having\n    // Eg. use `not_equal` instead of `not` `equal`\n\n    var isEmptyOp = conj == \"!\" && havingVals.length == 1 && havingVals[0] && (0, _stuff.isJsonLogic)(havingVals[0]) && conv.varKeys.includes(Object.keys(havingVals[0])[0]);\n\n    if (conj == \"!\" && !isEmptyOp) {\n      not = !not;\n      having = having[\"!\"];\n      conj = Object.keys(having)[0];\n      havingVals = having[conj];\n      if (!Array.isArray(havingVals)) havingVals = [havingVals];\n    }\n  } // Use reversed op\n\n\n  if (not && canRev && opConfig.reversedOp) {\n    not = false;\n    opKey = opConfig.reversedOp;\n    opConfig = config.operators[opKey];\n  }\n\n  var widget = (0, _ruleUtils.getWidgetForFieldOp)(config, field, opKey);\n  var convertedArgs = args.map(function (v) {\n    return convertFromLogic(v, conv, config, \"val\", meta, false, fieldConfig, widget, parentField);\n  });\n\n  if (convertedArgs.filter(function (v) {\n    return v === undefined;\n  }).length) {\n    //meta.errors.push(`Undefined arg for field ${field} and op ${opKey}`);\n    return undefined;\n  }\n\n  var res;\n\n  if (fieldConfig.type == \"!group\" && having) {\n    if (conv.conjunctions[conj] !== undefined) {\n      res = convertConj(conj, havingVals, conv, config, not, meta, field, true);\n      not = false; // not was applied to group\n    } else {\n      var _rule$properties;\n\n      // need to be wrapped in `rule_group`\n      var rule = convertOp(conj, havingVals, conv, config, not && canRev, meta, field);\n\n      if (not && canRev && !(rule !== null && rule !== void 0 && (_rule$properties = rule.properties) !== null && _rule$properties !== void 0 && _rule$properties.not)) {\n        not = false; // op was reversed in rule\n      }\n\n      res = wrapInDefaultConjRuleGroup(rule, field, fieldConfig, config, conv.conjunctions[\"and\"]);\n    }\n\n    if (!res) return undefined;\n    res.type = \"rule_group\";\n\n    if (not) {\n      Object.assign(res.properties, {\n        not: not\n      });\n    }\n\n    Object.assign(res.properties, {\n      field: field,\n      mode: fieldConfig.mode,\n      operator: opKey\n    });\n\n    if (fieldConfig.mode == \"array\") {\n      Object.assign(res.properties, {\n        value: convertedArgs.map(function (v) {\n          return v.value;\n        }),\n        valueSrc: convertedArgs.map(function (v) {\n          return v.valueSrc;\n        }),\n        valueType: convertedArgs.map(function (v) {\n          return v.valueType;\n        })\n      });\n    }\n  } else if (fieldConfig.type == \"!group\" && !having) {\n    res = {\n      type: \"rule_group\",\n      id: (0, _uuid[\"default\"])(),\n      children1: {},\n      properties: {\n        conjunction: (0, _defaultUtils.defaultGroupConjunction)(config, fieldConfig),\n        not: not,\n        mode: fieldConfig.mode,\n        field: field,\n        operator: opKey\n      }\n    };\n\n    if (fieldConfig.mode == \"array\") {\n      Object.assign(res.properties, {\n        value: convertedArgs.map(function (v) {\n          return v.value;\n        }),\n        valueSrc: convertedArgs.map(function (v) {\n          return v.valueSrc;\n        }),\n        valueType: convertedArgs.map(function (v) {\n          return v.valueType;\n        })\n      });\n    }\n  } else {\n    var asyncListValuesArr = convertedArgs.map(function (v) {\n      return v.asyncListValues;\n    }).filter(function (v) {\n      return v != undefined;\n    });\n    var asyncListValues = asyncListValuesArr.length ? asyncListValuesArr[0] : undefined;\n    res = {\n      type: \"rule\",\n      id: (0, _uuid[\"default\"])(),\n      properties: {\n        field: field,\n        operator: opKey,\n        value: convertedArgs.map(function (v) {\n          return v.value;\n        }),\n        valueSrc: convertedArgs.map(function (v) {\n          return v.valueSrc;\n        }),\n        valueType: convertedArgs.map(function (v) {\n          return v.valueType;\n        }),\n        asyncListValues: asyncListValues\n      }\n    };\n\n    if (not) {\n      //meta.errors.push(`No rev op for ${opKey}`);\n      res = wrapInDefaultConj(res, config, not);\n    }\n  }\n\n  return res;\n};"]},"metadata":{},"sourceType":"script"}