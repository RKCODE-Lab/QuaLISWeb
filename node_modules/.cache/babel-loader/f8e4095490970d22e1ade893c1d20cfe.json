{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.jsonLogicFormat = void 0;\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _toArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toArray\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _stuff = require(\"../utils/stuff\");\n\nvar _configUtils = require(\"../utils/configUtils\");\n\nvar _ruleUtils = require(\"../utils/ruleUtils\");\n\nvar _defaultUtils = require(\"../utils/defaultUtils\");\n\nvar _funcUtils = require(\"../utils/funcUtils\");\n\nvar _immutable = require(\"immutable\");\n\nvar _omit = _interopRequireDefault(require(\"lodash/omit\"));\n\nvar _pick = _interopRequireDefault(require(\"lodash/pick\"));\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2[\"default\"])(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n  if (!it) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n} // http://jsonlogic.com/\n\n\nvar jsonLogicFormat = function jsonLogicFormat(item, config) {\n  //meta is mutable\n  var meta = {\n    usedFields: [],\n    errors: []\n  };\n  var logic = formatItem(item, config, meta, true); // build empty data\n\n  var errors = meta.errors,\n      usedFields = meta.usedFields;\n  var fieldSeparator = config.settings.fieldSeparator;\n  var data = {};\n\n  var _iterator = _createForOfIteratorHelper(usedFields),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var ff = _step.value;\n      var def = (0, _configUtils.getFieldConfig)(config, ff) || {};\n      var parts = ff.split(fieldSeparator);\n      var tmp = data;\n\n      for (var i = 0; i < parts.length; i++) {\n        var p = parts[i];\n        var pdef = (0, _configUtils.getFieldConfig)(config, parts.slice(0, i + 1)) || {};\n\n        if (i != parts.length - 1) {\n          if (pdef.type == \"!group\" && pdef.mode != \"struct\") {\n            if (!tmp[p]) tmp[p] = [{}];\n            tmp = tmp[p][0];\n          } else {\n            if (!tmp[p]) tmp[p] = {};\n            tmp = tmp[p];\n          }\n        } else {\n          if (!tmp[p]) tmp[p] = null; // can use def.type for sample values\n        }\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return {\n    errors: errors,\n    logic: logic,\n    data: data\n  };\n};\n\nexports.jsonLogicFormat = jsonLogicFormat;\n\nvar formatItem = function formatItem(item, config, meta, isRoot) {\n  var parentField = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  if (!item) return undefined;\n  var type = item.get(\"type\");\n\n  if (type === \"group\" || type === \"rule_group\") {\n    return formatGroup(item, config, meta, isRoot, parentField);\n  } else if (type === \"rule\") {\n    return formatRule(item, config, meta, parentField);\n  }\n\n  return undefined;\n};\n\nvar formatGroup = function formatGroup(item, config, meta, isRoot) {\n  var parentField = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  var type = item.get(\"type\");\n  var properties = item.get(\"properties\") || new _immutable.Map();\n  var mode = properties.get(\"mode\");\n  var children = item.get(\"children1\");\n  var field = properties.get(\"field\");\n  if (!children) return undefined;\n  var conjunction = properties.get(\"conjunction\");\n  if (!conjunction) conjunction = (0, _defaultUtils.defaultConjunction)(config);\n  var conj = conjunction.toLowerCase();\n  var not = properties.get(\"not\");\n\n  if (conj != \"and\" && conj != \"or\") {\n    meta.errors.push(\"Conjunction \".concat(conj, \" is not supported\"));\n    return undefined;\n  }\n\n  var isRuleGroup = type === \"rule_group\" && !isRoot;\n  var groupField = isRuleGroup && mode != \"struct\" ? field : parentField;\n  var groupOperator = properties.get(\"operator\");\n  var groupOperatorDefinition = groupOperator && (0, _configUtils.getOperatorConfig)(config, groupOperator, field) || null;\n  var groupValue = properties.get(\"value\");\n  var formattedValue = formatItemValue(config, properties, meta, groupOperator, parentField);\n  var isGroup0 = isRuleGroup && (!groupOperator || groupOperatorDefinition.cardinality == 0);\n  var list = children.map(function (currentChild) {\n    return formatItem(currentChild, config, meta, false, groupField);\n  }).filter(function (currentChild) {\n    return typeof currentChild !== \"undefined\";\n  });\n\n  if (isRuleGroup && mode != \"struct\" && !isGroup0) {\n    // \"count\" rule can have no \"having\" children, but should have number value\n    if (formattedValue == undefined) return undefined;\n  } else {\n    if (!list.size) return undefined;\n  }\n\n  var resultQuery = {};\n  if (list.size == 1 && !isRoot) resultQuery = list.first();else resultQuery[conj] = list.toList().toJS(); // revert\n\n  if (not) {\n    resultQuery = {\n      \"!\": resultQuery\n    };\n  } // rule_group (issue #246)\n\n\n  if (isRuleGroup && mode != \"struct\") {\n    if (isGroup0) {\n      // config.settings.groupOperators\n      var op = groupOperator || \"some\";\n      resultQuery = (0, _defineProperty2[\"default\"])({}, op, [formatField(meta, config, field, parentField), resultQuery]);\n    } else {\n      // there is rule for count\n      var filter = !list.size ? formatField(meta, config, field, parentField) : {\n        \"filter\": [formatField(meta, config, field, parentField), resultQuery]\n      };\n      var count = {\n        \"reduce\": [filter, {\n          \"+\": [1, {\n            \"var\": \"accumulator\"\n          }]\n        }, 0]\n      };\n      resultQuery = formatLogic(config, properties, count, formattedValue, groupOperator);\n    }\n  }\n\n  return resultQuery;\n};\n\nvar formatRule = function formatRule(item, config, meta) {\n  var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var properties = item.get(\"properties\") || new _immutable.Map();\n  var field = properties.get(\"field\");\n  var operator = properties.get(\"operator\");\n  var operatorOptions = properties.get(\"operatorOptions\");\n  operatorOptions = operatorOptions ? operatorOptions.toJS() : null;\n  if (operatorOptions && !Object.keys(operatorOptions).length) operatorOptions = null;\n  if (field == null || operator == null) return undefined;\n  var fieldDefinition = (0, _configUtils.getFieldConfig)(config, field) || {};\n  var operatorDefinition = (0, _configUtils.getOperatorConfig)(config, operator, field) || {};\n  var reversedOp = operatorDefinition.reversedOp;\n  var revOperatorDefinition = (0, _configUtils.getOperatorConfig)(config, reversedOp, field) || {};\n\n  var _fieldType = fieldDefinition.type || \"undefined\";\n\n  var cardinality = (0, _stuff.defaultValue)(operatorDefinition.cardinality, 1); // check op\n\n  var isRev = false;\n\n  if (!operatorDefinition.jsonLogic && !revOperatorDefinition.jsonLogic) {\n    meta.errors.push(\"Operator \".concat(operator, \" is not supported\"));\n    return undefined;\n  }\n\n  if (!operatorDefinition.jsonLogic && revOperatorDefinition.jsonLogic) {\n    isRev = true;\n    var _ref = [reversedOp, operator];\n    operator = _ref[0];\n    reversedOp = _ref[1];\n    var _ref2 = [revOperatorDefinition, operatorDefinition];\n    operatorDefinition = _ref2[0];\n    revOperatorDefinition = _ref2[1];\n  }\n\n  var formattedValue = formatItemValue(config, properties, meta, operator, parentField);\n  if (formattedValue === undefined) return undefined;\n  var formattedField = formatField(meta, config, field, parentField);\n  return formatLogic(config, properties, formattedField, formattedValue, operator, operatorOptions, isRev);\n};\n\nvar formatItemValue = function formatItemValue(config, properties, meta, operator, parentField) {\n  var field = properties.get(\"field\");\n  var iValueSrc = properties.get(\"valueSrc\");\n  var iValueType = properties.get(\"valueType\");\n  var fieldDefinition = (0, _configUtils.getFieldConfig)(config, field) || {};\n  var operatorDefinition = (0, _configUtils.getOperatorConfig)(config, operator, field) || {};\n  var cardinality = (0, _stuff.defaultValue)(operatorDefinition.cardinality, 1);\n  var iValue = properties.get(\"value\");\n  var asyncListValues = properties.get(\"asyncListValues\");\n  if (iValue == undefined) return undefined;\n  var valueSrcs = [];\n  var valueTypes = [];\n  var oldUsedFields = meta.usedFields;\n  var fvalue = iValue.map(function (currentValue, ind) {\n    var valueSrc = iValueSrc ? iValueSrc.get(ind) : null;\n    var valueType = iValueType ? iValueType.get(ind) : null;\n    var cValue = (0, _funcUtils.completeValue)(currentValue, valueSrc, config);\n    var widget = (0, _ruleUtils.getWidgetForFieldOp)(config, field, operator, valueSrc);\n    var fieldWidgetDef = (0, _omit[\"default\"])((0, _configUtils.getFieldWidgetConfig)(config, field, operator, widget, valueSrc), [\"factory\"]);\n    var fv = formatValue(meta, config, cValue, valueSrc, valueType, fieldWidgetDef, fieldDefinition, operator, operatorDefinition, parentField, asyncListValues);\n\n    if (fv !== undefined) {\n      valueSrcs.push(valueSrc);\n      valueTypes.push(valueType);\n    }\n\n    return fv;\n  });\n  var hasUndefinedValues = fvalue.filter(function (v) {\n    return v === undefined;\n  }).size > 0;\n\n  if (fvalue.size < cardinality || hasUndefinedValues) {\n    meta.usedFields = oldUsedFields; // restore\n\n    return undefined;\n  }\n\n  return cardinality > 1 ? fvalue.toArray() : cardinality == 1 ? fvalue.first() : null;\n};\n\nvar formatValue = function formatValue(meta, config, currentValue, valueSrc, valueType, fieldWidgetDef, fieldDef, operator, operatorDef) {\n  var parentField = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : null;\n  var asyncListValues = arguments.length > 10 ? arguments[10] : undefined;\n  if (currentValue === undefined) return undefined;\n  var ret;\n\n  if (valueSrc == \"field\") {\n    ret = formatField(meta, config, currentValue, parentField);\n  } else if (valueSrc == \"func\") {\n    ret = formatFunc(meta, config, currentValue, parentField);\n  } else if (typeof fieldWidgetDef.jsonLogic === \"function\") {\n    var fn = fieldWidgetDef.jsonLogic;\n    var args = [currentValue, _objectSpread(_objectSpread({}, (0, _pick[\"default\"])(fieldDef, [\"fieldSettings\", \"listValues\"])), {}, {\n      asyncListValues: asyncListValues\n    }), //useful options: valueFormat for date/time\n    (0, _omit[\"default\"])(fieldWidgetDef, [\"formatValue\", \"mongoFormatValue\", \"sqlFormatValue\", \"jsonLogic\", \"elasticSearchFormatValue\"])];\n\n    if (operator) {\n      args.push(operator);\n      args.push(operatorDef);\n    }\n\n    ret = fn.apply(void 0, args);\n  } else {\n    ret = currentValue;\n  }\n\n  return ret;\n};\n\nvar formatFunc = function formatFunc(meta, config, currentValue) {\n  var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var funcKey = currentValue.get(\"func\");\n  var args = currentValue.get(\"args\");\n  var funcConfig = (0, _configUtils.getFuncConfig)(config, funcKey);\n\n  if (!funcConfig.jsonLogic) {\n    meta.errors.push(\"Func \".concat(funcKey, \" is not supported\"));\n    return undefined;\n  }\n\n  var formattedArgs = {};\n\n  for (var argKey in funcConfig.args) {\n    var argConfig = funcConfig.args[argKey];\n    var fieldDef = (0, _configUtils.getFieldConfig)(config, argConfig);\n    var argVal = args ? args.get(argKey) : undefined;\n    var argValue = argVal ? argVal.get(\"value\") : undefined;\n    var argValueSrc = argVal ? argVal.get(\"valueSrc\") : undefined;\n    var formattedArgVal = formatValue(meta, config, argValue, argValueSrc, argConfig.type, fieldDef, argConfig, null, null, parentField);\n\n    if (argValue != undefined && formattedArgVal === undefined) {\n      meta.errors.push(\"Can't format value of arg \".concat(argKey, \" for func \").concat(funcKey));\n      return undefined;\n    }\n\n    if (formattedArgVal !== undefined) {\n      // skip optional in the end\n      formattedArgs[argKey] = formattedArgVal;\n    }\n  }\n\n  var formattedArgsArr = Object.values(formattedArgs);\n  var ret;\n\n  if (typeof funcConfig.jsonLogic === \"function\") {\n    var fn = funcConfig.jsonLogic;\n    var _args = [formattedArgs];\n    ret = fn.apply(void 0, _args);\n  } else {\n    var funcName = funcConfig.jsonLogic || funcKey;\n    var isMethod = !!funcConfig.jsonLogicIsMethod;\n\n    if (isMethod) {\n      var _formattedArgsArr = (0, _toArray2[\"default\"])(formattedArgsArr),\n          obj = _formattedArgsArr[0],\n          params = _formattedArgsArr.slice(1);\n\n      if (params.length) {\n        ret = {\n          \"method\": [obj, funcName, params]\n        };\n      } else {\n        ret = {\n          \"method\": [obj, funcName]\n        };\n      }\n    } else {\n      ret = (0, _defineProperty2[\"default\"])({}, funcName, formattedArgsArr);\n    }\n  }\n\n  return ret;\n};\n\nvar formatField = function formatField(meta, config, field) {\n  var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var _config$settings = config.settings,\n      fieldSeparator = _config$settings.fieldSeparator,\n      jsonLogic = _config$settings.jsonLogic;\n  var ret;\n\n  if (field) {\n    if (Array.isArray(field)) field = field.join(fieldSeparator);\n    var fieldDef = (0, _configUtils.getFieldConfig)(config, field) || {};\n    var fieldName = field;\n\n    if (fieldDef.fieldName) {\n      fieldName = fieldDef.fieldName;\n    }\n\n    if (parentField) {\n      var parentFieldDef = (0, _configUtils.getFieldConfig)(config, parentField) || {};\n      var parentFieldName = parentField;\n\n      if (parentFieldDef.fieldName) {\n        parentFieldName = parentFieldDef.fieldName;\n      }\n\n      if (fieldName.indexOf(parentFieldName + fieldSeparator) == 0) {\n        fieldName = fieldName.slice((parentFieldName + fieldSeparator).length);\n      } else {\n        meta.errors.push(\"Can't cut group \".concat(parentFieldName, \" from field \").concat(fieldName));\n      }\n    }\n\n    var varName = fieldDef.jsonLogicVar || (fieldDef.type == \"!group\" ? jsonLogic.groupVarKey : \"var\");\n    ret = (0, _defineProperty2[\"default\"])({}, varName, fieldName);\n    if (meta.usedFields.indexOf(field) == -1) meta.usedFields.push(field);\n  }\n\n  return ret;\n};\n\nvar formatLogic = function formatLogic(config, properties, formattedField, formattedValue, operator) {\n  var operatorOptions = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n  var isRev = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n  var field = properties.get(\"field\");\n  var operatorDefinition = (0, _configUtils.getOperatorConfig)(config, operator, field) || {};\n  var cardinality = (0, _stuff.defaultValue)(operatorDefinition.cardinality, 1);\n  var isReverseArgs = (0, _stuff.defaultValue)(operatorDefinition._jsonLogicIsRevArgs, false);\n  var formatteOp = operator;\n  if (typeof operatorDefinition.jsonLogic == \"string\") formatteOp = operatorDefinition.jsonLogic;\n  var fn = typeof operatorDefinition.jsonLogic == \"function\" ? operatorDefinition.jsonLogic : null;\n\n  if (!fn) {\n    var rangeOps = [\"<\", \"<=\", \">\", \">=\"];\n\n    fn = function fn(field, op, val, opDef, opOpts) {\n      if (cardinality == 0) return (0, _defineProperty2[\"default\"])({}, formatteOp, formattedField);else if (cardinality == 1 && isReverseArgs) return (0, _defineProperty2[\"default\"])({}, formatteOp, [formattedValue, formattedField]);else if (cardinality == 1) return (0, _defineProperty2[\"default\"])({}, formatteOp, [formattedField, formattedValue]);else if (cardinality == 2 && rangeOps.includes(formatteOp)) return (0, _defineProperty2[\"default\"])({}, formatteOp, [formattedValue[0], formattedField, formattedValue[1]]);else return (0, _defineProperty2[\"default\"])({}, formatteOp, [formattedField].concat((0, _toConsumableArray2[\"default\"])(formattedValue)));\n    };\n  }\n\n  var args = [formattedField, operator, formattedValue, (0, _omit[\"default\"])(operatorDefinition, [\"formatOp\", \"mongoFormatOp\", \"sqlFormatOp\", \"jsonLogic\"]), operatorOptions];\n  var ruleQuery = fn.apply(void 0, args);\n\n  if (isRev) {\n    ruleQuery = {\n      \"!\": ruleQuery\n    };\n  }\n\n  return ruleQuery;\n};","map":{"version":3,"sources":["D:/LIMSWFH/LIMSPOSTGRESQL/QuaLISWeb/node_modules/react-awesome-query-builder/lib/export/jsonLogic.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","jsonLogicFormat","_toConsumableArray2","_toArray2","_defineProperty2","_stuff","_configUtils","_ruleUtils","_defaultUtils","_funcUtils","_immutable","_omit","_pick","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","_createForOfIteratorHelper","o","allowArrayLike","it","Symbol","iterator","Array","isArray","_unsupportedIterableToArray","F","s","n","done","e","_e","f","TypeError","normalCompletion","didErr","err","call","step","next","_e2","minLen","_arrayLikeToArray","prototype","toString","slice","constructor","name","from","test","arr","len","arr2","item","config","meta","usedFields","errors","logic","formatItem","fieldSeparator","settings","data","_iterator","_step","ff","def","getFieldConfig","parts","split","tmp","p","pdef","type","mode","isRoot","parentField","undefined","get","formatGroup","formatRule","properties","Map","children","field","conjunction","defaultConjunction","conj","toLowerCase","not","concat","isRuleGroup","groupField","groupOperator","groupOperatorDefinition","getOperatorConfig","groupValue","formattedValue","formatItemValue","isGroup0","cardinality","list","map","currentChild","size","resultQuery","first","toList","toJS","op","formatField","count","formatLogic","operator","operatorOptions","fieldDefinition","operatorDefinition","reversedOp","revOperatorDefinition","_fieldType","defaultValue","isRev","jsonLogic","_ref","_ref2","formattedField","iValueSrc","iValueType","iValue","asyncListValues","valueSrcs","valueTypes","oldUsedFields","fvalue","currentValue","ind","valueSrc","valueType","cValue","completeValue","widget","getWidgetForFieldOp","fieldWidgetDef","getFieldWidgetConfig","fv","formatValue","hasUndefinedValues","v","toArray","fieldDef","operatorDef","ret","formatFunc","fn","args","funcKey","funcConfig","getFuncConfig","formattedArgs","argKey","argConfig","argVal","argValue","argValueSrc","formattedArgVal","formattedArgsArr","values","_args","funcName","isMethod","jsonLogicIsMethod","_formattedArgsArr","obj","params","_config$settings","join","fieldName","parentFieldDef","parentFieldName","indexOf","varName","jsonLogicVar","groupVarKey","isReverseArgs","_jsonLogicIsRevArgs","formatteOp","rangeOps","val","opDef","opOpts","includes","ruleQuery"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.jsonLogicFormat = void 0;\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _toArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toArray\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _stuff = require(\"../utils/stuff\");\n\nvar _configUtils = require(\"../utils/configUtils\");\n\nvar _ruleUtils = require(\"../utils/ruleUtils\");\n\nvar _defaultUtils = require(\"../utils/defaultUtils\");\n\nvar _funcUtils = require(\"../utils/funcUtils\");\n\nvar _immutable = require(\"immutable\");\n\nvar _omit = _interopRequireDefault(require(\"lodash/omit\"));\n\nvar _pick = _interopRequireDefault(require(\"lodash/pick\"));\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2[\"default\"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n// http://jsonlogic.com/\nvar jsonLogicFormat = function jsonLogicFormat(item, config) {\n  //meta is mutable\n  var meta = {\n    usedFields: [],\n    errors: []\n  };\n  var logic = formatItem(item, config, meta, true); // build empty data\n\n  var errors = meta.errors,\n      usedFields = meta.usedFields;\n  var fieldSeparator = config.settings.fieldSeparator;\n  var data = {};\n\n  var _iterator = _createForOfIteratorHelper(usedFields),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var ff = _step.value;\n      var def = (0, _configUtils.getFieldConfig)(config, ff) || {};\n      var parts = ff.split(fieldSeparator);\n      var tmp = data;\n\n      for (var i = 0; i < parts.length; i++) {\n        var p = parts[i];\n        var pdef = (0, _configUtils.getFieldConfig)(config, parts.slice(0, i + 1)) || {};\n\n        if (i != parts.length - 1) {\n          if (pdef.type == \"!group\" && pdef.mode != \"struct\") {\n            if (!tmp[p]) tmp[p] = [{}];\n            tmp = tmp[p][0];\n          } else {\n            if (!tmp[p]) tmp[p] = {};\n            tmp = tmp[p];\n          }\n        } else {\n          if (!tmp[p]) tmp[p] = null; // can use def.type for sample values\n        }\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return {\n    errors: errors,\n    logic: logic,\n    data: data\n  };\n};\n\nexports.jsonLogicFormat = jsonLogicFormat;\n\nvar formatItem = function formatItem(item, config, meta, isRoot) {\n  var parentField = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  if (!item) return undefined;\n  var type = item.get(\"type\");\n\n  if (type === \"group\" || type === \"rule_group\") {\n    return formatGroup(item, config, meta, isRoot, parentField);\n  } else if (type === \"rule\") {\n    return formatRule(item, config, meta, parentField);\n  }\n\n  return undefined;\n};\n\nvar formatGroup = function formatGroup(item, config, meta, isRoot) {\n  var parentField = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  var type = item.get(\"type\");\n  var properties = item.get(\"properties\") || new _immutable.Map();\n  var mode = properties.get(\"mode\");\n  var children = item.get(\"children1\");\n  var field = properties.get(\"field\");\n  if (!children) return undefined;\n  var conjunction = properties.get(\"conjunction\");\n  if (!conjunction) conjunction = (0, _defaultUtils.defaultConjunction)(config);\n  var conj = conjunction.toLowerCase();\n  var not = properties.get(\"not\");\n\n  if (conj != \"and\" && conj != \"or\") {\n    meta.errors.push(\"Conjunction \".concat(conj, \" is not supported\"));\n    return undefined;\n  }\n\n  var isRuleGroup = type === \"rule_group\" && !isRoot;\n  var groupField = isRuleGroup && mode != \"struct\" ? field : parentField;\n  var groupOperator = properties.get(\"operator\");\n  var groupOperatorDefinition = groupOperator && (0, _configUtils.getOperatorConfig)(config, groupOperator, field) || null;\n  var groupValue = properties.get(\"value\");\n  var formattedValue = formatItemValue(config, properties, meta, groupOperator, parentField);\n  var isGroup0 = isRuleGroup && (!groupOperator || groupOperatorDefinition.cardinality == 0);\n  var list = children.map(function (currentChild) {\n    return formatItem(currentChild, config, meta, false, groupField);\n  }).filter(function (currentChild) {\n    return typeof currentChild !== \"undefined\";\n  });\n\n  if (isRuleGroup && mode != \"struct\" && !isGroup0) {\n    // \"count\" rule can have no \"having\" children, but should have number value\n    if (formattedValue == undefined) return undefined;\n  } else {\n    if (!list.size) return undefined;\n  }\n\n  var resultQuery = {};\n  if (list.size == 1 && !isRoot) resultQuery = list.first();else resultQuery[conj] = list.toList().toJS(); // revert\n\n  if (not) {\n    resultQuery = {\n      \"!\": resultQuery\n    };\n  } // rule_group (issue #246)\n\n\n  if (isRuleGroup && mode != \"struct\") {\n    if (isGroup0) {\n      // config.settings.groupOperators\n      var op = groupOperator || \"some\";\n      resultQuery = (0, _defineProperty2[\"default\"])({}, op, [formatField(meta, config, field, parentField), resultQuery]);\n    } else {\n      // there is rule for count\n      var filter = !list.size ? formatField(meta, config, field, parentField) : {\n        \"filter\": [formatField(meta, config, field, parentField), resultQuery]\n      };\n      var count = {\n        \"reduce\": [filter, {\n          \"+\": [1, {\n            \"var\": \"accumulator\"\n          }]\n        }, 0]\n      };\n      resultQuery = formatLogic(config, properties, count, formattedValue, groupOperator);\n    }\n  }\n\n  return resultQuery;\n};\n\nvar formatRule = function formatRule(item, config, meta) {\n  var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var properties = item.get(\"properties\") || new _immutable.Map();\n  var field = properties.get(\"field\");\n  var operator = properties.get(\"operator\");\n  var operatorOptions = properties.get(\"operatorOptions\");\n  operatorOptions = operatorOptions ? operatorOptions.toJS() : null;\n  if (operatorOptions && !Object.keys(operatorOptions).length) operatorOptions = null;\n  if (field == null || operator == null) return undefined;\n  var fieldDefinition = (0, _configUtils.getFieldConfig)(config, field) || {};\n  var operatorDefinition = (0, _configUtils.getOperatorConfig)(config, operator, field) || {};\n  var reversedOp = operatorDefinition.reversedOp;\n  var revOperatorDefinition = (0, _configUtils.getOperatorConfig)(config, reversedOp, field) || {};\n\n  var _fieldType = fieldDefinition.type || \"undefined\";\n\n  var cardinality = (0, _stuff.defaultValue)(operatorDefinition.cardinality, 1); // check op\n\n  var isRev = false;\n\n  if (!operatorDefinition.jsonLogic && !revOperatorDefinition.jsonLogic) {\n    meta.errors.push(\"Operator \".concat(operator, \" is not supported\"));\n    return undefined;\n  }\n\n  if (!operatorDefinition.jsonLogic && revOperatorDefinition.jsonLogic) {\n    isRev = true;\n    var _ref = [reversedOp, operator];\n    operator = _ref[0];\n    reversedOp = _ref[1];\n    var _ref2 = [revOperatorDefinition, operatorDefinition];\n    operatorDefinition = _ref2[0];\n    revOperatorDefinition = _ref2[1];\n  }\n\n  var formattedValue = formatItemValue(config, properties, meta, operator, parentField);\n  if (formattedValue === undefined) return undefined;\n  var formattedField = formatField(meta, config, field, parentField);\n  return formatLogic(config, properties, formattedField, formattedValue, operator, operatorOptions, isRev);\n};\n\nvar formatItemValue = function formatItemValue(config, properties, meta, operator, parentField) {\n  var field = properties.get(\"field\");\n  var iValueSrc = properties.get(\"valueSrc\");\n  var iValueType = properties.get(\"valueType\");\n  var fieldDefinition = (0, _configUtils.getFieldConfig)(config, field) || {};\n  var operatorDefinition = (0, _configUtils.getOperatorConfig)(config, operator, field) || {};\n  var cardinality = (0, _stuff.defaultValue)(operatorDefinition.cardinality, 1);\n  var iValue = properties.get(\"value\");\n  var asyncListValues = properties.get(\"asyncListValues\");\n  if (iValue == undefined) return undefined;\n  var valueSrcs = [];\n  var valueTypes = [];\n  var oldUsedFields = meta.usedFields;\n  var fvalue = iValue.map(function (currentValue, ind) {\n    var valueSrc = iValueSrc ? iValueSrc.get(ind) : null;\n    var valueType = iValueType ? iValueType.get(ind) : null;\n    var cValue = (0, _funcUtils.completeValue)(currentValue, valueSrc, config);\n    var widget = (0, _ruleUtils.getWidgetForFieldOp)(config, field, operator, valueSrc);\n    var fieldWidgetDef = (0, _omit[\"default\"])((0, _configUtils.getFieldWidgetConfig)(config, field, operator, widget, valueSrc), [\"factory\"]);\n    var fv = formatValue(meta, config, cValue, valueSrc, valueType, fieldWidgetDef, fieldDefinition, operator, operatorDefinition, parentField, asyncListValues);\n\n    if (fv !== undefined) {\n      valueSrcs.push(valueSrc);\n      valueTypes.push(valueType);\n    }\n\n    return fv;\n  });\n  var hasUndefinedValues = fvalue.filter(function (v) {\n    return v === undefined;\n  }).size > 0;\n\n  if (fvalue.size < cardinality || hasUndefinedValues) {\n    meta.usedFields = oldUsedFields; // restore\n\n    return undefined;\n  }\n\n  return cardinality > 1 ? fvalue.toArray() : cardinality == 1 ? fvalue.first() : null;\n};\n\nvar formatValue = function formatValue(meta, config, currentValue, valueSrc, valueType, fieldWidgetDef, fieldDef, operator, operatorDef) {\n  var parentField = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : null;\n  var asyncListValues = arguments.length > 10 ? arguments[10] : undefined;\n  if (currentValue === undefined) return undefined;\n  var ret;\n\n  if (valueSrc == \"field\") {\n    ret = formatField(meta, config, currentValue, parentField);\n  } else if (valueSrc == \"func\") {\n    ret = formatFunc(meta, config, currentValue, parentField);\n  } else if (typeof fieldWidgetDef.jsonLogic === \"function\") {\n    var fn = fieldWidgetDef.jsonLogic;\n    var args = [currentValue, _objectSpread(_objectSpread({}, (0, _pick[\"default\"])(fieldDef, [\"fieldSettings\", \"listValues\"])), {}, {\n      asyncListValues: asyncListValues\n    }), //useful options: valueFormat for date/time\n    (0, _omit[\"default\"])(fieldWidgetDef, [\"formatValue\", \"mongoFormatValue\", \"sqlFormatValue\", \"jsonLogic\", \"elasticSearchFormatValue\"])];\n\n    if (operator) {\n      args.push(operator);\n      args.push(operatorDef);\n    }\n\n    ret = fn.apply(void 0, args);\n  } else {\n    ret = currentValue;\n  }\n\n  return ret;\n};\n\nvar formatFunc = function formatFunc(meta, config, currentValue) {\n  var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var funcKey = currentValue.get(\"func\");\n  var args = currentValue.get(\"args\");\n  var funcConfig = (0, _configUtils.getFuncConfig)(config, funcKey);\n\n  if (!funcConfig.jsonLogic) {\n    meta.errors.push(\"Func \".concat(funcKey, \" is not supported\"));\n    return undefined;\n  }\n\n  var formattedArgs = {};\n\n  for (var argKey in funcConfig.args) {\n    var argConfig = funcConfig.args[argKey];\n    var fieldDef = (0, _configUtils.getFieldConfig)(config, argConfig);\n    var argVal = args ? args.get(argKey) : undefined;\n    var argValue = argVal ? argVal.get(\"value\") : undefined;\n    var argValueSrc = argVal ? argVal.get(\"valueSrc\") : undefined;\n    var formattedArgVal = formatValue(meta, config, argValue, argValueSrc, argConfig.type, fieldDef, argConfig, null, null, parentField);\n\n    if (argValue != undefined && formattedArgVal === undefined) {\n      meta.errors.push(\"Can't format value of arg \".concat(argKey, \" for func \").concat(funcKey));\n      return undefined;\n    }\n\n    if (formattedArgVal !== undefined) {\n      // skip optional in the end\n      formattedArgs[argKey] = formattedArgVal;\n    }\n  }\n\n  var formattedArgsArr = Object.values(formattedArgs);\n  var ret;\n\n  if (typeof funcConfig.jsonLogic === \"function\") {\n    var fn = funcConfig.jsonLogic;\n    var _args = [formattedArgs];\n    ret = fn.apply(void 0, _args);\n  } else {\n    var funcName = funcConfig.jsonLogic || funcKey;\n    var isMethod = !!funcConfig.jsonLogicIsMethod;\n\n    if (isMethod) {\n      var _formattedArgsArr = (0, _toArray2[\"default\"])(formattedArgsArr),\n          obj = _formattedArgsArr[0],\n          params = _formattedArgsArr.slice(1);\n\n      if (params.length) {\n        ret = {\n          \"method\": [obj, funcName, params]\n        };\n      } else {\n        ret = {\n          \"method\": [obj, funcName]\n        };\n      }\n    } else {\n      ret = (0, _defineProperty2[\"default\"])({}, funcName, formattedArgsArr);\n    }\n  }\n\n  return ret;\n};\n\nvar formatField = function formatField(meta, config, field) {\n  var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var _config$settings = config.settings,\n      fieldSeparator = _config$settings.fieldSeparator,\n      jsonLogic = _config$settings.jsonLogic;\n  var ret;\n\n  if (field) {\n    if (Array.isArray(field)) field = field.join(fieldSeparator);\n    var fieldDef = (0, _configUtils.getFieldConfig)(config, field) || {};\n    var fieldName = field;\n\n    if (fieldDef.fieldName) {\n      fieldName = fieldDef.fieldName;\n    }\n\n    if (parentField) {\n      var parentFieldDef = (0, _configUtils.getFieldConfig)(config, parentField) || {};\n      var parentFieldName = parentField;\n\n      if (parentFieldDef.fieldName) {\n        parentFieldName = parentFieldDef.fieldName;\n      }\n\n      if (fieldName.indexOf(parentFieldName + fieldSeparator) == 0) {\n        fieldName = fieldName.slice((parentFieldName + fieldSeparator).length);\n      } else {\n        meta.errors.push(\"Can't cut group \".concat(parentFieldName, \" from field \").concat(fieldName));\n      }\n    }\n\n    var varName = fieldDef.jsonLogicVar || (fieldDef.type == \"!group\" ? jsonLogic.groupVarKey : \"var\");\n    ret = (0, _defineProperty2[\"default\"])({}, varName, fieldName);\n    if (meta.usedFields.indexOf(field) == -1) meta.usedFields.push(field);\n  }\n\n  return ret;\n};\n\nvar formatLogic = function formatLogic(config, properties, formattedField, formattedValue, operator) {\n  var operatorOptions = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n  var isRev = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n  var field = properties.get(\"field\");\n  var operatorDefinition = (0, _configUtils.getOperatorConfig)(config, operator, field) || {};\n  var cardinality = (0, _stuff.defaultValue)(operatorDefinition.cardinality, 1);\n  var isReverseArgs = (0, _stuff.defaultValue)(operatorDefinition._jsonLogicIsRevArgs, false);\n  var formatteOp = operator;\n  if (typeof operatorDefinition.jsonLogic == \"string\") formatteOp = operatorDefinition.jsonLogic;\n  var fn = typeof operatorDefinition.jsonLogic == \"function\" ? operatorDefinition.jsonLogic : null;\n\n  if (!fn) {\n    var rangeOps = [\"<\", \"<=\", \">\", \">=\"];\n\n    fn = function fn(field, op, val, opDef, opOpts) {\n      if (cardinality == 0) return (0, _defineProperty2[\"default\"])({}, formatteOp, formattedField);else if (cardinality == 1 && isReverseArgs) return (0, _defineProperty2[\"default\"])({}, formatteOp, [formattedValue, formattedField]);else if (cardinality == 1) return (0, _defineProperty2[\"default\"])({}, formatteOp, [formattedField, formattedValue]);else if (cardinality == 2 && rangeOps.includes(formatteOp)) return (0, _defineProperty2[\"default\"])({}, formatteOp, [formattedValue[0], formattedField, formattedValue[1]]);else return (0, _defineProperty2[\"default\"])({}, formatteOp, [formattedField].concat((0, _toConsumableArray2[\"default\"])(formattedValue)));\n    };\n  }\n\n  var args = [formattedField, operator, formattedValue, (0, _omit[\"default\"])(operatorDefinition, [\"formatOp\", \"mongoFormatOp\", \"sqlFormatOp\", \"jsonLogic\"]), operatorOptions];\n  var ruleQuery = fn.apply(void 0, args);\n\n  if (isRev) {\n    ruleQuery = {\n      \"!\": ruleQuery\n    };\n  }\n\n  return ruleQuery;\n};"]},"metadata":{},"sourceType":"script"}