{"ast":null,"code":"import rsapi from '../rsapi';\nimport { DEFAULT_RETURN } from './LoginTypes';\nimport { constructOptionList, sortData, rearrangeDateFormat } from '../components/CommonScript';\nimport { toast } from 'react-toastify';\nimport Axios from 'axios';\nimport { initRequest } from './LoginAction';\nexport function getChecklistVersion(checklist, userInfo, masterData) {\n  return function (dispatch) {\n    const inputData = {\n      \"nchecklistcode\": checklist.nchecklistcode,\n      userinfo: userInfo\n    };\n    dispatch(initRequest(true));\n    rsapi.post(\"checklist/getChecklistVersion\", inputData).then(response => {\n      masterData = { ...masterData,\n        ...response.data,\n        selectedchecklist: checklist\n      };\n      sortData(masterData);\n      dispatch({\n        type: DEFAULT_RETURN,\n        payload: {\n          masterData,\n          loading: false\n        }\n      });\n    }).catch(error => {\n      dispatch({\n        type: DEFAULT_RETURN,\n        payload: {\n          loading: false\n        }\n      });\n\n      if (error.response.status === 500) {\n        toast.error(error.message);\n      } else {\n        toast.warn(error.response.data);\n      }\n    });\n  };\n}\nexport function getVersionQB(versionObject) {\n  let {\n    version,\n    masterData,\n    userInfo\n  } = versionObject;\n  return function (dispatch) {\n    if (!(masterData.selectedversion.nchecklistversioncode === version.nchecklistversioncode)) {\n      const inputData = {\n        nchecklistversioncode: version.nchecklistversioncode,\n        userinfo: userInfo\n      }; //const url1=rsapi.post('checklist/getActiveChecklistVersionById',inputData)\n\n      const url2 = rsapi.post('checklist/getChecklistVersionQB', inputData);\n      dispatch(initRequest(true));\n      Axios.all([url2]).then(response => {\n        masterData = { ...masterData,\n          checklistversionqb: response[0].data.checklistversionqb,\n          selectedversion: version\n        };\n        sortData(masterData);\n        dispatch({\n          type: DEFAULT_RETURN,\n          payload: {\n            masterData,\n            loading: false\n          }\n        });\n      }).catch(error => {\n        dispatch({\n          type: DEFAULT_RETURN,\n          payload: {\n            loading: false\n          }\n        });\n\n        if (error.response.status === 500) {\n          toast.error(error.message);\n        } else {\n          toast.warn(error.response.data);\n        }\n      });\n    } else {\n      dispatch({\n        type: DEFAULT_RETURN,\n        payload: {\n          masterData,\n          loading: false\n        }\n      });\n    }\n  };\n}\nexport function viewVersionTemplate(version, userInfo, ncontrolCode) {\n  return function (dispatch) {\n    dispatch(initRequest(true));\n    rsapi.post(\"checklist/viewTemplate\", {\n      \"nchecklistversioncode\": version.nchecklistversioncode,\n      \"flag\": 1,\n      \"ntransactionresultcode\": 1,\n      \"userinfo\": userInfo\n    }).then(response => {\n      let selectedRecord = {};\n      let lsteditedQB = [];\n      response.data.map(checklist => {\n        selectedRecord[checklist.nchecklistversionqbcode] = {\n          nchecklistqbcode: checklist.nchecklistqbcode,\n          nchecklistversioncode: checklist.nchecklistversioncode,\n          nchecklistversionqbcode: checklist.nchecklistversionqbcode,\n          sdefaultvalue: checklist.nchecklistcomponentcode === 7 ? rearrangeDateFormat(userInfo, checklist.sdefaultvalue) : checklist.sdefaultvalue === 'null' ? undefined : checklist.sdefaultvalue\n        };\n        lsteditedQB.push(checklist.nchecklistversionqbcode);\n        return null;\n      });\n      response.data.map(checklist => {\n        selectedRecord['jsondata'] = { ...selectedRecord['jsondata'],\n          [checklist.nchecklistversionqbcode]: checklist.nchecklistcomponentcode === 7 ? rearrangeDateFormat(userInfo, checklist.sdefaultvalue) : checklist.sdefaultvalue === 'null' ? undefined : checklist.sdefaultvalue\n        };\n        return null;\n      });\n      selectedRecord[\"editedQB\"] = lsteditedQB;\n      dispatch({\n        type: DEFAULT_RETURN,\n        payload: {\n          openTemplateModal: true,\n          templateData: response.data,\n          loading: false,\n          ncontrolcode: ncontrolCode,\n          selectedRecord: selectedRecord\n        }\n      });\n    }).catch(error => {\n      dispatch({\n        type: DEFAULT_RETURN,\n        payload: {\n          loading: false\n        }\n      });\n\n      if (error.response.status === 500) {\n        toast.error(error.message);\n      } else {\n        toast.warn(error.response.data);\n      }\n    });\n  };\n} // export function filterChecklistColumnData(filterValue, masterData, userInfo) {\n//     return function(dispatch){\n//         let checklistCode = 0;   \n//         let searchedData = undefined;\n//         if (filterValue === \"\"){\n//             checklistCode = masterData[\"checklist\"][0].nchecklistcode;\n//         } \n//         else{\n//             searchedData = searchData(filterValue, masterData[\"checklist\"]);\n//             if (searchedData.length > 0){\n//                 checklistCode = searchedData[0].nchecklistcode; \n//             }\n//         }\n//         if (checklistCode !== 0){\n//             dispatch(initRequest(true));\n//             rsapi.post(\"checklist/getChecklistVersion\", {nchecklistcode:checklistCode,userinfo:userInfo})\n//             .then(response=>{                \n//                 masterData[\"checklistversion\"] = sortData(response.data[\"checklistversion\"]);\n//                 masterData[\"selectedversion\"] = response.data[\"selectedversion\"];\n//                 masterData[\"checklistversionqb\"] =  sortData(response.data[\"checklistversionqb\"]);\n//                 masterData[\"selectedchecklist\"] =searchedData?searchedData[0]:masterData[\"checklist\"][0];\n//                 masterData[\"searchedData\"] = searchedData;\n//                 dispatch({type: DEFAULT_RETURN, payload:{masterData,   loading:false}});\n//             })\n//             .catch(error=>{\n//                 dispatch({type: DEFAULT_RETURN, payload: {loading:false}})\n//                 if (error.response.status === 500){\n//                     toast.error(error.message);\n//                 } \n//                 else{               \n//                     toast.warn(error.response.data);\n//                 }  \n//             }) \n//         }else{\n//             masterData[\"checklistversion\"] = [];\n//             masterData[\"selectedversion\"] = [];\n//             masterData[\"checklistversionqb\"] = [];\n//             masterData[\"selectedchecklist\"] =[];\n//             masterData[\"searchedData\"] = [];\n//             dispatch({type: DEFAULT_RETURN, payload:{masterData,   loading:false}});\n//         }\n//     }\n// }   \n\nexport function onSaveTemplate(selectedRecord, userInfo) {\n  return function (dispatch) {\n    let listChecklistVersionTemplate = [];\n\n    if (selectedRecord && selectedRecord.editedQB) {\n      selectedRecord.editedQB.map(qbcode => listChecklistVersionTemplate.push(selectedRecord[qbcode] && selectedRecord[qbcode].sdefaultvalue != null ? selectedRecord[qbcode] : selectedRecord[qbcode] = {\n        \"nchecklistqbcode\": selectedRecord[qbcode].nchecklistqbcode,\n        \"nchecklistversioncode\": selectedRecord[qbcode].nchecklistversioncode,\n        \"nchecklistversionqbcode\": selectedRecord[qbcode].nchecklistversionqbcode,\n        \"sdefaultvalue\": \"\"\n      })); //  listChecklistVersionTemplate.push(selectedRecord[qbcode]))\n\n      dispatch(initRequest(true));\n      rsapi.post(\"checklist/createUpdateChecklistVersionTemplate\", {\n        checklistversiontemplate: listChecklistVersionTemplate,\n        \"userinfo\": userInfo\n      }).then(response => {\n        dispatch({\n          type: DEFAULT_RETURN,\n          payload: {\n            selectedRecord: {},\n            templateData: undefined,\n            openTemplateModal: false,\n            loading: false\n          }\n        });\n      }).catch(error => {\n        dispatch({\n          type: DEFAULT_RETURN,\n          payload: {\n            loading: false\n          }\n        });\n\n        if (error.response.status === 500) {\n          toast.error(error.message);\n        } else {\n          toast.warn(error.response.data);\n        }\n      });\n    } else {\n      dispatch({\n        type: DEFAULT_RETURN,\n        payload: {\n          openTemplateModal: false,\n          selectedRecord: {},\n          templateData: undefined,\n          loading: false\n        }\n      });\n    }\n  };\n}\nexport function showChecklistAddScreen(nchecklistversioncode, id, ncontrolcode, userInfo) {\n  return function (dispatch) {\n    let modalName = id === 'checklist' ? 'openModal' : 'openChildModal';\n\n    if (id === \"checklistversionqb\") {\n      dispatch(initRequest(true));\n      rsapi.post(\"checklist/getVersionQBAddEditData\", {\n        \"nchecklistversioncode\": nchecklistversioncode,\n        \"userinfo\": userInfo\n      }).then(response => {\n        const optionsQBCategoryMap = constructOptionList(response.data.qbcategory || [], \"nchecklistqbcategorycode\", \"schecklistqbcategoryname\", undefined, undefined, true);\n        const availableQBCategory = optionsQBCategoryMap.get(\"OptionList\");\n        let listQbObj = {\n          listQb: {}\n        };\n        let optionsChecklistComponentMap;\n        availableQBCategory.map(cat => {\n          optionsChecklistComponentMap = constructOptionList(response.data.checklistqb[cat.label] || [], \"nchecklistqbcode\", \"squestion\", undefined, undefined, true);\n          listQbObj = {\n            listQb: { ...listQbObj.listQb,\n              [cat.label]: optionsChecklistComponentMap.get(\"OptionList\")\n            }\n          };\n          return null;\n        });\n        dispatch({\n          type: DEFAULT_RETURN,\n          payload: {\n            [modalName]: true,\n            selectedRecord: {},\n            operation: \"create\",\n            id,\n            QBCategory: undefined,\n            QB: undefined,\n            availableQBCategory,\n            listQb: listQbObj.listQb,\n            availableQB: [],\n            ncontrolcode,\n            loading: false\n          }\n        });\n      }).catch(error => {\n        dispatch({\n          type: DEFAULT_RETURN,\n          payload: {\n            loading: false\n          }\n        });\n\n        if (error.response.status === 500) {\n          toast.error(error.message);\n        } else {\n          toast.warn(error.response.data);\n        }\n      });\n    } else {\n      dispatch({\n        type: DEFAULT_RETURN,\n        payload: {\n          [modalName]: true,\n          selectedRecord: {},\n          operation: \"create\",\n          id,\n          ncontrolcode,\n          loading: false\n        }\n      });\n    }\n  };\n}\nexport function fetchChecklistRecordByID(editParam) {\n  return function (dispatch) {\n    if (editParam.screenName.toLowerCase() === \"checklist\" || editParam.screenName.toLowerCase() === \"checklistversion\") {\n      let modalName = editParam.screenName.toLowerCase() === \"checklist\" ? 'openModal' : 'openChildModal';\n      dispatch(initRequest(true));\n      rsapi.post(\"checklist/getActive\" + editParam.screenName + \"ById\", {\n        [editParam.primaryKeyField]: editParam.primaryKeyValue,\n        \"userinfo\": editParam.userInfo\n      }).then(response => {\n        dispatch({\n          type: DEFAULT_RETURN,\n          payload: {\n            [modalName]: true,\n            selectedRecord: response.data,\n            operation: editParam.operation,\n            id: editParam.screenName.toLowerCase(),\n            ncontrolcode: editParam.ncontrolCode,\n            masterData: editParam.masterData,\n            loading: false\n          }\n        });\n      }).catch(error => {\n        dispatch({\n          type: DEFAULT_RETURN,\n          payload: {\n            loading: false\n          }\n        });\n\n        if (error.response.status === 500) {\n          toast.error(error.message);\n        } else {\n          toast.warn(error.response.data);\n        }\n      });\n    } else {\n      const url1 = rsapi.post(\"checklist/getVersionQBAddEditData\", {\n        \"nchecklistversioncode\": editParam.masterData.selectedversion.nchecklistversioncode,\n        \"userinfo\": editParam.userInfo\n      });\n      const url2 = rsapi.post(\"checklist/getActive\" + editParam.screenName + \"ById\", {\n        [editParam.primaryKeyField]: editParam.primaryKeyValue,\n        \"userinfo\": editParam.userInfo\n      });\n      dispatch(initRequest(true));\n      Axios.all([url1, url2]).then(response => {\n        let selectedId = editParam.primaryKeyValue; // const optionsQBCategoryMap = constructOptionList(response[0].data.qbcategory || [], \"nchecklistqbcategorycode\", \"schecklistqbcategoryname\", undefined, undefined, true);\n        // const optionsChecklistComponentMap = constructOptionList(response[0].data.checklistqb || [], \"nchecklistqbcode\", \"squestion\", undefined, undefined, true);\n        // const availableQBCategory = optionsQBCategoryMap.get(\"OptionList\");\n        // const availableQB = optionsChecklistComponentMap.get(\"OptionList\");\n\n        dispatch({\n          type: DEFAULT_RETURN,\n          payload: {\n            masterData: editParam.masterData,\n            openChildModal: true,\n            selectedRecord: response[1].data,\n            operation: \"update\",\n            id: editParam.screenName.toLowerCase(),\n            // availableQBCategory ,\n            // availableQB ,\n            QBCategory: {\n              \"value\": response[1].data[\"nchecklistqbcategorycode\"],\n              \"label\": response[1].data[\"schecklistqbcategoryname\"]\n            },\n            QB: {\n              \"value\": response[1].data[\"nchecklistqbcode\"],\n              \"label\": response[1].data[\"squestion\"]\n            },\n            ncontrolcode: editParam.ncontrolCode,\n            loading: false,\n            selectedId\n          }\n        });\n      }).catch(error => {\n        dispatch({\n          type: DEFAULT_RETURN,\n          payload: {\n            loading: false\n          }\n        });\n\n        if (error.response.status === 500) {\n          toast.error(error.message);\n        } else {\n          toast.warn(error.response.data);\n        }\n      });\n    }\n  };\n}","map":{"version":3,"sources":["D:/LIMSWFH/LIMSPOSTGRESQL/QuaLISWeb/src/actions/ChecklistAction.js"],"names":["rsapi","DEFAULT_RETURN","constructOptionList","sortData","rearrangeDateFormat","toast","Axios","initRequest","getChecklistVersion","checklist","userInfo","masterData","dispatch","inputData","nchecklistcode","userinfo","post","then","response","data","selectedchecklist","type","payload","loading","catch","error","status","message","warn","getVersionQB","versionObject","version","selectedversion","nchecklistversioncode","url2","all","checklistversionqb","viewVersionTemplate","ncontrolCode","selectedRecord","lsteditedQB","map","nchecklistversionqbcode","nchecklistqbcode","sdefaultvalue","nchecklistcomponentcode","undefined","push","openTemplateModal","templateData","ncontrolcode","onSaveTemplate","listChecklistVersionTemplate","editedQB","qbcode","checklistversiontemplate","showChecklistAddScreen","id","modalName","optionsQBCategoryMap","qbcategory","availableQBCategory","get","listQbObj","listQb","optionsChecklistComponentMap","cat","checklistqb","label","operation","QBCategory","QB","availableQB","fetchChecklistRecordByID","editParam","screenName","toLowerCase","primaryKeyField","primaryKeyValue","url1","selectedId","openChildModal"],"mappings":"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","sourcesContent":["import rsapi from '../rsapi';\r\nimport { DEFAULT_RETURN } from './LoginTypes';\r\nimport { constructOptionList, sortData,rearrangeDateFormat } from '../components/CommonScript'\r\nimport { toast } from 'react-toastify';\r\nimport Axios from 'axios';\r\nimport { initRequest } from './LoginAction';\r\n\r\n\r\nexport function getChecklistVersion(checklist, userInfo, masterData) {\r\n\r\n    return function (dispatch) {\r\n        const inputData = { \"nchecklistcode\": checklist.nchecklistcode, userinfo: userInfo }\r\n        dispatch(initRequest(true));\r\n        rsapi.post(\"checklist/getChecklistVersion\", inputData)\r\n            .then(response => {\r\n\r\n                masterData = {\r\n                    ...masterData,\r\n                    ...response.data,\r\n                    selectedchecklist: checklist,\r\n                }\r\n                sortData(masterData)\r\n                dispatch({\r\n                    type: DEFAULT_RETURN, payload: { masterData, loading: false }\r\n                })\r\n            })\r\n            .catch(error => {\r\n                dispatch({ type: DEFAULT_RETURN, payload: { loading: false } })\r\n                if (error.response.status === 500) {\r\n                    toast.error(error.message);\r\n                }\r\n                else {\r\n                    toast.warn(error.response.data);\r\n                }\r\n            })\r\n    }\r\n}\r\n\r\nexport function getVersionQB(versionObject) {\r\n    let { version, masterData, userInfo } = versionObject\r\n    return function (dispatch) {\r\n        if (!(masterData.selectedversion.nchecklistversioncode === version.nchecklistversioncode)) {\r\n            const inputData = { nchecklistversioncode: version.nchecklistversioncode, userinfo: userInfo }\r\n            //const url1=rsapi.post('checklist/getActiveChecklistVersionById',inputData)\r\n            const url2 = rsapi.post('checklist/getChecklistVersionQB', inputData)\r\n            dispatch(initRequest(true));\r\n            Axios.all([url2])\r\n                .then(response => {\r\n                    masterData = {\r\n                        ...masterData,\r\n                        checklistversionqb: response[0].data.checklistversionqb,\r\n                        selectedversion: version\r\n                    }\r\n                    sortData(masterData)\r\n                    dispatch({\r\n                        type: DEFAULT_RETURN, payload: {\r\n                            masterData,\r\n                            loading: false\r\n                        }\r\n                    });\r\n                })\r\n                .catch(error => {\r\n                    dispatch({ type: DEFAULT_RETURN, payload: { loading: false } })\r\n                    if (error.response.status === 500) {\r\n                        toast.error(error.message);\r\n                    }\r\n                    else {\r\n                        toast.warn(error.response.data);\r\n                    }\r\n                })\r\n        } else {\r\n            dispatch({\r\n                type: DEFAULT_RETURN, payload: { masterData, loading: false }\r\n            })\r\n        }\r\n    }\r\n}\r\n\r\nexport function viewVersionTemplate(version, userInfo, ncontrolCode) {\r\n\r\n    return function (dispatch) {\r\n\r\n        dispatch(initRequest(true));\r\n        rsapi.post(\"checklist/viewTemplate\", {\r\n            \"nchecklistversioncode\": version.nchecklistversioncode, \"flag\": 1, \"ntransactionresultcode\": 1\r\n            , \"userinfo\": userInfo\r\n        })\r\n            .then(response => {\r\n\r\n                let selectedRecord = {};\r\n                let lsteditedQB = [];\r\n\r\n                response.data.map(checklist => {\r\n                    selectedRecord[checklist.nchecklistversionqbcode] = {\r\n                        nchecklistqbcode: checklist.nchecklistqbcode,\r\n                        nchecklistversioncode: checklist.nchecklistversioncode,\r\n                        nchecklistversionqbcode: checklist.nchecklistversionqbcode,\r\n                        sdefaultvalue: checklist.nchecklistcomponentcode === 7  ? rearrangeDateFormat(userInfo,checklist.sdefaultvalue) :checklist.sdefaultvalue === 'null' ? undefined : checklist.sdefaultvalue ,\r\n                     \r\n                    }\r\n                    lsteditedQB.push(checklist.nchecklistversionqbcode);\r\n                    return null;\r\n                });\r\n                response.data.map(checklist => {\r\n                    selectedRecord['jsondata'] = {\r\n                        ...selectedRecord['jsondata'],\r\n                        [checklist.nchecklistversionqbcode]:checklist.nchecklistcomponentcode ===7 ? rearrangeDateFormat(userInfo,checklist.sdefaultvalue) :checklist.sdefaultvalue === 'null' ? undefined : checklist.sdefaultvalue \r\n                    }\r\n                    return null;\r\n                });\r\n                selectedRecord[\"editedQB\"] = lsteditedQB;\r\n\r\n\r\n                dispatch({\r\n                    type: DEFAULT_RETURN, payload: {\r\n                        openTemplateModal: true,\r\n                        templateData: response.data,\r\n                        loading: false,\r\n                        ncontrolcode:ncontrolCode,\r\n                        selectedRecord: selectedRecord\r\n                    }\r\n                })\r\n            })\r\n            .catch(error => {\r\n                dispatch({ type: DEFAULT_RETURN, payload: { loading: false } })\r\n                if (error.response.status === 500) {\r\n                    toast.error(error.message);\r\n                }\r\n                else {\r\n                    toast.warn(error.response.data);\r\n                }\r\n            })\r\n    }\r\n}\r\n// export function filterChecklistColumnData(filterValue, masterData, userInfo) {\r\n//     return function(dispatch){\r\n//         let checklistCode = 0;   \r\n//         let searchedData = undefined;\r\n//         if (filterValue === \"\"){\r\n//             checklistCode = masterData[\"checklist\"][0].nchecklistcode;\r\n//         } \r\n//         else{\r\n\r\n//             searchedData = searchData(filterValue, masterData[\"checklist\"]);\r\n\r\n//             if (searchedData.length > 0){\r\n//                 checklistCode = searchedData[0].nchecklistcode; \r\n//             }\r\n\r\n//         }\r\n//         if (checklistCode !== 0){\r\n\r\n//             dispatch(initRequest(true));\r\n//             rsapi.post(\"checklist/getChecklistVersion\", {nchecklistcode:checklistCode,userinfo:userInfo})\r\n//             .then(response=>{                \r\n//                 masterData[\"checklistversion\"] = sortData(response.data[\"checklistversion\"]);\r\n//                 masterData[\"selectedversion\"] = response.data[\"selectedversion\"];\r\n//                 masterData[\"checklistversionqb\"] =  sortData(response.data[\"checklistversionqb\"]);\r\n//                 masterData[\"selectedchecklist\"] =searchedData?searchedData[0]:masterData[\"checklist\"][0];\r\n//                 masterData[\"searchedData\"] = searchedData;\r\n//                 dispatch({type: DEFAULT_RETURN, payload:{masterData,   loading:false}});\r\n//             })\r\n//             .catch(error=>{\r\n//                 dispatch({type: DEFAULT_RETURN, payload: {loading:false}})\r\n//                 if (error.response.status === 500){\r\n//                     toast.error(error.message);\r\n//                 } \r\n//                 else{               \r\n//                     toast.warn(error.response.data);\r\n//                 }  \r\n//             }) \r\n\r\n//         }else{\r\n//             masterData[\"checklistversion\"] = [];\r\n//             masterData[\"selectedversion\"] = [];\r\n//             masterData[\"checklistversionqb\"] = [];\r\n//             masterData[\"selectedchecklist\"] =[];\r\n//             masterData[\"searchedData\"] = [];\r\n//             dispatch({type: DEFAULT_RETURN, payload:{masterData,   loading:false}});\r\n\r\n//         }\r\n//     }\r\n// }   \r\n\r\nexport function onSaveTemplate(selectedRecord, userInfo) {\r\n\r\n    return function (dispatch) {\r\n\r\n        \r\n        let listChecklistVersionTemplate = [];\r\n        if (selectedRecord && selectedRecord.editedQB) {\r\n            selectedRecord.editedQB.map(qbcode =>\r\n                listChecklistVersionTemplate.push(selectedRecord[qbcode] && selectedRecord[qbcode].sdefaultvalue !=null ? selectedRecord[qbcode]:\r\n                     selectedRecord[qbcode]={\r\n                        \"nchecklistqbcode\":selectedRecord[qbcode].nchecklistqbcode,\r\n                        \"nchecklistversioncode\":selectedRecord[qbcode].nchecklistversioncode,\r\n                        \"nchecklistversionqbcode\":selectedRecord[qbcode].nchecklistversionqbcode,\r\n                        \"sdefaultvalue\":\"\"\r\n\r\n                     }  ))\r\n\r\n              //  listChecklistVersionTemplate.push(selectedRecord[qbcode]))\r\n            dispatch(initRequest(true));\r\n            rsapi.post(\"checklist/createUpdateChecklistVersionTemplate\",\r\n                { checklistversiontemplate: listChecklistVersionTemplate, \"userinfo\": userInfo })\r\n\r\n                .then(response => {\r\n\r\n                    dispatch({\r\n                        type: DEFAULT_RETURN, payload: {\r\n                            selectedRecord: {},\r\n                            templateData: undefined,\r\n                            openTemplateModal: false,\r\n                            loading: false\r\n                        }\r\n                    })\r\n                })\r\n                .catch(error => {\r\n                    dispatch({ type: DEFAULT_RETURN, payload: { loading: false } })\r\n                    if (error.response.status === 500) {\r\n                        toast.error(error.message);\r\n                    }\r\n                    else {\r\n                        toast.warn(error.response.data);\r\n                    }\r\n                })\r\n        } else {\r\n\r\n            dispatch({\r\n                type: DEFAULT_RETURN, payload: {\r\n                    openTemplateModal: false, selectedRecord: {},templateData: undefined, loading: false\r\n                }\r\n            })\r\n        }\r\n    }\r\n}\r\n\r\n\r\nexport function showChecklistAddScreen(nchecklistversioncode, id, ncontrolcode, userInfo) {\r\n    return function (dispatch) {\r\n        let modalName = (id === 'checklist') ? 'openModal' : 'openChildModal'\r\n        if (id === \"checklistversionqb\") {\r\n            dispatch(initRequest(true));\r\n            rsapi.post(\"checklist/getVersionQBAddEditData\",\r\n                { \"nchecklistversioncode\": nchecklistversioncode, \"userinfo\": userInfo })\r\n                .then(response => {\r\n                    const optionsQBCategoryMap = constructOptionList(response.data.qbcategory || [], \"nchecklistqbcategorycode\", \"schecklistqbcategoryname\", undefined, undefined, true);\r\n                    const availableQBCategory = optionsQBCategoryMap.get(\"OptionList\");\r\n                    let listQbObj={listQb:{}};\r\n                    let optionsChecklistComponentMap;\r\n                    availableQBCategory.map(cat=>\r\n                        {\r\n                        optionsChecklistComponentMap = constructOptionList(response.data.checklistqb[cat.label] || [], \"nchecklistqbcode\", \"squestion\", undefined, undefined, true);\r\n                        listQbObj={listQb:{...listQbObj.listQb,[cat.label]: optionsChecklistComponentMap.get(\"OptionList\")}};\r\n                        return null;\r\n                        }\r\n                    )\r\n                    \r\n                    dispatch({\r\n                        type: DEFAULT_RETURN, payload: {\r\n                            [modalName]: true,\r\n                            selectedRecord: {},\r\n                            operation: \"create\",\r\n                            id, \r\n                            QBCategory: undefined, \r\n                            QB: undefined,\r\n                            availableQBCategory,\r\n                            listQb:listQbObj.listQb,\r\n                            availableQB: [],\r\n                            ncontrolcode, loading: false\r\n                        }\r\n                    })\r\n                })\r\n                .catch(error => {\r\n                    dispatch({ type: DEFAULT_RETURN, payload: { loading: false } })\r\n                    if (error.response.status === 500) {\r\n                        toast.error(error.message);\r\n                    }\r\n                    else {\r\n                        toast.warn(error.response.data);\r\n                    }\r\n                })\r\n        } else {\r\n            dispatch({\r\n                type: DEFAULT_RETURN, payload: {\r\n                    [modalName]: true,\r\n                    selectedRecord: {},\r\n                    operation: \"create\",\r\n                    id,\r\n                    ncontrolcode,\r\n                    loading: false\r\n                }\r\n            })\r\n        }\r\n    }\r\n}\r\n\r\nexport function fetchChecklistRecordByID(editParam) {\r\n    return function (dispatch) {\r\n\r\n        if (editParam.screenName.toLowerCase() === \"checklist\" || editParam.screenName.toLowerCase() === \"checklistversion\") {\r\n            let modalName = editParam.screenName.toLowerCase() === \"checklist\" ? 'openModal' : 'openChildModal'\r\n            dispatch(initRequest(true));\r\n            rsapi.post(\"checklist/getActive\" + editParam.screenName + \"ById\",\r\n                { [editParam.primaryKeyField]: editParam.primaryKeyValue, \"userinfo\": editParam.userInfo })\r\n\r\n                .then(response => {\r\n                    dispatch({\r\n                        type: DEFAULT_RETURN, payload: {\r\n                            [modalName]: true,\r\n                            selectedRecord: response.data,\r\n                            operation: editParam.operation,\r\n                            id: editParam.screenName.toLowerCase(),\r\n                            ncontrolcode: editParam.ncontrolCode,\r\n                            masterData: editParam.masterData,\r\n                            loading: false\r\n\r\n                        }\r\n                    })\r\n                })\r\n                .catch(error => {\r\n                    dispatch({ type: DEFAULT_RETURN, payload: { loading: false } })\r\n                    if (error.response.status === 500) {\r\n                        toast.error(error.message);\r\n                    }\r\n                    else {\r\n                        toast.warn(error.response.data);\r\n                    }\r\n                })\r\n        } else {\r\n            const url1 = rsapi.post(\"checklist/getVersionQBAddEditData\",\r\n                { \"nchecklistversioncode\": editParam.masterData.selectedversion.nchecklistversioncode, \"userinfo\": editParam.userInfo })\r\n            const url2 = rsapi.post(\"checklist/getActive\" + editParam.screenName + \"ById\",\r\n                { [editParam.primaryKeyField]: editParam.primaryKeyValue, \"userinfo\": editParam.userInfo })\r\n            dispatch(initRequest(true));\r\n            Axios.all([url1, url2])\r\n                .then(response => {\r\n                    let selectedId = editParam.primaryKeyValue\r\n                    // const optionsQBCategoryMap = constructOptionList(response[0].data.qbcategory || [], \"nchecklistqbcategorycode\", \"schecklistqbcategoryname\", undefined, undefined, true);\r\n                    // const optionsChecklistComponentMap = constructOptionList(response[0].data.checklistqb || [], \"nchecklistqbcode\", \"squestion\", undefined, undefined, true);\r\n                    // const availableQBCategory = optionsQBCategoryMap.get(\"OptionList\");\r\n                    // const availableQB = optionsChecklistComponentMap.get(\"OptionList\");\r\n                    dispatch({\r\n                        type: DEFAULT_RETURN, payload: {\r\n                            masterData: editParam.masterData,\r\n                            openChildModal: true,\r\n                            selectedRecord: response[1].data,\r\n                            operation: \"update\",\r\n                            id: editParam.screenName.toLowerCase(),\r\n                            // availableQBCategory ,\r\n                            // availableQB ,\r\n                            QBCategory: { \"value\": response[1].data[\"nchecklistqbcategorycode\"], \"label\": response[1].data[\"schecklistqbcategoryname\"] },\r\n                            QB: { \"value\": response[1].data[\"nchecklistqbcode\"], \"label\": response[1].data[\"squestion\"] },\r\n                            ncontrolcode: editParam.ncontrolCode, loading: false, selectedId\r\n                        }\r\n                    })\r\n                })\r\n                .catch(error => {\r\n                    dispatch({ type: DEFAULT_RETURN, payload: { loading: false } })\r\n                    if (error.response.status === 500) {\r\n                        toast.error(error.message);\r\n                    }\r\n                    else {\r\n                        toast.warn(error.response.data);\r\n                    }\r\n                })\r\n        }\r\n    }\r\n}"]},"metadata":{},"sourceType":"module"}