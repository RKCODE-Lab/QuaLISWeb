{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/extends\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nimport React, { Component } from \"react\";\nimport { Utils } from \"@react-awesome-query-builder/core\";\nimport { connect } from \"react-redux\";\nimport { logger } from \"../../utils/stuff\";\nimport context from \"../../stores/context\";\nimport * as constants from \"../../stores/constants\";\nimport PropTypes from \"prop-types\";\nimport * as actions from \"../../actions\";\nimport { pureShouldComponentUpdate, useOnPropsChanged, isUsingLegacyReactDomRender } from \"../../utils/reactUtils\";\nvar clone = Utils.clone;\nvar getFlatTree = Utils.TreeUtils.getFlatTree;\nvar _isReorderingTree = false;\n\nvar createSortableContainer = function createSortableContainer(Builder) {\n  var _class;\n\n  var CanMoveFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  return _class = /*#__PURE__*/function (_Component) {\n    _inherits(SortableContainer, _Component);\n\n    var _super = _createSuper(SortableContainer);\n\n    function SortableContainer(props) {\n      var _this;\n\n      _classCallCheck(this, SortableContainer);\n\n      _this = _super.call(this, props);\n\n      _this._getEventTarget = function (e, dragStart) {\n        return e && e.__mocked_window || document.body || window;\n      };\n\n      _this.onDragStart = function (id, dom, e) {\n        var treeEl = dom.closest(\".query-builder\");\n\n        if (_this._isUsingLegacyReactDomRender === undefined) {\n          _this._isUsingLegacyReactDomRender = isUsingLegacyReactDomRender(treeEl);\n        }\n\n        document.body.classList.add(\"qb-dragging\");\n        treeEl.classList.add(\"qb-dragging\");\n        var treeElContainer = treeEl.closest(\".query-builder-container\") || treeEl;\n        treeElContainer = _this._getScrollParent(treeElContainer) || document.body;\n        var scrollTop = treeElContainer.scrollTop;\n\n        var _dragEl = _this._getDraggableNodeEl(treeEl);\n\n        var _plhEl = _this._getPlaceholderNodeEl(treeEl);\n\n        var tmpAllGroups = treeEl.querySelectorAll(\".group--children\");\n        var anyGroup = tmpAllGroups.length ? tmpAllGroups[0] : null;\n        var groupPadding;\n\n        if (anyGroup) {\n          groupPadding = window.getComputedStyle(anyGroup, null).getPropertyValue(\"padding-left\");\n          groupPadding = parseInt(groupPadding);\n        }\n\n        var dragging = {\n          id: id,\n          x: dom.offsetLeft,\n          y: dom.offsetTop,\n          w: dom.offsetWidth,\n          h: dom.offsetHeight,\n          itemInfo: _this.tree.items[id],\n          paddingLeft: groupPadding\n        };\n        var dragStart = {\n          id: id,\n          x: dom.offsetLeft,\n          y: dom.offsetTop,\n          scrollTop: scrollTop,\n          clientX: e.clientX,\n          clientY: e.clientY,\n          itemInfo: clone(_this.tree.items[id]),\n          treeEl: treeEl,\n          treeElContainer: treeElContainer\n        };\n        var mousePos = {\n          clientX: e.clientX,\n          clientY: e.clientY\n        };\n\n        var target = _this._getEventTarget(e, dragStart);\n\n        _this.eventTarget = target;\n        target.addEventListener(\"mousemove\", _this.onDrag);\n        target.addEventListener(\"mouseup\", _this.onDragEnd);\n\n        _this.props.setDragStart(dragStart, dragging, mousePos);\n      };\n\n      _this.onDrag = function (e) {\n        var doHandleDrag = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        var dragging = Object.assign({}, _this.props.dragging);\n        var startDragging = _this.props.dragStart;\n        var paddingLeft = dragging.paddingLeft; //this.props.paddingLeft;\n\n        var treeElContainer = startDragging.treeElContainer;\n        var scrollTop = treeElContainer.scrollTop;\n        dragging.itemInfo = _this.tree.items[dragging.id];\n\n        if (!dragging.itemInfo) {\n          return;\n        }\n\n        var mousePos = {\n          clientX: e.clientX,\n          clientY: e.clientY\n        };\n        var startMousePos = {\n          clientX: startDragging.clientX,\n          clientY: startDragging.clientY\n        };\n\n        if (e.__mock_dom) {\n          var treeEl = startDragging.treeEl;\n\n          var dragEl = _this._getDraggableNodeEl(treeEl);\n\n          var plhEl = _this._getPlaceholderNodeEl(treeEl);\n\n          e.__mock_dom({\n            treeEl: treeEl,\n            dragEl: dragEl,\n            plhEl: plhEl\n          });\n        } //first init plX/plY\n\n\n        if (!startDragging.plX) {\n          var _treeEl = startDragging.treeEl;\n\n          var _plhEl2 = _this._getPlaceholderNodeEl(_treeEl);\n\n          if (_plhEl2) {\n            startDragging.plX = _plhEl2.getBoundingClientRect().left + window.scrollX;\n            startDragging.plY = _plhEl2.getBoundingClientRect().top + window.scrollY;\n          }\n        }\n\n        var startX = startDragging.x;\n        var startY = startDragging.y;\n        var startClientX = startDragging.clientX;\n        var startClientY = startDragging.clientY;\n        var startScrollTop = startDragging.scrollTop;\n        var pos = {\n          x: startX + (e.clientX - startClientX),\n          y: startY + (e.clientY - startClientY) + (scrollTop - startScrollTop)\n        };\n        dragging.x = pos.x;\n        dragging.y = pos.y;\n        dragging.paddingLeft = paddingLeft;\n        dragging.mousePos = mousePos;\n        dragging.startMousePos = startMousePos;\n\n        _this.props.setDragProgress(mousePos, dragging);\n\n        var moved = doHandleDrag ? _this.handleDrag(dragging, e, CanMoveFn) : false;\n\n        if (!moved) {\n          if (e.preventDefault) e.preventDefault();\n        }\n      };\n\n      _this.onDragEnd = function () {\n        var treeEl = _this.props.dragStart.treeEl;\n\n        _this.props.setDragEnd();\n\n        treeEl.classList.remove(\"qb-dragging\");\n        document.body.classList.remove(\"qb-dragging\");\n        _this._cacheEls = {};\n\n        var target = _this.eventTarget || _this._getEventTarget();\n\n        target.removeEventListener(\"mousemove\", _this.onDrag);\n        target.removeEventListener(\"mouseup\", _this.onDragEnd);\n      };\n\n      useOnPropsChanged(_assertThisInitialized(_this));\n\n      _this.onPropsChanged(props);\n\n      return _this;\n    }\n\n    _createClass(SortableContainer, [{\n      key: \"onPropsChanged\",\n      value: function onPropsChanged(nextProps) {\n        this.tree = getFlatTree(nextProps.tree);\n      }\n    }, {\n      key: \"shouldComponentUpdate\",\n      value: function shouldComponentUpdate(nextProps, nextState) {\n        var prevProps = this.props;\n        var prevState = this.state;\n        var should = pureShouldComponentUpdate(this)(nextProps, nextState);\n\n        if (should) {\n          if (prevState == nextState && prevProps != nextProps) {\n            var chs = [];\n\n            for (var k in nextProps) {\n              var changed = nextProps[k] != prevProps[k];\n\n              if (changed) {\n                //don't render <Builder> on dragging - appropriate redux-connected components will do it\n                if (k != \"dragging\" && k != \"mousePos\") chs.push(k);\n              }\n            }\n\n            if (!chs.length) should = false;\n          }\n        }\n\n        return should;\n      }\n    }, {\n      key: \"componentDidUpdate\",\n      value: function componentDidUpdate(_prevProps, _prevState) {\n        var dragging = this.props.dragging;\n        var startDragging = this.props.dragStart;\n        _isReorderingTree = false;\n\n        if (startDragging && startDragging.id) {\n          dragging.itemInfo = this.tree.items[dragging.id];\n\n          if (dragging.itemInfo) {\n            if (dragging.itemInfo.index != startDragging.itemInfo.index || dragging.itemInfo.parent != startDragging.itemInfo.parent) {\n              var treeEl = startDragging.treeEl;\n              var treeElContainer = startDragging.treeElContainer;\n\n              var plhEl = this._getPlaceholderNodeEl(treeEl, true);\n\n              if (plhEl) {\n                var plX = plhEl.getBoundingClientRect().left + window.scrollX;\n                var plY = plhEl.getBoundingClientRect().top + window.scrollY;\n                var oldPlX = startDragging.plX;\n                var oldPlY = startDragging.plY;\n                var scrollTop = treeElContainer.scrollTop;\n                startDragging.plX = plX;\n                startDragging.plY = plY;\n                startDragging.itemInfo = clone(dragging.itemInfo);\n                startDragging.y = plhEl.offsetTop;\n                startDragging.x = plhEl.offsetLeft;\n                startDragging.clientY += plY - oldPlY;\n                startDragging.clientX += plX - oldPlX;\n                if (treeElContainer != document.body) startDragging.scrollTop = scrollTop;\n                this.onDrag(this.props.mousePos, false);\n              }\n            }\n          }\n        }\n      }\n    }, {\n      key: \"_getNodeElById\",\n      value: function _getNodeElById(treeEl, indexId) {\n        var ignoreCache = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        if (indexId == null) return null;\n        if (!this._cacheEls) this._cacheEls = {};\n        var el = this._cacheEls[indexId];\n        if (el && document.contains(el) && !ignoreCache) return el;\n        el = treeEl.querySelector('.group-or-rule-container[data-id=\"' + indexId + '\"]');\n        this._cacheEls[indexId] = el;\n        return el;\n      }\n    }, {\n      key: \"_getDraggableNodeEl\",\n      value: function _getDraggableNodeEl(treeEl) {\n        var ignoreCache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        if (!this._cacheEls) this._cacheEls = {};\n        var el = this._cacheEls[\"draggable\"];\n        if (el && document.contains(el) && !ignoreCache) return el;\n        var els = treeEl.getElementsByClassName(\"qb-draggable\");\n        el = els.length ? els[0] : null;\n        this._cacheEls[\"draggable\"] = el;\n        return el;\n      }\n    }, {\n      key: \"_getPlaceholderNodeEl\",\n      value: function _getPlaceholderNodeEl(treeEl) {\n        var ignoreCache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        if (!this._cacheEls) this._cacheEls = {};\n        var el = this._cacheEls[\"placeholder\"];\n        if (el && document.contains(el) && !ignoreCache) return el;\n        var els = treeEl.getElementsByClassName(\"qb-placeholder\");\n        el = els.length ? els[0] : null;\n        this._cacheEls[\"placeholder\"] = el;\n        return el;\n      }\n    }, {\n      key: \"_isScrollable\",\n      value: function _isScrollable(node) {\n        var overflowY = window.getComputedStyle(node)[\"overflow-y\"];\n        return (overflowY === \"scroll\" || overflowY === \"auto\") && node.scrollHeight > node.offsetHeight;\n      }\n    }, {\n      key: \"_getScrollParent\",\n      value: function _getScrollParent(node) {\n        if (node == null) return null;\n\n        if (node === document.body || this._isScrollable(node)) {\n          return node;\n        } else {\n          return this._getScrollParent(node.parentNode);\n        }\n      }\n    }, {\n      key: \"handleDrag\",\n      value: function handleDrag(dragInfo, e, canMoveFn) {\n        var _this2 = this;\n\n        var canMoveBeforeAfterGroup = true;\n        var itemInfo = dragInfo.itemInfo;\n        var paddingLeft = dragInfo.paddingLeft;\n        var moveInfo = null;\n        var treeEl = this.props.dragStart.treeEl;\n        var dragId = dragInfo.id;\n\n        var dragEl = this._getDraggableNodeEl(treeEl);\n\n        var plhEl = this._getPlaceholderNodeEl(treeEl);\n\n        var dragRect, plhRect, hovRect, treeRect;\n\n        if (dragEl && plhEl) {\n          dragRect = dragEl.getBoundingClientRect();\n          plhRect = plhEl.getBoundingClientRect();\n\n          if (!plhRect.width) {\n            return;\n          }\n\n          var dragDirs = {\n            hrz: 0,\n            vrt: 0\n          };\n          if (dragRect.top < plhRect.top) dragDirs.vrt = -1; //up\n          else if (dragRect.bottom > plhRect.bottom) dragDirs.vrt = +1; //down\n\n          if (dragRect.left > plhRect.left) dragDirs.hrz = +1; //right\n          else if (dragRect.left < plhRect.left) dragDirs.hrz = -1; //left\n\n          treeRect = treeEl.getBoundingClientRect();\n          var trgCoord = {\n            x: treeRect.left + (treeRect.right - treeRect.left) / 2,\n            y: dragDirs.vrt >= 0 ? dragRect.bottom : dragRect.top\n          };\n          var hovCNodeEl;\n\n          if (e.__mocked_hov_container) {\n            hovCNodeEl = e.__mocked_hov_container;\n          } else {\n            var hovNodeEl = document.elementFromPoint(trgCoord.x, trgCoord.y - 1);\n            hovCNodeEl = hovNodeEl ? hovNodeEl.closest(\".group-or-rule-container\") : null;\n\n            if (!hovCNodeEl && hovNodeEl && hovNodeEl.classList.contains(\"query-builder-container\")) {\n              var _hovNodeEl$firstChild; // fix 2022-01-24 - get root .group-or-rule-container\n\n\n              var rootGroupContainer = hovNodeEl === null || hovNodeEl === void 0 ? void 0 : (_hovNodeEl$firstChild = hovNodeEl.firstChild) === null || _hovNodeEl$firstChild === void 0 ? void 0 : _hovNodeEl$firstChild.firstChild;\n\n              if (rootGroupContainer && rootGroupContainer.classList.contains(\"group-or-rule-container\")) {\n                hovCNodeEl = rootGroupContainer;\n              }\n            }\n          }\n\n          if (!hovCNodeEl) {\n            logger.log(\"out of tree bounds!\");\n          } else {\n            var isGroup = hovCNodeEl.classList.contains(\"group-container\");\n            var hovNodeId = hovCNodeEl.getAttribute(\"data-id\");\n            var hovEl = hovCNodeEl;\n            var doAppend = false;\n            var doPrepend = false;\n\n            if (hovEl) {\n              hovRect = hovEl.getBoundingClientRect();\n              var hovHeight = hovRect.bottom - hovRect.top;\n              var hovII = this.tree.items[hovNodeId];\n              var trgRect = null,\n                  trgEl = null,\n                  trgII = null,\n                  altII = null; //for canMoveBeforeAfterGroup\n\n              if (dragDirs.vrt == 0) {\n                trgII = itemInfo;\n                trgEl = plhEl;\n                if (trgEl) trgRect = trgEl.getBoundingClientRect();\n              } else {\n                if (isGroup) {\n                  if (dragDirs.vrt > 0) {\n                    //down\n                    //take group header (for prepend only)\n                    var hovInnerEl = hovCNodeEl.getElementsByClassName(\"group--header\");\n                    var hovEl2 = hovInnerEl.length ? hovInnerEl[0] : null;\n\n                    if (hovEl2) {\n                      var hovRect2 = hovEl2.getBoundingClientRect();\n                      var hovHeight2 = hovRect2.bottom - hovRect2.top;\n                      var isOverHover = dragRect.bottom - hovRect2.top > hovHeight2 * 3 / 4;\n\n                      if (isOverHover && hovII.top > dragInfo.itemInfo.top) {\n                        trgII = hovII;\n                        trgRect = hovRect2;\n                        trgEl = hovEl2;\n                        doPrepend = true;\n                      }\n                    }\n                  } else if (dragDirs.vrt < 0) {\n                    //up\n                    if (hovII.lev >= itemInfo.lev) {\n                      //take whole group\n                      var isClimbToHover = hovRect.bottom - dragRect.top >= 2;\n\n                      if (isClimbToHover && hovII.top < dragInfo.itemInfo.top) {\n                        trgII = hovII;\n                        trgRect = hovRect;\n                        trgEl = hovEl;\n                        doAppend = true;\n                      }\n                    }\n                  }\n\n                  if (!doPrepend && !doAppend || canMoveBeforeAfterGroup) {\n                    //take whole group and check if we can move before/after group\n                    var _isOverHover = dragDirs.vrt < 0 //up\n                    ? hovRect.bottom - dragRect.top > hovHeight - 5 : dragRect.bottom - hovRect.top > hovHeight - 5;\n\n                    if (_isOverHover) {\n                      if (!doPrepend && !doAppend) {\n                        trgII = hovII;\n                        trgRect = hovRect;\n                        trgEl = hovEl;\n                      }\n\n                      if (canMoveBeforeAfterGroup) {\n                        altII = hovII;\n                      }\n                    }\n                  }\n                } else {\n                  //check if we can move before/after group\n                  var _isOverHover2 = dragDirs.vrt < 0 //up\n                  ? hovRect.bottom - dragRect.top > hovHeight / 2 : dragRect.bottom - hovRect.top > hovHeight / 2;\n\n                  if (_isOverHover2) {\n                    trgII = hovII;\n                    trgRect = hovRect;\n                    trgEl = hovEl;\n                  }\n                }\n              }\n\n              var isSamePos = trgII && trgII.id == dragId;\n\n              if (trgRect) {\n                var dragLeftOffset = dragRect.left - treeRect.left;\n                var trgLeftOffset = trgRect.left - treeRect.left;\n\n                var _trgLev = trgLeftOffset / paddingLeft;\n\n                var dragLev = Math.max(0, Math.round(dragLeftOffset / paddingLeft)); //find all possible moves\n\n                var availMoves = [];\n                var altMoves = []; //alternatively can move after/before group, if can't move into it\n\n                if (isSamePos) {//do nothing\n                } else {\n                  if (isGroup) {\n                    if (doAppend) {\n                      availMoves.push([constants.PLACEMENT_APPEND, trgII, trgII.lev + 1]);\n                    } else if (doPrepend) {\n                      availMoves.push([constants.PLACEMENT_PREPEND, trgII, trgII.lev + 1]);\n                    } //alt\n\n\n                    if (canMoveBeforeAfterGroup && altII) {\n                      // fix 2022-01-24: do prepend/append instead of before/after for root\n                      var isToRoot = altII.lev == 0; // fix 2022-01-25: fix prepend/append instead of before/after for case_group\n\n                      var isToCase = altII.type == \"case_group\" && itemInfo.type != \"case_group\";\n                      var prevCaseId = altII.prev && this.tree.items[altII.prev].caseId;\n                      var nextCaseId = altII.next && this.tree.items[altII.next].caseId;\n                      if (itemInfo.caseId == prevCaseId) prevCaseId = null;\n                      if (itemInfo.caseId == nextCaseId) nextCaseId = null;\n                      var prevCase = prevCaseId && this.tree.items[prevCaseId];\n                      var nextCase = nextCaseId && this.tree.items[nextCaseId];\n\n                      if (dragDirs.vrt > 0) {\n                        //down\n                        if (isToRoot) {\n                          altMoves.push([constants.PLACEMENT_APPEND, altII, altII.lev + 1]);\n                        } else if (isToCase && nextCase) {\n                          altMoves.push([constants.PLACEMENT_PREPEND, nextCase, nextCase.lev + 1]);\n                        } else {\n                          altMoves.push([constants.PLACEMENT_AFTER, altII, altII.lev]);\n                        }\n                      } else if (dragDirs.vrt < 0) {\n                        //up\n                        if (isToRoot) {\n                          altMoves.push([constants.PLACEMENT_PREPEND, altII, altII.lev + 1]);\n                        } else if (isToCase && prevCase) {\n                          altMoves.push([constants.PLACEMENT_APPEND, prevCase, prevCase.lev + 1]);\n                        } else {\n                          altMoves.push([constants.PLACEMENT_BEFORE, altII, altII.lev]);\n                        }\n                      }\n                    }\n                  }\n\n                  if (!doAppend && !doPrepend) {\n                    if (dragDirs.vrt < 0) {\n                      //up\n                      availMoves.push([constants.PLACEMENT_BEFORE, trgII, trgII.lev]);\n                    } else if (dragDirs.vrt > 0) {\n                      //down\n                      availMoves.push([constants.PLACEMENT_AFTER, trgII, trgII.lev]);\n                    }\n                  }\n                } //add case\n\n\n                var addCaseII = function addCaseII(am) {\n                  var toII = am[1];\n                  var fromCaseII = itemInfo.caseId ? _this2.tree.items[itemInfo.caseId] : null;\n                  var toCaseII = toII.caseId ? _this2.tree.items[toII.caseId] : null;\n                  return [].concat(_toConsumableArray(am), [fromCaseII, toCaseII]);\n                };\n\n                availMoves = availMoves.map(addCaseII);\n                altMoves = altMoves.map(addCaseII); //sanitize\n\n                availMoves = availMoves.filter(function (am) {\n                  var placement = am[0];\n                  var trg = am[1];\n                  if ((placement == constants.PLACEMENT_BEFORE || placement == constants.PLACEMENT_AFTER) && trg.parent == null) return false;\n                  if (trg.collapsed && (placement == constants.PLACEMENT_APPEND || placement == constants.PLACEMENT_PREPEND)) return false;\n                  var isInside = trg.id == itemInfo.id;\n\n                  if (!isInside) {\n                    var tmp = trg;\n\n                    while (tmp.parent) {\n                      tmp = _this2.tree.items[tmp.parent];\n\n                      if (tmp.id == itemInfo.id) {\n                        isInside = true;\n                        break;\n                      }\n                    }\n                  }\n\n                  return !isInside;\n                }).map(function (am) {\n                  var placement = am[0],\n                      toII = am[1],\n                      _lev = am[2],\n                      _fromCaseII = am[3],\n                      _toCaseII = am[4];\n                  var toParentII = null;\n                  if (placement == constants.PLACEMENT_APPEND || placement == constants.PLACEMENT_PREPEND) toParentII = toII;else toParentII = _this2.tree.items[toII.parent];\n                  if (toParentII && toParentII.parent == null) toParentII = null;\n                  am[5] = toParentII;\n                  return am;\n                });\n                var bestMode = null;\n                var filteredMoves = availMoves.filter(function (am) {\n                  return _this2.canMove(itemInfo, am[1], am[0], am[3], am[4], am[5], canMoveFn);\n                });\n\n                if (canMoveBeforeAfterGroup && filteredMoves.length == 0 && altMoves.length > 0) {\n                  filteredMoves = altMoves.filter(function (am) {\n                    return _this2.canMove(itemInfo, am[1], am[0], am[3], am[4], am[5], canMoveFn);\n                  });\n                }\n\n                var levs = filteredMoves.map(function (am) {\n                  return am[2];\n                });\n                var curLev = itemInfo.lev;\n                var allLevs = levs.concat(curLev);\n                var closestDragLev = null;\n                if (allLevs.indexOf(dragLev) != -1) closestDragLev = dragLev;else if (dragLev > Math.max.apply(Math, _toConsumableArray(allLevs))) closestDragLev = Math.max.apply(Math, _toConsumableArray(allLevs));else if (dragLev < Math.min.apply(Math, _toConsumableArray(allLevs))) closestDragLev = Math.min.apply(Math, _toConsumableArray(allLevs));\n                bestMode = filteredMoves.find(function (am) {\n                  return am[2] == closestDragLev;\n                });\n                if (!isSamePos && !bestMode && filteredMoves.length) bestMode = filteredMoves[0];\n                moveInfo = bestMode;\n              }\n            }\n          }\n        }\n\n        if (moveInfo) {\n          this.move(itemInfo, moveInfo[1], moveInfo[0], moveInfo[3]); // logger.log(\"DRAG-N-DROP\", JSON.stringify({\n          //   dragRect,\n          //   plhRect,\n          //   treeRect,\n          //   hovRect,\n          //   startMousePos: dragInfo.startMousePos,\n          //   mousePos: dragInfo.mousePos,\n          // }));\n\n          return true;\n        }\n\n        return false;\n      }\n    }, {\n      key: \"canMove\",\n      value: function canMove(fromII, toII, placement, fromCaseII, toCaseII, toParentII, canMoveFn) {\n        if (!fromII || !toII) return false;\n        if (fromII.id === toII.id) return false;\n        var _this$props$config$se = this.props.config.settings,\n            canRegroup = _this$props$config$se.canRegroup,\n            canRegroupCases = _this$props$config$se.canRegroupCases,\n            maxNesting = _this$props$config$se.maxNesting,\n            maxNumberOfRules = _this$props$config$se.maxNumberOfRules,\n            canLeaveEmptyCase = _this$props$config$se.canLeaveEmptyCase;\n        var newLev = toParentII ? toParentII.lev + 1 : toII.lev;\n        var isBeforeAfter = placement == constants.PLACEMENT_BEFORE || placement == constants.PLACEMENT_AFTER;\n        var isPend = placement == constants.PLACEMENT_PREPEND || placement == constants.PLACEMENT_APPEND;\n        var isLev1 = isBeforeAfter && toII.lev == 1 || isPend && toII.lev == 0;\n        var isParentChange = fromII.parent != toII.parent;\n        var isStructChange = isPend || isParentChange; // can't move `case_group` anywhere but before/after anoter `case_group`\n\n        var isForbiddenStructChange = fromII.type == \"case_group\" && !isLev1 // can't restruct `rule_group`\n        || fromII.parentType == \"rule_group\" || toII.type == \"rule_group\" || toII.parentType == \"rule_group\" // only `case_group` can be placed under `switch_group`\n        || fromII.type != \"case_group\" && toII.type == \"case_group\" && isBeforeAfter || fromII.type != \"case_group\" && toII.type == \"switch_group\" // can't move rule/group to another case\n        || !canRegroupCases && fromII.caseId != toII.caseId;\n        var isLockedChange = toII.isLocked || fromII.isLocked || toParentII && toParentII.isLocked;\n        if (maxNesting && newLev > maxNesting) return false;\n        if (isStructChange && (!canRegroup || isForbiddenStructChange || isLockedChange)) return false;\n\n        if (fromII.type != \"case_group\" && fromII.caseId != toII.caseId) {\n          var isLastFromCase = fromCaseII ? fromCaseII._height == 2 : false;\n          var newRulesInTargetCase = toCaseII ? toCaseII.leafsCount + 1 : 0;\n          if (maxNumberOfRules && newRulesInTargetCase > maxNumberOfRules) return false;\n          if (isLastFromCase && !canLeaveEmptyCase) return false;\n        }\n\n        if (fromII.type == \"case_group\" && (fromII.isDefaultCase || toII.isDefaultCase || toII.type == \"switch_group\" && placement == constants.PLACEMENT_APPEND)) {\n          // leave default case alone\n          return false;\n        }\n\n        var res = true;\n\n        if (canMoveFn) {\n          res = canMoveFn(fromII.node.toJS(), toII.node.toJS(), placement, toParentII ? toParentII.node.toJS() : null);\n        }\n\n        return res;\n      }\n    }, {\n      key: \"move\",\n      value: function move(fromII, toII, placement, toParentII) {\n        if (!this._isUsingLegacyReactDomRender) {\n          _isReorderingTree = true;\n        } //logger.log(\"move\", fromII, toII, placement, toParentII);\n\n\n        this.props.actions.moveItem(fromII.path, toII.path, placement);\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        return /*#__PURE__*/React.createElement(Builder, _extends({}, this.props, {\n          onDragStart: this.onDragStart\n        }));\n      }\n    }]);\n\n    return SortableContainer;\n  }(Component), _class.propTypes = {\n    tree: PropTypes.any.isRequired,\n    //instanceOf(Immutable.Map)\n    actions: PropTypes.object.isRequired // {moveItem: Function, ..}\n    //... see Builder\n\n  }, _class;\n};\n\nexport default (function (Builder) {\n  var CanMoveFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var ConnectedSortableContainer = connect(function (state) {\n    return {\n      dragging: state.dragging,\n      dragStart: state.dragStart,\n      mousePos: state.mousePos\n    };\n  }, {\n    setDragStart: actions.drag.setDragStart,\n    setDragProgress: actions.drag.setDragProgress,\n    setDragEnd: actions.drag.setDragEnd\n  }, null, {\n    context: context\n  })(createSortableContainer(Builder, CanMoveFn));\n  ConnectedSortableContainer.displayName = \"ConnectedSortableContainer\";\n  return ConnectedSortableContainer;\n});\nexport { _isReorderingTree };","map":{"version":3,"sources":["D:/LIMSWFH/LIMSPOSTGRESQL/QuaLISWeb/node_modules/@react-awesome-query-builder/ui/esm/components/containers/SortableContainer.js"],"names":["_extends","_toConsumableArray","_classCallCheck","_createClass","_assertThisInitialized","_inherits","_possibleConstructorReturn","_getPrototypeOf","_createSuper","Derived","hasNativeReflectConstruct","_isNativeReflectConstruct","_createSuperInternal","Super","result","NewTarget","constructor","Reflect","construct","arguments","apply","sham","Proxy","Boolean","prototype","valueOf","call","e","React","Component","Utils","connect","logger","context","constants","PropTypes","actions","pureShouldComponentUpdate","useOnPropsChanged","isUsingLegacyReactDomRender","clone","getFlatTree","TreeUtils","_isReorderingTree","createSortableContainer","Builder","_class","CanMoveFn","length","undefined","_Component","SortableContainer","_super","props","_this","_getEventTarget","dragStart","__mocked_window","document","body","window","onDragStart","id","dom","treeEl","closest","_isUsingLegacyReactDomRender","classList","add","treeElContainer","_getScrollParent","scrollTop","_dragEl","_getDraggableNodeEl","_plhEl","_getPlaceholderNodeEl","tmpAllGroups","querySelectorAll","anyGroup","groupPadding","getComputedStyle","getPropertyValue","parseInt","dragging","x","offsetLeft","y","offsetTop","w","offsetWidth","h","offsetHeight","itemInfo","tree","items","paddingLeft","clientX","clientY","mousePos","target","eventTarget","addEventListener","onDrag","onDragEnd","setDragStart","doHandleDrag","Object","assign","startDragging","startMousePos","__mock_dom","dragEl","plhEl","plX","_treeEl","_plhEl2","getBoundingClientRect","left","scrollX","plY","top","scrollY","startX","startY","startClientX","startClientY","startScrollTop","pos","setDragProgress","moved","handleDrag","preventDefault","setDragEnd","remove","_cacheEls","removeEventListener","onPropsChanged","key","value","nextProps","shouldComponentUpdate","nextState","prevProps","prevState","state","should","chs","k","changed","push","componentDidUpdate","_prevProps","_prevState","index","parent","oldPlX","oldPlY","_getNodeElById","indexId","ignoreCache","el","contains","querySelector","els","getElementsByClassName","_isScrollable","node","overflowY","scrollHeight","parentNode","dragInfo","canMoveFn","_this2","canMoveBeforeAfterGroup","moveInfo","dragId","dragRect","plhRect","hovRect","treeRect","width","dragDirs","hrz","vrt","bottom","trgCoord","right","hovCNodeEl","__mocked_hov_container","hovNodeEl","elementFromPoint","_hovNodeEl$firstChild","rootGroupContainer","firstChild","log","isGroup","hovNodeId","getAttribute","hovEl","doAppend","doPrepend","hovHeight","hovII","trgRect","trgEl","trgII","altII","hovInnerEl","hovEl2","hovRect2","hovHeight2","isOverHover","lev","isClimbToHover","_isOverHover","_isOverHover2","isSamePos","dragLeftOffset","trgLeftOffset","_trgLev","dragLev","Math","max","round","availMoves","altMoves","PLACEMENT_APPEND","PLACEMENT_PREPEND","isToRoot","isToCase","type","prevCaseId","prev","caseId","nextCaseId","next","prevCase","nextCase","PLACEMENT_AFTER","PLACEMENT_BEFORE","addCaseII","am","toII","fromCaseII","toCaseII","concat","map","filter","placement","trg","collapsed","isInside","tmp","_lev","_fromCaseII","_toCaseII","toParentII","bestMode","filteredMoves","canMove","levs","curLev","allLevs","closestDragLev","indexOf","min","find","move","fromII","_this$props$config$se","config","settings","canRegroup","canRegroupCases","maxNesting","maxNumberOfRules","canLeaveEmptyCase","newLev","isBeforeAfter","isPend","isLev1","isParentChange","isStructChange","isForbiddenStructChange","parentType","isLockedChange","isLocked","isLastFromCase","_height","newRulesInTargetCase","leafsCount","isDefaultCase","res","toJS","moveItem","path","render","createElement","propTypes","any","isRequired","object","ConnectedSortableContainer","drag","displayName"],"mappings":"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","sourcesContent":["import _extends from \"@babel/runtime/helpers/extends\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nimport React, { Component } from \"react\";\nimport { Utils } from \"@react-awesome-query-builder/core\";\nimport { connect } from \"react-redux\";\nimport { logger } from \"../../utils/stuff\";\nimport context from \"../../stores/context\";\nimport * as constants from \"../../stores/constants\";\nimport PropTypes from \"prop-types\";\nimport * as actions from \"../../actions\";\nimport { pureShouldComponentUpdate, useOnPropsChanged, isUsingLegacyReactDomRender } from \"../../utils/reactUtils\";\nvar clone = Utils.clone;\nvar getFlatTree = Utils.TreeUtils.getFlatTree;\nvar _isReorderingTree = false;\nvar createSortableContainer = function createSortableContainer(Builder) {\n  var _class;\n  var CanMoveFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  return _class = /*#__PURE__*/function (_Component) {\n    _inherits(SortableContainer, _Component);\n    var _super = _createSuper(SortableContainer);\n    function SortableContainer(props) {\n      var _this;\n      _classCallCheck(this, SortableContainer);\n      _this = _super.call(this, props);\n      _this._getEventTarget = function (e, dragStart) {\n        return e && e.__mocked_window || document.body || window;\n      };\n      _this.onDragStart = function (id, dom, e) {\n        var treeEl = dom.closest(\".query-builder\");\n        if (_this._isUsingLegacyReactDomRender === undefined) {\n          _this._isUsingLegacyReactDomRender = isUsingLegacyReactDomRender(treeEl);\n        }\n        document.body.classList.add(\"qb-dragging\");\n        treeEl.classList.add(\"qb-dragging\");\n        var treeElContainer = treeEl.closest(\".query-builder-container\") || treeEl;\n        treeElContainer = _this._getScrollParent(treeElContainer) || document.body;\n        var scrollTop = treeElContainer.scrollTop;\n        var _dragEl = _this._getDraggableNodeEl(treeEl);\n        var _plhEl = _this._getPlaceholderNodeEl(treeEl);\n        var tmpAllGroups = treeEl.querySelectorAll(\".group--children\");\n        var anyGroup = tmpAllGroups.length ? tmpAllGroups[0] : null;\n        var groupPadding;\n        if (anyGroup) {\n          groupPadding = window.getComputedStyle(anyGroup, null).getPropertyValue(\"padding-left\");\n          groupPadding = parseInt(groupPadding);\n        }\n        var dragging = {\n          id: id,\n          x: dom.offsetLeft,\n          y: dom.offsetTop,\n          w: dom.offsetWidth,\n          h: dom.offsetHeight,\n          itemInfo: _this.tree.items[id],\n          paddingLeft: groupPadding\n        };\n        var dragStart = {\n          id: id,\n          x: dom.offsetLeft,\n          y: dom.offsetTop,\n          scrollTop: scrollTop,\n          clientX: e.clientX,\n          clientY: e.clientY,\n          itemInfo: clone(_this.tree.items[id]),\n          treeEl: treeEl,\n          treeElContainer: treeElContainer\n        };\n        var mousePos = {\n          clientX: e.clientX,\n          clientY: e.clientY\n        };\n        var target = _this._getEventTarget(e, dragStart);\n        _this.eventTarget = target;\n        target.addEventListener(\"mousemove\", _this.onDrag);\n        target.addEventListener(\"mouseup\", _this.onDragEnd);\n        _this.props.setDragStart(dragStart, dragging, mousePos);\n      };\n      _this.onDrag = function (e) {\n        var doHandleDrag = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        var dragging = Object.assign({}, _this.props.dragging);\n        var startDragging = _this.props.dragStart;\n        var paddingLeft = dragging.paddingLeft; //this.props.paddingLeft;\n        var treeElContainer = startDragging.treeElContainer;\n        var scrollTop = treeElContainer.scrollTop;\n        dragging.itemInfo = _this.tree.items[dragging.id];\n        if (!dragging.itemInfo) {\n          return;\n        }\n        var mousePos = {\n          clientX: e.clientX,\n          clientY: e.clientY\n        };\n        var startMousePos = {\n          clientX: startDragging.clientX,\n          clientY: startDragging.clientY\n        };\n        if (e.__mock_dom) {\n          var treeEl = startDragging.treeEl;\n          var dragEl = _this._getDraggableNodeEl(treeEl);\n          var plhEl = _this._getPlaceholderNodeEl(treeEl);\n          e.__mock_dom({\n            treeEl: treeEl,\n            dragEl: dragEl,\n            plhEl: plhEl\n          });\n        }\n\n        //first init plX/plY\n        if (!startDragging.plX) {\n          var _treeEl = startDragging.treeEl;\n          var _plhEl2 = _this._getPlaceholderNodeEl(_treeEl);\n          if (_plhEl2) {\n            startDragging.plX = _plhEl2.getBoundingClientRect().left + window.scrollX;\n            startDragging.plY = _plhEl2.getBoundingClientRect().top + window.scrollY;\n          }\n        }\n        var startX = startDragging.x;\n        var startY = startDragging.y;\n        var startClientX = startDragging.clientX;\n        var startClientY = startDragging.clientY;\n        var startScrollTop = startDragging.scrollTop;\n        var pos = {\n          x: startX + (e.clientX - startClientX),\n          y: startY + (e.clientY - startClientY) + (scrollTop - startScrollTop)\n        };\n        dragging.x = pos.x;\n        dragging.y = pos.y;\n        dragging.paddingLeft = paddingLeft;\n        dragging.mousePos = mousePos;\n        dragging.startMousePos = startMousePos;\n        _this.props.setDragProgress(mousePos, dragging);\n        var moved = doHandleDrag ? _this.handleDrag(dragging, e, CanMoveFn) : false;\n        if (!moved) {\n          if (e.preventDefault) e.preventDefault();\n        }\n      };\n      _this.onDragEnd = function () {\n        var treeEl = _this.props.dragStart.treeEl;\n        _this.props.setDragEnd();\n        treeEl.classList.remove(\"qb-dragging\");\n        document.body.classList.remove(\"qb-dragging\");\n        _this._cacheEls = {};\n        var target = _this.eventTarget || _this._getEventTarget();\n        target.removeEventListener(\"mousemove\", _this.onDrag);\n        target.removeEventListener(\"mouseup\", _this.onDragEnd);\n      };\n      useOnPropsChanged(_assertThisInitialized(_this));\n      _this.onPropsChanged(props);\n      return _this;\n    }\n    _createClass(SortableContainer, [{\n      key: \"onPropsChanged\",\n      value: function onPropsChanged(nextProps) {\n        this.tree = getFlatTree(nextProps.tree);\n      }\n    }, {\n      key: \"shouldComponentUpdate\",\n      value: function shouldComponentUpdate(nextProps, nextState) {\n        var prevProps = this.props;\n        var prevState = this.state;\n        var should = pureShouldComponentUpdate(this)(nextProps, nextState);\n        if (should) {\n          if (prevState == nextState && prevProps != nextProps) {\n            var chs = [];\n            for (var k in nextProps) {\n              var changed = nextProps[k] != prevProps[k];\n              if (changed) {\n                //don't render <Builder> on dragging - appropriate redux-connected components will do it\n                if (k != \"dragging\" && k != \"mousePos\") chs.push(k);\n              }\n            }\n            if (!chs.length) should = false;\n          }\n        }\n        return should;\n      }\n    }, {\n      key: \"componentDidUpdate\",\n      value: function componentDidUpdate(_prevProps, _prevState) {\n        var dragging = this.props.dragging;\n        var startDragging = this.props.dragStart;\n        _isReorderingTree = false;\n        if (startDragging && startDragging.id) {\n          dragging.itemInfo = this.tree.items[dragging.id];\n          if (dragging.itemInfo) {\n            if (dragging.itemInfo.index != startDragging.itemInfo.index || dragging.itemInfo.parent != startDragging.itemInfo.parent) {\n              var treeEl = startDragging.treeEl;\n              var treeElContainer = startDragging.treeElContainer;\n              var plhEl = this._getPlaceholderNodeEl(treeEl, true);\n              if (plhEl) {\n                var plX = plhEl.getBoundingClientRect().left + window.scrollX;\n                var plY = plhEl.getBoundingClientRect().top + window.scrollY;\n                var oldPlX = startDragging.plX;\n                var oldPlY = startDragging.plY;\n                var scrollTop = treeElContainer.scrollTop;\n                startDragging.plX = plX;\n                startDragging.plY = plY;\n                startDragging.itemInfo = clone(dragging.itemInfo);\n                startDragging.y = plhEl.offsetTop;\n                startDragging.x = plhEl.offsetLeft;\n                startDragging.clientY += plY - oldPlY;\n                startDragging.clientX += plX - oldPlX;\n                if (treeElContainer != document.body) startDragging.scrollTop = scrollTop;\n                this.onDrag(this.props.mousePos, false);\n              }\n            }\n          }\n        }\n      }\n    }, {\n      key: \"_getNodeElById\",\n      value: function _getNodeElById(treeEl, indexId) {\n        var ignoreCache = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        if (indexId == null) return null;\n        if (!this._cacheEls) this._cacheEls = {};\n        var el = this._cacheEls[indexId];\n        if (el && document.contains(el) && !ignoreCache) return el;\n        el = treeEl.querySelector('.group-or-rule-container[data-id=\"' + indexId + '\"]');\n        this._cacheEls[indexId] = el;\n        return el;\n      }\n    }, {\n      key: \"_getDraggableNodeEl\",\n      value: function _getDraggableNodeEl(treeEl) {\n        var ignoreCache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        if (!this._cacheEls) this._cacheEls = {};\n        var el = this._cacheEls[\"draggable\"];\n        if (el && document.contains(el) && !ignoreCache) return el;\n        var els = treeEl.getElementsByClassName(\"qb-draggable\");\n        el = els.length ? els[0] : null;\n        this._cacheEls[\"draggable\"] = el;\n        return el;\n      }\n    }, {\n      key: \"_getPlaceholderNodeEl\",\n      value: function _getPlaceholderNodeEl(treeEl) {\n        var ignoreCache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        if (!this._cacheEls) this._cacheEls = {};\n        var el = this._cacheEls[\"placeholder\"];\n        if (el && document.contains(el) && !ignoreCache) return el;\n        var els = treeEl.getElementsByClassName(\"qb-placeholder\");\n        el = els.length ? els[0] : null;\n        this._cacheEls[\"placeholder\"] = el;\n        return el;\n      }\n    }, {\n      key: \"_isScrollable\",\n      value: function _isScrollable(node) {\n        var overflowY = window.getComputedStyle(node)[\"overflow-y\"];\n        return (overflowY === \"scroll\" || overflowY === \"auto\") && node.scrollHeight > node.offsetHeight;\n      }\n    }, {\n      key: \"_getScrollParent\",\n      value: function _getScrollParent(node) {\n        if (node == null) return null;\n        if (node === document.body || this._isScrollable(node)) {\n          return node;\n        } else {\n          return this._getScrollParent(node.parentNode);\n        }\n      }\n    }, {\n      key: \"handleDrag\",\n      value: function handleDrag(dragInfo, e, canMoveFn) {\n        var _this2 = this;\n        var canMoveBeforeAfterGroup = true;\n        var itemInfo = dragInfo.itemInfo;\n        var paddingLeft = dragInfo.paddingLeft;\n        var moveInfo = null;\n        var treeEl = this.props.dragStart.treeEl;\n        var dragId = dragInfo.id;\n        var dragEl = this._getDraggableNodeEl(treeEl);\n        var plhEl = this._getPlaceholderNodeEl(treeEl);\n        var dragRect, plhRect, hovRect, treeRect;\n        if (dragEl && plhEl) {\n          dragRect = dragEl.getBoundingClientRect();\n          plhRect = plhEl.getBoundingClientRect();\n          if (!plhRect.width) {\n            return;\n          }\n          var dragDirs = {\n            hrz: 0,\n            vrt: 0\n          };\n          if (dragRect.top < plhRect.top) dragDirs.vrt = -1; //up\n          else if (dragRect.bottom > plhRect.bottom) dragDirs.vrt = +1; //down\n          if (dragRect.left > plhRect.left) dragDirs.hrz = +1; //right\n          else if (dragRect.left < plhRect.left) dragDirs.hrz = -1; //left\n\n          treeRect = treeEl.getBoundingClientRect();\n          var trgCoord = {\n            x: treeRect.left + (treeRect.right - treeRect.left) / 2,\n            y: dragDirs.vrt >= 0 ? dragRect.bottom : dragRect.top\n          };\n          var hovCNodeEl;\n          if (e.__mocked_hov_container) {\n            hovCNodeEl = e.__mocked_hov_container;\n          } else {\n            var hovNodeEl = document.elementFromPoint(trgCoord.x, trgCoord.y - 1);\n            hovCNodeEl = hovNodeEl ? hovNodeEl.closest(\".group-or-rule-container\") : null;\n            if (!hovCNodeEl && hovNodeEl && hovNodeEl.classList.contains(\"query-builder-container\")) {\n              var _hovNodeEl$firstChild;\n              // fix 2022-01-24 - get root .group-or-rule-container\n              var rootGroupContainer = hovNodeEl === null || hovNodeEl === void 0 ? void 0 : (_hovNodeEl$firstChild = hovNodeEl.firstChild) === null || _hovNodeEl$firstChild === void 0 ? void 0 : _hovNodeEl$firstChild.firstChild;\n              if (rootGroupContainer && rootGroupContainer.classList.contains(\"group-or-rule-container\")) {\n                hovCNodeEl = rootGroupContainer;\n              }\n            }\n          }\n          if (!hovCNodeEl) {\n            logger.log(\"out of tree bounds!\");\n          } else {\n            var isGroup = hovCNodeEl.classList.contains(\"group-container\");\n            var hovNodeId = hovCNodeEl.getAttribute(\"data-id\");\n            var hovEl = hovCNodeEl;\n            var doAppend = false;\n            var doPrepend = false;\n            if (hovEl) {\n              hovRect = hovEl.getBoundingClientRect();\n              var hovHeight = hovRect.bottom - hovRect.top;\n              var hovII = this.tree.items[hovNodeId];\n              var trgRect = null,\n                trgEl = null,\n                trgII = null,\n                altII = null; //for canMoveBeforeAfterGroup\n\n              if (dragDirs.vrt == 0) {\n                trgII = itemInfo;\n                trgEl = plhEl;\n                if (trgEl) trgRect = trgEl.getBoundingClientRect();\n              } else {\n                if (isGroup) {\n                  if (dragDirs.vrt > 0) {\n                    //down\n                    //take group header (for prepend only)\n                    var hovInnerEl = hovCNodeEl.getElementsByClassName(\"group--header\");\n                    var hovEl2 = hovInnerEl.length ? hovInnerEl[0] : null;\n                    if (hovEl2) {\n                      var hovRect2 = hovEl2.getBoundingClientRect();\n                      var hovHeight2 = hovRect2.bottom - hovRect2.top;\n                      var isOverHover = dragRect.bottom - hovRect2.top > hovHeight2 * 3 / 4;\n                      if (isOverHover && hovII.top > dragInfo.itemInfo.top) {\n                        trgII = hovII;\n                        trgRect = hovRect2;\n                        trgEl = hovEl2;\n                        doPrepend = true;\n                      }\n                    }\n                  } else if (dragDirs.vrt < 0) {\n                    //up\n                    if (hovII.lev >= itemInfo.lev) {\n                      //take whole group\n                      var isClimbToHover = hovRect.bottom - dragRect.top >= 2;\n                      if (isClimbToHover && hovII.top < dragInfo.itemInfo.top) {\n                        trgII = hovII;\n                        trgRect = hovRect;\n                        trgEl = hovEl;\n                        doAppend = true;\n                      }\n                    }\n                  }\n                  if (!doPrepend && !doAppend || canMoveBeforeAfterGroup) {\n                    //take whole group and check if we can move before/after group\n                    var _isOverHover = dragDirs.vrt < 0 //up\n                    ? hovRect.bottom - dragRect.top > hovHeight - 5 : dragRect.bottom - hovRect.top > hovHeight - 5;\n                    if (_isOverHover) {\n                      if (!doPrepend && !doAppend) {\n                        trgII = hovII;\n                        trgRect = hovRect;\n                        trgEl = hovEl;\n                      }\n                      if (canMoveBeforeAfterGroup) {\n                        altII = hovII;\n                      }\n                    }\n                  }\n                } else {\n                  //check if we can move before/after group\n                  var _isOverHover2 = dragDirs.vrt < 0 //up\n                  ? hovRect.bottom - dragRect.top > hovHeight / 2 : dragRect.bottom - hovRect.top > hovHeight / 2;\n                  if (_isOverHover2) {\n                    trgII = hovII;\n                    trgRect = hovRect;\n                    trgEl = hovEl;\n                  }\n                }\n              }\n              var isSamePos = trgII && trgII.id == dragId;\n              if (trgRect) {\n                var dragLeftOffset = dragRect.left - treeRect.left;\n                var trgLeftOffset = trgRect.left - treeRect.left;\n                var _trgLev = trgLeftOffset / paddingLeft;\n                var dragLev = Math.max(0, Math.round(dragLeftOffset / paddingLeft));\n\n                //find all possible moves\n                var availMoves = [];\n                var altMoves = []; //alternatively can move after/before group, if can't move into it\n                if (isSamePos) {\n                  //do nothing\n                } else {\n                  if (isGroup) {\n                    if (doAppend) {\n                      availMoves.push([constants.PLACEMENT_APPEND, trgII, trgII.lev + 1]);\n                    } else if (doPrepend) {\n                      availMoves.push([constants.PLACEMENT_PREPEND, trgII, trgII.lev + 1]);\n                    }\n                    //alt\n                    if (canMoveBeforeAfterGroup && altII) {\n                      // fix 2022-01-24: do prepend/append instead of before/after for root\n                      var isToRoot = altII.lev == 0;\n                      // fix 2022-01-25: fix prepend/append instead of before/after for case_group\n                      var isToCase = altII.type == \"case_group\" && itemInfo.type != \"case_group\";\n                      var prevCaseId = altII.prev && this.tree.items[altII.prev].caseId;\n                      var nextCaseId = altII.next && this.tree.items[altII.next].caseId;\n                      if (itemInfo.caseId == prevCaseId) prevCaseId = null;\n                      if (itemInfo.caseId == nextCaseId) nextCaseId = null;\n                      var prevCase = prevCaseId && this.tree.items[prevCaseId];\n                      var nextCase = nextCaseId && this.tree.items[nextCaseId];\n                      if (dragDirs.vrt > 0) {\n                        //down\n                        if (isToRoot) {\n                          altMoves.push([constants.PLACEMENT_APPEND, altII, altII.lev + 1]);\n                        } else if (isToCase && nextCase) {\n                          altMoves.push([constants.PLACEMENT_PREPEND, nextCase, nextCase.lev + 1]);\n                        } else {\n                          altMoves.push([constants.PLACEMENT_AFTER, altII, altII.lev]);\n                        }\n                      } else if (dragDirs.vrt < 0) {\n                        //up\n                        if (isToRoot) {\n                          altMoves.push([constants.PLACEMENT_PREPEND, altII, altII.lev + 1]);\n                        } else if (isToCase && prevCase) {\n                          altMoves.push([constants.PLACEMENT_APPEND, prevCase, prevCase.lev + 1]);\n                        } else {\n                          altMoves.push([constants.PLACEMENT_BEFORE, altII, altII.lev]);\n                        }\n                      }\n                    }\n                  }\n                  if (!doAppend && !doPrepend) {\n                    if (dragDirs.vrt < 0) {\n                      //up\n                      availMoves.push([constants.PLACEMENT_BEFORE, trgII, trgII.lev]);\n                    } else if (dragDirs.vrt > 0) {\n                      //down\n                      availMoves.push([constants.PLACEMENT_AFTER, trgII, trgII.lev]);\n                    }\n                  }\n                }\n\n                //add case\n                var addCaseII = function addCaseII(am) {\n                  var toII = am[1];\n                  var fromCaseII = itemInfo.caseId ? _this2.tree.items[itemInfo.caseId] : null;\n                  var toCaseII = toII.caseId ? _this2.tree.items[toII.caseId] : null;\n                  return [].concat(_toConsumableArray(am), [fromCaseII, toCaseII]);\n                };\n                availMoves = availMoves.map(addCaseII);\n                altMoves = altMoves.map(addCaseII);\n\n                //sanitize\n                availMoves = availMoves.filter(function (am) {\n                  var placement = am[0];\n                  var trg = am[1];\n                  if ((placement == constants.PLACEMENT_BEFORE || placement == constants.PLACEMENT_AFTER) && trg.parent == null) return false;\n                  if (trg.collapsed && (placement == constants.PLACEMENT_APPEND || placement == constants.PLACEMENT_PREPEND)) return false;\n                  var isInside = trg.id == itemInfo.id;\n                  if (!isInside) {\n                    var tmp = trg;\n                    while (tmp.parent) {\n                      tmp = _this2.tree.items[tmp.parent];\n                      if (tmp.id == itemInfo.id) {\n                        isInside = true;\n                        break;\n                      }\n                    }\n                  }\n                  return !isInside;\n                }).map(function (am) {\n                  var placement = am[0],\n                    toII = am[1],\n                    _lev = am[2],\n                    _fromCaseII = am[3],\n                    _toCaseII = am[4];\n                  var toParentII = null;\n                  if (placement == constants.PLACEMENT_APPEND || placement == constants.PLACEMENT_PREPEND) toParentII = toII;else toParentII = _this2.tree.items[toII.parent];\n                  if (toParentII && toParentII.parent == null) toParentII = null;\n                  am[5] = toParentII;\n                  return am;\n                });\n                var bestMode = null;\n                var filteredMoves = availMoves.filter(function (am) {\n                  return _this2.canMove(itemInfo, am[1], am[0], am[3], am[4], am[5], canMoveFn);\n                });\n                if (canMoveBeforeAfterGroup && filteredMoves.length == 0 && altMoves.length > 0) {\n                  filteredMoves = altMoves.filter(function (am) {\n                    return _this2.canMove(itemInfo, am[1], am[0], am[3], am[4], am[5], canMoveFn);\n                  });\n                }\n                var levs = filteredMoves.map(function (am) {\n                  return am[2];\n                });\n                var curLev = itemInfo.lev;\n                var allLevs = levs.concat(curLev);\n                var closestDragLev = null;\n                if (allLevs.indexOf(dragLev) != -1) closestDragLev = dragLev;else if (dragLev > Math.max.apply(Math, _toConsumableArray(allLevs))) closestDragLev = Math.max.apply(Math, _toConsumableArray(allLevs));else if (dragLev < Math.min.apply(Math, _toConsumableArray(allLevs))) closestDragLev = Math.min.apply(Math, _toConsumableArray(allLevs));\n                bestMode = filteredMoves.find(function (am) {\n                  return am[2] == closestDragLev;\n                });\n                if (!isSamePos && !bestMode && filteredMoves.length) bestMode = filteredMoves[0];\n                moveInfo = bestMode;\n              }\n            }\n          }\n        }\n        if (moveInfo) {\n          this.move(itemInfo, moveInfo[1], moveInfo[0], moveInfo[3]);\n\n          // logger.log(\"DRAG-N-DROP\", JSON.stringify({\n          //   dragRect,\n          //   plhRect,\n          //   treeRect,\n          //   hovRect,\n          //   startMousePos: dragInfo.startMousePos,\n          //   mousePos: dragInfo.mousePos,\n          // }));\n          return true;\n        }\n        return false;\n      }\n    }, {\n      key: \"canMove\",\n      value: function canMove(fromII, toII, placement, fromCaseII, toCaseII, toParentII, canMoveFn) {\n        if (!fromII || !toII) return false;\n        if (fromII.id === toII.id) return false;\n        var _this$props$config$se = this.props.config.settings,\n          canRegroup = _this$props$config$se.canRegroup,\n          canRegroupCases = _this$props$config$se.canRegroupCases,\n          maxNesting = _this$props$config$se.maxNesting,\n          maxNumberOfRules = _this$props$config$se.maxNumberOfRules,\n          canLeaveEmptyCase = _this$props$config$se.canLeaveEmptyCase;\n        var newLev = toParentII ? toParentII.lev + 1 : toII.lev;\n        var isBeforeAfter = placement == constants.PLACEMENT_BEFORE || placement == constants.PLACEMENT_AFTER;\n        var isPend = placement == constants.PLACEMENT_PREPEND || placement == constants.PLACEMENT_APPEND;\n        var isLev1 = isBeforeAfter && toII.lev == 1 || isPend && toII.lev == 0;\n        var isParentChange = fromII.parent != toII.parent;\n        var isStructChange = isPend || isParentChange;\n        // can't move `case_group` anywhere but before/after anoter `case_group`\n        var isForbiddenStructChange = fromII.type == \"case_group\" && !isLev1\n        // can't restruct `rule_group`\n        || fromII.parentType == \"rule_group\" || toII.type == \"rule_group\" || toII.parentType == \"rule_group\"\n        // only `case_group` can be placed under `switch_group`\n        || fromII.type != \"case_group\" && toII.type == \"case_group\" && isBeforeAfter || fromII.type != \"case_group\" && toII.type == \"switch_group\"\n        // can't move rule/group to another case\n        || !canRegroupCases && fromII.caseId != toII.caseId;\n        var isLockedChange = toII.isLocked || fromII.isLocked || toParentII && toParentII.isLocked;\n        if (maxNesting && newLev > maxNesting) return false;\n        if (isStructChange && (!canRegroup || isForbiddenStructChange || isLockedChange)) return false;\n        if (fromII.type != \"case_group\" && fromII.caseId != toII.caseId) {\n          var isLastFromCase = fromCaseII ? fromCaseII._height == 2 : false;\n          var newRulesInTargetCase = toCaseII ? toCaseII.leafsCount + 1 : 0;\n          if (maxNumberOfRules && newRulesInTargetCase > maxNumberOfRules) return false;\n          if (isLastFromCase && !canLeaveEmptyCase) return false;\n        }\n        if (fromII.type == \"case_group\" && (fromII.isDefaultCase || toII.isDefaultCase || toII.type == \"switch_group\" && placement == constants.PLACEMENT_APPEND)) {\n          // leave default case alone\n          return false;\n        }\n        var res = true;\n        if (canMoveFn) {\n          res = canMoveFn(fromII.node.toJS(), toII.node.toJS(), placement, toParentII ? toParentII.node.toJS() : null);\n        }\n        return res;\n      }\n    }, {\n      key: \"move\",\n      value: function move(fromII, toII, placement, toParentII) {\n        if (!this._isUsingLegacyReactDomRender) {\n          _isReorderingTree = true;\n        }\n        //logger.log(\"move\", fromII, toII, placement, toParentII);\n        this.props.actions.moveItem(fromII.path, toII.path, placement);\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        return /*#__PURE__*/React.createElement(Builder, _extends({}, this.props, {\n          onDragStart: this.onDragStart\n        }));\n      }\n    }]);\n    return SortableContainer;\n  }(Component), _class.propTypes = {\n    tree: PropTypes.any.isRequired,\n    //instanceOf(Immutable.Map)\n    actions: PropTypes.object.isRequired // {moveItem: Function, ..}\n    //... see Builder\n  }, _class;\n};\nexport default (function (Builder) {\n  var CanMoveFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var ConnectedSortableContainer = connect(function (state) {\n    return {\n      dragging: state.dragging,\n      dragStart: state.dragStart,\n      mousePos: state.mousePos\n    };\n  }, {\n    setDragStart: actions.drag.setDragStart,\n    setDragProgress: actions.drag.setDragProgress,\n    setDragEnd: actions.drag.setDragEnd\n  }, null, {\n    context: context\n  })(createSortableContainer(Builder, CanMoveFn));\n  ConnectedSortableContainer.displayName = \"ConnectedSortableContainer\";\n  return ConnectedSortableContainer;\n});\nexport { _isReorderingTree };"]},"metadata":{},"sourceType":"module"}