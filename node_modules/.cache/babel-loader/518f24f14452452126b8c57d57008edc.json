{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nimport { getFieldConfig, getOperatorConfig, getFieldWidgetConfig, getFuncConfig } from \"../utils/configUtils\";\nimport { getFieldPath, getFieldPathLabels, getWidgetForFieldOp, formatFieldName } from \"../utils/ruleUtils\";\nimport omit from \"lodash/omit\";\nimport pick from \"lodash/pick\";\nimport { defaultValue } from \"../utils/stuff\";\nimport { defaultConjunction } from \"../utils/defaultUtils\";\nimport { completeValue } from \"../utils/funcUtils\";\nimport { List, Map } from \"immutable\";\nexport var queryString = function queryString(item, config) {\n  var isForDisplay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false; //meta is mutable\n\n  var meta = {\n    errors: []\n  };\n  var res = formatItem(item, config, meta, isForDisplay, null);\n  if (meta.errors.length) console.warn(\"Errors while exporting to string:\", meta.errors);\n  return res;\n};\n\nvar formatItem = function formatItem(item, config, meta) {\n  var isForDisplay = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var parentField = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  if (!item) return undefined;\n  var type = item.get(\"type\");\n  var children = item.get(\"children1\");\n\n  if (type === \"group\" || type === \"rule_group\") {\n    return formatGroup(item, config, meta, isForDisplay, parentField);\n  } else if (type === \"rule\") {\n    return formatRule(item, config, meta, isForDisplay, parentField);\n  }\n\n  return undefined;\n};\n\nvar formatGroup = function formatGroup(item, config, meta) {\n  var isForDisplay = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var parentField = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  var type = item.get(\"type\");\n  var properties = item.get(\"properties\") || new Map();\n  var mode = properties.get(\"mode\");\n  var children = item.get(\"children1\") || new List();\n  var isRuleGroup = type === \"rule_group\"; // TIP: don't cut group for mode == 'struct' and don't do aggr format (maybe later)\n\n  var groupField = isRuleGroup && mode == \"array\" ? properties.get(\"field\") : null;\n  var canHaveEmptyChildren = isRuleGroup && mode == \"array\";\n  var not = properties.get(\"not\");\n  var list = children.map(function (currentChild) {\n    return formatItem(currentChild, config, meta, isForDisplay, groupField);\n  }).filter(function (currentChild) {\n    return typeof currentChild !== \"undefined\";\n  });\n  if (!canHaveEmptyChildren && !list.size) return undefined;\n  var conjunction = properties.get(\"conjunction\");\n  if (!conjunction) conjunction = defaultConjunction(config);\n  var conjunctionDefinition = config.conjunctions[conjunction];\n  var conjStr = list.size ? conjunctionDefinition.formatConj(list, conjunction, not, isForDisplay) : null;\n  var ret;\n\n  if (groupField) {\n    var aggrArgs = formatRule(item, config, meta, isForDisplay, parentField, true);\n\n    if (aggrArgs) {\n      var _config$settings;\n\n      var isRev = aggrArgs.pop();\n      var args = [conjStr].concat(_toConsumableArray(aggrArgs));\n      ret = (_config$settings = config.settings).formatAggr.apply(_config$settings, _toConsumableArray(args));\n\n      if (isRev) {\n        ret = config.settings.formatReverse(ret, null, null, null, null, isForDisplay);\n      }\n    }\n  } else {\n    ret = conjStr;\n  }\n\n  return ret;\n};\n\nvar formatItemValue = function formatItemValue(config, properties, meta, _operator, isForDisplay, parentField) {\n  var field = properties.get(\"field\");\n  var iValueSrc = properties.get(\"valueSrc\");\n  var iValueType = properties.get(\"valueType\");\n  var fieldDef = getFieldConfig(config, field) || {};\n\n  var operator = _operator || properties.get(\"operator\");\n\n  var operatorDef = getOperatorConfig(config, operator, field) || {};\n  var cardinality = defaultValue(operatorDef.cardinality, 1);\n  var iValue = properties.get(\"value\");\n  var asyncListValues = properties.get(\"asyncListValues\");\n  var valueSrcs = [];\n  var valueTypes = [];\n  var formattedValue;\n\n  if (iValue != undefined) {\n    var fvalue = iValue.map(function (currentValue, ind) {\n      var valueSrc = iValueSrc ? iValueSrc.get(ind) : null;\n      var valueType = iValueType ? iValueType.get(ind) : null;\n      var cValue = completeValue(currentValue, valueSrc, config);\n      var widget = getWidgetForFieldOp(config, field, operator, valueSrc);\n      var fieldWidgetDef = omit(getFieldWidgetConfig(config, field, operator, widget, valueSrc), [\"factory\"]);\n      var fv = formatValue(config, meta, cValue, valueSrc, valueType, fieldWidgetDef, fieldDef, operator, operatorDef, isForDisplay, parentField, asyncListValues);\n\n      if (fv !== undefined) {\n        valueSrcs.push(valueSrc);\n        valueTypes.push(valueType);\n      }\n\n      return fv;\n    });\n    var hasUndefinedValues = fvalue.filter(function (v) {\n      return v === undefined;\n    }).size > 0;\n\n    if (!(hasUndefinedValues || fvalue.size < cardinality)) {\n      formattedValue = cardinality == 1 ? fvalue.first() : fvalue;\n    }\n  }\n\n  return [formattedValue, valueSrcs.length > 1 ? valueSrcs : valueSrcs[0], valueTypes.length > 1 ? valueTypes : valueTypes[0]];\n};\n\nvar buildFnToFormatOp = function buildFnToFormatOp(operator, operatorDefinition) {\n  var fop = operatorDefinition.labelForFormat || operator;\n  var cardinality = defaultValue(operatorDefinition.cardinality, 1);\n  var fn;\n\n  if (cardinality == 0) {\n    fn = function fn(field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {\n      return \"\".concat(field, \" \").concat(fop);\n    };\n  } else if (cardinality == 1) {\n    fn = function fn(field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {\n      return \"\".concat(field, \" \").concat(fop, \" \").concat(values);\n    };\n  } else if (cardinality == 2) {\n    // between\n    fn = function fn(field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {\n      var valFrom = values.first();\n      var valTo = values.get(1);\n      return \"\".concat(field, \" \").concat(fop, \" \").concat(valFrom, \" AND \").concat(valTo);\n    };\n  }\n\n  return fn;\n};\n\nvar formatRule = function formatRule(item, config, meta) {\n  var isForDisplay = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var parentField = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  var returnArgs = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  var properties = item.get(\"properties\") || new Map();\n  var field = properties.get(\"field\");\n  var operator = properties.get(\"operator\");\n  var operatorOptions = properties.get(\"operatorOptions\");\n  if (field == null || operator == null) return undefined;\n  var fieldDef = getFieldConfig(config, field) || {};\n  var operatorDef = getOperatorConfig(config, operator, field) || {};\n  var reversedOp = operatorDef.reversedOp;\n  var revOperatorDef = getOperatorConfig(config, reversedOp, field) || {}; //check op\n\n  var isRev = false;\n  var fn = operatorDef.formatOp;\n\n  if (!fn && reversedOp) {\n    fn = revOperatorDef.formatOp;\n\n    if (fn) {\n      isRev = true;\n      var _ref = [reversedOp, operator];\n      operator = _ref[0];\n      reversedOp = _ref[1];\n      var _ref2 = [revOperatorDef, operatorDef];\n      operatorDef = _ref2[0];\n      revOperatorDef = _ref2[1];\n    }\n  } //find fn to format expr\n\n\n  if (!fn) fn = buildFnToFormatOp(operator, operatorDef);\n  if (!fn) return undefined; //format field\n\n  var formattedField = formatField(config, meta, field, isForDisplay, parentField); //format value\n\n  var _formatItemValue = formatItemValue(config, properties, meta, operator, isForDisplay, parentField),\n      _formatItemValue2 = _slicedToArray(_formatItemValue, 3),\n      formattedValue = _formatItemValue2[0],\n      valueSrc = _formatItemValue2[1],\n      valueType = _formatItemValue2[2];\n\n  if (formattedValue === undefined) return undefined;\n  var args = [formattedField, operator, formattedValue, valueSrc, valueType, omit(operatorDef, [\"formatOp\", \"mongoFormatOp\", \"sqlFormatOp\", \"jsonLogic\", \"spelFormatOp\"]), operatorOptions, isForDisplay, fieldDef, isRev];\n\n  if (returnArgs) {\n    return args;\n  } else {\n    //format expr\n    var ret = fn.apply(void 0, args); //rev\n\n    if (isRev) {\n      ret = config.settings.formatReverse(ret, operator, reversedOp, operatorDef, revOperatorDef, isForDisplay);\n    }\n\n    return ret;\n  }\n};\n\nvar formatValue = function formatValue(config, meta, value, valueSrc, valueType, fieldWidgetDef, fieldDef, operator, opDef, isForDisplay) {\n  var parentField = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : null;\n  var asyncListValues = arguments.length > 11 ? arguments[11] : undefined;\n  if (value === undefined) return undefined;\n  var ret;\n\n  if (valueSrc == \"field\") {\n    ret = formatField(config, meta, value, isForDisplay, parentField);\n  } else if (valueSrc == \"func\") {\n    ret = formatFunc(config, meta, value, isForDisplay, parentField);\n  } else {\n    if (typeof fieldWidgetDef.formatValue === \"function\") {\n      var fn = fieldWidgetDef.formatValue;\n      var args = [value, _objectSpread(_objectSpread({}, pick(fieldDef, [\"fieldSettings\", \"listValues\"])), {}, {\n        asyncListValues: asyncListValues\n      }), //useful options: valueFormat for date/time\n      omit(fieldWidgetDef, [\"formatValue\", \"mongoFormatValue\", \"sqlFormatValue\", \"jsonLogic\", \"elasticSearchFormatValue\", \"spelFormatValue\"]), isForDisplay];\n\n      if (operator) {\n        args.push(operator);\n        args.push(opDef);\n      }\n\n      if (valueSrc == \"field\") {\n        var valFieldDefinition = getFieldConfig(config, value) || {};\n        args.push(valFieldDefinition);\n      }\n\n      ret = fn.apply(void 0, args);\n    } else {\n      ret = value;\n    }\n  }\n\n  return ret;\n};\n\nvar formatField = function formatField(config, meta, field, isForDisplay) {\n  var parentField = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  var cutParentField = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n  var _config$settings2 = config.settings,\n      fieldSeparator = _config$settings2.fieldSeparator,\n      fieldSeparatorDisplay = _config$settings2.fieldSeparatorDisplay;\n  var ret = null;\n\n  if (field) {\n    var fieldDefinition = getFieldConfig(config, field) || {};\n    var fieldParts = Array.isArray(field) ? field : field.split(fieldSeparator);\n\n    var _fieldKeys = getFieldPath(field, config);\n\n    var fieldPartsLabels = getFieldPathLabels(field, config, cutParentField ? parentField : null);\n    var fieldFullLabel = fieldPartsLabels ? fieldPartsLabels.join(fieldSeparatorDisplay) : null;\n    var fieldLabel2 = fieldDefinition.label2 || fieldFullLabel;\n    var formatFieldFn = config.settings.formatField;\n    var fieldName = formatFieldName(field, config, meta, cutParentField ? parentField : null);\n    ret = formatFieldFn(fieldName, fieldParts, fieldLabel2, fieldDefinition, config, isForDisplay);\n  }\n\n  return ret;\n};\n\nvar formatFunc = function formatFunc(config, meta, funcValue, isForDisplay) {\n  var parentField = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  var funcKey = funcValue.get(\"func\");\n  var args = funcValue.get(\"args\");\n  var funcConfig = getFuncConfig(config, funcKey);\n  var funcName = isForDisplay && funcConfig.label || funcKey;\n  var formattedArgs = {};\n  var formattedArgsWithNames = {};\n\n  for (var argKey in funcConfig.args) {\n    var argConfig = funcConfig.args[argKey];\n    var fieldDef = getFieldConfig(config, argConfig);\n    var argVal = args ? args.get(argKey) : undefined;\n    var argValue = argVal ? argVal.get(\"value\") : undefined;\n    var argValueSrc = argVal ? argVal.get(\"valueSrc\") : undefined;\n    var argAsyncListValues = argVal ? argVal.get(\"asyncListValues\") : undefined;\n    var formattedArgVal = formatValue(config, meta, argValue, argValueSrc, argConfig.type, fieldDef, argConfig, null, null, isForDisplay, parentField, argAsyncListValues);\n    var argName = isForDisplay && argConfig.label || argKey;\n\n    if (formattedArgVal !== undefined) {\n      // skip optional in the end\n      formattedArgs[argKey] = formattedArgVal;\n      formattedArgsWithNames[argName] = formattedArgVal;\n    }\n  }\n\n  var ret = null;\n\n  if (typeof funcConfig.formatFunc === \"function\") {\n    var fn = funcConfig.formatFunc;\n    var _args = [formattedArgs, isForDisplay];\n    ret = fn.apply(void 0, _args);\n  } else {\n    var argsStr = Object.entries(formattedArgsWithNames).map(function (_ref3) {\n      var _ref4 = _slicedToArray(_ref3, 2),\n          k = _ref4[0],\n          v = _ref4[1];\n\n      return isForDisplay ? \"\".concat(k, \": \").concat(v) : \"\".concat(v);\n    }).join(\", \");\n    ret = \"\".concat(funcName, \"(\").concat(argsStr, \")\");\n  }\n\n  return ret;\n};","map":{"version":3,"sources":["E:/WorkingFolder/React_Postgres/ALPD/SOURCE-512/QuaLISWeb/node_modules/@react-awesome-query-builder/core/esm/export/queryString.js"],"names":["_defineProperty","_slicedToArray","_toConsumableArray","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","getFieldConfig","getOperatorConfig","getFieldWidgetConfig","getFuncConfig","getFieldPath","getFieldPathLabels","getWidgetForFieldOp","formatFieldName","omit","pick","defaultValue","defaultConjunction","completeValue","List","Map","queryString","item","config","isForDisplay","undefined","meta","errors","res","formatItem","console","warn","parentField","type","get","children","formatGroup","formatRule","properties","mode","isRuleGroup","groupField","canHaveEmptyChildren","not","list","map","currentChild","size","conjunction","conjunctionDefinition","conjunctions","conjStr","formatConj","ret","aggrArgs","_config$settings","isRev","pop","args","concat","settings","formatAggr","formatReverse","formatItemValue","_operator","field","iValueSrc","iValueType","fieldDef","operator","operatorDef","cardinality","iValue","asyncListValues","valueSrcs","valueTypes","formattedValue","fvalue","currentValue","ind","valueSrc","valueType","cValue","widget","fieldWidgetDef","fv","formatValue","hasUndefinedValues","v","first","buildFnToFormatOp","operatorDefinition","fop","labelForFormat","fn","op","values","opDef","operatorOptions","valFrom","valTo","returnArgs","reversedOp","revOperatorDef","formatOp","_ref","_ref2","formattedField","formatField","_formatItemValue","_formatItemValue2","value","formatFunc","valFieldDefinition","cutParentField","_config$settings2","fieldSeparator","fieldSeparatorDisplay","fieldDefinition","fieldParts","Array","isArray","split","_fieldKeys","fieldPartsLabels","fieldFullLabel","join","fieldLabel2","label2","formatFieldFn","fieldName","funcValue","funcKey","funcConfig","funcName","label","formattedArgs","formattedArgsWithNames","argKey","argConfig","argVal","argValue","argValueSrc","argAsyncListValues","formattedArgVal","argName","_args","argsStr","entries","_ref3","_ref4","k"],"mappings":"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","sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nimport { getFieldConfig, getOperatorConfig, getFieldWidgetConfig, getFuncConfig } from \"../utils/configUtils\";\nimport { getFieldPath, getFieldPathLabels, getWidgetForFieldOp, formatFieldName } from \"../utils/ruleUtils\";\nimport omit from \"lodash/omit\";\nimport pick from \"lodash/pick\";\nimport { defaultValue } from \"../utils/stuff\";\nimport { defaultConjunction } from \"../utils/defaultUtils\";\nimport { completeValue } from \"../utils/funcUtils\";\nimport { List, Map } from \"immutable\";\nexport var queryString = function queryString(item, config) {\n  var isForDisplay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  //meta is mutable\n  var meta = {\n    errors: []\n  };\n  var res = formatItem(item, config, meta, isForDisplay, null);\n  if (meta.errors.length) console.warn(\"Errors while exporting to string:\", meta.errors);\n  return res;\n};\nvar formatItem = function formatItem(item, config, meta) {\n  var isForDisplay = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var parentField = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  if (!item) return undefined;\n  var type = item.get(\"type\");\n  var children = item.get(\"children1\");\n  if (type === \"group\" || type === \"rule_group\") {\n    return formatGroup(item, config, meta, isForDisplay, parentField);\n  } else if (type === \"rule\") {\n    return formatRule(item, config, meta, isForDisplay, parentField);\n  }\n  return undefined;\n};\nvar formatGroup = function formatGroup(item, config, meta) {\n  var isForDisplay = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var parentField = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  var type = item.get(\"type\");\n  var properties = item.get(\"properties\") || new Map();\n  var mode = properties.get(\"mode\");\n  var children = item.get(\"children1\") || new List();\n  var isRuleGroup = type === \"rule_group\";\n  // TIP: don't cut group for mode == 'struct' and don't do aggr format (maybe later)\n  var groupField = isRuleGroup && mode == \"array\" ? properties.get(\"field\") : null;\n  var canHaveEmptyChildren = isRuleGroup && mode == \"array\";\n  var not = properties.get(\"not\");\n  var list = children.map(function (currentChild) {\n    return formatItem(currentChild, config, meta, isForDisplay, groupField);\n  }).filter(function (currentChild) {\n    return typeof currentChild !== \"undefined\";\n  });\n  if (!canHaveEmptyChildren && !list.size) return undefined;\n  var conjunction = properties.get(\"conjunction\");\n  if (!conjunction) conjunction = defaultConjunction(config);\n  var conjunctionDefinition = config.conjunctions[conjunction];\n  var conjStr = list.size ? conjunctionDefinition.formatConj(list, conjunction, not, isForDisplay) : null;\n  var ret;\n  if (groupField) {\n    var aggrArgs = formatRule(item, config, meta, isForDisplay, parentField, true);\n    if (aggrArgs) {\n      var _config$settings;\n      var isRev = aggrArgs.pop();\n      var args = [conjStr].concat(_toConsumableArray(aggrArgs));\n      ret = (_config$settings = config.settings).formatAggr.apply(_config$settings, _toConsumableArray(args));\n      if (isRev) {\n        ret = config.settings.formatReverse(ret, null, null, null, null, isForDisplay);\n      }\n    }\n  } else {\n    ret = conjStr;\n  }\n  return ret;\n};\nvar formatItemValue = function formatItemValue(config, properties, meta, _operator, isForDisplay, parentField) {\n  var field = properties.get(\"field\");\n  var iValueSrc = properties.get(\"valueSrc\");\n  var iValueType = properties.get(\"valueType\");\n  var fieldDef = getFieldConfig(config, field) || {};\n  var operator = _operator || properties.get(\"operator\");\n  var operatorDef = getOperatorConfig(config, operator, field) || {};\n  var cardinality = defaultValue(operatorDef.cardinality, 1);\n  var iValue = properties.get(\"value\");\n  var asyncListValues = properties.get(\"asyncListValues\");\n  var valueSrcs = [];\n  var valueTypes = [];\n  var formattedValue;\n  if (iValue != undefined) {\n    var fvalue = iValue.map(function (currentValue, ind) {\n      var valueSrc = iValueSrc ? iValueSrc.get(ind) : null;\n      var valueType = iValueType ? iValueType.get(ind) : null;\n      var cValue = completeValue(currentValue, valueSrc, config);\n      var widget = getWidgetForFieldOp(config, field, operator, valueSrc);\n      var fieldWidgetDef = omit(getFieldWidgetConfig(config, field, operator, widget, valueSrc), [\"factory\"]);\n      var fv = formatValue(config, meta, cValue, valueSrc, valueType, fieldWidgetDef, fieldDef, operator, operatorDef, isForDisplay, parentField, asyncListValues);\n      if (fv !== undefined) {\n        valueSrcs.push(valueSrc);\n        valueTypes.push(valueType);\n      }\n      return fv;\n    });\n    var hasUndefinedValues = fvalue.filter(function (v) {\n      return v === undefined;\n    }).size > 0;\n    if (!(hasUndefinedValues || fvalue.size < cardinality)) {\n      formattedValue = cardinality == 1 ? fvalue.first() : fvalue;\n    }\n  }\n  return [formattedValue, valueSrcs.length > 1 ? valueSrcs : valueSrcs[0], valueTypes.length > 1 ? valueTypes : valueTypes[0]];\n};\nvar buildFnToFormatOp = function buildFnToFormatOp(operator, operatorDefinition) {\n  var fop = operatorDefinition.labelForFormat || operator;\n  var cardinality = defaultValue(operatorDefinition.cardinality, 1);\n  var fn;\n  if (cardinality == 0) {\n    fn = function fn(field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {\n      return \"\".concat(field, \" \").concat(fop);\n    };\n  } else if (cardinality == 1) {\n    fn = function fn(field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {\n      return \"\".concat(field, \" \").concat(fop, \" \").concat(values);\n    };\n  } else if (cardinality == 2) {\n    // between\n    fn = function fn(field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {\n      var valFrom = values.first();\n      var valTo = values.get(1);\n      return \"\".concat(field, \" \").concat(fop, \" \").concat(valFrom, \" AND \").concat(valTo);\n    };\n  }\n  return fn;\n};\nvar formatRule = function formatRule(item, config, meta) {\n  var isForDisplay = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var parentField = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  var returnArgs = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  var properties = item.get(\"properties\") || new Map();\n  var field = properties.get(\"field\");\n  var operator = properties.get(\"operator\");\n  var operatorOptions = properties.get(\"operatorOptions\");\n  if (field == null || operator == null) return undefined;\n  var fieldDef = getFieldConfig(config, field) || {};\n  var operatorDef = getOperatorConfig(config, operator, field) || {};\n  var reversedOp = operatorDef.reversedOp;\n  var revOperatorDef = getOperatorConfig(config, reversedOp, field) || {};\n\n  //check op\n  var isRev = false;\n  var fn = operatorDef.formatOp;\n  if (!fn && reversedOp) {\n    fn = revOperatorDef.formatOp;\n    if (fn) {\n      isRev = true;\n      var _ref = [reversedOp, operator];\n      operator = _ref[0];\n      reversedOp = _ref[1];\n      var _ref2 = [revOperatorDef, operatorDef];\n      operatorDef = _ref2[0];\n      revOperatorDef = _ref2[1];\n    }\n  }\n\n  //find fn to format expr\n  if (!fn) fn = buildFnToFormatOp(operator, operatorDef);\n  if (!fn) return undefined;\n\n  //format field\n  var formattedField = formatField(config, meta, field, isForDisplay, parentField);\n\n  //format value\n  var _formatItemValue = formatItemValue(config, properties, meta, operator, isForDisplay, parentField),\n    _formatItemValue2 = _slicedToArray(_formatItemValue, 3),\n    formattedValue = _formatItemValue2[0],\n    valueSrc = _formatItemValue2[1],\n    valueType = _formatItemValue2[2];\n  if (formattedValue === undefined) return undefined;\n  var args = [formattedField, operator, formattedValue, valueSrc, valueType, omit(operatorDef, [\"formatOp\", \"mongoFormatOp\", \"sqlFormatOp\", \"jsonLogic\", \"spelFormatOp\"]), operatorOptions, isForDisplay, fieldDef, isRev];\n  if (returnArgs) {\n    return args;\n  } else {\n    //format expr\n    var ret = fn.apply(void 0, args);\n\n    //rev\n    if (isRev) {\n      ret = config.settings.formatReverse(ret, operator, reversedOp, operatorDef, revOperatorDef, isForDisplay);\n    }\n    return ret;\n  }\n};\nvar formatValue = function formatValue(config, meta, value, valueSrc, valueType, fieldWidgetDef, fieldDef, operator, opDef, isForDisplay) {\n  var parentField = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : null;\n  var asyncListValues = arguments.length > 11 ? arguments[11] : undefined;\n  if (value === undefined) return undefined;\n  var ret;\n  if (valueSrc == \"field\") {\n    ret = formatField(config, meta, value, isForDisplay, parentField);\n  } else if (valueSrc == \"func\") {\n    ret = formatFunc(config, meta, value, isForDisplay, parentField);\n  } else {\n    if (typeof fieldWidgetDef.formatValue === \"function\") {\n      var fn = fieldWidgetDef.formatValue;\n      var args = [value, _objectSpread(_objectSpread({}, pick(fieldDef, [\"fieldSettings\", \"listValues\"])), {}, {\n        asyncListValues: asyncListValues\n      }),\n      //useful options: valueFormat for date/time\n      omit(fieldWidgetDef, [\"formatValue\", \"mongoFormatValue\", \"sqlFormatValue\", \"jsonLogic\", \"elasticSearchFormatValue\", \"spelFormatValue\"]), isForDisplay];\n      if (operator) {\n        args.push(operator);\n        args.push(opDef);\n      }\n      if (valueSrc == \"field\") {\n        var valFieldDefinition = getFieldConfig(config, value) || {};\n        args.push(valFieldDefinition);\n      }\n      ret = fn.apply(void 0, args);\n    } else {\n      ret = value;\n    }\n  }\n  return ret;\n};\nvar formatField = function formatField(config, meta, field, isForDisplay) {\n  var parentField = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  var cutParentField = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n  var _config$settings2 = config.settings,\n    fieldSeparator = _config$settings2.fieldSeparator,\n    fieldSeparatorDisplay = _config$settings2.fieldSeparatorDisplay;\n  var ret = null;\n  if (field) {\n    var fieldDefinition = getFieldConfig(config, field) || {};\n    var fieldParts = Array.isArray(field) ? field : field.split(fieldSeparator);\n    var _fieldKeys = getFieldPath(field, config);\n    var fieldPartsLabels = getFieldPathLabels(field, config, cutParentField ? parentField : null);\n    var fieldFullLabel = fieldPartsLabels ? fieldPartsLabels.join(fieldSeparatorDisplay) : null;\n    var fieldLabel2 = fieldDefinition.label2 || fieldFullLabel;\n    var formatFieldFn = config.settings.formatField;\n    var fieldName = formatFieldName(field, config, meta, cutParentField ? parentField : null);\n    ret = formatFieldFn(fieldName, fieldParts, fieldLabel2, fieldDefinition, config, isForDisplay);\n  }\n  return ret;\n};\nvar formatFunc = function formatFunc(config, meta, funcValue, isForDisplay) {\n  var parentField = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  var funcKey = funcValue.get(\"func\");\n  var args = funcValue.get(\"args\");\n  var funcConfig = getFuncConfig(config, funcKey);\n  var funcName = isForDisplay && funcConfig.label || funcKey;\n  var formattedArgs = {};\n  var formattedArgsWithNames = {};\n  for (var argKey in funcConfig.args) {\n    var argConfig = funcConfig.args[argKey];\n    var fieldDef = getFieldConfig(config, argConfig);\n    var argVal = args ? args.get(argKey) : undefined;\n    var argValue = argVal ? argVal.get(\"value\") : undefined;\n    var argValueSrc = argVal ? argVal.get(\"valueSrc\") : undefined;\n    var argAsyncListValues = argVal ? argVal.get(\"asyncListValues\") : undefined;\n    var formattedArgVal = formatValue(config, meta, argValue, argValueSrc, argConfig.type, fieldDef, argConfig, null, null, isForDisplay, parentField, argAsyncListValues);\n    var argName = isForDisplay && argConfig.label || argKey;\n    if (formattedArgVal !== undefined) {\n      // skip optional in the end\n      formattedArgs[argKey] = formattedArgVal;\n      formattedArgsWithNames[argName] = formattedArgVal;\n    }\n  }\n  var ret = null;\n  if (typeof funcConfig.formatFunc === \"function\") {\n    var fn = funcConfig.formatFunc;\n    var _args = [formattedArgs, isForDisplay];\n    ret = fn.apply(void 0, _args);\n  } else {\n    var argsStr = Object.entries(formattedArgsWithNames).map(function (_ref3) {\n      var _ref4 = _slicedToArray(_ref3, 2),\n        k = _ref4[0],\n        v = _ref4[1];\n      return isForDisplay ? \"\".concat(k, \": \").concat(v) : \"\".concat(v);\n    }).join(\", \");\n    ret = \"\".concat(funcName, \"(\").concat(argsStr, \")\");\n  }\n  return ret;\n};"]},"metadata":{},"sourceType":"module"}