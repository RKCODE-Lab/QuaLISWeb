{"ast":null,"code":"'use strict';\n\nvar _ = require('underscore');\n\nvar objectUtils = require('../../utils/object');\n\nvar removeTopBrackets = function removeTopBrackets(condition) {\n  if (condition.length && condition[0] === '(' && condition[condition.length - 1] === ')') {\n    condition = condition.slice(1, condition.length - 1);\n  }\n\n  return condition;\n};\n\nvar termKeys = ['select', 'query', 'field', 'value', 'func', 'expression'];\n\nvar isTerm = function isTerm(obj) {\n  return objectUtils.isObjectObject(obj) && objectUtils.hasSome(obj, termKeys);\n};\n\nmodule.exports = function (dialect) {\n  dialect.blocks.add('distinct', function () {\n    return 'distinct';\n  });\n  dialect.blocks.add('fields', function (params) {\n    var fields = params.fields || {};\n\n    if (!_.isObject(fields)) {\n      throw new Error('Invalid `fields` property type \"' + typeof fields + '\"');\n    }\n\n    if (_.isEmpty(fields)) return '*'; // If fields is array: ['a', {b: 'c'}, {name: '', table: 't', alias: 'r'}]\n\n    if (_.isArray(fields)) {\n      fields = _(fields).map(function (field) {\n        if (objectUtils.isSimpleValue(field) || isTerm(field) || _.has(field, 'name')) {\n          // if field has simple type or is field object: {name: '', table: 't', alias: 'r'}\n          return dialect.buildBlock('term', {\n            term: field,\n            type: 'field'\n          });\n        } else {\n          // if field is non-field object: {b: 'c'}\n          return dialect.buildBlock('fields', {\n            fields: field\n          });\n        }\n      }); // If fields is object: {a: 'u', b: {table: 't', alias: 'c'}}\n    } else {\n      // use keys as field names\n      fields = _(fields).map(function (field, name) {\n        // if field is not an object value, use it as alias\n        if (_.isString(field)) field = {\n          alias: field\n        }; // if field does not have name, get it from key\n\n        if (!_.has(field, 'name')) field = _.defaults({\n          name: name\n        }, field);\n        return dialect.buildBlock('term', {\n          term: field,\n          type: 'field'\n        });\n      });\n    }\n\n    return _(fields).compact().join(', ');\n  });\n  dialect.blocks.add('term', function (params) {\n    var term = params.term;\n    var type = params.type || 'field';\n    var isSimpleValue = objectUtils.isSimpleValue(term);\n\n    var isArray = _.isArray(term);\n\n    if (isSimpleValue && !_.isString(term) || isArray) type = 'value';\n\n    if (isSimpleValue || !isTerm(term) || isArray) {\n      term = _(term).chain().pick('cast', 'alias').extend(_.object([type], [term])).value();\n    }\n\n    type = _(termKeys).find(function (key) {\n      return _.has(term, key);\n    });\n    var result = dialect.buildBlock(type, _(term).pick(type));\n\n    if (_.has(term, 'cast')) {\n      result = 'cast(' + result + ' as ' + term.cast + ')';\n    }\n\n    if (_.has(term, 'alias')) {\n      result += ' ' + dialect.buildBlock('alias', {\n        alias: term.alias\n      });\n    }\n\n    return result;\n  });\n  dialect.blocks.add('table', function (params) {\n    return dialect.buildBlock('name', {\n      name: params.table\n    });\n  });\n  dialect.blocks.add('func', function (params) {\n    var func = params.func;\n    if (_.isString(func)) func = {\n      name: func\n    };\n\n    if (!_.isObject(func)) {\n      throw new Error('Invalid `func` property type \"' + typeof func + '\"');\n    }\n\n    if (!_.has(func, 'name')) {\n      throw new Error('`func.name` property is required');\n    }\n\n    var args = '';\n\n    if (_.isArray(func.args)) {\n      args = _(func.args).map(function (arg) {\n        return dialect.buildBlock('term', {\n          term: arg,\n          type: 'value'\n        });\n      }).join(', ');\n    }\n\n    return func.name + '(' + args + ')';\n  });\n  dialect.blocks.add('expression', function (params) {\n    var expression = params.expression;\n    if (_.isString(expression)) expression = {\n      pattern: expression\n    };\n\n    if (!_.isObject(expression)) {\n      throw new Error('Invalid `expression` property type \"' + typeof expression + '\"');\n    }\n\n    if (!_.has(expression, 'pattern')) {\n      throw new Error('`expression.pattern` property is required');\n    }\n\n    var values = expression.values || {};\n    return expression.pattern.replace(/\\{([a-z0-9]+)\\}/ig, function (fullMatch, block) {\n      if (!_.has(values, block)) {\n        throw new Error('Field `' + block + '` is required in `expression.values` property');\n      }\n\n      return dialect.buildBlock('term', {\n        term: values[block],\n        type: 'value'\n      });\n    }).trim();\n  });\n  dialect.blocks.add('field', function (params) {\n    var field = params.field;\n    if (_.isString(field)) field = {\n      name: field\n    };\n\n    if (!_.isObject(field)) {\n      throw new Error('Invalid `field` property type \"' + typeof field + '\"');\n    }\n\n    if (!_.has(field, 'name')) {\n      throw new Error('`field.name` property is required');\n    }\n\n    var result = dialect.buildBlock('name', {\n      name: field.name\n    });\n\n    if (_.has(field, 'table')) {\n      result = dialect.buildBlock('table', {\n        table: field.table\n      }) + '.' + result;\n    }\n\n    return result;\n  });\n  dialect.blocks.add('value', function (params) {\n    var value = params.value;\n    if (_.isRegExp(value)) value = value.source;\n    return dialect.builder._pushValue(value);\n  });\n  dialect.blocks.add('name', function (params) {\n    return dialect._wrapIdentifier(params.name);\n  });\n  dialect.blocks.add('alias', function (params) {\n    var alias = params.alias;\n    if (_.isString(alias)) alias = {\n      name: alias\n    };\n\n    if (!_.isObject(alias)) {\n      throw new Error('Invalid `alias` property type \"' + typeof alias + '\"');\n    }\n\n    if (!_.has(alias, 'name')) {\n      throw new Error('`alias.name` property is required');\n    }\n\n    var result = 'as ' + dialect._wrapIdentifier(alias.name);\n\n    if (_.isArray(alias.columns)) {\n      result += '(' + _(alias.columns).map(function (column) {\n        return dialect._wrapIdentifier(column);\n      }).join(', ') + ')';\n    }\n\n    return result;\n  });\n  dialect.blocks.add('condition', function (params) {\n    var result = dialect.buildCondition({\n      value: params.condition,\n      defaultFetchingOperator: '$value'\n    });\n\n    if (result) {\n      result = 'where ' + removeTopBrackets(result);\n    }\n\n    return result;\n  });\n  dialect.blocks.add('modifier', function (params) {\n    var result = dialect.buildModifier({\n      modifier: params.modifier\n    });\n\n    if (result) {\n      result = 'set ' + result;\n    }\n\n    return result;\n  });\n  dialect.blocks.add('join', function (params) {\n    var join = params.join;\n    var result = ''; // if join is array -> make each joinItem\n\n    if (_.isArray(join)) {\n      result = _(join).map(function (joinItem) {\n        return dialect.buildTemplate('joinItem', joinItem);\n      }).join(' '); // if join is object -> set table name from key and make each joinItem\n    } else if (_.isObject(join)) {\n      result = _(join).map(function (joinItem, table) {\n        if (!objectUtils.hasSome(joinItem, ['table', 'query', 'select', 'expression'])) {\n          joinItem = _.defaults({\n            table: table\n          }, joinItem);\n        }\n\n        return dialect.buildTemplate('joinItem', joinItem);\n      }).join(' ');\n    }\n\n    return result;\n  });\n  dialect.blocks.add('joinItem:type', function (params) {\n    return params.type.toLowerCase();\n  });\n  dialect.blocks.add('joinItem:on', function (params) {\n    // `on` block is use `$field` as default query operator because it most used case\n    var result = dialect.buildCondition({\n      value: params.on,\n      defaultFetchingOperator: '$field'\n    });\n\n    if (result) {\n      result = 'on ' + removeTopBrackets(result);\n    }\n\n    return result;\n  });\n  dialect.blocks.add('group', function (params) {\n    var group = params.group;\n    var result = '';\n    if (_.isString(group)) group = [group];\n\n    if (_.isArray(group)) {\n      result = _(group).map(function (field) {\n        return dialect.buildBlock('term', {\n          term: field,\n          type: 'field'\n        });\n      }).join(', ');\n    }\n\n    if (result) {\n      result = 'group by ' + result;\n    }\n\n    return result;\n  });\n  dialect.blocks.add('having', function (params) {\n    var result = dialect.buildCondition({\n      value: params.having,\n      defaultFetchingOperator: '$value'\n    });\n\n    if (result) {\n      result = 'having ' + removeTopBrackets(result);\n    }\n\n    return result;\n  });\n  dialect.blocks.add('sort', function (params) {\n    var sort = params.sort;\n    var result = '';\n    if (_.isString(sort)) sort = [sort];\n\n    if (_.isArray(sort)) {\n      result = _(sort).map(function (sortField) {\n        return dialect._wrapIdentifier(sortField);\n      }).join(', ');\n    } else if (_.isObject(sort)) {\n      result = _(sort).map(function (direction, field) {\n        return dialect._wrapIdentifier(field) + ' ' + (direction > 0 ? 'asc' : 'desc');\n      }).join(', ');\n    }\n\n    if (result) {\n      result = 'order by ' + result;\n    }\n\n    return result;\n  });\n  dialect.blocks.add('limit', function (params) {\n    return 'limit ' + dialect.builder._pushValue(params.limit);\n  });\n  dialect.blocks.add('offset', function (params) {\n    return 'offset ' + dialect.builder._pushValue(params.offset);\n  });\n  dialect.blocks.add('or', function (params) {\n    return 'or ' + params.or;\n  });\n  dialect.blocks.add('insert:values', function (params) {\n    var values = params.values;\n    if (!_.isArray(values)) values = [values];\n\n    var fields = params.fields || _(values).chain().map(function (row) {\n      return _(row).keys();\n    }).flatten().uniq().value();\n\n    return dialect.buildTemplate('insertValues', {\n      fields: fields,\n      values: _(values).map(function (row) {\n        return _(fields).map(function (field) {\n          return dialect.buildBlock('value', {\n            value: row[field]\n          });\n        });\n      })\n    });\n  });\n  dialect.blocks.add('insertValues:values', function (params) {\n    return _(params.values).map(function (row) {\n      return '(' + row.join(', ') + ')';\n    }).join(', ');\n  });\n  dialect.blocks.add('queryBody', function (params) {\n    var queryBody = params.queryBody || {};\n    return dialect.buildTemplate(queryBody.type || 'select', queryBody);\n  });\n  dialect.blocks.add('query', function (params) {\n    var templateParams = {\n      queryBody: params.query\n    };\n\n    if (params.query && params.query.type === 'union') {\n      templateParams.alias = params.query.alias;\n    }\n\n    return dialect.buildTemplate('subQuery', templateParams);\n  });\n  dialect.blocks.add('select', function (params) {\n    var templateParams = {\n      queryBody: params.select\n    };\n\n    if (params.select && params.select.type === 'union') {\n      templateParams.alias = params.select.alias;\n    }\n\n    return dialect.buildTemplate('subQuery', templateParams);\n  });\n  dialect.blocks.add('queries', function (params) {\n    return _(params.queries).map(function (query) {\n      return dialect.buildTemplate('query', {\n        queryBody: query\n      });\n    }).join(' ' + params.type + (params.all ? ' all' : '') + ' ');\n  });\n\n  function buildWith(withList) {\n    var result = ''; // if with clause is array -> make each withItem\n\n    if (_.isArray(withList)) {\n      result = _(withList).map(function (withItem) {\n        return dialect.buildTemplate('withItem', withItem);\n      }).join(', '); // if with clause is object -> set name from key and make each withItem\n    } else if (_.isObject(withList)) {\n      result = _(withList).map(function (withItem, name) {\n        if (!withItem.name) {\n          withItem = _.clone(withItem);\n          withItem.name = name;\n        }\n\n        return dialect.buildTemplate('withItem', withItem);\n      }).join(', ');\n    }\n\n    return result;\n  }\n\n  dialect.blocks.add('with', function (params) {\n    var result = buildWith(params['with']);\n    if (result) result = 'with ' + result;\n    return result;\n  });\n  dialect.blocks.add('withRecursive', function (params) {\n    var result = buildWith(params.withRecursive);\n    if (result) result = 'with recursive ' + result;\n    return result;\n  });\n  dialect.blocks.add('returning', function (params) {\n    var result = dialect.buildBlock('fields', {\n      fields: params.returning\n    });\n    if (result) result = 'returning ' + result;\n    return result;\n  });\n};","map":{"version":3,"sources":["D:/Postgres_workingFolder/QuaLISWeb/node_modules/json-sql/lib/dialects/base/blocks.js"],"names":["_","require","objectUtils","removeTopBrackets","condition","length","slice","termKeys","isTerm","obj","isObjectObject","hasSome","module","exports","dialect","blocks","add","params","fields","isObject","Error","isEmpty","isArray","map","field","isSimpleValue","has","buildBlock","term","type","name","isString","alias","defaults","compact","join","chain","pick","extend","object","value","find","key","result","cast","table","func","args","arg","expression","pattern","values","replace","fullMatch","block","trim","isRegExp","source","builder","_pushValue","_wrapIdentifier","columns","column","buildCondition","defaultFetchingOperator","buildModifier","modifier","joinItem","buildTemplate","toLowerCase","on","group","having","sort","sortField","direction","limit","offset","or","row","keys","flatten","uniq","queryBody","templateParams","query","select","queries","all","buildWith","withList","withItem","clone","withRecursive","returning"],"mappings":"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","sourcesContent":["'use strict';\n\nvar _ = require('underscore');\nvar objectUtils = require('../../utils/object');\n\nvar removeTopBrackets = function(condition) {\n\tif (condition.length && condition[0] === '(' &&\n\t\tcondition[condition.length - 1] === ')') {\n\t\tcondition = condition.slice(1, condition.length - 1);\n\t}\n\n\treturn condition;\n};\n\nvar termKeys = ['select', 'query', 'field', 'value', 'func', 'expression'];\nvar isTerm = function(obj) {\n\treturn objectUtils.isObjectObject(obj) && objectUtils.hasSome(obj, termKeys);\n};\n\nmodule.exports = function(dialect) {\n\tdialect.blocks.add('distinct', function() {\n\t\treturn 'distinct';\n\t});\n\n\tdialect.blocks.add('fields', function(params) {\n\t\tvar fields = params.fields || {};\n\n\t\tif (!_.isObject(fields)) {\n\t\t\tthrow new Error('Invalid `fields` property type \"' + (typeof fields) + '\"');\n\t\t}\n\n\t\tif (_.isEmpty(fields)) return '*';\n\n\t\t// If fields is array: ['a', {b: 'c'}, {name: '', table: 't', alias: 'r'}]\n\t\tif (_.isArray(fields)) {\n\t\t\tfields = _(fields).map(function(field) {\n\t\t\t\tif (objectUtils.isSimpleValue(field) || isTerm(field) || _.has(field, 'name')) {\n\t\t\t\t\t// if field has simple type or is field object: {name: '', table: 't', alias: 'r'}\n\t\t\t\t\treturn dialect.buildBlock('term', {term: field, type: 'field'});\n\t\t\t\t} else {\n\t\t\t\t\t// if field is non-field object: {b: 'c'}\n\t\t\t\t\treturn dialect.buildBlock('fields', {fields: field});\n\t\t\t\t}\n\t\t\t});\n\n\t\t// If fields is object: {a: 'u', b: {table: 't', alias: 'c'}}\n\t\t} else {\n\t\t\t// use keys as field names\n\t\t\tfields = _(fields).map(function(field, name) {\n\t\t\t\t// if field is not an object value, use it as alias\n\t\t\t\tif (_.isString(field)) field = {alias: field};\n\n\t\t\t\t// if field does not have name, get it from key\n\t\t\t\tif (!_.has(field, 'name')) field = _.defaults({name: name}, field);\n\n\t\t\t\treturn dialect.buildBlock('term', {term: field, type: 'field'});\n\t\t\t});\n\t\t}\n\n\t\treturn _(fields).compact().join(', ');\n\t});\n\n\tdialect.blocks.add('term', function(params) {\n\t\tvar term = params.term;\n\t\tvar type = params.type || 'field';\n\n\t\tvar isSimpleValue = objectUtils.isSimpleValue(term);\n\t\tvar isArray = _.isArray(term);\n\n\t\tif (isSimpleValue && !_.isString(term) || isArray) type = 'value';\n\n\t\tif (isSimpleValue || !isTerm(term) || isArray) {\n\t\t\tterm = _(term).chain().pick('cast', 'alias').extend(_.object([type], [term])).value();\n\t\t}\n\n\t\ttype = _(termKeys).find(function(key) {\n\t\t\treturn _.has(term, key);\n\t\t});\n\n\t\tvar result = dialect.buildBlock(type, _(term).pick(type));\n\n\t\tif (_.has(term, 'cast')) {\n\t\t\tresult = 'cast(' + result + ' as ' + term.cast + ')';\n\t\t}\n\n\t\tif (_.has(term, 'alias')) {\n\t\t\tresult += ' ' + dialect.buildBlock('alias', {alias: term.alias});\n\t\t}\n\n\t\treturn result;\n\t});\n\n\tdialect.blocks.add('table', function(params) {\n\t\treturn dialect.buildBlock('name', {name: params.table});\n\t});\n\n\tdialect.blocks.add('func', function(params) {\n\t\tvar func = params.func;\n\n\t\tif (_.isString(func)) func = {name: func};\n\n\t\tif (!_.isObject(func)) {\n\t\t\tthrow new Error('Invalid `func` property type \"' + (typeof func) + '\"');\n\t\t}\n\n\t\tif (!_.has(func, 'name')) {\n\t\t\tthrow new Error('`func.name` property is required');\n\t\t}\n\n\t\tvar args = '';\n\n\t\tif (_.isArray(func.args)) {\n\t\t\targs = _(func.args).map(function(arg) {\n\t\t\t\treturn dialect.buildBlock('term', {term: arg, type: 'value'});\n\t\t\t}).join(', ');\n\t\t}\n\n\t\treturn func.name + '(' + args + ')';\n\t});\n\n\tdialect.blocks.add('expression', function(params) {\n\t\tvar expression = params.expression;\n\n\t\tif (_.isString(expression)) expression = {pattern: expression};\n\n\t\tif (!_.isObject(expression)) {\n\t\t\tthrow new Error('Invalid `expression` property type \"' + (typeof expression) + '\"');\n\t\t}\n\n\t\tif (!_.has(expression, 'pattern')) {\n\t\t\tthrow new Error('`expression.pattern` property is required');\n\t\t}\n\n\t\tvar values = expression.values || {};\n\n\t\treturn expression.pattern.replace(/\\{([a-z0-9]+)\\}/ig, function(fullMatch, block) {\n\t\t\tif (!_.has(values, block)) {\n\t\t\t\tthrow new Error('Field `' + block + '` is required in `expression.values` property');\n\t\t\t}\n\n\t\t\treturn dialect.buildBlock('term', {term: values[block], type: 'value'});\n\t\t}).trim();\n\t});\n\n\tdialect.blocks.add('field', function(params) {\n\t\tvar field = params.field;\n\n\t\tif (_.isString(field)) field = {name: field};\n\n\t\tif (!_.isObject(field)) {\n\t\t\tthrow new Error('Invalid `field` property type \"' + (typeof field) + '\"');\n\t\t}\n\n\t\tif (!_.has(field, 'name')) {\n\t\t\tthrow new Error('`field.name` property is required');\n\t\t}\n\n\t\tvar result = dialect.buildBlock('name', {name: field.name});\n\n\t\tif (_.has(field, 'table')) {\n\t\t\tresult = dialect.buildBlock('table', {table: field.table}) + '.' + result;\n\t\t}\n\n\t\treturn result;\n\t});\n\n\tdialect.blocks.add('value', function(params) {\n\t\tvar value = params.value;\n\t\tif (_.isRegExp(value)) value = value.source;\n\t\treturn dialect.builder._pushValue(value);\n\t});\n\n\tdialect.blocks.add('name', function(params) {\n\t\treturn dialect._wrapIdentifier(params.name);\n\t});\n\n\tdialect.blocks.add('alias', function(params) {\n\t\tvar alias = params.alias;\n\n\t\tif (_.isString(alias)) alias = {name: alias};\n\n\t\tif (!_.isObject(alias)) {\n\t\t\tthrow new Error('Invalid `alias` property type \"' + (typeof alias) + '\"');\n\t\t}\n\t\tif (!_.has(alias, 'name')) {\n\t\t\tthrow new Error('`alias.name` property is required');\n\t\t}\n\n\t\tvar result = 'as ' + dialect._wrapIdentifier(alias.name);\n\n\t\tif (_.isArray(alias.columns)) {\n\t\t\tresult += '(' + _(alias.columns).map(function(column) {\n\t\t\t\treturn dialect._wrapIdentifier(column);\n\t\t\t}).join(', ') + ')';\n\t\t}\n\n\t\treturn result;\n\t});\n\n\tdialect.blocks.add('condition', function(params) {\n\t\tvar result = dialect.buildCondition({\n\t\t\tvalue: params.condition,\n\t\t\tdefaultFetchingOperator: '$value'\n\t\t});\n\n\t\tif (result) {\n\t\t\tresult = 'where ' + removeTopBrackets(result);\n\t\t}\n\n\t\treturn result;\n\t});\n\n\tdialect.blocks.add('modifier', function(params) {\n\t\tvar result = dialect.buildModifier({\n\t\t\tmodifier: params.modifier\n\t\t});\n\n\t\tif (result) {\n\t\t\tresult = 'set ' + result;\n\t\t}\n\n\t\treturn result;\n\t});\n\n\tdialect.blocks.add('join', function(params) {\n\t\tvar join = params.join;\n\t\tvar result = '';\n\n\t\t// if join is array -> make each joinItem\n\t\tif (_.isArray(join)) {\n\t\t\tresult = _(join).map(function(joinItem) {\n\t\t\t\treturn dialect.buildTemplate('joinItem', joinItem);\n\t\t\t}).join(' ');\n\n\t\t// if join is object -> set table name from key and make each joinItem\n\t\t} else if (_.isObject(join)) {\n\t\t\tresult = _(join).map(function(joinItem, table) {\n\t\t\t\tif (!objectUtils.hasSome(joinItem, ['table', 'query', 'select', 'expression'])) {\n\t\t\t\t\tjoinItem = _.defaults({table: table}, joinItem);\n\t\t\t\t}\n\n\t\t\t\treturn dialect.buildTemplate('joinItem', joinItem);\n\t\t\t}).join(' ');\n\t\t}\n\n\t\treturn result;\n\t});\n\n\tdialect.blocks.add('joinItem:type', function(params) {\n\t\treturn params.type.toLowerCase();\n\t});\n\n\tdialect.blocks.add('joinItem:on', function(params) {\n\t\t// `on` block is use `$field` as default query operator because it most used case\n\t\tvar result = dialect.buildCondition({\n\t\t\tvalue: params.on,\n\t\t\tdefaultFetchingOperator: '$field'\n\t\t});\n\n\t\tif (result) {\n\t\t\tresult = 'on ' + removeTopBrackets(result);\n\t\t}\n\n\t\treturn result;\n\t});\n\n\tdialect.blocks.add('group', function(params) {\n\t\tvar group = params.group;\n\t\tvar result = '';\n\n\t\tif (_.isString(group)) group = [group];\n\n\t\tif (_.isArray(group)) {\n\t\t\tresult = _(group).map(function(field) {\n\t\t\t\treturn dialect.buildBlock('term', {term: field, type: 'field'});\n\t\t\t}).join(', ');\n\t\t}\n\n\t\tif (result) {\n\t\t\tresult = 'group by ' + result;\n\t\t}\n\n\t\treturn result;\n\t});\n\n\tdialect.blocks.add('having', function(params) {\n\t\tvar result = dialect.buildCondition({\n\t\t\tvalue: params.having,\n\t\t\tdefaultFetchingOperator: '$value'\n\t\t});\n\n\t\tif (result) {\n\t\t\tresult = 'having ' + removeTopBrackets(result);\n\t\t}\n\n\t\treturn result;\n\t});\n\n\tdialect.blocks.add('sort', function(params) {\n\t\tvar sort = params.sort;\n\t\tvar result = '';\n\n\t\tif (_.isString(sort)) sort = [sort];\n\n\t\tif (_.isArray(sort)) {\n\t\t\tresult = _(sort).map(function(sortField) {\n\t\t\t\treturn dialect._wrapIdentifier(sortField);\n\t\t\t}).join(', ');\n\t\t} else if (_.isObject(sort)) {\n\t\t\tresult = _(sort).map(function(direction, field) {\n\t\t\t\treturn dialect._wrapIdentifier(field) + ' ' + (direction > 0 ? 'asc' : 'desc');\n\t\t\t}).join(', ');\n\t\t}\n\n\t\tif (result) {\n\t\t\tresult = 'order by ' + result;\n\t\t}\n\n\t\treturn result;\n\t});\n\n\tdialect.blocks.add('limit', function(params) {\n\t\treturn 'limit ' + dialect.builder._pushValue(params.limit);\n\t});\n\n\tdialect.blocks.add('offset', function(params) {\n\t\treturn 'offset ' + dialect.builder._pushValue(params.offset);\n\t});\n\n\tdialect.blocks.add('or', function(params) {\n\t\treturn 'or ' + params.or;\n\t});\n\n\tdialect.blocks.add('insert:values', function(params) {\n\t\tvar values = params.values;\n\n\t\tif (!_.isArray(values)) values = [values];\n\n\t\tvar fields = params.fields || _(values)\n\t\t\t.chain()\n\t\t\t.map(function(row) {\n\t\t\t\treturn _(row).keys();\n\t\t\t})\n\t\t\t.flatten()\n\t\t\t.uniq()\n\t\t\t.value();\n\n\t\treturn dialect.buildTemplate('insertValues', {\n\t\t\tfields: fields,\n\t\t\tvalues: _(values).map(function(row) {\n\t\t\t\treturn _(fields).map(function(field) {\n\t\t\t\t\treturn dialect.buildBlock('value', {value: row[field]});\n\t\t\t\t});\n\t\t\t})\n\t\t});\n\t});\n\n\tdialect.blocks.add('insertValues:values', function(params) {\n\t\treturn _(params.values).map(function(row) {\n\t\t\treturn '(' + row.join(', ') + ')';\n\t\t}).join(', ');\n\t});\n\n\tdialect.blocks.add('queryBody', function(params) {\n\t\tvar queryBody = params.queryBody || {};\n\n\t\treturn dialect.buildTemplate(queryBody.type || 'select', queryBody);\n\t});\n\n\tdialect.blocks.add('query', function(params) {\n\t\tvar templateParams = {\n\t\t\tqueryBody: params.query\n\t\t};\n\t\tif (params.query && params.query.type === 'union') {\n\t\t\ttemplateParams.alias = params.query.alias;\n\t\t}\n\n\t\treturn dialect.buildTemplate('subQuery', templateParams);\n\t});\n\n\tdialect.blocks.add('select', function(params) {\n\t\tvar templateParams = {\n\t\t\tqueryBody: params.select\n\t\t};\n\t\tif (params.select && params.select.type === 'union') {\n\t\t\ttemplateParams.alias = params.select.alias;\n\t\t}\n\n\t\treturn dialect.buildTemplate('subQuery', templateParams);\n\t});\n\n\tdialect.blocks.add('queries', function(params) {\n\t\treturn _(params.queries).map(function(query) {\n\t\t\treturn dialect.buildTemplate('query', {queryBody: query});\n\t\t}).join(' ' + params.type + (params.all ? ' all' : '') + ' ');\n\t});\n\n\tfunction buildWith(withList) {\n\t\tvar result = '';\n\n\t\t// if with clause is array -> make each withItem\n\t\tif (_.isArray(withList)) {\n\t\t\tresult = _(withList).map(function(withItem) {\n\t\t\t\treturn dialect.buildTemplate('withItem', withItem);\n\t\t\t}).join(', ');\n\n\t\t// if with clause is object -> set name from key and make each withItem\n\t\t} else if (_.isObject(withList)) {\n\t\t\tresult = _(withList).map(function(withItem, name) {\n\t\t\t\tif (!withItem.name) {\n\t\t\t\t\twithItem = _.clone(withItem);\n\t\t\t\t\twithItem.name = name;\n\t\t\t\t}\n\t\t\t\treturn dialect.buildTemplate('withItem', withItem);\n\t\t\t}).join(', ');\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tdialect.blocks.add('with', function(params) {\n\t\tvar result = buildWith(params['with']);\n\n\t\tif (result) result = 'with ' + result;\n\n\t\treturn result;\n\t});\n\n\tdialect.blocks.add('withRecursive', function(params) {\n\t\tvar result = buildWith(params.withRecursive);\n\n\t\tif (result) result = 'with recursive ' + result;\n\n\t\treturn result;\n\t});\n\n\tdialect.blocks.add('returning', function(params) {\n\t\tvar result = dialect.buildBlock('fields', {fields: params.returning});\n\n\t\tif (result) result = 'returning ' + result;\n\n\t\treturn result;\n\t});\n};\n"]},"metadata":{},"sourceType":"script"}