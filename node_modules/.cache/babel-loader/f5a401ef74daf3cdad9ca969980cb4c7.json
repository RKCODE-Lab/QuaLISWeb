{"ast":null,"code":"import { DOMSerializer, DOMParser as ProseMirrorDOMParser } from 'prosemirror-model';\nimport { AllSelection } from 'prosemirror-state';\nvar blockWrappers = ['div', 'ol', 'ul', 'li', 'table', 'tbody', 'thead', 'tfoot', 'td', 'th', 'p', 'tr', 'col', 'colgroup', 'article', 'main', 'nav', 'header', 'footer', 'aside', 'section'];\n/**\n * Trims the whitespace around the provided block nodes.\n *\n * @param html - Input HTML content\n * @param trimAroundTags - Block elements to which trimming will be applied.\n * Defaults to block nodes of the current default schema:\n * 'div', 'ol', 'ul', 'li', 'table', 'tbody', 'thead', 'tfoot', 'td', 'th', 'p'\n * and additional table and semantic nodes from the default Angular Editor schema:\n * 'tr', 'col', 'colgroup', 'article', 'main', 'nav', 'header', 'footer', 'aside', 'section'\n *\n * @returns The trimmed HTML content\n */\n\nexport var trimWhitespace = function (html, trimAroundTags) {\n  if (trimAroundTags === void 0) {\n    trimAroundTags = blockWrappers;\n  }\n\n  var tags = trimAroundTags.join('|');\n  return html.replace(new RegExp('\\\\s*(<(?:' + tags + ')(?:\\\\s[^>]*?)?>)', 'g'), '$1').replace(new RegExp('(<\\\\/(?:' + tags + ')(?:\\\\s[^>]*?)?>)\\\\s*', 'g'), '$1');\n};\n/**\n * Creates a DocumentFragment from the given HTML content.\n *\n * @param html\n * @returns DocumentFragment\n */\n\nexport var htmlToFragment = function (html) {\n  var template = document.createElement('template');\n  var fragment;\n\n  if ('content' in template) {\n    template.innerHTML = html;\n    fragment = template.content;\n  } else {\n    // Internet Explorer\n    var parsedDocument = new DOMParser().parseFromString(html, 'text/html');\n    fragment = document.createDocumentFragment();\n    var dom = parsedDocument.body;\n\n    while (dom && dom.firstChild) {\n      fragment.appendChild(dom.firstChild);\n    }\n  }\n\n  return fragment;\n};\n/**\n * Creates a DocumentFragment from the given ProseMirrorNode.\n * @param doc ProseMirrorNode\n * @returns DocumentFragment\n */\n\nexport var pmDocToFragment = function (doc) {\n  return DOMSerializer.fromSchema(doc.type.schema).serializeFragment(doc.content);\n};\n/**\n * Creates a ProseMirrorNode from the given DOM element.\n *\n * @param dom\n * @param schema\n * @param parseOptions\n * @returns ProseMirrorNode\n */\n\nexport var domToPmDoc = function (dom, schema, parseOptions) {\n  return ProseMirrorDOMParser.fromSchema(schema).parse(dom, parseOptions);\n};\n/**\n * Creates a ProseMirrorNode from the given HTML content.\n *\n * @param content - The new HTML content.\n * @param schema - The document schema.\n * @param parseOptions - ProseMirror parse options recognized by the `parse` and `parseSlice` methods.\n * @returns - New ProseMirrorNode instance.\n */\n\nexport var parseContent = function (content, schema, parseOptions) {\n  var dom = htmlToFragment(content);\n  return domToPmDoc(dom, schema, parseOptions);\n};\n/**\n * A function that serializes the Editor State content as HTML string.\n *\n * @param state - The Editor State\n * @returns - The serialized content\n */\n\nexport var getHtml = function (state) {\n  var fragment = pmDocToFragment(state.doc);\n  var container = document.createElement('div');\n  container.appendChild(fragment);\n  return container.innerHTML;\n};\n/**\n * Replaces the content of the editor with a new one.\n *\n * @param content - The new HTML content.\n * @param commandName - The name of the command.\n * @param parseOptions - ProseMirror parse options recognized by the `parse` and `parseSlice` methods.\n * @returns - Command function that takes an editor `state` and `dispatch` function.\n */\n\nexport var setHtml = function (content, command, parseOptions) {\n  if (command === void 0) {\n    command = 'setHTML';\n  }\n\n  if (parseOptions === void 0) {\n    parseOptions = {\n      preserveWhitespace: 'full'\n    };\n  }\n\n  return function (state, dispatch) {\n    return dispatch(state.tr.setSelection(new AllSelection(state.doc)).replaceSelectionWith(parseContent(content, state.schema, parseOptions)).setMeta('commandName', command));\n  };\n};","map":{"version":3,"sources":["D:/Postgres_workingFolder/QuaLISWeb/node_modules/@progress/kendo-editor-common/dist/es/source.js"],"names":["DOMSerializer","DOMParser","ProseMirrorDOMParser","AllSelection","blockWrappers","trimWhitespace","html","trimAroundTags","tags","join","replace","RegExp","htmlToFragment","template","document","createElement","fragment","innerHTML","content","parsedDocument","parseFromString","createDocumentFragment","dom","body","firstChild","appendChild","pmDocToFragment","doc","fromSchema","type","schema","serializeFragment","domToPmDoc","parseOptions","parse","parseContent","getHtml","state","container","setHtml","command","preserveWhitespace","dispatch","tr","setSelection","replaceSelectionWith","setMeta"],"mappings":"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","sourcesContent":["import { DOMSerializer, DOMParser as ProseMirrorDOMParser } from 'prosemirror-model';\nimport { AllSelection } from 'prosemirror-state';\nvar blockWrappers = [\n    'div', 'ol', 'ul', 'li', 'table', 'tbody', 'thead', 'tfoot', 'td', 'th', 'p',\n    'tr', 'col', 'colgroup', 'article', 'main', 'nav', 'header', 'footer', 'aside', 'section'\n];\n/**\n * Trims the whitespace around the provided block nodes.\n *\n * @param html - Input HTML content\n * @param trimAroundTags - Block elements to which trimming will be applied.\n * Defaults to block nodes of the current default schema:\n * 'div', 'ol', 'ul', 'li', 'table', 'tbody', 'thead', 'tfoot', 'td', 'th', 'p'\n * and additional table and semantic nodes from the default Angular Editor schema:\n * 'tr', 'col', 'colgroup', 'article', 'main', 'nav', 'header', 'footer', 'aside', 'section'\n *\n * @returns The trimmed HTML content\n */\nexport var trimWhitespace = function (html, trimAroundTags) {\n    if (trimAroundTags === void 0) { trimAroundTags = blockWrappers; }\n    var tags = trimAroundTags.join('|');\n    return html.replace(new RegExp('\\\\s*(<(?:' + tags + ')(?:\\\\s[^>]*?)?>)', 'g'), '$1')\n        .replace(new RegExp('(<\\\\/(?:' + tags + ')(?:\\\\s[^>]*?)?>)\\\\s*', 'g'), '$1');\n};\n/**\n * Creates a DocumentFragment from the given HTML content.\n *\n * @param html\n * @returns DocumentFragment\n */\nexport var htmlToFragment = function (html) {\n    var template = document.createElement('template');\n    var fragment;\n    if ('content' in template) {\n        template.innerHTML = html;\n        fragment = template.content;\n    }\n    else {\n        // Internet Explorer\n        var parsedDocument = new DOMParser().parseFromString(html, 'text/html');\n        fragment = document.createDocumentFragment();\n        var dom = parsedDocument.body;\n        while (dom && dom.firstChild) {\n            fragment.appendChild(dom.firstChild);\n        }\n    }\n    return fragment;\n};\n/**\n * Creates a DocumentFragment from the given ProseMirrorNode.\n * @param doc ProseMirrorNode\n * @returns DocumentFragment\n */\nexport var pmDocToFragment = function (doc) {\n    return DOMSerializer.fromSchema(doc.type.schema).serializeFragment(doc.content);\n};\n/**\n * Creates a ProseMirrorNode from the given DOM element.\n *\n * @param dom\n * @param schema\n * @param parseOptions\n * @returns ProseMirrorNode\n */\nexport var domToPmDoc = function (dom, schema, parseOptions) {\n    return ProseMirrorDOMParser.fromSchema(schema).parse(dom, parseOptions);\n};\n/**\n * Creates a ProseMirrorNode from the given HTML content.\n *\n * @param content - The new HTML content.\n * @param schema - The document schema.\n * @param parseOptions - ProseMirror parse options recognized by the `parse` and `parseSlice` methods.\n * @returns - New ProseMirrorNode instance.\n */\nexport var parseContent = function (content, schema, parseOptions) {\n    var dom = htmlToFragment(content);\n    return domToPmDoc(dom, schema, parseOptions);\n};\n/**\n * A function that serializes the Editor State content as HTML string.\n *\n * @param state - The Editor State\n * @returns - The serialized content\n */\nexport var getHtml = function (state) {\n    var fragment = pmDocToFragment(state.doc);\n    var container = document.createElement('div');\n    container.appendChild(fragment);\n    return container.innerHTML;\n};\n/**\n * Replaces the content of the editor with a new one.\n *\n * @param content - The new HTML content.\n * @param commandName - The name of the command.\n * @param parseOptions - ProseMirror parse options recognized by the `parse` and `parseSlice` methods.\n * @returns - Command function that takes an editor `state` and `dispatch` function.\n */\nexport var setHtml = function (content, command, parseOptions) {\n    if (command === void 0) { command = 'setHTML'; }\n    if (parseOptions === void 0) { parseOptions = { preserveWhitespace: 'full' }; }\n    return function (state, dispatch) {\n        return dispatch(state.tr\n            .setSelection(new AllSelection(state.doc))\n            .replaceSelectionWith(parseContent(content, state.schema, parseOptions))\n            .setMeta('commandName', command));\n    };\n};\n"]},"metadata":{},"sourceType":"module"}