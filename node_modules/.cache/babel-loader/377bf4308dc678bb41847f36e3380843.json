{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.sqlFormat = void 0;\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _configUtils = require(\"../utils/configUtils\");\n\nvar _ruleUtils = require(\"../utils/ruleUtils\");\n\nvar _omit = _interopRequireDefault(require(\"lodash/omit\"));\n\nvar _pick = _interopRequireDefault(require(\"lodash/pick\"));\n\nvar _stuff = require(\"../utils/stuff\");\n\nvar _defaultUtils = require(\"../utils/defaultUtils\");\n\nvar _default = require(\"../config/default\");\n\nvar _funcUtils = require(\"../utils/funcUtils\");\n\nvar _immutable = require(\"immutable\");\n\nvar _sql = require(\"../utils/sql\");\n\nvar sqlFormat = function sqlFormat(tree, config) {\n  //meta is mutable\n  var meta = {\n    errors: []\n  };\n  var res = formatItem(tree, config, meta);\n  if (meta.errors.length) console.warn(\"Errors while exporting to SQL:\", meta.errors);\n  return res;\n};\n\nexports.sqlFormat = sqlFormat;\n\nvar formatItem = function formatItem(item, config, meta) {\n  if (!item) return undefined;\n  var type = item.get(\"type\");\n  var children = item.get(\"children1\");\n\n  if ((type === \"group\" || type === \"rule_group\") && children && children.size) {\n    return formatGroup(item, config, meta);\n  } else if (type === \"rule\") {\n    return formatRule(item, config, meta);\n  }\n\n  return undefined;\n};\n\nvar formatGroup = function formatGroup(item, config, meta) {\n  var type = item.get(\"type\");\n  var properties = item.get(\"properties\") || new _immutable.Map();\n  var children = item.get(\"children1\");\n  var groupField = type === \"rule_group\" ? properties.get(\"field\") : null;\n  var groupFieldDef = (0, _configUtils.getFieldConfig)(config, groupField) || {};\n\n  if (groupFieldDef.mode == \"array\") {\n    meta.errors.push(\"Aggregation is not supported for \".concat(groupField));\n  }\n\n  var not = properties.get(\"not\");\n  var list = children.map(function (currentChild) {\n    return formatItem(currentChild, config, meta);\n  }).filter(function (currentChild) {\n    return typeof currentChild !== \"undefined\";\n  });\n  if (!list.size) return undefined;\n  var conjunction = properties.get(\"conjunction\");\n  if (!conjunction) conjunction = (0, _defaultUtils.defaultConjunction)(config);\n  var conjunctionDefinition = config.conjunctions[conjunction];\n  return conjunctionDefinition.sqlFormatConj(list, conjunction, not);\n};\n\nvar formatRule = function formatRule(item, config, meta) {\n  var properties = item.get(\"properties\") || new _immutable.Map();\n  var field = properties.get(\"field\");\n  var operator = properties.get(\"operator\");\n  var operatorOptions = properties.get(\"operatorOptions\");\n  var iValueSrc = properties.get(\"valueSrc\");\n  var iValueType = properties.get(\"valueType\");\n  var iValue = properties.get(\"value\");\n  if (field == null || operator == null) return undefined;\n  var fieldDefinition = (0, _configUtils.getFieldConfig)(config, field) || {};\n  var operatorDefinition = (0, _configUtils.getOperatorConfig)(config, operator, field) || {};\n  var reversedOp = operatorDefinition.reversedOp;\n  var revOperatorDefinition = (0, _configUtils.getOperatorConfig)(config, reversedOp, field) || {};\n  var cardinality = (0, _stuff.defaultValue)(operatorDefinition.cardinality, 1); //format value\n\n  var valueSrcs = [];\n  var valueTypes = [];\n  var fvalue = iValue.map(function (currentValue, ind) {\n    var valueSrc = iValueSrc ? iValueSrc.get(ind) : null;\n    var valueType = iValueType ? iValueType.get(ind) : null;\n    var cValue = (0, _funcUtils.completeValue)(currentValue, valueSrc, config);\n    var widget = (0, _ruleUtils.getWidgetForFieldOp)(config, field, operator, valueSrc);\n    var fieldWidgetDefinition = (0, _omit[\"default\"])((0, _configUtils.getFieldWidgetConfig)(config, field, operator, widget, valueSrc), [\"factory\"]);\n    var fv = formatValue(meta, config, cValue, valueSrc, valueType, fieldWidgetDefinition, fieldDefinition, operator, operatorDefinition);\n\n    if (fv !== undefined) {\n      valueSrcs.push(valueSrc);\n      valueTypes.push(valueType);\n    }\n\n    return fv;\n  });\n  var hasUndefinedValues = fvalue.filter(function (v) {\n    return v === undefined;\n  }).size > 0;\n  if (hasUndefinedValues || fvalue.size < cardinality) return undefined;\n  var formattedValue = cardinality == 1 ? fvalue.first() : fvalue; //find fn to format expr\n\n  var isRev = false;\n  var fn = operatorDefinition.sqlFormatOp;\n\n  if (!fn && reversedOp) {\n    fn = revOperatorDefinition.sqlFormatOp;\n\n    if (fn) {\n      isRev = true;\n    }\n  }\n\n  if (!fn) {\n    var sqlOp = operatorDefinition.sqlOp || operator;\n\n    if (cardinality == 0) {\n      fn = function fn(field, op, values, valueSrc, valueType, opDef, operatorOptions) {\n        return \"\".concat(field, \" \").concat(sqlOp);\n      };\n    } else if (cardinality == 1) {\n      fn = function fn(field, op, value, valueSrc, valueType, opDef, operatorOptions) {\n        return \"\".concat(field, \" \").concat(sqlOp, \" \").concat(value);\n      };\n    } else if (cardinality == 2) {\n      // between\n      fn = function fn(field, op, values, valueSrc, valueType, opDef, operatorOptions) {\n        var valFrom = values.first();\n        var valTo = values.get(1);\n        return \"\".concat(field, \" \").concat(sqlOp, \" \").concat(valFrom, \" AND \").concat(valTo);\n      };\n    }\n  }\n\n  if (!fn) {\n    meta.errors.push(\"Operator \".concat(operator, \" is not supported\"));\n    return undefined;\n  } //format field\n\n\n  var formattedField = formatField(meta, config, field); //format expr\n\n  var args = [formattedField, operator, formattedValue, valueSrcs.length > 1 ? valueSrcs : valueSrcs[0], valueTypes.length > 1 ? valueTypes : valueTypes[0], (0, _omit[\"default\"])(operatorDefinition, [\"formatOp\", \"mongoFormatOp\", \"sqlFormatOp\", \"jsonLogic\"]), operatorOptions];\n  var ret = fn.apply(void 0, args);\n\n  if (isRev) {\n    ret = config.settings.sqlFormatReverse(ret, operator, reversedOp, operatorDefinition, revOperatorDefinition);\n  }\n\n  return ret;\n};\n\nvar formatValue = function formatValue(meta, config, currentValue, valueSrc, valueType, fieldWidgetDef, fieldDef, operator, operatorDef) {\n  if (currentValue === undefined) return undefined;\n  var ret;\n\n  if (valueSrc == \"field\") {\n    ret = formatField(meta, config, currentValue);\n  } else if (valueSrc == \"func\") {\n    ret = formatFunc(meta, config, currentValue);\n  } else {\n    if (typeof fieldWidgetDef.sqlFormatValue === \"function\") {\n      var fn = fieldWidgetDef.sqlFormatValue;\n      var args = [currentValue, (0, _pick[\"default\"])(fieldDef, [\"fieldSettings\", \"listValues\"]), //useful options: valueFormat for date/time\n      (0, _omit[\"default\"])(fieldWidgetDef, [\"formatValue\", \"mongoFormatValue\", \"sqlFormatValue\", \"jsonLogic\", \"elasticSearchFormatValue\"])];\n\n      if (operator) {\n        args.push(operator);\n        args.push(operatorDef);\n      }\n\n      if (valueSrc == \"field\") {\n        var valFieldDefinition = (0, _configUtils.getFieldConfig)(config, currentValue) || {};\n        args.push(valFieldDefinition);\n      }\n\n      ret = fn.apply(void 0, args);\n    } else {\n      ret = _sql.SqlString.escape(currentValue);\n    }\n  }\n\n  return ret;\n};\n\nvar formatField = function formatField(meta, config, field) {\n  var fieldSeparator = config.settings.fieldSeparator;\n  var fieldDefinition = (0, _configUtils.getFieldConfig)(config, field) || {};\n  var fieldParts = Array.isArray(field) ? field : field.split(fieldSeparator);\n\n  var _fieldKeys = (0, _ruleUtils.getFieldPath)(field, config);\n\n  var fieldPartsLabels = (0, _ruleUtils.getFieldPathLabels)(field, config);\n  var fieldFullLabel = fieldPartsLabels ? fieldPartsLabels.join(fieldSeparator) : null;\n  var formatFieldFn = config.settings.formatField || _default.settings.formatField;\n  var fieldName = (0, _ruleUtils.formatFieldName)(field, config, meta);\n  var formattedField = formatFieldFn(fieldName, fieldParts, fieldFullLabel, fieldDefinition, config);\n  return formattedField;\n};\n\nvar formatFunc = function formatFunc(meta, config, currentValue) {\n  var funcKey = currentValue.get(\"func\");\n  var args = currentValue.get(\"args\");\n  var funcConfig = (0, _configUtils.getFuncConfig)(config, funcKey);\n  var funcName = funcConfig.sqlFunc || funcKey;\n  var formattedArgs = {};\n\n  for (var argKey in funcConfig.args) {\n    var argConfig = funcConfig.args[argKey];\n    var fieldDef = (0, _configUtils.getFieldConfig)(config, argConfig);\n    var argVal = args ? args.get(argKey) : undefined;\n    var argValue = argVal ? argVal.get(\"value\") : undefined;\n    var argValueSrc = argVal ? argVal.get(\"valueSrc\") : undefined;\n    var formattedArgVal = formatValue(meta, config, argValue, argValueSrc, argConfig.type, fieldDef, argConfig, null, null);\n\n    if (argValue != undefined && formattedArgVal === undefined) {\n      meta.errors.push(\"Can't format value of arg \".concat(argKey, \" for func \").concat(funcKey));\n      return undefined;\n    }\n\n    if (formattedArgVal !== undefined) {\n      // skip optional in the end\n      formattedArgs[argKey] = formattedArgVal;\n    }\n  }\n\n  var ret;\n\n  if (typeof funcConfig.sqlFormatFunc === \"function\") {\n    var fn = funcConfig.sqlFormatFunc;\n    var _args = [formattedArgs];\n    ret = fn.apply(void 0, _args);\n  } else {\n    var argsStr = Object.entries(formattedArgs).map(function (_ref) {\n      var _ref2 = (0, _slicedToArray2[\"default\"])(_ref, 2),\n          k = _ref2[0],\n          v = _ref2[1];\n\n      return v;\n    }).join(\", \");\n    ret = \"\".concat(funcName, \"(\").concat(argsStr, \")\");\n  }\n\n  return ret;\n};","map":{"version":3,"sources":["D:/node_modules/react-awesome-query-builder/lib/export/sql.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","sqlFormat","_slicedToArray2","_configUtils","_ruleUtils","_omit","_pick","_stuff","_defaultUtils","_default","_funcUtils","_immutable","_sql","tree","config","meta","errors","res","formatItem","length","console","warn","item","undefined","type","get","children","size","formatGroup","formatRule","properties","Map","groupField","groupFieldDef","getFieldConfig","mode","push","concat","not","list","map","currentChild","filter","conjunction","defaultConjunction","conjunctionDefinition","conjunctions","sqlFormatConj","field","operator","operatorOptions","iValueSrc","iValueType","iValue","fieldDefinition","operatorDefinition","getOperatorConfig","reversedOp","revOperatorDefinition","cardinality","defaultValue","valueSrcs","valueTypes","fvalue","currentValue","ind","valueSrc","valueType","cValue","completeValue","widget","getWidgetForFieldOp","fieldWidgetDefinition","getFieldWidgetConfig","fv","formatValue","hasUndefinedValues","v","formattedValue","first","isRev","fn","sqlFormatOp","sqlOp","op","values","opDef","valFrom","valTo","formattedField","formatField","args","ret","apply","settings","sqlFormatReverse","fieldWidgetDef","fieldDef","operatorDef","formatFunc","sqlFormatValue","valFieldDefinition","SqlString","escape","fieldSeparator","fieldParts","Array","isArray","split","_fieldKeys","getFieldPath","fieldPartsLabels","getFieldPathLabels","fieldFullLabel","join","formatFieldFn","fieldName","formatFieldName","funcKey","funcConfig","getFuncConfig","funcName","sqlFunc","formattedArgs","argKey","argConfig","argVal","argValue","argValueSrc","formattedArgVal","sqlFormatFunc","_args","argsStr","entries","_ref","_ref2","k"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.sqlFormat = void 0;\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _configUtils = require(\"../utils/configUtils\");\n\nvar _ruleUtils = require(\"../utils/ruleUtils\");\n\nvar _omit = _interopRequireDefault(require(\"lodash/omit\"));\n\nvar _pick = _interopRequireDefault(require(\"lodash/pick\"));\n\nvar _stuff = require(\"../utils/stuff\");\n\nvar _defaultUtils = require(\"../utils/defaultUtils\");\n\nvar _default = require(\"../config/default\");\n\nvar _funcUtils = require(\"../utils/funcUtils\");\n\nvar _immutable = require(\"immutable\");\n\nvar _sql = require(\"../utils/sql\");\n\nvar sqlFormat = function sqlFormat(tree, config) {\n  //meta is mutable\n  var meta = {\n    errors: []\n  };\n  var res = formatItem(tree, config, meta);\n  if (meta.errors.length) console.warn(\"Errors while exporting to SQL:\", meta.errors);\n  return res;\n};\n\nexports.sqlFormat = sqlFormat;\n\nvar formatItem = function formatItem(item, config, meta) {\n  if (!item) return undefined;\n  var type = item.get(\"type\");\n  var children = item.get(\"children1\");\n\n  if ((type === \"group\" || type === \"rule_group\") && children && children.size) {\n    return formatGroup(item, config, meta);\n  } else if (type === \"rule\") {\n    return formatRule(item, config, meta);\n  }\n\n  return undefined;\n};\n\nvar formatGroup = function formatGroup(item, config, meta) {\n  var type = item.get(\"type\");\n  var properties = item.get(\"properties\") || new _immutable.Map();\n  var children = item.get(\"children1\");\n  var groupField = type === \"rule_group\" ? properties.get(\"field\") : null;\n  var groupFieldDef = (0, _configUtils.getFieldConfig)(config, groupField) || {};\n\n  if (groupFieldDef.mode == \"array\") {\n    meta.errors.push(\"Aggregation is not supported for \".concat(groupField));\n  }\n\n  var not = properties.get(\"not\");\n  var list = children.map(function (currentChild) {\n    return formatItem(currentChild, config, meta);\n  }).filter(function (currentChild) {\n    return typeof currentChild !== \"undefined\";\n  });\n  if (!list.size) return undefined;\n  var conjunction = properties.get(\"conjunction\");\n  if (!conjunction) conjunction = (0, _defaultUtils.defaultConjunction)(config);\n  var conjunctionDefinition = config.conjunctions[conjunction];\n  return conjunctionDefinition.sqlFormatConj(list, conjunction, not);\n};\n\nvar formatRule = function formatRule(item, config, meta) {\n  var properties = item.get(\"properties\") || new _immutable.Map();\n  var field = properties.get(\"field\");\n  var operator = properties.get(\"operator\");\n  var operatorOptions = properties.get(\"operatorOptions\");\n  var iValueSrc = properties.get(\"valueSrc\");\n  var iValueType = properties.get(\"valueType\");\n  var iValue = properties.get(\"value\");\n  if (field == null || operator == null) return undefined;\n  var fieldDefinition = (0, _configUtils.getFieldConfig)(config, field) || {};\n  var operatorDefinition = (0, _configUtils.getOperatorConfig)(config, operator, field) || {};\n  var reversedOp = operatorDefinition.reversedOp;\n  var revOperatorDefinition = (0, _configUtils.getOperatorConfig)(config, reversedOp, field) || {};\n  var cardinality = (0, _stuff.defaultValue)(operatorDefinition.cardinality, 1); //format value\n\n  var valueSrcs = [];\n  var valueTypes = [];\n  var fvalue = iValue.map(function (currentValue, ind) {\n    var valueSrc = iValueSrc ? iValueSrc.get(ind) : null;\n    var valueType = iValueType ? iValueType.get(ind) : null;\n    var cValue = (0, _funcUtils.completeValue)(currentValue, valueSrc, config);\n    var widget = (0, _ruleUtils.getWidgetForFieldOp)(config, field, operator, valueSrc);\n    var fieldWidgetDefinition = (0, _omit[\"default\"])((0, _configUtils.getFieldWidgetConfig)(config, field, operator, widget, valueSrc), [\"factory\"]);\n    var fv = formatValue(meta, config, cValue, valueSrc, valueType, fieldWidgetDefinition, fieldDefinition, operator, operatorDefinition);\n\n    if (fv !== undefined) {\n      valueSrcs.push(valueSrc);\n      valueTypes.push(valueType);\n    }\n\n    return fv;\n  });\n  var hasUndefinedValues = fvalue.filter(function (v) {\n    return v === undefined;\n  }).size > 0;\n  if (hasUndefinedValues || fvalue.size < cardinality) return undefined;\n  var formattedValue = cardinality == 1 ? fvalue.first() : fvalue; //find fn to format expr\n\n  var isRev = false;\n  var fn = operatorDefinition.sqlFormatOp;\n\n  if (!fn && reversedOp) {\n    fn = revOperatorDefinition.sqlFormatOp;\n\n    if (fn) {\n      isRev = true;\n    }\n  }\n\n  if (!fn) {\n    var sqlOp = operatorDefinition.sqlOp || operator;\n\n    if (cardinality == 0) {\n      fn = function fn(field, op, values, valueSrc, valueType, opDef, operatorOptions) {\n        return \"\".concat(field, \" \").concat(sqlOp);\n      };\n    } else if (cardinality == 1) {\n      fn = function fn(field, op, value, valueSrc, valueType, opDef, operatorOptions) {\n        return \"\".concat(field, \" \").concat(sqlOp, \" \").concat(value);\n      };\n    } else if (cardinality == 2) {\n      // between\n      fn = function fn(field, op, values, valueSrc, valueType, opDef, operatorOptions) {\n        var valFrom = values.first();\n        var valTo = values.get(1);\n        return \"\".concat(field, \" \").concat(sqlOp, \" \").concat(valFrom, \" AND \").concat(valTo);\n      };\n    }\n  }\n\n  if (!fn) {\n    meta.errors.push(\"Operator \".concat(operator, \" is not supported\"));\n    return undefined;\n  } //format field\n\n\n  var formattedField = formatField(meta, config, field); //format expr\n\n  var args = [formattedField, operator, formattedValue, valueSrcs.length > 1 ? valueSrcs : valueSrcs[0], valueTypes.length > 1 ? valueTypes : valueTypes[0], (0, _omit[\"default\"])(operatorDefinition, [\"formatOp\", \"mongoFormatOp\", \"sqlFormatOp\", \"jsonLogic\"]), operatorOptions];\n  var ret = fn.apply(void 0, args);\n\n  if (isRev) {\n    ret = config.settings.sqlFormatReverse(ret, operator, reversedOp, operatorDefinition, revOperatorDefinition);\n  }\n\n  return ret;\n};\n\nvar formatValue = function formatValue(meta, config, currentValue, valueSrc, valueType, fieldWidgetDef, fieldDef, operator, operatorDef) {\n  if (currentValue === undefined) return undefined;\n  var ret;\n\n  if (valueSrc == \"field\") {\n    ret = formatField(meta, config, currentValue);\n  } else if (valueSrc == \"func\") {\n    ret = formatFunc(meta, config, currentValue);\n  } else {\n    if (typeof fieldWidgetDef.sqlFormatValue === \"function\") {\n      var fn = fieldWidgetDef.sqlFormatValue;\n      var args = [currentValue, (0, _pick[\"default\"])(fieldDef, [\"fieldSettings\", \"listValues\"]), //useful options: valueFormat for date/time\n      (0, _omit[\"default\"])(fieldWidgetDef, [\"formatValue\", \"mongoFormatValue\", \"sqlFormatValue\", \"jsonLogic\", \"elasticSearchFormatValue\"])];\n\n      if (operator) {\n        args.push(operator);\n        args.push(operatorDef);\n      }\n\n      if (valueSrc == \"field\") {\n        var valFieldDefinition = (0, _configUtils.getFieldConfig)(config, currentValue) || {};\n        args.push(valFieldDefinition);\n      }\n\n      ret = fn.apply(void 0, args);\n    } else {\n      ret = _sql.SqlString.escape(currentValue);\n    }\n  }\n\n  return ret;\n};\n\nvar formatField = function formatField(meta, config, field) {\n  var fieldSeparator = config.settings.fieldSeparator;\n  var fieldDefinition = (0, _configUtils.getFieldConfig)(config, field) || {};\n  var fieldParts = Array.isArray(field) ? field : field.split(fieldSeparator);\n\n  var _fieldKeys = (0, _ruleUtils.getFieldPath)(field, config);\n\n  var fieldPartsLabels = (0, _ruleUtils.getFieldPathLabels)(field, config);\n  var fieldFullLabel = fieldPartsLabels ? fieldPartsLabels.join(fieldSeparator) : null;\n  var formatFieldFn = config.settings.formatField || _default.settings.formatField;\n  var fieldName = (0, _ruleUtils.formatFieldName)(field, config, meta);\n  var formattedField = formatFieldFn(fieldName, fieldParts, fieldFullLabel, fieldDefinition, config);\n  return formattedField;\n};\n\nvar formatFunc = function formatFunc(meta, config, currentValue) {\n  var funcKey = currentValue.get(\"func\");\n  var args = currentValue.get(\"args\");\n  var funcConfig = (0, _configUtils.getFuncConfig)(config, funcKey);\n  var funcName = funcConfig.sqlFunc || funcKey;\n  var formattedArgs = {};\n\n  for (var argKey in funcConfig.args) {\n    var argConfig = funcConfig.args[argKey];\n    var fieldDef = (0, _configUtils.getFieldConfig)(config, argConfig);\n    var argVal = args ? args.get(argKey) : undefined;\n    var argValue = argVal ? argVal.get(\"value\") : undefined;\n    var argValueSrc = argVal ? argVal.get(\"valueSrc\") : undefined;\n    var formattedArgVal = formatValue(meta, config, argValue, argValueSrc, argConfig.type, fieldDef, argConfig, null, null);\n\n    if (argValue != undefined && formattedArgVal === undefined) {\n      meta.errors.push(\"Can't format value of arg \".concat(argKey, \" for func \").concat(funcKey));\n      return undefined;\n    }\n\n    if (formattedArgVal !== undefined) {\n      // skip optional in the end\n      formattedArgs[argKey] = formattedArgVal;\n    }\n  }\n\n  var ret;\n\n  if (typeof funcConfig.sqlFormatFunc === \"function\") {\n    var fn = funcConfig.sqlFormatFunc;\n    var _args = [formattedArgs];\n    ret = fn.apply(void 0, _args);\n  } else {\n    var argsStr = Object.entries(formattedArgs).map(function (_ref) {\n      var _ref2 = (0, _slicedToArray2[\"default\"])(_ref, 2),\n          k = _ref2[0],\n          v = _ref2[1];\n\n      return v;\n    }).join(\", \");\n    ret = \"\".concat(funcName, \"(\").concat(argsStr, \")\");\n  }\n\n  return ret;\n};"]},"metadata":{},"sourceType":"script"}