{"ast":null,"code":"import { Node, Fragment } from 'prosemirror-model';\nimport { TextSelection, AllSelection, NodeSelection } from 'prosemirror-state';\nimport { parseContent } from './source';\nexport var changeStylesString = function (styleText, newStyle) {\n  var styleToChange = newStyle.style;\n  var regExp = newStyle.value;\n  var newValue = newStyle.newValue;\n\n  if (!styleText) {\n    return {\n      changed: false,\n      style: null\n    };\n  }\n\n  var styles = styleText.split(/\\s*;\\s*/).filter(function (s) {\n    return Boolean(s);\n  });\n  var filtered = styles.filter(function (s) {\n    var nameValue = s.split(/\\s*:\\s*/);\n    return !(nameValue[0].toLowerCase() === styleToChange && regExp.test(nameValue[1]));\n  });\n\n  if (newValue) {\n    filtered.push(styleToChange + \": \" + newValue);\n  }\n\n  return {\n    style: filtered.join('; ') + (filtered.length ? ';' : ''),\n    changed: Boolean(newValue) || filtered.length !== styles.length\n  };\n};\n/**\n * Determines if a given node type can be inserted at the current cursor position.\n */\n\nexport var canInsert = function (state, nodeType) {\n  var $from = state.selection.$from;\n\n  for (var d = $from.depth; d >= 0; d--) {\n    var index = $from.index(d);\n\n    if ($from.node(d).canReplaceWith(index, index, nodeType)) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nvar getTypeName = function (n) {\n  return n instanceof Node ? n.type.name : n.name;\n};\n\nvar findNthParentNode = function (predicate, depth) {\n  if (depth === void 0) {\n    depth = 1;\n  }\n\n  return function (selection) {\n    var $from = selection.$from;\n\n    for (var i = $from.depth; i > 0; i--) {\n      var node = $from.node(i);\n\n      if (predicate(node)) {\n        depth = depth - 1;\n\n        if (depth === 0) {\n          return {\n            depth: i,\n            node: node\n          };\n        }\n      }\n    }\n  };\n};\n\nexport var findNthParentNodeOfType = function (nodeType, depth) {\n  if (depth === void 0) {\n    depth = 1;\n  }\n\n  return function (selection) {\n    return findNthParentNode(function (node) {\n      return getTypeName(node) === getTypeName(nodeType);\n    }, depth)(selection);\n  };\n};\n/**\n * Inserts the given node at the place of current selection.\n */\n\nexport var insertNode = function (node, scrollIntoView) {\n  return function (state, dispatch) {\n    var tr = state.tr.replaceSelectionWith(node);\n\n    if (scrollIntoView) {\n      tr.scrollIntoView();\n    }\n\n    dispatch(tr);\n  };\n};\nexport var hasSameMarkup = function (dom1, dom2, schema, parseOptions) {\n  var fragment1 = Fragment.from(parseContent(dom1, schema, parseOptions));\n  var fragment2 = Fragment.from(parseContent(dom2, schema, parseOptions));\n  return fragment1.eq(fragment2);\n};\nexport var getSelectionText = function (state) {\n  var sel = state.selection;\n\n  if (sel instanceof TextSelection || sel instanceof AllSelection) {\n    var fragment = sel.content().content;\n    return fragment.textBetween(0, fragment.size);\n  }\n\n  return '';\n};\nexport var getNodeFromSelection = function (state) {\n  if (state.selection instanceof NodeSelection) {\n    return state.selection.node;\n  }\n};\n/**\n * Returns the text from the selection if only text is selected on a single line.\n * If selection contains leaf nodes (br, image) between text elements or\n * text from multiple block nodes, the function will return empty string.\n *\n * Useful for values of the inputs of Link and Find&Replace dialogs where the inputs value has been retrieved from the selection and\n * should be single line text only.\n */\n\nexport var selectedLineTextOnly = function (state) {\n  var result = '',\n      hasLeafs = false;\n  var selection = state.selection,\n      doc = state.doc;\n  var $from = selection.$from,\n      $to = selection.$to,\n      from = selection.from,\n      to = selection.to;\n\n  if ($from.sameParent($to)) {\n    doc.nodesBetween(from, to, function (node) {\n      hasLeafs = hasLeafs || node.isLeaf && !node.isText;\n    });\n\n    if (!hasLeafs) {\n      result = getSelectionText(state);\n    }\n  }\n\n  return result;\n};\n/**\n * Used by ViewHtml/ViewSource dialogs for making the HTML more readable.\n */\n\nexport var indentHtml = function (content) {\n  return content.replace(/<\\/(p|li|ul|ol|h[1-6]|table|tr|td|th)>/ig, '</$1>\\n').replace(/<(ul|ol)([^>]*)><li/ig, '<$1$2>\\n<li').replace(/<br \\/>/ig, '<br />\\n').replace(/\\n$/, '');\n};\nexport var shallowEqual = function (object1, object2) {\n  var keys1 = Object.keys(object1);\n  var keys2 = Object.keys(object2);\n  return keys1.length === keys2.length && keys1.every(function (k) {\n    return object1[k] === object2[k];\n  });\n};\nvar applyToWordDefault = {\n  before: /[^ !,?.\\[\\]{}()]+$/i,\n  after: /^[^ !,?.\\[\\]{}()]+/i\n};\n/**\n * if options.applyToWord is set, expands the selection to the word where the cursor is and\n * returns modified state and dispatch.\n */\n\nexport var expandSelection = function (state, dispatch, options) {\n  if (!options.applyToWord || !state.selection.empty) {\n    return {\n      state: state,\n      dispatch: dispatch\n    };\n  }\n\n  var applyToWordOptions = options.applyToWord === true ? applyToWordDefault : options.applyToWord;\n  var initialPosition = null;\n  var tr = state.tr;\n  var selection = state.selection;\n  var before = selection.$head.nodeBefore;\n  var after = selection.$head.nodeAfter;\n\n  if (before && before.type.name === 'text' && before.text && after && after.type.name === 'text' && after.text) {\n    var children_1 = [];\n    selection.$head.parent.descendants(function (node, pos) {\n      children_1.push({\n        node: node,\n        pos: pos\n      });\n      return false;\n    });\n    var cursor_1 = selection.$head.parentOffset;\n    var nodeIndex = children_1.findIndex(function (_a) {\n      var node = _a.node,\n          pos = _a.pos;\n      return pos <= cursor_1 && pos + node.nodeSize >= cursor_1;\n    });\n    var text = children_1[nodeIndex].node.text;\n    var skip = false;\n\n    for (var i = nodeIndex - 1; i >= 0; i--) {\n      var element = children_1[i];\n\n      if (!skip && element && element.node.type.name === 'text') {\n        text = element.node.text + text;\n      } else {\n        skip = true;\n        cursor_1 -= element.node.nodeSize;\n      }\n    }\n\n    for (var i = nodeIndex + 1; i < children_1.length; i++) {\n      var element = children_1[i];\n\n      if (element && element.node.type.name === 'text') {\n        text = text + element.node.text;\n      } else {\n        break;\n      }\n    }\n\n    var textBefore = text.substring(0, cursor_1);\n    var textAfter = text.substring(cursor_1);\n    var matchBefore = applyToWordOptions.before.exec(textBefore);\n    var matchAfter = applyToWordOptions.after.exec(textAfter);\n\n    if (matchBefore && matchAfter) {\n      var extendLeft = matchBefore[0].length;\n      var extendRight = matchAfter[0].length;\n      var pos = initialPosition = selection.from;\n      tr.setSelection(TextSelection.create(state.doc, pos - extendLeft, pos + extendRight));\n      var cmdState = {\n        tr: tr,\n        selection: tr.selection,\n        doc: tr.doc,\n        storedMarks: null,\n        schema: tr.doc.type.schema\n      };\n\n      var cmdDispatch = function (tran) {\n        tran.setSelection(TextSelection.create(tran.doc, initialPosition));\n        dispatch(tran);\n      };\n\n      return {\n        state: cmdState,\n        dispatch: cmdDispatch\n      };\n    }\n  }\n\n  return {\n    state: state,\n    dispatch: dispatch\n  };\n};\n/**\n * if options.applyToWord is set, expands the selection to the word where the cursor is and\n * use the modified state for the passed command.\n * Designed to work with toggleInlineFormat, applyInlineStyle and applyLink functions.\n *\n * Example:\n * const applyToWord: boolean|{before: RegExp, after: RegExp} = true;\n * // or applyToWord = { before: /[^ !,?.\\[\\]{}()]+$/i, after: /^[^ !,?.\\[\\]{}()]+/i }};\n *\n * const command = expandToWordWrap(toggleInlineFormat, {...bold, applyToWord );\n * command(view.state, view.dispatch);\n */\n\nexport var expandToWordWrap = function (command, options) {\n  return function (state, dispatch, _view) {\n    var _a = expandSelection(state, dispatch, options),\n        cmdState = _a.state,\n        cmdDispatch = _a.dispatch;\n\n    return command(options)(cmdState, cmdDispatch);\n  };\n};","map":{"version":3,"sources":["D:/Postgres_workingFolder/QuaLISWeb/node_modules/@progress/kendo-editor-common/dist/es/utils.js"],"names":["Node","Fragment","TextSelection","AllSelection","NodeSelection","parseContent","changeStylesString","styleText","newStyle","styleToChange","style","regExp","value","newValue","changed","styles","split","filter","s","Boolean","filtered","nameValue","toLowerCase","test","push","join","length","canInsert","state","nodeType","$from","selection","d","depth","index","node","canReplaceWith","getTypeName","n","type","name","findNthParentNode","predicate","i","findNthParentNodeOfType","insertNode","scrollIntoView","dispatch","tr","replaceSelectionWith","hasSameMarkup","dom1","dom2","schema","parseOptions","fragment1","from","fragment2","eq","getSelectionText","sel","fragment","content","textBetween","size","getNodeFromSelection","selectedLineTextOnly","result","hasLeafs","doc","$to","to","sameParent","nodesBetween","isLeaf","isText","indentHtml","replace","shallowEqual","object1","object2","keys1","Object","keys","keys2","every","k","applyToWordDefault","before","after","expandSelection","options","applyToWord","empty","applyToWordOptions","initialPosition","$head","nodeBefore","nodeAfter","text","children_1","parent","descendants","pos","cursor_1","parentOffset","nodeIndex","findIndex","_a","nodeSize","skip","element","textBefore","substring","textAfter","matchBefore","exec","matchAfter","extendLeft","extendRight","setSelection","create","cmdState","storedMarks","cmdDispatch","tran","expandToWordWrap","command","_view"],"mappings":"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","sourcesContent":["import { Node, Fragment } from 'prosemirror-model';\nimport { TextSelection, AllSelection, NodeSelection } from 'prosemirror-state';\nimport { parseContent } from './source';\nexport var changeStylesString = function (styleText, newStyle) {\n    var styleToChange = newStyle.style;\n    var regExp = newStyle.value;\n    var newValue = newStyle.newValue;\n    if (!styleText) {\n        return { changed: false, style: null };\n    }\n    var styles = styleText.split(/\\s*;\\s*/).filter(function (s) { return Boolean(s); });\n    var filtered = styles.filter(function (s) {\n        var nameValue = s.split(/\\s*:\\s*/);\n        return !(nameValue[0].toLowerCase() === styleToChange && regExp.test(nameValue[1]));\n    });\n    if (newValue) {\n        filtered.push(styleToChange + \": \" + newValue);\n    }\n    return {\n        style: filtered.join('; ') + (filtered.length ? ';' : ''),\n        changed: Boolean(newValue) || filtered.length !== styles.length\n    };\n};\n/**\n * Determines if a given node type can be inserted at the current cursor position.\n */\nexport var canInsert = function (state, nodeType) {\n    var $from = state.selection.$from;\n    for (var d = $from.depth; d >= 0; d--) {\n        var index = $from.index(d);\n        if ($from.node(d).canReplaceWith(index, index, nodeType)) {\n            return true;\n        }\n    }\n    return false;\n};\nvar getTypeName = function (n) {\n    return n instanceof Node ? n.type.name : n.name;\n};\nvar findNthParentNode = function (predicate, depth) {\n    if (depth === void 0) { depth = 1; }\n    return function (selection) {\n        var $from = selection.$from;\n        for (var i = $from.depth; i > 0; i--) {\n            var node = $from.node(i);\n            if (predicate(node)) {\n                depth = depth - 1;\n                if (depth === 0) {\n                    return { depth: i, node: node };\n                }\n            }\n        }\n    };\n};\nexport var findNthParentNodeOfType = function (nodeType, depth) {\n    if (depth === void 0) { depth = 1; }\n    return function (selection) {\n        return findNthParentNode(function (node) { return getTypeName(node) === getTypeName(nodeType); }, depth)(selection);\n    };\n};\n/**\n * Inserts the given node at the place of current selection.\n */\nexport var insertNode = function (node, scrollIntoView) { return function (state, dispatch) {\n    var tr = state.tr.replaceSelectionWith(node);\n    if (scrollIntoView) {\n        tr.scrollIntoView();\n    }\n    dispatch(tr);\n}; };\nexport var hasSameMarkup = function (dom1, dom2, schema, parseOptions) {\n    var fragment1 = Fragment.from(parseContent(dom1, schema, parseOptions));\n    var fragment2 = Fragment.from(parseContent(dom2, schema, parseOptions));\n    return fragment1.eq(fragment2);\n};\nexport var getSelectionText = function (state) {\n    var sel = state.selection;\n    if (sel instanceof TextSelection || sel instanceof AllSelection) {\n        var fragment = sel.content().content;\n        return fragment.textBetween(0, fragment.size);\n    }\n    return '';\n};\nexport var getNodeFromSelection = function (state) {\n    if (state.selection instanceof NodeSelection) {\n        return state.selection.node;\n    }\n};\n/**\n * Returns the text from the selection if only text is selected on a single line.\n * If selection contains leaf nodes (br, image) between text elements or\n * text from multiple block nodes, the function will return empty string.\n *\n * Useful for values of the inputs of Link and Find&Replace dialogs where the inputs value has been retrieved from the selection and\n * should be single line text only.\n */\nexport var selectedLineTextOnly = function (state) {\n    var result = '', hasLeafs = false;\n    var selection = state.selection, doc = state.doc;\n    var $from = selection.$from, $to = selection.$to, from = selection.from, to = selection.to;\n    if ($from.sameParent($to)) {\n        doc.nodesBetween(from, to, function (node) {\n            hasLeafs = hasLeafs || (node.isLeaf && !node.isText);\n        });\n        if (!hasLeafs) {\n            result = getSelectionText(state);\n        }\n    }\n    return result;\n};\n/**\n * Used by ViewHtml/ViewSource dialogs for making the HTML more readable.\n */\nexport var indentHtml = function (content) {\n    return content.replace(/<\\/(p|li|ul|ol|h[1-6]|table|tr|td|th)>/ig, '</$1>\\n')\n        .replace(/<(ul|ol)([^>]*)><li/ig, '<$1$2>\\n<li')\n        .replace(/<br \\/>/ig, '<br />\\n')\n        .replace(/\\n$/, '');\n};\nexport var shallowEqual = function (object1, object2) {\n    var keys1 = Object.keys(object1);\n    var keys2 = Object.keys(object2);\n    return keys1.length === keys2.length &&\n        keys1.every(function (k) { return object1[k] === object2[k]; });\n};\nvar applyToWordDefault = { before: /[^ !,?.\\[\\]{}()]+$/i, after: /^[^ !,?.\\[\\]{}()]+/i };\n/**\n * if options.applyToWord is set, expands the selection to the word where the cursor is and\n * returns modified state and dispatch.\n */\nexport var expandSelection = function (state, dispatch, options) {\n    if (!options.applyToWord || !state.selection.empty) {\n        return { state: state, dispatch: dispatch };\n    }\n    var applyToWordOptions = options.applyToWord === true ? applyToWordDefault : options.applyToWord;\n    var initialPosition = null;\n    var tr = state.tr;\n    var selection = state.selection;\n    var before = selection.$head.nodeBefore;\n    var after = selection.$head.nodeAfter;\n    if (before && before.type.name === 'text' && before.text && after && after.type.name === 'text' && after.text) {\n        var children_1 = [];\n        selection.$head.parent.descendants(function (node, pos) {\n            children_1.push({ node: node, pos: pos });\n            return false;\n        });\n        var cursor_1 = selection.$head.parentOffset;\n        var nodeIndex = children_1.findIndex(function (_a) {\n            var node = _a.node, pos = _a.pos;\n            return pos <= cursor_1 && pos + node.nodeSize >= cursor_1;\n        });\n        var text = children_1[nodeIndex].node.text;\n        var skip = false;\n        for (var i = nodeIndex - 1; i >= 0; i--) {\n            var element = children_1[i];\n            if (!skip && element && element.node.type.name === 'text') {\n                text = element.node.text + text;\n            }\n            else {\n                skip = true;\n                cursor_1 -= element.node.nodeSize;\n            }\n        }\n        for (var i = nodeIndex + 1; i < children_1.length; i++) {\n            var element = children_1[i];\n            if (element && element.node.type.name === 'text') {\n                text = text + element.node.text;\n            }\n            else {\n                break;\n            }\n        }\n        var textBefore = text.substring(0, cursor_1);\n        var textAfter = text.substring(cursor_1);\n        var matchBefore = applyToWordOptions.before.exec(textBefore);\n        var matchAfter = applyToWordOptions.after.exec(textAfter);\n        if (matchBefore && matchAfter) {\n            var extendLeft = matchBefore[0].length;\n            var extendRight = matchAfter[0].length;\n            var pos = initialPosition = selection.from;\n            tr.setSelection(TextSelection.create(state.doc, pos - extendLeft, pos + extendRight));\n            var cmdState = {\n                tr: tr,\n                selection: tr.selection,\n                doc: tr.doc,\n                storedMarks: null,\n                schema: tr.doc.type.schema\n            };\n            var cmdDispatch = function (tran) {\n                tran.setSelection(TextSelection.create(tran.doc, initialPosition));\n                dispatch(tran);\n            };\n            return { state: cmdState, dispatch: cmdDispatch };\n        }\n    }\n    return { state: state, dispatch: dispatch };\n};\n/**\n * if options.applyToWord is set, expands the selection to the word where the cursor is and\n * use the modified state for the passed command.\n * Designed to work with toggleInlineFormat, applyInlineStyle and applyLink functions.\n *\n * Example:\n * const applyToWord: boolean|{before: RegExp, after: RegExp} = true;\n * // or applyToWord = { before: /[^ !,?.\\[\\]{}()]+$/i, after: /^[^ !,?.\\[\\]{}()]+/i }};\n *\n * const command = expandToWordWrap(toggleInlineFormat, {...bold, applyToWord );\n * command(view.state, view.dispatch);\n */\nexport var expandToWordWrap = function (command, options) {\n    return function (state, dispatch, _view) {\n        var _a = expandSelection(state, dispatch, options), cmdState = _a.state, cmdDispatch = _a.dispatch;\n        return command(options)(cmdState, cmdDispatch);\n    };\n};\n"]},"metadata":{},"sourceType":"module"}