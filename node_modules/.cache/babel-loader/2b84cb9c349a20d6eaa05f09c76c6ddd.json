{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _typeof = require(\"@babel/runtime/helpers/typeof\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _immutable = _interopRequireDefault(require(\"immutable\"));\n\nvar _treeUtils = require(\"../utils/treeUtils\");\n\nvar _defaultUtils = require(\"../utils/defaultUtils\");\n\nvar constants = _interopRequireWildcard(require(\"../constants\"));\n\nvar _uuid = _interopRequireDefault(require(\"../utils/uuid\"));\n\nvar _configUtils = require(\"../utils/configUtils\");\n\nvar _ruleUtils = require(\"../utils/ruleUtils\");\n\nvar _stuff = require(\"../utils/stuff\");\n\nvar _validation = require(\"../utils/validation\");\n\nvar _omit = _interopRequireDefault(require(\"lodash/omit\"));\n\nvar _mapValues = _interopRequireDefault(require(\"lodash/mapValues\"));\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n    return {\n      \"default\": obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache(nodeInterop);\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj[\"default\"] = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n  if (!it) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      (0, _defineProperty2[\"default\"])(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n/**\n * @param {object} config\n * @param {Immutable.List} path\n * @param {Immutable.Map} properties\n */\n\n\nvar addNewGroup = function addNewGroup(state, path, type, groupUuid, properties, config) {\n  var children = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n  var meta = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : {};\n  var shouldCreateEmptyGroup = config.settings.shouldCreateEmptyGroup;\n  var groupPath = path.push(groupUuid);\n  var canAddNewRule = !shouldCreateEmptyGroup;\n  var isDefaultCase = !!(meta !== null && meta !== void 0 && meta.isDefaultCase);\n  var origState = state;\n  state = addItem(state, path, type, groupUuid, (0, _defaultUtils.defaultGroupProperties)(config).merge(properties || {}), config, children);\n\n  if (state !== origState) {\n    if (!children && !isDefaultCase) {\n      state = state.setIn((0, _treeUtils.expandTreePath)(groupPath, \"children1\"), new _immutable[\"default\"].OrderedMap()); // Add one empty rule into new group\n\n      if (canAddNewRule) {\n        state = addItem(state, groupPath, \"rule\", (0, _uuid[\"default\"])(), (0, _defaultUtils.defaultRuleProperties)(config), config);\n      }\n    }\n\n    state = (0, _treeUtils.fixPathsInTree)(state);\n  }\n\n  return state;\n};\n/**\n * @param {object} config\n * @param {Immutable.List} path\n * @param {Immutable.Map} properties\n */\n\n\nvar removeGroup = function removeGroup(state, path, config) {\n  state = removeItem(state, path);\n  var canLeaveEmptyGroup = config.settings.canLeaveEmptyGroup;\n  var parentPath = path.slice(0, -1);\n  var isEmptyParentGroup = !(0, _treeUtils.hasChildren)(state, parentPath);\n\n  if (isEmptyParentGroup && !canLeaveEmptyGroup) {\n    // check ancestors for emptiness (and delete 'em if empty)\n    state = (0, _treeUtils.fixEmptyGroupsInTree)(state);\n\n    if ((0, _treeUtils.isEmptyTree)(state) && !canLeaveEmptyGroup) {\n      // if whole query is empty, add one empty rule to root\n      state = addItem(state, new _immutable[\"default\"].List(), \"rule\", (0, _uuid[\"default\"])(), (0, _defaultUtils.defaultRuleProperties)(config), config);\n    }\n  }\n\n  state = (0, _treeUtils.fixPathsInTree)(state);\n  return state;\n};\n/**\n * @param {object} config\n * @param {Immutable.List} path\n */\n\n\nvar removeRule = function removeRule(state, path, config) {\n  state = removeItem(state, path);\n  var canLeaveEmptyGroup = config.settings.canLeaveEmptyGroup;\n  var parentPath = path.pop();\n  var parent = state.getIn((0, _treeUtils.expandTreePath)(parentPath));\n  var parentField = parent.getIn([\"properties\", \"field\"]);\n  var parentOperator = parent.getIn([\"properties\", \"operator\"]);\n  var parentValue = parent.getIn([\"properties\", \"value\", 0]);\n  var parentFieldConfig = parentField ? (0, _configUtils.getFieldConfig)(config, parentField) : null;\n  var parentOperatorConfig = parentOperator ? (0, _configUtils.getOperatorConfig)(config, parentOperator, parentField) : null;\n  var hasGroupCountRule = parentField && parentOperator && parentOperatorConfig.cardinality != 0; // && parentValue != undefined;\n\n  var isParentRuleGroup = parent.get(\"type\") == \"rule_group\";\n  var isEmptyParentGroup = !(0, _treeUtils.hasChildren)(state, parentPath);\n  var canLeaveEmpty = isParentRuleGroup ? hasGroupCountRule && parentFieldConfig.initialEmptyWhere : canLeaveEmptyGroup;\n\n  if (isEmptyParentGroup && !canLeaveEmpty) {\n    if (isParentRuleGroup) {\n      // deleted last rule from rule_group, so delete whole rule_group\n      state = state.deleteIn((0, _treeUtils.expandTreePath)(parentPath));\n    } // check ancestors for emptiness (and delete 'em if empty)\n\n\n    state = (0, _treeUtils.fixEmptyGroupsInTree)(state);\n\n    if ((0, _treeUtils.isEmptyTree)(state) && !canLeaveEmptyGroup) {\n      // if whole query is empty, add one empty rule to root\n      state = addItem(state, new _immutable[\"default\"].List(), \"rule\", (0, _uuid[\"default\"])(), (0, _defaultUtils.defaultRuleProperties)(config), config);\n    }\n  }\n\n  state = (0, _treeUtils.fixPathsInTree)(state);\n  return state;\n};\n/**\n * @param {Immutable.Map} state\n * @param {Immutable.List} path\n * @param {bool} not\n */\n\n\nvar setNot = function setNot(state, path, not) {\n  return state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"not\"), not);\n};\n/**\n * @param {Immutable.Map} state\n * @param {Immutable.List} path\n * @param {bool} lock\n */\n\n\nvar setLock = function setLock(state, path, lock) {\n  return (0, _treeUtils.removeIsLockedInTree)(state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"isLocked\"), lock));\n};\n/**\n * @param {Immutable.Map} state\n * @param {Immutable.List} path\n * @param {string} conjunction\n */\n\n\nvar setConjunction = function setConjunction(state, path, conjunction) {\n  return state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"conjunction\"), conjunction);\n}; // convert children deeply from JS to Immutable\n\n\nvar _addChildren1 = function _addChildren1(config, item, children) {\n  if (children && Array.isArray(children)) {\n    item.children1 = new _immutable[\"default\"].OrderedMap(children.reduce(function (map, it) {\n      var id1 = (0, _uuid[\"default\"])();\n\n      var it1 = _objectSpread(_objectSpread({}, it), {}, {\n        properties: (0, _defaultUtils.defaultItemProperties)(config, it).merge(it.properties || {}),\n        id: id1\n      });\n\n      _addChildren1(config, it1, it1.children1); //todo: guarantee order\n\n\n      return _objectSpread(_objectSpread({}, map), {}, (0, _defineProperty2[\"default\"])({}, id1, new _immutable[\"default\"].Map(it1)));\n    }, {}));\n  }\n};\n/**\n * @param {Immutable.Map} state\n * @param {Immutable.List} path\n * @param {string} type\n * @param {string} id\n * @param {Immutable.OrderedMap} properties\n * @param {object} config\n */\n\n\nvar addItem = function addItem(state, path, type, id, properties, config) {\n  var children = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n  if (type == \"switch_group\") throw new Error(\"Can't add switch_group programmatically\");\n  var _config$settings = config.settings,\n      maxNumberOfCases = _config$settings.maxNumberOfCases,\n      maxNumberOfRules = _config$settings.maxNumberOfRules,\n      maxNesting = _config$settings.maxNesting;\n  var rootType = state.get(\"type\");\n  var isTernary = rootType == \"switch_group\";\n  var targetItem = state.getIn((0, _treeUtils.expandTreePath)(path));\n  var caseGroup = isTernary ? state.getIn((0, _treeUtils.expandTreePath)(path.take(2))) : null;\n  var childrenPath = (0, _treeUtils.expandTreePath)(path, \"children1\");\n  var targetChildren = state.getIn(childrenPath);\n  var hasChildren = !!targetChildren && targetChildren.size;\n  var targetChildrenSize = hasChildren ? targetChildren.size : null;\n  var currentNumber, maxNumber;\n\n  if (type == \"case_group\") {\n    currentNumber = targetChildrenSize;\n    maxNumber = maxNumberOfCases;\n  } else if (type == \"group\") {\n    currentNumber = path.size;\n    maxNumber = maxNesting;\n  } else if ((targetItem === null || targetItem === void 0 ? void 0 : targetItem.get(\"type\")) == \"rule_group\") {// don't restrict\n  } else {\n    currentNumber = isTernary ? (0, _treeUtils.getTotalRulesCountInTree)(caseGroup) : (0, _treeUtils.getTotalRulesCountInTree)(state);\n    maxNumber = maxNumberOfRules;\n  }\n\n  var canAdd = maxNumber && currentNumber ? currentNumber < maxNumber : true;\n  var item = {\n    type: type,\n    id: id,\n    properties: properties\n  };\n\n  _addChildren1(config, item, children);\n\n  var isLastDefaultCase = type == \"case_group\" && hasChildren && targetChildren.last().get(\"children1\") == null;\n\n  if (canAdd) {\n    var newChildren = new _immutable[\"default\"].OrderedMap((0, _defineProperty2[\"default\"])({}, id, new _immutable[\"default\"].Map(item)));\n\n    if (!hasChildren) {\n      state = state.setIn(childrenPath, newChildren);\n    } else if (isLastDefaultCase) {\n      var _Immutable$OrderedMap2;\n\n      var last = targetChildren.last();\n      var newChildrenWithLast = new _immutable[\"default\"].OrderedMap((_Immutable$OrderedMap2 = {}, (0, _defineProperty2[\"default\"])(_Immutable$OrderedMap2, id, new _immutable[\"default\"].Map(item)), (0, _defineProperty2[\"default\"])(_Immutable$OrderedMap2, last.get(\"id\"), last), _Immutable$OrderedMap2));\n      state = state.deleteIn((0, _treeUtils.expandTreePath)(childrenPath, \"children1\", last.get(\"id\")));\n      state = state.mergeIn(childrenPath, newChildrenWithLast);\n    } else {\n      state = state.mergeIn(childrenPath, newChildren);\n    }\n\n    state = (0, _treeUtils.fixPathsInTree)(state);\n  }\n\n  return state;\n};\n/**\n * @param {Immutable.Map} state\n * @param {Immutable.List} path\n */\n\n\nvar removeItem = function removeItem(state, path) {\n  state = state.deleteIn((0, _treeUtils.expandTreePath)(path));\n  state = (0, _treeUtils.fixPathsInTree)(state);\n  return state;\n};\n/**\n * @param {Immutable.Map} state\n * @param {Immutable.List} fromPath\n * @param {Immutable.List} toPath\n * @param {string} placement, see constants PLACEMENT_*: PLACEMENT_AFTER, PLACEMENT_BEFORE, PLACEMENT_APPEND, PLACEMENT_PREPEND\n * @param {object} config\n */\n\n\nvar moveItem = function moveItem(state, fromPath, toPath, placement, config) {\n  var from = (0, _treeUtils.getItemByPath)(state, fromPath);\n  var sourcePath = fromPath.pop();\n  var source = fromPath.size > 1 ? (0, _treeUtils.getItemByPath)(state, sourcePath) : null;\n  var sourceChildren = source ? source.get(\"children1\") : null;\n  var to = (0, _treeUtils.getItemByPath)(state, toPath);\n  var targetPath = placement == constants.PLACEMENT_APPEND || placement == constants.PLACEMENT_PREPEND ? toPath : toPath.pop();\n  var target = placement == constants.PLACEMENT_APPEND || placement == constants.PLACEMENT_PREPEND ? to : toPath.size > 1 ? (0, _treeUtils.getItemByPath)(state, targetPath) : null;\n  var targetChildren = target ? target.get(\"children1\") : null;\n  if (!source || !target) return state;\n  var isSameParent = source.get(\"id\") == target.get(\"id\");\n  var isSourceInsideTarget = targetPath.size < sourcePath.size && (0, _stuff.deepEqual)(targetPath.toArray(), sourcePath.toArray().slice(0, targetPath.size));\n  var isTargetInsideSource = targetPath.size > sourcePath.size && (0, _stuff.deepEqual)(sourcePath.toArray(), targetPath.toArray().slice(0, sourcePath.size));\n  var sourceSubpathFromTarget = null;\n  var targetSubpathFromSource = null;\n\n  if (isSourceInsideTarget) {\n    sourceSubpathFromTarget = _immutable[\"default\"].List(sourcePath.toArray().slice(targetPath.size));\n  } else if (isTargetInsideSource) {\n    targetSubpathFromSource = _immutable[\"default\"].List(targetPath.toArray().slice(sourcePath.size));\n  }\n\n  var newTargetChildren = targetChildren,\n      newSourceChildren = sourceChildren;\n  if (!isTargetInsideSource) newSourceChildren = newSourceChildren[\"delete\"](from.get(\"id\"));\n\n  if (isSameParent) {\n    newTargetChildren = newSourceChildren;\n  } else if (isSourceInsideTarget) {\n    newTargetChildren = newTargetChildren.updateIn((0, _treeUtils.expandTreeSubpath)(sourceSubpathFromTarget, \"children1\"), function (_oldChildren) {\n      return newSourceChildren;\n    });\n  }\n\n  if (placement == constants.PLACEMENT_BEFORE || placement == constants.PLACEMENT_AFTER) {\n    newTargetChildren = _immutable[\"default\"].OrderedMap().withMutations(function (r) {\n      var _iterator = _createForOfIteratorHelper(newTargetChildren.entries()),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _step$value = (0, _slicedToArray2[\"default\"])(_step.value, 2),\n              itemId = _step$value[0],\n              item = _step$value[1];\n\n          if (itemId == to.get(\"id\") && placement == constants.PLACEMENT_BEFORE) {\n            r.set(from.get(\"id\"), from);\n          }\n\n          r.set(itemId, item);\n\n          if (itemId == to.get(\"id\") && placement == constants.PLACEMENT_AFTER) {\n            r.set(from.get(\"id\"), from);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    });\n  } else if (placement == constants.PLACEMENT_APPEND) {\n    newTargetChildren = newTargetChildren.merge((0, _defineProperty2[\"default\"])({}, from.get(\"id\"), from));\n  } else if (placement == constants.PLACEMENT_PREPEND) {\n    newTargetChildren = _immutable[\"default\"].OrderedMap((0, _defineProperty2[\"default\"])({}, from.get(\"id\"), from)).merge(newTargetChildren);\n  }\n\n  if (isTargetInsideSource) {\n    newSourceChildren = newSourceChildren.updateIn((0, _treeUtils.expandTreeSubpath)(targetSubpathFromSource, \"children1\"), function (_oldChildren) {\n      return newTargetChildren;\n    });\n    newSourceChildren = newSourceChildren[\"delete\"](from.get(\"id\"));\n  }\n\n  if (!isSameParent && !isSourceInsideTarget) state = state.updateIn((0, _treeUtils.expandTreePath)(sourcePath, \"children1\"), function (_oldChildren) {\n    return newSourceChildren;\n  });\n  if (!isTargetInsideSource) state = state.updateIn((0, _treeUtils.expandTreePath)(targetPath, \"children1\"), function (_oldChildren) {\n    return newTargetChildren;\n  });\n  state = (0, _treeUtils.fixPathsInTree)(state);\n  return state;\n};\n/**\n * @param {Immutable.Map} state\n * @param {Immutable.List} path\n * @param {string} field\n */\n\n\nvar setField = function setField(state, path, newField, config) {\n  if (!newField) return removeItem(state, path);\n  var _config$settings2 = config.settings,\n      fieldSeparator = _config$settings2.fieldSeparator,\n      setOpOnChangeField = _config$settings2.setOpOnChangeField,\n      showErrorMessage = _config$settings2.showErrorMessage;\n  if (Array.isArray(newField)) newField = newField.join(fieldSeparator);\n  var currentType = state.getIn((0, _treeUtils.expandTreePath)(path, \"type\"));\n  var currentProperties = state.getIn((0, _treeUtils.expandTreePath)(path, \"properties\"));\n  var wasRuleGroup = currentType == \"rule_group\";\n  var newFieldConfig = (0, _configUtils.getFieldConfig)(config, newField);\n  var isRuleGroup = newFieldConfig.type == \"!group\";\n  var isRuleGroupExt = isRuleGroup && newFieldConfig.mode == \"array\";\n  var isChangeToAnotherType = wasRuleGroup != isRuleGroup;\n  var currentOperator = currentProperties.get(\"operator\");\n  var currentOperatorOptions = currentProperties.get(\"operatorOptions\");\n\n  var _currentField = currentProperties.get(\"field\");\n\n  var _currentValue = currentProperties.get(\"value\");\n\n  var _currentValueSrc = currentProperties.get(\"valueSrc\", new _immutable[\"default\"].List());\n\n  var _currentValueType = currentProperties.get(\"valueType\", new _immutable[\"default\"].List()); // If the newly selected field supports the same operator the rule currently\n  // uses, keep it selected.\n\n\n  var lastOp = newFieldConfig && newFieldConfig.operators.indexOf(currentOperator) !== -1 ? currentOperator : null;\n  var newOperator = null;\n  var availOps = (0, _ruleUtils.getOperatorsForField)(config, newField);\n  if (availOps && availOps.length == 1) newOperator = availOps[0];else if (availOps && availOps.length > 1) {\n    var _iterator2 = _createForOfIteratorHelper(setOpOnChangeField || []),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var strategy = _step2.value;\n        if (strategy == \"keep\" && !isChangeToAnotherType) newOperator = lastOp;else if (strategy == \"default\") newOperator = (0, _defaultUtils.defaultOperator)(config, newField, false);else if (strategy == \"first\") newOperator = (0, _ruleUtils.getFirstOperator)(config, newField);\n        if (newOperator) //found op for strategy\n          break;\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  }\n\n  if (!isRuleGroup && !newFieldConfig.operators) {\n    console.warn(\"Type \".concat(newFieldConfig.type, \" is not supported\"));\n    return state;\n  }\n\n  if (wasRuleGroup && !isRuleGroup) {\n    state = state.setIn((0, _treeUtils.expandTreePath)(path, \"type\"), \"rule\");\n    state = state.deleteIn((0, _treeUtils.expandTreePath)(path, \"children1\"));\n    state = state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\"), new _immutable[\"default\"].OrderedMap());\n  }\n\n  if (isRuleGroup) {\n    state = state.setIn((0, _treeUtils.expandTreePath)(path, \"type\"), \"rule_group\");\n\n    var _getNewValueForFieldO = (0, _ruleUtils.getNewValueForFieldOp)(config, config, currentProperties, newField, newOperator, \"field\", true),\n        canReuseValue = _getNewValueForFieldO.canReuseValue,\n        newValue = _getNewValueForFieldO.newValue,\n        newValueSrc = _getNewValueForFieldO.newValueSrc,\n        newValueType = _getNewValueForFieldO.newValueType,\n        operatorCardinality = _getNewValueForFieldO.operatorCardinality;\n\n    var groupProperties = (0, _defaultUtils.defaultGroupProperties)(config, newFieldConfig).merge({\n      field: newField,\n      mode: newFieldConfig.mode\n    });\n\n    if (isRuleGroupExt) {\n      groupProperties = groupProperties.merge({\n        operator: newOperator,\n        value: newValue,\n        valueSrc: newValueSrc,\n        valueType: newValueType\n      });\n    }\n\n    state = state.setIn((0, _treeUtils.expandTreePath)(path, \"children1\"), new _immutable[\"default\"].OrderedMap());\n    state = state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\"), groupProperties);\n\n    if (newFieldConfig.initialEmptyWhere && operatorCardinality == 1) {// just `COUNT(grp) > 1` without `HAVING ..`\n      // no childeren\n    } else {\n      state = addItem(state, path, \"rule\", (0, _uuid[\"default\"])(), (0, _defaultUtils.defaultRuleProperties)(config, newField), config);\n    }\n\n    state = (0, _treeUtils.fixPathsInTree)(state);\n    return state;\n  }\n\n  return state.updateIn((0, _treeUtils.expandTreePath)(path, \"properties\"), function (map) {\n    return map.withMutations(function (current) {\n      var _getNewValueForFieldO2 = (0, _ruleUtils.getNewValueForFieldOp)(config, config, current, newField, newOperator, \"field\", true),\n          canReuseValue = _getNewValueForFieldO2.canReuseValue,\n          newValue = _getNewValueForFieldO2.newValue,\n          newValueSrc = _getNewValueForFieldO2.newValueSrc,\n          newValueType = _getNewValueForFieldO2.newValueType,\n          newValueError = _getNewValueForFieldO2.newValueError;\n\n      if (showErrorMessage) {\n        current = current.set(\"valueError\", newValueError);\n      }\n\n      var newOperatorOptions = canReuseValue ? currentOperatorOptions : (0, _defaultUtils.defaultOperatorOptions)(config, newOperator, newField);\n      return current.set(\"field\", newField).set(\"operator\", newOperator).set(\"operatorOptions\", newOperatorOptions).set(\"value\", newValue).set(\"valueSrc\", newValueSrc).set(\"valueType\", newValueType)[\"delete\"](\"asyncListValues\");\n    });\n  });\n};\n/**\n * @param {Immutable.Map} state\n * @param {Immutable.List} path\n * @param {string} operator\n */\n\n\nvar setOperator = function setOperator(state, path, newOperator, config) {\n  var showErrorMessage = config.settings.showErrorMessage;\n  var properties = state.getIn((0, _treeUtils.expandTreePath)(path, \"properties\"));\n  var children = state.getIn((0, _treeUtils.expandTreePath)(path, \"children1\"));\n  var currentField = properties.get(\"field\");\n  var fieldConfig = (0, _configUtils.getFieldConfig)(config, currentField);\n  var isRuleGroup = fieldConfig.type == \"!group\";\n  var operatorConfig = (0, _configUtils.getOperatorConfig)(config, newOperator, currentField);\n  var operatorCardinality = operatorConfig ? (0, _stuff.defaultValue)(operatorConfig.cardinality, 1) : null;\n  state = state.updateIn((0, _treeUtils.expandTreePath)(path, \"properties\"), function (map) {\n    return map.withMutations(function (current) {\n      var currentField = current.get(\"field\");\n      var currentOperatorOptions = current.get(\"operatorOptions\");\n\n      var _currentValue = current.get(\"value\", new _immutable[\"default\"].List());\n\n      var _currentValueSrc = current.get(\"valueSrc\", new _immutable[\"default\"].List());\n\n      var _currentOperator = current.get(\"operator\");\n\n      var _getNewValueForFieldO3 = (0, _ruleUtils.getNewValueForFieldOp)(config, config, current, currentField, newOperator, \"operator\", true),\n          canReuseValue = _getNewValueForFieldO3.canReuseValue,\n          newValue = _getNewValueForFieldO3.newValue,\n          newValueSrc = _getNewValueForFieldO3.newValueSrc,\n          newValueType = _getNewValueForFieldO3.newValueType,\n          newValueError = _getNewValueForFieldO3.newValueError;\n\n      if (showErrorMessage) {\n        current = current.set(\"valueError\", newValueError);\n      }\n\n      var newOperatorOptions = canReuseValue ? currentOperatorOptions : (0, _defaultUtils.defaultOperatorOptions)(config, newOperator, currentField);\n\n      if (!canReuseValue) {\n        current = current[\"delete\"](\"asyncListValues\");\n      }\n\n      return current.set(\"operator\", newOperator).set(\"operatorOptions\", newOperatorOptions).set(\"value\", newValue).set(\"valueSrc\", newValueSrc).set(\"valueType\", newValueType);\n    });\n  });\n\n  if (isRuleGroup) {\n    if (operatorCardinality == 0 && children.size == 0) {\n      state = addItem(state, path, \"rule\", (0, _uuid[\"default\"])(), (0, _defaultUtils.defaultRuleProperties)(config, currentField), config);\n    }\n  }\n\n  return state;\n};\n/**\n * @param {Immutable.Map} state\n * @param {Immutable.List} path\n * @param {integer} delta\n * @param {*} value\n * @param {string} valueType\n * @param {*} asyncListValues\n * @param {boolean} __isInternal\n */\n\n\nvar setValue = function setValue(state, path, delta, value, valueType, config, asyncListValues, __isInternal) {\n  var _config$settings3 = config.settings,\n      fieldSeparator = _config$settings3.fieldSeparator,\n      showErrorMessage = _config$settings3.showErrorMessage;\n  var isInternalValueChange;\n  var valueSrc = state.getIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"valueSrc\", delta + \"\")) || null;\n  if (valueSrc === \"field\" && Array.isArray(value)) value = value.join(fieldSeparator);\n  var field = state.getIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"field\")) || null;\n  var operator = state.getIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"operator\")) || null;\n  var operatorConfig = (0, _configUtils.getOperatorConfig)(config, operator, field);\n  var operatorCardinality = operator ? (0, _stuff.defaultValue)(operatorConfig.cardinality, 1) : null;\n  var isEndValue = false;\n  var canFix = false;\n  var calculatedValueType = valueType || calculateValueType(value, valueSrc, config);\n\n  var _validateValue = (0, _validation.validateValue)(config, field, field, operator, value, calculatedValueType, valueSrc, asyncListValues, canFix, isEndValue),\n      _validateValue2 = (0, _slicedToArray2[\"default\"])(_validateValue, 2),\n      validateError = _validateValue2[0],\n      fixedValue = _validateValue2[1];\n\n  var isValid = !validateError;\n\n  if (isValid && fixedValue !== value) {\n    // eg, get exact value from listValues (not string)\n    value = fixedValue;\n  } // Additional validation for range values\n\n\n  if (showErrorMessage) {\n    var w = (0, _ruleUtils.getWidgetForFieldOp)(config, field, operator, valueSrc);\n    var fieldWidgetDefinition = (0, _configUtils.getFieldWidgetConfig)(config, field, operator, w, valueSrc);\n    var valueSrcs = Array.from({\n      length: operatorCardinality\n    }, function (_, i) {\n      return state.getIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"valueSrc\", i + \"\")) || null;\n    });\n\n    if (operatorConfig && operatorConfig.validateValues && valueSrcs.filter(function (vs) {\n      return vs == \"value\" || vs == null;\n    }).length == operatorCardinality) {\n      var values = Array.from({\n        length: operatorCardinality\n      }, function (_, i) {\n        return i == delta ? value : state.getIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"value\", i + \"\")) || null;\n      });\n      var jsValues = fieldWidgetDefinition && fieldWidgetDefinition.toJS ? values.map(function (v) {\n        return fieldWidgetDefinition.toJS(v, fieldWidgetDefinition);\n      }) : values;\n      var rangeValidateError = operatorConfig.validateValues(jsValues);\n      state = state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"valueError\", operatorCardinality), rangeValidateError);\n    }\n  }\n\n  var lastValueArr = state.getIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"value\"));\n\n  if (!lastValueArr) {\n    state = state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"value\"), new _immutable[\"default\"].List(new Array(operatorCardinality))).setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"valueType\"), new _immutable[\"default\"].List(new Array(operatorCardinality))).setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"valueError\"), new _immutable[\"default\"].List(new Array(operatorCardinality)));\n  }\n\n  var lastValue = state.getIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"value\", delta + \"\"));\n  var lastError = state.getIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"valueError\", delta));\n  var isLastEmpty = lastValue == undefined;\n  var isLastError = !!lastError;\n\n  if (isValid || showErrorMessage) {\n    state = state.deleteIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"asyncListValues\")); // set only good value\n\n    if (typeof value === \"undefined\") {\n      state = state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"value\", delta + \"\"), undefined);\n      state = state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"valueType\", delta + \"\"), null);\n    } else {\n      if (asyncListValues) {\n        state = state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"asyncListValues\"), asyncListValues);\n      }\n\n      state = state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"value\", delta + \"\"), value);\n      state = state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"valueType\", delta + \"\"), calculatedValueType);\n      isInternalValueChange = __isInternal && !isLastEmpty && !isLastError;\n    }\n  }\n\n  if (showErrorMessage) {\n    state = state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"valueError\", delta), validateError);\n  }\n\n  if (__isInternal && (isValid && isLastError || !isValid && !isLastError)) {\n    state = state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"valueError\", delta), validateError);\n    isInternalValueChange = false;\n  }\n\n  return {\n    tree: state,\n    isInternalValueChange: isInternalValueChange\n  };\n};\n/**\n * @param {Immutable.Map} state\n * @param {Immutable.List} path\n * @param {integer} delta\n * @param {*} srcKey\n */\n\n\nvar setValueSrc = function setValueSrc(state, path, delta, srcKey, config) {\n  var showErrorMessage = config.settings.showErrorMessage;\n  var field = state.getIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"field\")) || null;\n  var operator = state.getIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"operator\")) || null;\n  state = state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"value\", delta + \"\"), undefined);\n  state = state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"valueType\", delta + \"\"), null);\n  state = state.deleteIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"asyncListValues\"));\n\n  if (showErrorMessage) {\n    // clear value error\n    state = state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"valueError\", delta), null); // if current operator is range, clear possible range error\n\n    var operatorConfig = (0, _configUtils.getOperatorConfig)(config, operator, field);\n    var operatorCardinality = operator ? (0, _stuff.defaultValue)(operatorConfig.cardinality, 1) : null;\n\n    if (operatorConfig.validateValues) {\n      state = state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"valueError\", operatorCardinality), null);\n    }\n  } // set valueSrc\n\n\n  if (typeof srcKey === \"undefined\") {\n    state = state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"valueSrc\", delta + \"\"), null);\n  } else {\n    state = state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"valueSrc\", delta + \"\"), srcKey);\n  } // maybe set default value\n\n\n  if (srcKey) {\n    var properties = state.getIn((0, _treeUtils.expandTreePath)(path, \"properties\")); // this call should return canReuseValue = false and provide default value\n\n    var _getNewValueForFieldO4 = (0, _ruleUtils.getNewValueForFieldOp)(config, config, properties, field, operator, \"valueSrc\", true),\n        canReuseValue = _getNewValueForFieldO4.canReuseValue,\n        newValue = _getNewValueForFieldO4.newValue,\n        newValueSrc = _getNewValueForFieldO4.newValueSrc,\n        newValueType = _getNewValueForFieldO4.newValueType,\n        newValueError = _getNewValueForFieldO4.newValueError;\n\n    if (!canReuseValue && newValueSrc.get(delta) == srcKey) {\n      state = state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"value\", delta + \"\"), newValue.get(delta));\n      state = state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"valueType\", delta + \"\"), newValueType.get(delta));\n    }\n  }\n\n  return state;\n};\n/**\n * @param {Immutable.Map} state\n * @param {Immutable.List} path\n * @param {string} name\n * @param {*} value\n */\n\n\nvar setOperatorOption = function setOperatorOption(state, path, name, value) {\n  return state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"operatorOptions\", name), value);\n};\n/**\n * @param {Immutable.Map} state\n */\n\n\nvar checkEmptyGroups = function checkEmptyGroups(state, config) {\n  var canLeaveEmptyGroup = config.settings.canLeaveEmptyGroup;\n\n  if (!canLeaveEmptyGroup) {\n    state = (0, _treeUtils.fixEmptyGroupsInTree)(state);\n  }\n\n  return state;\n};\n/**\n * \n */\n\n\nvar calculateValueType = function calculateValueType(value, valueSrc, config) {\n  var calculatedValueType = null;\n\n  if (value) {\n    if (valueSrc === \"field\") {\n      var fieldConfig = (0, _configUtils.getFieldConfig)(config, value);\n\n      if (fieldConfig) {\n        calculatedValueType = fieldConfig.type;\n      }\n    } else if (valueSrc === \"func\") {\n      var funcKey = value.get(\"func\");\n\n      if (funcKey) {\n        var funcConfig = (0, _configUtils.getFuncConfig)(config, funcKey);\n\n        if (funcConfig) {\n          calculatedValueType = funcConfig.returnType;\n        }\n      }\n    }\n  }\n\n  return calculatedValueType;\n};\n\nvar getField = function getField(state, path) {\n  var field = state.getIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"field\")) || null;\n  return field;\n};\n\nvar emptyDrag = {\n  dragging: {\n    id: null,\n    x: null,\n    y: null,\n    w: null,\n    h: null\n  },\n  mousePos: {},\n  dragStart: {\n    id: null\n  }\n};\n\nvar getActionMeta = function getActionMeta(action, state) {\n  var actionKeysToOmit = [\"config\", \"asyncListValues\", \"__isInternal\"];\n  var actionTypesToIgnore = [constants.SET_TREE, constants.SET_DRAG_START, constants.SET_DRAG_PROGRESS, constants.SET_DRAG_END];\n  var meta = (0, _mapValues[\"default\"])((0, _omit[\"default\"])(action, actionKeysToOmit), _stuff.applyToJS);\n  var affectedField = action.path && getField(state.tree, action.path) || action.field;\n  if (affectedField) meta.affectedField = affectedField;\n  if (actionTypesToIgnore.includes(action.type) || action.type.indexOf(\"@@redux\") == 0) meta = null;\n  return meta;\n};\n/**\n * @param {Immutable.Map} state\n * @param {object} action\n */\n\n\nvar _default = function _default(config) {\n  var emptyTree = (0, _defaultUtils.defaultRoot)(config);\n  var emptyState = Object.assign({}, {\n    tree: emptyTree\n  }, emptyDrag);\n  return function () {\n    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : emptyState;\n    var action = arguments.length > 1 ? arguments[1] : undefined;\n    var unset = {\n      __isInternalValueChange: undefined,\n      __lastAction: undefined\n    };\n    var set = {};\n    var actionMeta = getActionMeta(action, state);\n\n    switch (action.type) {\n      case constants.SET_TREE:\n        {\n          set.tree = action.tree;\n          break;\n        }\n\n      case constants.ADD_CASE_GROUP:\n        {\n          set.tree = addNewGroup(state.tree, action.path, \"case_group\", action.id, action.properties, action.config, action.children, action.meta);\n          break;\n        }\n\n      case constants.ADD_GROUP:\n        {\n          set.tree = addNewGroup(state.tree, action.path, \"group\", action.id, action.properties, action.config, action.children, action.meta);\n          break;\n        }\n\n      case constants.REMOVE_GROUP:\n        {\n          set.tree = removeGroup(state.tree, action.path, action.config);\n          break;\n        }\n\n      case constants.ADD_RULE:\n        {\n          set.tree = addItem(state.tree, action.path, action.ruleType, action.id, action.properties, action.config, action.children);\n          break;\n        }\n\n      case constants.REMOVE_RULE:\n        {\n          set.tree = removeRule(state.tree, action.path, action.config);\n          break;\n        }\n\n      case constants.SET_CONJUNCTION:\n        {\n          set.tree = setConjunction(state.tree, action.path, action.conjunction);\n          break;\n        }\n\n      case constants.SET_NOT:\n        {\n          set.tree = setNot(state.tree, action.path, action.not);\n          break;\n        }\n\n      case constants.SET_FIELD:\n        {\n          set.tree = setField(state.tree, action.path, action.field, action.config);\n          break;\n        }\n\n      case constants.SET_LOCK:\n        {\n          set.tree = setLock(state.tree, action.path, action.lock);\n          break;\n        }\n\n      case constants.SET_OPERATOR:\n        {\n          set.tree = setOperator(state.tree, action.path, action.operator, action.config);\n          break;\n        }\n\n      case constants.SET_VALUE:\n        {\n          var _setValue = setValue(state.tree, action.path, action.delta, action.value, action.valueType, action.config, action.asyncListValues, action.__isInternal),\n              tree = _setValue.tree,\n              isInternalValueChange = _setValue.isInternalValueChange;\n\n          set.__isInternalValueChange = isInternalValueChange;\n          set.tree = tree;\n          break;\n        }\n\n      case constants.SET_VALUE_SRC:\n        {\n          set.tree = setValueSrc(state.tree, action.path, action.delta, action.srcKey, action.config);\n          break;\n        }\n\n      case constants.SET_OPERATOR_OPTION:\n        {\n          set.tree = setOperatorOption(state.tree, action.path, action.name, action.value);\n          break;\n        }\n\n      case constants.MOVE_ITEM:\n        {\n          set.tree = moveItem(state.tree, action.fromPath, action.toPath, action.placement, action.config);\n          break;\n        }\n\n      case constants.SET_DRAG_START:\n        {\n          set.dragStart = action.dragStart;\n          set.dragging = action.dragging;\n          set.mousePos = action.mousePos;\n          break;\n        }\n\n      case constants.SET_DRAG_PROGRESS:\n        {\n          set.mousePos = action.mousePos;\n          set.dragging = action.dragging;\n          break;\n        }\n\n      case constants.SET_DRAG_END:\n        {\n          set.tree = checkEmptyGroups(state.tree, config);\n          set = _objectSpread(_objectSpread({}, set), emptyDrag);\n          break;\n        }\n\n      default:\n        {\n          break;\n        }\n    }\n\n    if (actionMeta) {\n      set.__lastAction = actionMeta;\n    }\n\n    return _objectSpread(_objectSpread(_objectSpread({}, state), unset), set);\n  };\n};\n\nexports[\"default\"] = _default;","map":{"version":3,"sources":["D:/LIMSWFH/LIMSPOSTGRESQL/QuaLISWeb/node_modules/react-awesome-query-builder/lib/stores/tree.js"],"names":["_interopRequireDefault","require","_typeof","Object","defineProperty","exports","value","_slicedToArray2","_defineProperty2","_immutable","_treeUtils","_defaultUtils","constants","_interopRequireWildcard","_uuid","_configUtils","_ruleUtils","_stuff","_validation","_omit","_mapValues","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","obj","__esModule","cache","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","_createForOfIteratorHelper","o","allowArrayLike","it","Symbol","iterator","Array","isArray","_unsupportedIterableToArray","length","i","F","s","n","done","e","_e","f","TypeError","normalCompletion","didErr","err","step","next","_e2","minLen","_arrayLikeToArray","toString","slice","constructor","name","from","test","arr","len","arr2","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","enumerable","push","apply","_objectSpread","target","arguments","source","forEach","getOwnPropertyDescriptors","defineProperties","addNewGroup","state","path","type","groupUuid","properties","config","children","undefined","meta","shouldCreateEmptyGroup","settings","groupPath","canAddNewRule","isDefaultCase","origState","addItem","defaultGroupProperties","merge","setIn","expandTreePath","OrderedMap","defaultRuleProperties","fixPathsInTree","removeGroup","removeItem","canLeaveEmptyGroup","parentPath","isEmptyParentGroup","hasChildren","fixEmptyGroupsInTree","isEmptyTree","List","removeRule","pop","parent","getIn","parentField","parentOperator","parentValue","parentFieldConfig","getFieldConfig","parentOperatorConfig","getOperatorConfig","hasGroupCountRule","cardinality","isParentRuleGroup","canLeaveEmpty","initialEmptyWhere","deleteIn","setNot","not","setLock","lock","removeIsLockedInTree","setConjunction","conjunction","_addChildren1","item","children1","reduce","map","id1","it1","defaultItemProperties","id","Map","Error","_config$settings","maxNumberOfCases","maxNumberOfRules","maxNesting","rootType","isTernary","targetItem","caseGroup","take","childrenPath","targetChildren","size","targetChildrenSize","currentNumber","maxNumber","getTotalRulesCountInTree","canAdd","isLastDefaultCase","last","newChildren","_Immutable$OrderedMap2","newChildrenWithLast","mergeIn","moveItem","fromPath","toPath","placement","getItemByPath","sourcePath","sourceChildren","to","targetPath","PLACEMENT_APPEND","PLACEMENT_PREPEND","isSameParent","isSourceInsideTarget","deepEqual","toArray","isTargetInsideSource","sourceSubpathFromTarget","targetSubpathFromSource","newTargetChildren","newSourceChildren","updateIn","expandTreeSubpath","_oldChildren","PLACEMENT_BEFORE","PLACEMENT_AFTER","withMutations","r","_iterator","entries","_step","_step$value","itemId","setField","newField","_config$settings2","fieldSeparator","setOpOnChangeField","showErrorMessage","join","currentType","currentProperties","wasRuleGroup","newFieldConfig","isRuleGroup","isRuleGroupExt","mode","isChangeToAnotherType","currentOperator","currentOperatorOptions","_currentField","_currentValue","_currentValueSrc","_currentValueType","lastOp","operators","indexOf","newOperator","availOps","getOperatorsForField","_iterator2","_step2","strategy","defaultOperator","getFirstOperator","console","warn","concat","_getNewValueForFieldO","getNewValueForFieldOp","canReuseValue","newValue","newValueSrc","newValueType","operatorCardinality","groupProperties","field","operator","valueSrc","valueType","current","_getNewValueForFieldO2","newValueError","newOperatorOptions","defaultOperatorOptions","setOperator","currentField","fieldConfig","operatorConfig","defaultValue","_currentOperator","_getNewValueForFieldO3","setValue","delta","asyncListValues","__isInternal","_config$settings3","isInternalValueChange","isEndValue","canFix","calculatedValueType","calculateValueType","_validateValue","validateValue","_validateValue2","validateError","fixedValue","isValid","w","getWidgetForFieldOp","fieldWidgetDefinition","getFieldWidgetConfig","valueSrcs","_","validateValues","vs","values","jsValues","toJS","v","rangeValidateError","lastValueArr","lastValue","lastError","isLastEmpty","isLastError","tree","setValueSrc","srcKey","_getNewValueForFieldO4","setOperatorOption","checkEmptyGroups","funcKey","funcConfig","getFuncConfig","returnType","getField","emptyDrag","dragging","x","y","h","mousePos","dragStart","getActionMeta","action","actionKeysToOmit","actionTypesToIgnore","SET_TREE","SET_DRAG_START","SET_DRAG_PROGRESS","SET_DRAG_END","applyToJS","affectedField","includes","_default","emptyTree","defaultRoot","emptyState","assign","unset","__isInternalValueChange","__lastAction","actionMeta","ADD_CASE_GROUP","ADD_GROUP","REMOVE_GROUP","ADD_RULE","ruleType","REMOVE_RULE","SET_CONJUNCTION","SET_NOT","SET_FIELD","SET_LOCK","SET_OPERATOR","SET_VALUE","_setValue","SET_VALUE_SRC","SET_OPERATOR_OPTION","MOVE_ITEM"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _typeof = require(\"@babel/runtime/helpers/typeof\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _immutable = _interopRequireDefault(require(\"immutable\"));\n\nvar _treeUtils = require(\"../utils/treeUtils\");\n\nvar _defaultUtils = require(\"../utils/defaultUtils\");\n\nvar constants = _interopRequireWildcard(require(\"../constants\"));\n\nvar _uuid = _interopRequireDefault(require(\"../utils/uuid\"));\n\nvar _configUtils = require(\"../utils/configUtils\");\n\nvar _ruleUtils = require(\"../utils/ruleUtils\");\n\nvar _stuff = require(\"../utils/stuff\");\n\nvar _validation = require(\"../utils/validation\");\n\nvar _omit = _interopRequireDefault(require(\"lodash/omit\"));\n\nvar _mapValues = _interopRequireDefault(require(\"lodash/mapValues\"));\n\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\n\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") { return { \"default\": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj[\"default\"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2[\"default\"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\n/**\n * @param {object} config\n * @param {Immutable.List} path\n * @param {Immutable.Map} properties\n */\nvar addNewGroup = function addNewGroup(state, path, type, groupUuid, properties, config) {\n  var children = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n  var meta = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : {};\n  var shouldCreateEmptyGroup = config.settings.shouldCreateEmptyGroup;\n  var groupPath = path.push(groupUuid);\n  var canAddNewRule = !shouldCreateEmptyGroup;\n  var isDefaultCase = !!(meta !== null && meta !== void 0 && meta.isDefaultCase);\n  var origState = state;\n  state = addItem(state, path, type, groupUuid, (0, _defaultUtils.defaultGroupProperties)(config).merge(properties || {}), config, children);\n\n  if (state !== origState) {\n    if (!children && !isDefaultCase) {\n      state = state.setIn((0, _treeUtils.expandTreePath)(groupPath, \"children1\"), new _immutable[\"default\"].OrderedMap()); // Add one empty rule into new group\n\n      if (canAddNewRule) {\n        state = addItem(state, groupPath, \"rule\", (0, _uuid[\"default\"])(), (0, _defaultUtils.defaultRuleProperties)(config), config);\n      }\n    }\n\n    state = (0, _treeUtils.fixPathsInTree)(state);\n  }\n\n  return state;\n};\n/**\n * @param {object} config\n * @param {Immutable.List} path\n * @param {Immutable.Map} properties\n */\n\n\nvar removeGroup = function removeGroup(state, path, config) {\n  state = removeItem(state, path);\n  var canLeaveEmptyGroup = config.settings.canLeaveEmptyGroup;\n  var parentPath = path.slice(0, -1);\n  var isEmptyParentGroup = !(0, _treeUtils.hasChildren)(state, parentPath);\n\n  if (isEmptyParentGroup && !canLeaveEmptyGroup) {\n    // check ancestors for emptiness (and delete 'em if empty)\n    state = (0, _treeUtils.fixEmptyGroupsInTree)(state);\n\n    if ((0, _treeUtils.isEmptyTree)(state) && !canLeaveEmptyGroup) {\n      // if whole query is empty, add one empty rule to root\n      state = addItem(state, new _immutable[\"default\"].List(), \"rule\", (0, _uuid[\"default\"])(), (0, _defaultUtils.defaultRuleProperties)(config), config);\n    }\n  }\n\n  state = (0, _treeUtils.fixPathsInTree)(state);\n  return state;\n};\n/**\n * @param {object} config\n * @param {Immutable.List} path\n */\n\n\nvar removeRule = function removeRule(state, path, config) {\n  state = removeItem(state, path);\n  var canLeaveEmptyGroup = config.settings.canLeaveEmptyGroup;\n  var parentPath = path.pop();\n  var parent = state.getIn((0, _treeUtils.expandTreePath)(parentPath));\n  var parentField = parent.getIn([\"properties\", \"field\"]);\n  var parentOperator = parent.getIn([\"properties\", \"operator\"]);\n  var parentValue = parent.getIn([\"properties\", \"value\", 0]);\n  var parentFieldConfig = parentField ? (0, _configUtils.getFieldConfig)(config, parentField) : null;\n  var parentOperatorConfig = parentOperator ? (0, _configUtils.getOperatorConfig)(config, parentOperator, parentField) : null;\n  var hasGroupCountRule = parentField && parentOperator && parentOperatorConfig.cardinality != 0; // && parentValue != undefined;\n\n  var isParentRuleGroup = parent.get(\"type\") == \"rule_group\";\n  var isEmptyParentGroup = !(0, _treeUtils.hasChildren)(state, parentPath);\n  var canLeaveEmpty = isParentRuleGroup ? hasGroupCountRule && parentFieldConfig.initialEmptyWhere : canLeaveEmptyGroup;\n\n  if (isEmptyParentGroup && !canLeaveEmpty) {\n    if (isParentRuleGroup) {\n      // deleted last rule from rule_group, so delete whole rule_group\n      state = state.deleteIn((0, _treeUtils.expandTreePath)(parentPath));\n    } // check ancestors for emptiness (and delete 'em if empty)\n\n\n    state = (0, _treeUtils.fixEmptyGroupsInTree)(state);\n\n    if ((0, _treeUtils.isEmptyTree)(state) && !canLeaveEmptyGroup) {\n      // if whole query is empty, add one empty rule to root\n      state = addItem(state, new _immutable[\"default\"].List(), \"rule\", (0, _uuid[\"default\"])(), (0, _defaultUtils.defaultRuleProperties)(config), config);\n    }\n  }\n\n  state = (0, _treeUtils.fixPathsInTree)(state);\n  return state;\n};\n/**\n * @param {Immutable.Map} state\n * @param {Immutable.List} path\n * @param {bool} not\n */\n\n\nvar setNot = function setNot(state, path, not) {\n  return state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"not\"), not);\n};\n/**\n * @param {Immutable.Map} state\n * @param {Immutable.List} path\n * @param {bool} lock\n */\n\n\nvar setLock = function setLock(state, path, lock) {\n  return (0, _treeUtils.removeIsLockedInTree)(state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"isLocked\"), lock));\n};\n/**\n * @param {Immutable.Map} state\n * @param {Immutable.List} path\n * @param {string} conjunction\n */\n\n\nvar setConjunction = function setConjunction(state, path, conjunction) {\n  return state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"conjunction\"), conjunction);\n}; // convert children deeply from JS to Immutable\n\n\nvar _addChildren1 = function _addChildren1(config, item, children) {\n  if (children && Array.isArray(children)) {\n    item.children1 = new _immutable[\"default\"].OrderedMap(children.reduce(function (map, it) {\n      var id1 = (0, _uuid[\"default\"])();\n\n      var it1 = _objectSpread(_objectSpread({}, it), {}, {\n        properties: (0, _defaultUtils.defaultItemProperties)(config, it).merge(it.properties || {}),\n        id: id1\n      });\n\n      _addChildren1(config, it1, it1.children1); //todo: guarantee order\n\n\n      return _objectSpread(_objectSpread({}, map), {}, (0, _defineProperty2[\"default\"])({}, id1, new _immutable[\"default\"].Map(it1)));\n    }, {}));\n  }\n};\n/**\n * @param {Immutable.Map} state\n * @param {Immutable.List} path\n * @param {string} type\n * @param {string} id\n * @param {Immutable.OrderedMap} properties\n * @param {object} config\n */\n\n\nvar addItem = function addItem(state, path, type, id, properties, config) {\n  var children = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n  if (type == \"switch_group\") throw new Error(\"Can't add switch_group programmatically\");\n  var _config$settings = config.settings,\n      maxNumberOfCases = _config$settings.maxNumberOfCases,\n      maxNumberOfRules = _config$settings.maxNumberOfRules,\n      maxNesting = _config$settings.maxNesting;\n  var rootType = state.get(\"type\");\n  var isTernary = rootType == \"switch_group\";\n  var targetItem = state.getIn((0, _treeUtils.expandTreePath)(path));\n  var caseGroup = isTernary ? state.getIn((0, _treeUtils.expandTreePath)(path.take(2))) : null;\n  var childrenPath = (0, _treeUtils.expandTreePath)(path, \"children1\");\n  var targetChildren = state.getIn(childrenPath);\n  var hasChildren = !!targetChildren && targetChildren.size;\n  var targetChildrenSize = hasChildren ? targetChildren.size : null;\n  var currentNumber, maxNumber;\n\n  if (type == \"case_group\") {\n    currentNumber = targetChildrenSize;\n    maxNumber = maxNumberOfCases;\n  } else if (type == \"group\") {\n    currentNumber = path.size;\n    maxNumber = maxNesting;\n  } else if ((targetItem === null || targetItem === void 0 ? void 0 : targetItem.get(\"type\")) == \"rule_group\") {// don't restrict\n  } else {\n    currentNumber = isTernary ? (0, _treeUtils.getTotalRulesCountInTree)(caseGroup) : (0, _treeUtils.getTotalRulesCountInTree)(state);\n    maxNumber = maxNumberOfRules;\n  }\n\n  var canAdd = maxNumber && currentNumber ? currentNumber < maxNumber : true;\n  var item = {\n    type: type,\n    id: id,\n    properties: properties\n  };\n\n  _addChildren1(config, item, children);\n\n  var isLastDefaultCase = type == \"case_group\" && hasChildren && targetChildren.last().get(\"children1\") == null;\n\n  if (canAdd) {\n    var newChildren = new _immutable[\"default\"].OrderedMap((0, _defineProperty2[\"default\"])({}, id, new _immutable[\"default\"].Map(item)));\n\n    if (!hasChildren) {\n      state = state.setIn(childrenPath, newChildren);\n    } else if (isLastDefaultCase) {\n      var _Immutable$OrderedMap2;\n\n      var last = targetChildren.last();\n      var newChildrenWithLast = new _immutable[\"default\"].OrderedMap((_Immutable$OrderedMap2 = {}, (0, _defineProperty2[\"default\"])(_Immutable$OrderedMap2, id, new _immutable[\"default\"].Map(item)), (0, _defineProperty2[\"default\"])(_Immutable$OrderedMap2, last.get(\"id\"), last), _Immutable$OrderedMap2));\n      state = state.deleteIn((0, _treeUtils.expandTreePath)(childrenPath, \"children1\", last.get(\"id\")));\n      state = state.mergeIn(childrenPath, newChildrenWithLast);\n    } else {\n      state = state.mergeIn(childrenPath, newChildren);\n    }\n\n    state = (0, _treeUtils.fixPathsInTree)(state);\n  }\n\n  return state;\n};\n/**\n * @param {Immutable.Map} state\n * @param {Immutable.List} path\n */\n\n\nvar removeItem = function removeItem(state, path) {\n  state = state.deleteIn((0, _treeUtils.expandTreePath)(path));\n  state = (0, _treeUtils.fixPathsInTree)(state);\n  return state;\n};\n/**\n * @param {Immutable.Map} state\n * @param {Immutable.List} fromPath\n * @param {Immutable.List} toPath\n * @param {string} placement, see constants PLACEMENT_*: PLACEMENT_AFTER, PLACEMENT_BEFORE, PLACEMENT_APPEND, PLACEMENT_PREPEND\n * @param {object} config\n */\n\n\nvar moveItem = function moveItem(state, fromPath, toPath, placement, config) {\n  var from = (0, _treeUtils.getItemByPath)(state, fromPath);\n  var sourcePath = fromPath.pop();\n  var source = fromPath.size > 1 ? (0, _treeUtils.getItemByPath)(state, sourcePath) : null;\n  var sourceChildren = source ? source.get(\"children1\") : null;\n  var to = (0, _treeUtils.getItemByPath)(state, toPath);\n  var targetPath = placement == constants.PLACEMENT_APPEND || placement == constants.PLACEMENT_PREPEND ? toPath : toPath.pop();\n  var target = placement == constants.PLACEMENT_APPEND || placement == constants.PLACEMENT_PREPEND ? to : toPath.size > 1 ? (0, _treeUtils.getItemByPath)(state, targetPath) : null;\n  var targetChildren = target ? target.get(\"children1\") : null;\n  if (!source || !target) return state;\n  var isSameParent = source.get(\"id\") == target.get(\"id\");\n  var isSourceInsideTarget = targetPath.size < sourcePath.size && (0, _stuff.deepEqual)(targetPath.toArray(), sourcePath.toArray().slice(0, targetPath.size));\n  var isTargetInsideSource = targetPath.size > sourcePath.size && (0, _stuff.deepEqual)(sourcePath.toArray(), targetPath.toArray().slice(0, sourcePath.size));\n  var sourceSubpathFromTarget = null;\n  var targetSubpathFromSource = null;\n\n  if (isSourceInsideTarget) {\n    sourceSubpathFromTarget = _immutable[\"default\"].List(sourcePath.toArray().slice(targetPath.size));\n  } else if (isTargetInsideSource) {\n    targetSubpathFromSource = _immutable[\"default\"].List(targetPath.toArray().slice(sourcePath.size));\n  }\n\n  var newTargetChildren = targetChildren,\n      newSourceChildren = sourceChildren;\n  if (!isTargetInsideSource) newSourceChildren = newSourceChildren[\"delete\"](from.get(\"id\"));\n\n  if (isSameParent) {\n    newTargetChildren = newSourceChildren;\n  } else if (isSourceInsideTarget) {\n    newTargetChildren = newTargetChildren.updateIn((0, _treeUtils.expandTreeSubpath)(sourceSubpathFromTarget, \"children1\"), function (_oldChildren) {\n      return newSourceChildren;\n    });\n  }\n\n  if (placement == constants.PLACEMENT_BEFORE || placement == constants.PLACEMENT_AFTER) {\n    newTargetChildren = _immutable[\"default\"].OrderedMap().withMutations(function (r) {\n      var _iterator = _createForOfIteratorHelper(newTargetChildren.entries()),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _step$value = (0, _slicedToArray2[\"default\"])(_step.value, 2),\n              itemId = _step$value[0],\n              item = _step$value[1];\n\n          if (itemId == to.get(\"id\") && placement == constants.PLACEMENT_BEFORE) {\n            r.set(from.get(\"id\"), from);\n          }\n\n          r.set(itemId, item);\n\n          if (itemId == to.get(\"id\") && placement == constants.PLACEMENT_AFTER) {\n            r.set(from.get(\"id\"), from);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    });\n  } else if (placement == constants.PLACEMENT_APPEND) {\n    newTargetChildren = newTargetChildren.merge((0, _defineProperty2[\"default\"])({}, from.get(\"id\"), from));\n  } else if (placement == constants.PLACEMENT_PREPEND) {\n    newTargetChildren = _immutable[\"default\"].OrderedMap((0, _defineProperty2[\"default\"])({}, from.get(\"id\"), from)).merge(newTargetChildren);\n  }\n\n  if (isTargetInsideSource) {\n    newSourceChildren = newSourceChildren.updateIn((0, _treeUtils.expandTreeSubpath)(targetSubpathFromSource, \"children1\"), function (_oldChildren) {\n      return newTargetChildren;\n    });\n    newSourceChildren = newSourceChildren[\"delete\"](from.get(\"id\"));\n  }\n\n  if (!isSameParent && !isSourceInsideTarget) state = state.updateIn((0, _treeUtils.expandTreePath)(sourcePath, \"children1\"), function (_oldChildren) {\n    return newSourceChildren;\n  });\n  if (!isTargetInsideSource) state = state.updateIn((0, _treeUtils.expandTreePath)(targetPath, \"children1\"), function (_oldChildren) {\n    return newTargetChildren;\n  });\n  state = (0, _treeUtils.fixPathsInTree)(state);\n  return state;\n};\n/**\n * @param {Immutable.Map} state\n * @param {Immutable.List} path\n * @param {string} field\n */\n\n\nvar setField = function setField(state, path, newField, config) {\n  if (!newField) return removeItem(state, path);\n  var _config$settings2 = config.settings,\n      fieldSeparator = _config$settings2.fieldSeparator,\n      setOpOnChangeField = _config$settings2.setOpOnChangeField,\n      showErrorMessage = _config$settings2.showErrorMessage;\n  if (Array.isArray(newField)) newField = newField.join(fieldSeparator);\n  var currentType = state.getIn((0, _treeUtils.expandTreePath)(path, \"type\"));\n  var currentProperties = state.getIn((0, _treeUtils.expandTreePath)(path, \"properties\"));\n  var wasRuleGroup = currentType == \"rule_group\";\n  var newFieldConfig = (0, _configUtils.getFieldConfig)(config, newField);\n  var isRuleGroup = newFieldConfig.type == \"!group\";\n  var isRuleGroupExt = isRuleGroup && newFieldConfig.mode == \"array\";\n  var isChangeToAnotherType = wasRuleGroup != isRuleGroup;\n  var currentOperator = currentProperties.get(\"operator\");\n  var currentOperatorOptions = currentProperties.get(\"operatorOptions\");\n\n  var _currentField = currentProperties.get(\"field\");\n\n  var _currentValue = currentProperties.get(\"value\");\n\n  var _currentValueSrc = currentProperties.get(\"valueSrc\", new _immutable[\"default\"].List());\n\n  var _currentValueType = currentProperties.get(\"valueType\", new _immutable[\"default\"].List()); // If the newly selected field supports the same operator the rule currently\n  // uses, keep it selected.\n\n\n  var lastOp = newFieldConfig && newFieldConfig.operators.indexOf(currentOperator) !== -1 ? currentOperator : null;\n  var newOperator = null;\n  var availOps = (0, _ruleUtils.getOperatorsForField)(config, newField);\n  if (availOps && availOps.length == 1) newOperator = availOps[0];else if (availOps && availOps.length > 1) {\n    var _iterator2 = _createForOfIteratorHelper(setOpOnChangeField || []),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var strategy = _step2.value;\n        if (strategy == \"keep\" && !isChangeToAnotherType) newOperator = lastOp;else if (strategy == \"default\") newOperator = (0, _defaultUtils.defaultOperator)(config, newField, false);else if (strategy == \"first\") newOperator = (0, _ruleUtils.getFirstOperator)(config, newField);\n        if (newOperator) //found op for strategy\n          break;\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  }\n\n  if (!isRuleGroup && !newFieldConfig.operators) {\n    console.warn(\"Type \".concat(newFieldConfig.type, \" is not supported\"));\n    return state;\n  }\n\n  if (wasRuleGroup && !isRuleGroup) {\n    state = state.setIn((0, _treeUtils.expandTreePath)(path, \"type\"), \"rule\");\n    state = state.deleteIn((0, _treeUtils.expandTreePath)(path, \"children1\"));\n    state = state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\"), new _immutable[\"default\"].OrderedMap());\n  }\n\n  if (isRuleGroup) {\n    state = state.setIn((0, _treeUtils.expandTreePath)(path, \"type\"), \"rule_group\");\n\n    var _getNewValueForFieldO = (0, _ruleUtils.getNewValueForFieldOp)(config, config, currentProperties, newField, newOperator, \"field\", true),\n        canReuseValue = _getNewValueForFieldO.canReuseValue,\n        newValue = _getNewValueForFieldO.newValue,\n        newValueSrc = _getNewValueForFieldO.newValueSrc,\n        newValueType = _getNewValueForFieldO.newValueType,\n        operatorCardinality = _getNewValueForFieldO.operatorCardinality;\n\n    var groupProperties = (0, _defaultUtils.defaultGroupProperties)(config, newFieldConfig).merge({\n      field: newField,\n      mode: newFieldConfig.mode\n    });\n\n    if (isRuleGroupExt) {\n      groupProperties = groupProperties.merge({\n        operator: newOperator,\n        value: newValue,\n        valueSrc: newValueSrc,\n        valueType: newValueType\n      });\n    }\n\n    state = state.setIn((0, _treeUtils.expandTreePath)(path, \"children1\"), new _immutable[\"default\"].OrderedMap());\n    state = state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\"), groupProperties);\n\n    if (newFieldConfig.initialEmptyWhere && operatorCardinality == 1) {// just `COUNT(grp) > 1` without `HAVING ..`\n      // no childeren\n    } else {\n      state = addItem(state, path, \"rule\", (0, _uuid[\"default\"])(), (0, _defaultUtils.defaultRuleProperties)(config, newField), config);\n    }\n\n    state = (0, _treeUtils.fixPathsInTree)(state);\n    return state;\n  }\n\n  return state.updateIn((0, _treeUtils.expandTreePath)(path, \"properties\"), function (map) {\n    return map.withMutations(function (current) {\n      var _getNewValueForFieldO2 = (0, _ruleUtils.getNewValueForFieldOp)(config, config, current, newField, newOperator, \"field\", true),\n          canReuseValue = _getNewValueForFieldO2.canReuseValue,\n          newValue = _getNewValueForFieldO2.newValue,\n          newValueSrc = _getNewValueForFieldO2.newValueSrc,\n          newValueType = _getNewValueForFieldO2.newValueType,\n          newValueError = _getNewValueForFieldO2.newValueError;\n\n      if (showErrorMessage) {\n        current = current.set(\"valueError\", newValueError);\n      }\n\n      var newOperatorOptions = canReuseValue ? currentOperatorOptions : (0, _defaultUtils.defaultOperatorOptions)(config, newOperator, newField);\n      return current.set(\"field\", newField).set(\"operator\", newOperator).set(\"operatorOptions\", newOperatorOptions).set(\"value\", newValue).set(\"valueSrc\", newValueSrc).set(\"valueType\", newValueType)[\"delete\"](\"asyncListValues\");\n    });\n  });\n};\n/**\n * @param {Immutable.Map} state\n * @param {Immutable.List} path\n * @param {string} operator\n */\n\n\nvar setOperator = function setOperator(state, path, newOperator, config) {\n  var showErrorMessage = config.settings.showErrorMessage;\n  var properties = state.getIn((0, _treeUtils.expandTreePath)(path, \"properties\"));\n  var children = state.getIn((0, _treeUtils.expandTreePath)(path, \"children1\"));\n  var currentField = properties.get(\"field\");\n  var fieldConfig = (0, _configUtils.getFieldConfig)(config, currentField);\n  var isRuleGroup = fieldConfig.type == \"!group\";\n  var operatorConfig = (0, _configUtils.getOperatorConfig)(config, newOperator, currentField);\n  var operatorCardinality = operatorConfig ? (0, _stuff.defaultValue)(operatorConfig.cardinality, 1) : null;\n  state = state.updateIn((0, _treeUtils.expandTreePath)(path, \"properties\"), function (map) {\n    return map.withMutations(function (current) {\n      var currentField = current.get(\"field\");\n      var currentOperatorOptions = current.get(\"operatorOptions\");\n\n      var _currentValue = current.get(\"value\", new _immutable[\"default\"].List());\n\n      var _currentValueSrc = current.get(\"valueSrc\", new _immutable[\"default\"].List());\n\n      var _currentOperator = current.get(\"operator\");\n\n      var _getNewValueForFieldO3 = (0, _ruleUtils.getNewValueForFieldOp)(config, config, current, currentField, newOperator, \"operator\", true),\n          canReuseValue = _getNewValueForFieldO3.canReuseValue,\n          newValue = _getNewValueForFieldO3.newValue,\n          newValueSrc = _getNewValueForFieldO3.newValueSrc,\n          newValueType = _getNewValueForFieldO3.newValueType,\n          newValueError = _getNewValueForFieldO3.newValueError;\n\n      if (showErrorMessage) {\n        current = current.set(\"valueError\", newValueError);\n      }\n\n      var newOperatorOptions = canReuseValue ? currentOperatorOptions : (0, _defaultUtils.defaultOperatorOptions)(config, newOperator, currentField);\n\n      if (!canReuseValue) {\n        current = current[\"delete\"](\"asyncListValues\");\n      }\n\n      return current.set(\"operator\", newOperator).set(\"operatorOptions\", newOperatorOptions).set(\"value\", newValue).set(\"valueSrc\", newValueSrc).set(\"valueType\", newValueType);\n    });\n  });\n\n  if (isRuleGroup) {\n    if (operatorCardinality == 0 && children.size == 0) {\n      state = addItem(state, path, \"rule\", (0, _uuid[\"default\"])(), (0, _defaultUtils.defaultRuleProperties)(config, currentField), config);\n    }\n  }\n\n  return state;\n};\n/**\n * @param {Immutable.Map} state\n * @param {Immutable.List} path\n * @param {integer} delta\n * @param {*} value\n * @param {string} valueType\n * @param {*} asyncListValues\n * @param {boolean} __isInternal\n */\n\n\nvar setValue = function setValue(state, path, delta, value, valueType, config, asyncListValues, __isInternal) {\n  var _config$settings3 = config.settings,\n      fieldSeparator = _config$settings3.fieldSeparator,\n      showErrorMessage = _config$settings3.showErrorMessage;\n  var isInternalValueChange;\n  var valueSrc = state.getIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"valueSrc\", delta + \"\")) || null;\n  if (valueSrc === \"field\" && Array.isArray(value)) value = value.join(fieldSeparator);\n  var field = state.getIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"field\")) || null;\n  var operator = state.getIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"operator\")) || null;\n  var operatorConfig = (0, _configUtils.getOperatorConfig)(config, operator, field);\n  var operatorCardinality = operator ? (0, _stuff.defaultValue)(operatorConfig.cardinality, 1) : null;\n  var isEndValue = false;\n  var canFix = false;\n  var calculatedValueType = valueType || calculateValueType(value, valueSrc, config);\n\n  var _validateValue = (0, _validation.validateValue)(config, field, field, operator, value, calculatedValueType, valueSrc, asyncListValues, canFix, isEndValue),\n      _validateValue2 = (0, _slicedToArray2[\"default\"])(_validateValue, 2),\n      validateError = _validateValue2[0],\n      fixedValue = _validateValue2[1];\n\n  var isValid = !validateError;\n\n  if (isValid && fixedValue !== value) {\n    // eg, get exact value from listValues (not string)\n    value = fixedValue;\n  } // Additional validation for range values\n\n\n  if (showErrorMessage) {\n    var w = (0, _ruleUtils.getWidgetForFieldOp)(config, field, operator, valueSrc);\n    var fieldWidgetDefinition = (0, _configUtils.getFieldWidgetConfig)(config, field, operator, w, valueSrc);\n    var valueSrcs = Array.from({\n      length: operatorCardinality\n    }, function (_, i) {\n      return state.getIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"valueSrc\", i + \"\")) || null;\n    });\n\n    if (operatorConfig && operatorConfig.validateValues && valueSrcs.filter(function (vs) {\n      return vs == \"value\" || vs == null;\n    }).length == operatorCardinality) {\n      var values = Array.from({\n        length: operatorCardinality\n      }, function (_, i) {\n        return i == delta ? value : state.getIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"value\", i + \"\")) || null;\n      });\n      var jsValues = fieldWidgetDefinition && fieldWidgetDefinition.toJS ? values.map(function (v) {\n        return fieldWidgetDefinition.toJS(v, fieldWidgetDefinition);\n      }) : values;\n      var rangeValidateError = operatorConfig.validateValues(jsValues);\n      state = state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"valueError\", operatorCardinality), rangeValidateError);\n    }\n  }\n\n  var lastValueArr = state.getIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"value\"));\n\n  if (!lastValueArr) {\n    state = state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"value\"), new _immutable[\"default\"].List(new Array(operatorCardinality))).setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"valueType\"), new _immutable[\"default\"].List(new Array(operatorCardinality))).setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"valueError\"), new _immutable[\"default\"].List(new Array(operatorCardinality)));\n  }\n\n  var lastValue = state.getIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"value\", delta + \"\"));\n  var lastError = state.getIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"valueError\", delta));\n  var isLastEmpty = lastValue == undefined;\n  var isLastError = !!lastError;\n\n  if (isValid || showErrorMessage) {\n    state = state.deleteIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"asyncListValues\")); // set only good value\n\n    if (typeof value === \"undefined\") {\n      state = state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"value\", delta + \"\"), undefined);\n      state = state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"valueType\", delta + \"\"), null);\n    } else {\n      if (asyncListValues) {\n        state = state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"asyncListValues\"), asyncListValues);\n      }\n\n      state = state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"value\", delta + \"\"), value);\n      state = state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"valueType\", delta + \"\"), calculatedValueType);\n      isInternalValueChange = __isInternal && !isLastEmpty && !isLastError;\n    }\n  }\n\n  if (showErrorMessage) {\n    state = state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"valueError\", delta), validateError);\n  }\n\n  if (__isInternal && (isValid && isLastError || !isValid && !isLastError)) {\n    state = state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"valueError\", delta), validateError);\n    isInternalValueChange = false;\n  }\n\n  return {\n    tree: state,\n    isInternalValueChange: isInternalValueChange\n  };\n};\n/**\n * @param {Immutable.Map} state\n * @param {Immutable.List} path\n * @param {integer} delta\n * @param {*} srcKey\n */\n\n\nvar setValueSrc = function setValueSrc(state, path, delta, srcKey, config) {\n  var showErrorMessage = config.settings.showErrorMessage;\n  var field = state.getIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"field\")) || null;\n  var operator = state.getIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"operator\")) || null;\n  state = state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"value\", delta + \"\"), undefined);\n  state = state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"valueType\", delta + \"\"), null);\n  state = state.deleteIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"asyncListValues\"));\n\n  if (showErrorMessage) {\n    // clear value error\n    state = state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"valueError\", delta), null); // if current operator is range, clear possible range error\n\n    var operatorConfig = (0, _configUtils.getOperatorConfig)(config, operator, field);\n    var operatorCardinality = operator ? (0, _stuff.defaultValue)(operatorConfig.cardinality, 1) : null;\n\n    if (operatorConfig.validateValues) {\n      state = state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"valueError\", operatorCardinality), null);\n    }\n  } // set valueSrc\n\n\n  if (typeof srcKey === \"undefined\") {\n    state = state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"valueSrc\", delta + \"\"), null);\n  } else {\n    state = state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"valueSrc\", delta + \"\"), srcKey);\n  } // maybe set default value\n\n\n  if (srcKey) {\n    var properties = state.getIn((0, _treeUtils.expandTreePath)(path, \"properties\")); // this call should return canReuseValue = false and provide default value\n\n    var _getNewValueForFieldO4 = (0, _ruleUtils.getNewValueForFieldOp)(config, config, properties, field, operator, \"valueSrc\", true),\n        canReuseValue = _getNewValueForFieldO4.canReuseValue,\n        newValue = _getNewValueForFieldO4.newValue,\n        newValueSrc = _getNewValueForFieldO4.newValueSrc,\n        newValueType = _getNewValueForFieldO4.newValueType,\n        newValueError = _getNewValueForFieldO4.newValueError;\n\n    if (!canReuseValue && newValueSrc.get(delta) == srcKey) {\n      state = state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"value\", delta + \"\"), newValue.get(delta));\n      state = state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"valueType\", delta + \"\"), newValueType.get(delta));\n    }\n  }\n\n  return state;\n};\n/**\n * @param {Immutable.Map} state\n * @param {Immutable.List} path\n * @param {string} name\n * @param {*} value\n */\n\n\nvar setOperatorOption = function setOperatorOption(state, path, name, value) {\n  return state.setIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"operatorOptions\", name), value);\n};\n/**\n * @param {Immutable.Map} state\n */\n\n\nvar checkEmptyGroups = function checkEmptyGroups(state, config) {\n  var canLeaveEmptyGroup = config.settings.canLeaveEmptyGroup;\n\n  if (!canLeaveEmptyGroup) {\n    state = (0, _treeUtils.fixEmptyGroupsInTree)(state);\n  }\n\n  return state;\n};\n/**\n * \n */\n\n\nvar calculateValueType = function calculateValueType(value, valueSrc, config) {\n  var calculatedValueType = null;\n\n  if (value) {\n    if (valueSrc === \"field\") {\n      var fieldConfig = (0, _configUtils.getFieldConfig)(config, value);\n\n      if (fieldConfig) {\n        calculatedValueType = fieldConfig.type;\n      }\n    } else if (valueSrc === \"func\") {\n      var funcKey = value.get(\"func\");\n\n      if (funcKey) {\n        var funcConfig = (0, _configUtils.getFuncConfig)(config, funcKey);\n\n        if (funcConfig) {\n          calculatedValueType = funcConfig.returnType;\n        }\n      }\n    }\n  }\n\n  return calculatedValueType;\n};\n\nvar getField = function getField(state, path) {\n  var field = state.getIn((0, _treeUtils.expandTreePath)(path, \"properties\", \"field\")) || null;\n  return field;\n};\n\nvar emptyDrag = {\n  dragging: {\n    id: null,\n    x: null,\n    y: null,\n    w: null,\n    h: null\n  },\n  mousePos: {},\n  dragStart: {\n    id: null\n  }\n};\n\nvar getActionMeta = function getActionMeta(action, state) {\n  var actionKeysToOmit = [\"config\", \"asyncListValues\", \"__isInternal\"];\n  var actionTypesToIgnore = [constants.SET_TREE, constants.SET_DRAG_START, constants.SET_DRAG_PROGRESS, constants.SET_DRAG_END];\n  var meta = (0, _mapValues[\"default\"])((0, _omit[\"default\"])(action, actionKeysToOmit), _stuff.applyToJS);\n  var affectedField = action.path && getField(state.tree, action.path) || action.field;\n  if (affectedField) meta.affectedField = affectedField;\n  if (actionTypesToIgnore.includes(action.type) || action.type.indexOf(\"@@redux\") == 0) meta = null;\n  return meta;\n};\n/**\n * @param {Immutable.Map} state\n * @param {object} action\n */\n\n\nvar _default = function _default(config) {\n  var emptyTree = (0, _defaultUtils.defaultRoot)(config);\n  var emptyState = Object.assign({}, {\n    tree: emptyTree\n  }, emptyDrag);\n  return function () {\n    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : emptyState;\n    var action = arguments.length > 1 ? arguments[1] : undefined;\n    var unset = {\n      __isInternalValueChange: undefined,\n      __lastAction: undefined\n    };\n    var set = {};\n    var actionMeta = getActionMeta(action, state);\n\n    switch (action.type) {\n      case constants.SET_TREE:\n        {\n          set.tree = action.tree;\n          break;\n        }\n\n      case constants.ADD_CASE_GROUP:\n        {\n          set.tree = addNewGroup(state.tree, action.path, \"case_group\", action.id, action.properties, action.config, action.children, action.meta);\n          break;\n        }\n\n      case constants.ADD_GROUP:\n        {\n          set.tree = addNewGroup(state.tree, action.path, \"group\", action.id, action.properties, action.config, action.children, action.meta);\n          break;\n        }\n\n      case constants.REMOVE_GROUP:\n        {\n          set.tree = removeGroup(state.tree, action.path, action.config);\n          break;\n        }\n\n      case constants.ADD_RULE:\n        {\n          set.tree = addItem(state.tree, action.path, action.ruleType, action.id, action.properties, action.config, action.children);\n          break;\n        }\n\n      case constants.REMOVE_RULE:\n        {\n          set.tree = removeRule(state.tree, action.path, action.config);\n          break;\n        }\n\n      case constants.SET_CONJUNCTION:\n        {\n          set.tree = setConjunction(state.tree, action.path, action.conjunction);\n          break;\n        }\n\n      case constants.SET_NOT:\n        {\n          set.tree = setNot(state.tree, action.path, action.not);\n          break;\n        }\n\n      case constants.SET_FIELD:\n        {\n          set.tree = setField(state.tree, action.path, action.field, action.config);\n          break;\n        }\n\n      case constants.SET_LOCK:\n        {\n          set.tree = setLock(state.tree, action.path, action.lock);\n          break;\n        }\n\n      case constants.SET_OPERATOR:\n        {\n          set.tree = setOperator(state.tree, action.path, action.operator, action.config);\n          break;\n        }\n\n      case constants.SET_VALUE:\n        {\n          var _setValue = setValue(state.tree, action.path, action.delta, action.value, action.valueType, action.config, action.asyncListValues, action.__isInternal),\n              tree = _setValue.tree,\n              isInternalValueChange = _setValue.isInternalValueChange;\n\n          set.__isInternalValueChange = isInternalValueChange;\n          set.tree = tree;\n          break;\n        }\n\n      case constants.SET_VALUE_SRC:\n        {\n          set.tree = setValueSrc(state.tree, action.path, action.delta, action.srcKey, action.config);\n          break;\n        }\n\n      case constants.SET_OPERATOR_OPTION:\n        {\n          set.tree = setOperatorOption(state.tree, action.path, action.name, action.value);\n          break;\n        }\n\n      case constants.MOVE_ITEM:\n        {\n          set.tree = moveItem(state.tree, action.fromPath, action.toPath, action.placement, action.config);\n          break;\n        }\n\n      case constants.SET_DRAG_START:\n        {\n          set.dragStart = action.dragStart;\n          set.dragging = action.dragging;\n          set.mousePos = action.mousePos;\n          break;\n        }\n\n      case constants.SET_DRAG_PROGRESS:\n        {\n          set.mousePos = action.mousePos;\n          set.dragging = action.dragging;\n          break;\n        }\n\n      case constants.SET_DRAG_END:\n        {\n          set.tree = checkEmptyGroups(state.tree, config);\n          set = _objectSpread(_objectSpread({}, set), emptyDrag);\n          break;\n        }\n\n      default:\n        {\n          break;\n        }\n    }\n\n    if (actionMeta) {\n      set.__lastAction = actionMeta;\n    }\n\n    return _objectSpread(_objectSpread(_objectSpread({}, state), unset), set);\n  };\n};\n\nexports[\"default\"] = _default;"]},"metadata":{},"sourceType":"script"}