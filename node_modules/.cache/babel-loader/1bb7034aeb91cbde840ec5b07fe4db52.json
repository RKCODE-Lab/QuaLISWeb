{"ast":null,"code":"import _typeof from \"@babel/runtime/helpers/typeof\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport { getFieldConfig, getOperatorConfig, getFieldWidgetConfig, getFieldRawConfig } from \"./configUtils\";\nimport { defaultValue, getFirstDefined } from \"../utils/stuff\";\nimport Immutable from \"immutable\";\nimport { validateValue } from \"../utils/validation\";\nimport last from \"lodash/last\";\nvar selectTypes = [\"select\", \"multiselect\", \"treeselect\", \"treemultiselect\"];\n/**\n * @param {object} config\n * @param {object} oldConfig\n * @param {Immutable.Map} current\n * @param {string} newField\n * @param {string} newOperator\n * @param {string} changedProp\n * @return {object} - {canReuseValue, newValue, newValueSrc, newValueType, newValueError}\n */\n\nexport var getNewValueForFieldOp = function getNewValueForFieldOp(config) {\n  var oldConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var current = arguments.length > 2 ? arguments[2] : undefined;\n  var newField = arguments.length > 3 ? arguments[3] : undefined;\n  var newOperator = arguments.length > 4 ? arguments[4] : undefined;\n  var changedProp = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n  var canFix = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : true;\n  var isEndValue = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;\n  if (!oldConfig) oldConfig = config;\n  var currentField = current.get(\"field\");\n  var currentOperator = current.get(\"operator\");\n  var currentValue = current.get(\"value\");\n  var currentValueSrc = current.get(\"valueSrc\", new Immutable.List());\n  var currentValueType = current.get(\"valueType\", new Immutable.List());\n  var currentAsyncListValues = current.get(\"asyncListValues\"); //const isValidatingTree = (changedProp === null);\n\n  var _config$settings = config.settings,\n      convertableWidgets = _config$settings.convertableWidgets,\n      clearValueOnChangeField = _config$settings.clearValueOnChangeField,\n      clearValueOnChangeOp = _config$settings.clearValueOnChangeOp,\n      showErrorMessage = _config$settings.showErrorMessage; //const currentOperatorConfig = getOperatorConfig(oldConfig, currentOperator, currentField);\n\n  var newOperatorConfig = getOperatorConfig(config, newOperator, newField); //const currentOperatorCardinality = currentOperator ? defaultValue(currentOperatorConfig.cardinality, 1) : null;\n\n  var operatorCardinality = newOperator ? defaultValue(newOperatorConfig.cardinality, 1) : null;\n  var currentFieldConfig = getFieldConfig(oldConfig, currentField);\n  var newFieldConfig = getFieldConfig(config, newField);\n  var canReuseValue = currentField && currentOperator && newOperator && currentValue != undefined && (!changedProp || changedProp == \"field\" && !clearValueOnChangeField || changedProp == \"operator\" && !clearValueOnChangeOp) && currentFieldConfig && newFieldConfig && currentFieldConfig.type == newFieldConfig.type;\n\n  if (canReuseValue && selectTypes.includes(currentFieldConfig.type) && changedProp == \"field\") {\n    // different fields of select types has different listValues\n    canReuseValue = false;\n  } // compare old & new widgets\n\n\n  for (var i = 0; i < operatorCardinality; i++) {\n    var vs = currentValueSrc.get(i) || null;\n    var currentWidget = getWidgetForFieldOp(oldConfig, currentField, currentOperator, vs);\n    var newWidget = getWidgetForFieldOp(config, newField, newOperator, vs); // need to also check value widgets if we changed operator and current value source was 'field'\n    // cause for select type op '=' requires single value and op 'in' requires array value\n\n    var currentValueWidget = vs == \"value\" ? currentWidget : getWidgetForFieldOp(oldConfig, currentField, currentOperator, \"value\");\n    var newValueWidget = vs == \"value\" ? newWidget : getWidgetForFieldOp(config, newField, newOperator, \"value\");\n    var canReuseWidget = newValueWidget == currentValueWidget || (convertableWidgets[currentValueWidget] || []).includes(newValueWidget);\n    if (!canReuseWidget) canReuseValue = false;\n  }\n\n  if (currentOperator != newOperator && [currentOperator, newOperator].includes(\"proximity\")) canReuseValue = false;\n  var firstWidgetConfig = getFieldWidgetConfig(config, newField, newOperator, null, currentValueSrc.first());\n  var valueSources = getValueSourcesForFieldOp(config, newField, newOperator);\n  var valueFixes = {};\n  var valueErrors = Array.from({\n    length: operatorCardinality\n  }, function () {\n    return null;\n  });\n\n  if (canReuseValue) {\n    var _loop = function _loop() {\n      var v = currentValue.get(_i);\n      var vType = currentValueType.get(_i) || null;\n      var vSrc = currentValueSrc.get(_i) || null;\n      var isValidSrc = valueSources.find(function (v) {\n        return v == vSrc;\n      }) != null;\n      if (!isValidSrc && _i > 0 && vSrc == null) isValidSrc = true; // make exception for range widgets (when changing op from '==' to 'between')\n\n      var asyncListValues = currentAsyncListValues;\n\n      var _validateValue = validateValue(config, newField, newField, newOperator, v, vType, vSrc, asyncListValues, canFix, isEndValue),\n          _validateValue2 = _slicedToArray(_validateValue, 2),\n          validateError = _validateValue2[0],\n          fixedValue = _validateValue2[1];\n\n      var isValid = !validateError; // Allow bad value with error message\n      // But not on field change - in that case just drop bad value that can't be reused\n      // ? Maybe we should also drop bad value on op change?\n      // For bad multiselect value we have both error message + fixed value.\n      //  If we show error message, it will gone on next tree validation\n\n      var fixValue = fixedValue !== v;\n      var dropValue = !isValidSrc || !isValid && (changedProp == \"field\" || !showErrorMessage && !fixValue);\n      var showValueError = !!validateError && showErrorMessage && !dropValue && !fixValue;\n\n      if (showValueError) {\n        valueErrors[_i] = validateError;\n      }\n\n      if (fixValue) {\n        valueFixes[_i] = fixedValue;\n      }\n\n      if (dropValue) {\n        canReuseValue = false;\n        return \"break\";\n      }\n    };\n\n    for (var _i = 0; _i < operatorCardinality; _i++) {\n      var _ret = _loop();\n\n      if (_ret === \"break\") break;\n    }\n  } // reuse value OR get defaultValue for cardinality 1 (it means default range values is not supported yet, todo)\n\n\n  var newValue = null,\n      newValueSrc = null,\n      newValueType = null,\n      newValueError = null;\n  newValue = new Immutable.List(Array.from({\n    length: operatorCardinality\n  }, function (_ignore, i) {\n    var v = undefined;\n\n    if (canReuseValue) {\n      if (i < currentValue.size) {\n        v = currentValue.get(i);\n\n        if (valueFixes[i] !== undefined) {\n          v = valueFixes[i];\n        }\n      }\n    } else if (operatorCardinality == 1) {\n      var _newFieldConfig$field;\n\n      v = getFirstDefined([newFieldConfig === null || newFieldConfig === void 0 ? void 0 : newFieldConfig.defaultValue, newFieldConfig === null || newFieldConfig === void 0 ? void 0 : (_newFieldConfig$field = newFieldConfig.fieldSettings) === null || _newFieldConfig$field === void 0 ? void 0 : _newFieldConfig$field.defaultValue, firstWidgetConfig === null || firstWidgetConfig === void 0 ? void 0 : firstWidgetConfig.defaultValue]);\n    }\n\n    return v;\n  }));\n  newValueSrc = new Immutable.List(Array.from({\n    length: operatorCardinality\n  }, function (_ignore, i) {\n    var vs = null;\n\n    if (canReuseValue) {\n      if (i < currentValueSrc.size) vs = currentValueSrc.get(i);\n    } else if (valueSources.length == 1) {\n      vs = valueSources[0];\n    } else if (valueSources.length > 1) {\n      vs = valueSources[0];\n    }\n\n    return vs;\n  }));\n\n  if (showErrorMessage) {\n    if (newOperatorConfig && newOperatorConfig.validateValues && newValueSrc.toJS().filter(function (vs) {\n      return vs == \"value\" || vs == null;\n    }).length == operatorCardinality) {\n      // last element in `valueError` list is for range validation error\n      var jsValues = firstWidgetConfig && firstWidgetConfig.toJS ? newValue.toJS().map(function (v) {\n        return firstWidgetConfig.toJS(v, firstWidgetConfig);\n      }) : newValue.toJS();\n      var rangeValidateError = newOperatorConfig.validateValues(jsValues);\n\n      if (showErrorMessage) {\n        valueErrors.push(rangeValidateError);\n      }\n    }\n\n    newValueError = new Immutable.List(valueErrors);\n  }\n\n  newValueType = new Immutable.List(Array.from({\n    length: operatorCardinality\n  }, function (_ignore, i) {\n    var vt = null;\n\n    if (canReuseValue) {\n      if (i < currentValueType.size) vt = currentValueType.get(i);\n    } else if (operatorCardinality == 1 && firstWidgetConfig && firstWidgetConfig.type !== undefined) {\n      vt = firstWidgetConfig.type;\n    } else if (operatorCardinality == 1 && newFieldConfig && newFieldConfig.type !== undefined) {\n      vt = newFieldConfig.type == \"!group\" ? \"number\" : newFieldConfig.type;\n    }\n\n    return vt;\n  }));\n  return {\n    canReuseValue: canReuseValue,\n    newValue: newValue,\n    newValueSrc: newValueSrc,\n    newValueType: newValueType,\n    newValueError: newValueError,\n    operatorCardinality: operatorCardinality\n  };\n};\nexport var getFirstField = function getFirstField(config) {\n  var parentRuleGroupPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var fieldSeparator = config.settings.fieldSeparator;\n  var parentPathArr = typeof parentRuleGroupPath == \"string\" ? parentRuleGroupPath.split(fieldSeparator) : parentRuleGroupPath;\n  var parentField = parentRuleGroupPath ? getFieldRawConfig(config, parentRuleGroupPath) : config;\n  var firstField = parentField,\n      key = null,\n      keysPath = [];\n\n  do {\n    var subfields = firstField === config ? config.fields : firstField.subfields;\n\n    if (!subfields || !Object.keys(subfields).length) {\n      firstField = key = null;\n      break;\n    }\n\n    key = Object.keys(subfields)[0];\n    keysPath.push(key);\n    firstField = subfields[key];\n  } while (firstField.type == \"!struct\" || firstField.type == \"!group\");\n\n  return (parentPathArr || []).concat(keysPath).join(fieldSeparator);\n};\nexport var getOperatorsForField = function getOperatorsForField(config, field) {\n  var fieldConfig = getFieldConfig(config, field);\n  var fieldOps = fieldConfig ? fieldConfig.operators : [];\n  return fieldOps;\n};\nexport var getFirstOperator = function getFirstOperator(config, field) {\n  var fieldOps = getOperatorsForField(config, field);\n  return fieldOps ? fieldOps[0] : null;\n};\nexport var getFieldPath = function getFieldPath(field, config) {\n  var onlyKeys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  if (!field) return null;\n  var fieldSeparator = config.settings.fieldSeparator;\n  var parts = Array.isArray(field) ? field : field.split(fieldSeparator);\n  if (onlyKeys) return parts;else return parts.map(function (_curr, ind, arr) {\n    return arr.slice(0, ind + 1);\n  }).map(function (parts) {\n    return parts.join(fieldSeparator);\n  });\n};\nexport var getFuncPathLabels = function getFuncPathLabels(field, config) {\n  var parentField = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  return getFieldPathLabels(field, config, parentField, \"funcs\", \"subfields\");\n};\nexport var getFieldPathLabels = function getFieldPathLabels(field, config) {\n  var parentField = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var fieldsKey = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"fields\";\n  var subfieldsKey = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : \"subfields\";\n  if (!field) return null;\n  var fieldSeparator = config.settings.fieldSeparator;\n  var parts = Array.isArray(field) ? field : field.split(fieldSeparator);\n  var parentParts = parentField ? Array.isArray(parentField) ? parentField : parentField.split(fieldSeparator) : [];\n  return parts.slice(parentParts.length).map(function (_curr, ind, arr) {\n    return arr.slice(0, ind + 1);\n  }).map(function (parts) {\n    return [].concat(_toConsumableArray(parentParts), _toConsumableArray(parts)).join(fieldSeparator);\n  }).map(function (part) {\n    var cnf = getFieldRawConfig(config, part, fieldsKey, subfieldsKey);\n    return cnf && cnf.label || cnf && last(part.split(fieldSeparator));\n  }).filter(function (label) {\n    return label != null;\n  });\n};\nexport var getFieldPartsConfigs = function getFieldPartsConfigs(field, config) {\n  var parentField = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  if (!field) return null;\n  var parentFieldDef = parentField && getFieldRawConfig(config, parentField) || null;\n  var fieldSeparator = config.settings.fieldSeparator;\n  var parts = Array.isArray(field) ? field : field.split(fieldSeparator);\n  var parentParts = parentField ? Array.isArray(parentField) ? parentField : parentField.split(fieldSeparator) : [];\n  return parts.slice(parentParts.length).map(function (_curr, ind, arr) {\n    return arr.slice(0, ind + 1);\n  }).map(function (parts) {\n    return {\n      part: [].concat(_toConsumableArray(parentParts), _toConsumableArray(parts)).join(fieldSeparator),\n      key: parts[parts.length - 1]\n    };\n  }).map(function (_ref) {\n    var part = _ref.part,\n        key = _ref.key;\n    var cnf = getFieldRawConfig(config, part);\n    return {\n      key: key,\n      cnf: cnf\n    };\n  }).map(function (_ref2, ind, arr) {\n    var key = _ref2.key,\n        cnf = _ref2.cnf;\n    var parentCnf = ind > 0 ? arr[ind - 1].cnf : parentFieldDef;\n    return [key, cnf, parentCnf];\n  });\n};\nexport var getValueLabel = function getValueLabel(config, field, operator, delta) {\n  var valueSrc = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  var isSpecialRange = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  var isFuncArg = field && _typeof(field) == \"object\" && !!field.func && !!field.arg;\n  var showLabels = config.settings.showLabels;\n  var fieldConfig = getFieldConfig(config, field);\n  var fieldWidgetConfig = getFieldWidgetConfig(config, field, operator, null, valueSrc) || {};\n  var mergedOpConfig = getOperatorConfig(config, operator, field) || {};\n  var cardinality = isSpecialRange ? 1 : mergedOpConfig.cardinality;\n  var ret = null;\n\n  if (cardinality > 1) {\n    var valueLabels = fieldWidgetConfig.valueLabels || mergedOpConfig.valueLabels;\n    if (valueLabels) ret = valueLabels[delta];\n\n    if (ret && _typeof(ret) != \"object\") {\n      ret = {\n        label: ret,\n        placeholder: ret\n      };\n    }\n\n    if (!ret) {\n      ret = {\n        label: config.settings.valueLabel + \" \" + (delta + 1),\n        placeholder: config.settings.valuePlaceholder + \" \" + (delta + 1)\n      };\n    }\n  } else {\n    var label = fieldWidgetConfig.valueLabel;\n    var placeholder = fieldWidgetConfig.valuePlaceholder;\n\n    if (isFuncArg) {\n      if (!label) label = fieldConfig.label || field.arg;\n      if (!placeholder && !showLabels) placeholder = fieldConfig.label || field.arg;\n    }\n\n    ret = {\n      label: label || config.settings.valueLabel,\n      placeholder: placeholder || config.settings.valuePlaceholder\n    };\n  }\n\n  return ret;\n};\n\nfunction _getWidgetsAndSrcsForFieldOp(config, field) {\n  var operator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var valueSrc = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var widgets = [];\n  var valueSrcs = [];\n  if (!field) return {\n    widgets: widgets,\n    valueSrcs: valueSrcs\n  };\n\n  var isFuncArg = _typeof(field) == \"object\" && (!!field.func && !!field.arg || field._isFuncArg);\n\n  var fieldConfig = getFieldConfig(config, field);\n  var opConfig = operator ? config.operators[operator] : null;\n\n  if (fieldConfig && fieldConfig.widgets) {\n    var _loop2 = function _loop2() {\n      var widgetConfig = fieldConfig.widgets[widget]; // if (!config.widgets[widget]) {\n      //   continue;\n      // }\n\n      var widgetValueSrc = config.widgets[widget].valueSrc || \"value\";\n      var canAdd = true;\n\n      if (widget == \"field\") {\n        canAdd = canAdd && filterValueSourcesForField(config, [\"field\"], fieldConfig).length > 0;\n      }\n\n      if (widget == \"func\") {\n        canAdd = canAdd && filterValueSourcesForField(config, [\"func\"], fieldConfig).length > 0;\n      } // If can't check operators, don't add\n      // Func args don't have operators\n\n\n      if (valueSrc == \"value\" && !widgetConfig.operators && !isFuncArg && field != \"!case_value\") canAdd = false;\n      if (widgetConfig.operators && operator) canAdd = canAdd && widgetConfig.operators.indexOf(operator) != -1;\n      if (valueSrc && valueSrc != widgetValueSrc && valueSrc != \"const\") canAdd = false;\n      if (opConfig && opConfig.cardinality == 0 && widgetValueSrc != \"value\") canAdd = false;\n\n      if (canAdd) {\n        widgets.push(widget);\n        var canAddValueSrc = fieldConfig.valueSources && fieldConfig.valueSources.indexOf(widgetValueSrc) != -1;\n        if (opConfig && opConfig.valueSources && opConfig.valueSources.indexOf(widgetValueSrc) == -1) canAddValueSrc = false;\n        if (canAddValueSrc && !valueSrcs.find(function (v) {\n          return v == widgetValueSrc;\n        })) valueSrcs.push(widgetValueSrc);\n      }\n    };\n\n    for (var widget in fieldConfig.widgets) {\n      _loop2();\n    }\n  }\n\n  var widgetWeight = function widgetWeight(w) {\n    var wg = 0;\n\n    if (fieldConfig.preferWidgets) {\n      if (fieldConfig.preferWidgets.includes(w)) wg += 10 - fieldConfig.preferWidgets.indexOf(w);\n    } else if (w == fieldConfig.mainWidget) {\n      wg += 100;\n    }\n\n    if (w == \"field\") {\n      wg -= 1;\n    }\n\n    if (w == \"func\") {\n      wg -= 2;\n    }\n\n    return wg;\n  };\n\n  widgets.sort(function (w1, w2) {\n    return widgetWeight(w2) - widgetWeight(w1);\n  });\n  return {\n    widgets: widgets,\n    valueSrcs: valueSrcs\n  };\n}\n\nexport var getWidgetsForFieldOp = function getWidgetsForFieldOp(config, field, operator) {\n  var valueSrc = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n  var _getWidgetsAndSrcsFor = _getWidgetsAndSrcsForFieldOp(config, field, operator, valueSrc),\n      widgets = _getWidgetsAndSrcsFor.widgets;\n\n  return widgets;\n};\nexport var filterValueSourcesForField = function filterValueSourcesForField(config, valueSrcs, fieldDefinition) {\n  if (!fieldDefinition) return valueSrcs;\n  return valueSrcs.filter(function (vs) {\n    var canAdd = true;\n\n    if (vs == \"field\") {\n      if (config._fieldsCntByType) {\n        // tip: LHS field can be used as arg in RHS function\n        var minCnt = fieldDefinition._isFuncArg ? 0 : 1;\n        canAdd = canAdd && config._fieldsCntByType[fieldDefinition.type] > minCnt;\n      }\n    }\n\n    if (vs == \"func\") {\n      if (config._funcsCntByType) canAdd = canAdd && !!config._funcsCntByType[fieldDefinition.type];\n      if (fieldDefinition.funcs) canAdd = canAdd && fieldDefinition.funcs.length > 0;\n    }\n\n    return canAdd;\n  });\n};\nexport var getValueSourcesForFieldOp = function getValueSourcesForFieldOp(config, field, operator) {\n  var fieldDefinition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var leftFieldForFunc = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n\n  var _getWidgetsAndSrcsFor2 = _getWidgetsAndSrcsForFieldOp(config, field, operator, null),\n      valueSrcs = _getWidgetsAndSrcsFor2.valueSrcs;\n\n  var filteredValueSrcs = filterValueSourcesForField(config, valueSrcs, fieldDefinition);\n  return filteredValueSrcs;\n};\nexport var getWidgetForFieldOp = function getWidgetForFieldOp(config, field, operator) {\n  var valueSrc = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n  var _getWidgetsAndSrcsFor3 = _getWidgetsAndSrcsForFieldOp(config, field, operator, valueSrc),\n      widgets = _getWidgetsAndSrcsFor3.widgets;\n\n  var widget = null;\n  if (widgets.length) widget = widgets[0];\n  return widget;\n};\nexport var formatFieldName = function formatFieldName(field, config, meta) {\n  var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  if (!field) return;\n  var fieldDef = getFieldConfig(config, field) || {};\n  var fieldSeparator = config.settings.fieldSeparator;\n  var fieldParts = Array.isArray(field) ? field : field.split(fieldSeparator);\n  var fieldName = Array.isArray(field) ? field.join(fieldSeparator) : field;\n\n  if (fieldDef.tableName) {\n    // legacy\n    var fieldPartsCopy = _toConsumableArray(fieldParts);\n\n    fieldPartsCopy[0] = fieldDef.tableName;\n    fieldName = fieldPartsCopy.join(fieldSeparator);\n  }\n\n  if (fieldDef.fieldName) {\n    fieldName = fieldDef.fieldName;\n  }\n\n  if (parentField) {\n    var parentFieldDef = getFieldConfig(config, parentField) || {};\n    var parentFieldName = parentField;\n\n    if (parentFieldDef.fieldName) {\n      parentFieldName = parentFieldDef.fieldName;\n    }\n\n    if (fieldName.indexOf(parentFieldName + fieldSeparator) == 0) {\n      fieldName = fieldName.slice((parentFieldName + fieldSeparator).length);\n    } else {\n      meta.errors.push(\"Can't cut group \".concat(parentFieldName, \" from field \").concat(fieldName));\n    }\n  }\n\n  return fieldName;\n};","map":{"version":3,"sources":["D:/LIMSWFH/LIMSPOSTGRESQL/QuaLISWeb/node_modules/@react-awesome-query-builder/core/esm/utils/ruleUtils.js"],"names":["_typeof","_toConsumableArray","_slicedToArray","getFieldConfig","getOperatorConfig","getFieldWidgetConfig","getFieldRawConfig","defaultValue","getFirstDefined","Immutable","validateValue","last","selectTypes","getNewValueForFieldOp","config","oldConfig","arguments","length","undefined","current","newField","newOperator","changedProp","canFix","isEndValue","currentField","get","currentOperator","currentValue","currentValueSrc","List","currentValueType","currentAsyncListValues","_config$settings","settings","convertableWidgets","clearValueOnChangeField","clearValueOnChangeOp","showErrorMessage","newOperatorConfig","operatorCardinality","cardinality","currentFieldConfig","newFieldConfig","canReuseValue","type","includes","i","vs","currentWidget","getWidgetForFieldOp","newWidget","currentValueWidget","newValueWidget","canReuseWidget","firstWidgetConfig","first","valueSources","getValueSourcesForFieldOp","valueFixes","valueErrors","Array","from","_loop","v","_i","vType","vSrc","isValidSrc","find","asyncListValues","_validateValue","_validateValue2","validateError","fixedValue","isValid","fixValue","dropValue","showValueError","_ret","newValue","newValueSrc","newValueType","newValueError","_ignore","size","_newFieldConfig$field","fieldSettings","validateValues","toJS","filter","jsValues","map","rangeValidateError","push","vt","getFirstField","parentRuleGroupPath","fieldSeparator","parentPathArr","split","parentField","firstField","key","keysPath","subfields","fields","Object","keys","concat","join","getOperatorsForField","field","fieldConfig","fieldOps","operators","getFirstOperator","getFieldPath","onlyKeys","parts","isArray","_curr","ind","arr","slice","getFuncPathLabels","getFieldPathLabels","fieldsKey","subfieldsKey","parentParts","part","cnf","label","getFieldPartsConfigs","parentFieldDef","_ref","_ref2","parentCnf","getValueLabel","operator","delta","valueSrc","isSpecialRange","isFuncArg","func","arg","showLabels","fieldWidgetConfig","mergedOpConfig","ret","valueLabels","placeholder","valueLabel","valuePlaceholder","_getWidgetsAndSrcsForFieldOp","widgets","valueSrcs","_isFuncArg","opConfig","_loop2","widgetConfig","widget","widgetValueSrc","canAdd","filterValueSourcesForField","indexOf","canAddValueSrc","widgetWeight","w","wg","preferWidgets","mainWidget","sort","w1","w2","getWidgetsForFieldOp","_getWidgetsAndSrcsFor","fieldDefinition","_fieldsCntByType","minCnt","_funcsCntByType","funcs","leftFieldForFunc","_getWidgetsAndSrcsFor2","filteredValueSrcs","_getWidgetsAndSrcsFor3","formatFieldName","meta","fieldDef","fieldParts","fieldName","tableName","fieldPartsCopy","parentFieldName","errors"],"mappings":"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","sourcesContent":["import _typeof from \"@babel/runtime/helpers/typeof\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport { getFieldConfig, getOperatorConfig, getFieldWidgetConfig, getFieldRawConfig } from \"./configUtils\";\nimport { defaultValue, getFirstDefined } from \"../utils/stuff\";\nimport Immutable from \"immutable\";\nimport { validateValue } from \"../utils/validation\";\nimport last from \"lodash/last\";\nvar selectTypes = [\"select\", \"multiselect\", \"treeselect\", \"treemultiselect\"];\n\n/**\n * @param {object} config\n * @param {object} oldConfig\n * @param {Immutable.Map} current\n * @param {string} newField\n * @param {string} newOperator\n * @param {string} changedProp\n * @return {object} - {canReuseValue, newValue, newValueSrc, newValueType, newValueError}\n */\nexport var getNewValueForFieldOp = function getNewValueForFieldOp(config) {\n  var oldConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var current = arguments.length > 2 ? arguments[2] : undefined;\n  var newField = arguments.length > 3 ? arguments[3] : undefined;\n  var newOperator = arguments.length > 4 ? arguments[4] : undefined;\n  var changedProp = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n  var canFix = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : true;\n  var isEndValue = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;\n  if (!oldConfig) oldConfig = config;\n  var currentField = current.get(\"field\");\n  var currentOperator = current.get(\"operator\");\n  var currentValue = current.get(\"value\");\n  var currentValueSrc = current.get(\"valueSrc\", new Immutable.List());\n  var currentValueType = current.get(\"valueType\", new Immutable.List());\n  var currentAsyncListValues = current.get(\"asyncListValues\");\n\n  //const isValidatingTree = (changedProp === null);\n  var _config$settings = config.settings,\n    convertableWidgets = _config$settings.convertableWidgets,\n    clearValueOnChangeField = _config$settings.clearValueOnChangeField,\n    clearValueOnChangeOp = _config$settings.clearValueOnChangeOp,\n    showErrorMessage = _config$settings.showErrorMessage;\n\n  //const currentOperatorConfig = getOperatorConfig(oldConfig, currentOperator, currentField);\n  var newOperatorConfig = getOperatorConfig(config, newOperator, newField);\n  //const currentOperatorCardinality = currentOperator ? defaultValue(currentOperatorConfig.cardinality, 1) : null;\n  var operatorCardinality = newOperator ? defaultValue(newOperatorConfig.cardinality, 1) : null;\n  var currentFieldConfig = getFieldConfig(oldConfig, currentField);\n  var newFieldConfig = getFieldConfig(config, newField);\n  var canReuseValue = currentField && currentOperator && newOperator && currentValue != undefined && (!changedProp || changedProp == \"field\" && !clearValueOnChangeField || changedProp == \"operator\" && !clearValueOnChangeOp) && currentFieldConfig && newFieldConfig && currentFieldConfig.type == newFieldConfig.type;\n  if (canReuseValue && selectTypes.includes(currentFieldConfig.type) && changedProp == \"field\") {\n    // different fields of select types has different listValues\n    canReuseValue = false;\n  }\n\n  // compare old & new widgets\n  for (var i = 0; i < operatorCardinality; i++) {\n    var vs = currentValueSrc.get(i) || null;\n    var currentWidget = getWidgetForFieldOp(oldConfig, currentField, currentOperator, vs);\n    var newWidget = getWidgetForFieldOp(config, newField, newOperator, vs);\n    // need to also check value widgets if we changed operator and current value source was 'field'\n    // cause for select type op '=' requires single value and op 'in' requires array value\n    var currentValueWidget = vs == \"value\" ? currentWidget : getWidgetForFieldOp(oldConfig, currentField, currentOperator, \"value\");\n    var newValueWidget = vs == \"value\" ? newWidget : getWidgetForFieldOp(config, newField, newOperator, \"value\");\n    var canReuseWidget = newValueWidget == currentValueWidget || (convertableWidgets[currentValueWidget] || []).includes(newValueWidget);\n    if (!canReuseWidget) canReuseValue = false;\n  }\n  if (currentOperator != newOperator && [currentOperator, newOperator].includes(\"proximity\")) canReuseValue = false;\n  var firstWidgetConfig = getFieldWidgetConfig(config, newField, newOperator, null, currentValueSrc.first());\n  var valueSources = getValueSourcesForFieldOp(config, newField, newOperator);\n  var valueFixes = {};\n  var valueErrors = Array.from({\n    length: operatorCardinality\n  }, function () {\n    return null;\n  });\n  if (canReuseValue) {\n    var _loop = function _loop() {\n      var v = currentValue.get(_i);\n      var vType = currentValueType.get(_i) || null;\n      var vSrc = currentValueSrc.get(_i) || null;\n      var isValidSrc = valueSources.find(function (v) {\n        return v == vSrc;\n      }) != null;\n      if (!isValidSrc && _i > 0 && vSrc == null) isValidSrc = true; // make exception for range widgets (when changing op from '==' to 'between')\n      var asyncListValues = currentAsyncListValues;\n      var _validateValue = validateValue(config, newField, newField, newOperator, v, vType, vSrc, asyncListValues, canFix, isEndValue),\n        _validateValue2 = _slicedToArray(_validateValue, 2),\n        validateError = _validateValue2[0],\n        fixedValue = _validateValue2[1];\n      var isValid = !validateError;\n      // Allow bad value with error message\n      // But not on field change - in that case just drop bad value that can't be reused\n      // ? Maybe we should also drop bad value on op change?\n      // For bad multiselect value we have both error message + fixed value.\n      //  If we show error message, it will gone on next tree validation\n      var fixValue = fixedValue !== v;\n      var dropValue = !isValidSrc || !isValid && (changedProp == \"field\" || !showErrorMessage && !fixValue);\n      var showValueError = !!validateError && showErrorMessage && !dropValue && !fixValue;\n      if (showValueError) {\n        valueErrors[_i] = validateError;\n      }\n      if (fixValue) {\n        valueFixes[_i] = fixedValue;\n      }\n      if (dropValue) {\n        canReuseValue = false;\n        return \"break\";\n      }\n    };\n    for (var _i = 0; _i < operatorCardinality; _i++) {\n      var _ret = _loop();\n      if (_ret === \"break\") break;\n    }\n  }\n\n  // reuse value OR get defaultValue for cardinality 1 (it means default range values is not supported yet, todo)\n  var newValue = null,\n    newValueSrc = null,\n    newValueType = null,\n    newValueError = null;\n  newValue = new Immutable.List(Array.from({\n    length: operatorCardinality\n  }, function (_ignore, i) {\n    var v = undefined;\n    if (canReuseValue) {\n      if (i < currentValue.size) {\n        v = currentValue.get(i);\n        if (valueFixes[i] !== undefined) {\n          v = valueFixes[i];\n        }\n      }\n    } else if (operatorCardinality == 1) {\n      var _newFieldConfig$field;\n      v = getFirstDefined([newFieldConfig === null || newFieldConfig === void 0 ? void 0 : newFieldConfig.defaultValue, newFieldConfig === null || newFieldConfig === void 0 ? void 0 : (_newFieldConfig$field = newFieldConfig.fieldSettings) === null || _newFieldConfig$field === void 0 ? void 0 : _newFieldConfig$field.defaultValue, firstWidgetConfig === null || firstWidgetConfig === void 0 ? void 0 : firstWidgetConfig.defaultValue]);\n    }\n    return v;\n  }));\n  newValueSrc = new Immutable.List(Array.from({\n    length: operatorCardinality\n  }, function (_ignore, i) {\n    var vs = null;\n    if (canReuseValue) {\n      if (i < currentValueSrc.size) vs = currentValueSrc.get(i);\n    } else if (valueSources.length == 1) {\n      vs = valueSources[0];\n    } else if (valueSources.length > 1) {\n      vs = valueSources[0];\n    }\n    return vs;\n  }));\n  if (showErrorMessage) {\n    if (newOperatorConfig && newOperatorConfig.validateValues && newValueSrc.toJS().filter(function (vs) {\n      return vs == \"value\" || vs == null;\n    }).length == operatorCardinality) {\n      // last element in `valueError` list is for range validation error\n      var jsValues = firstWidgetConfig && firstWidgetConfig.toJS ? newValue.toJS().map(function (v) {\n        return firstWidgetConfig.toJS(v, firstWidgetConfig);\n      }) : newValue.toJS();\n      var rangeValidateError = newOperatorConfig.validateValues(jsValues);\n      if (showErrorMessage) {\n        valueErrors.push(rangeValidateError);\n      }\n    }\n    newValueError = new Immutable.List(valueErrors);\n  }\n  newValueType = new Immutable.List(Array.from({\n    length: operatorCardinality\n  }, function (_ignore, i) {\n    var vt = null;\n    if (canReuseValue) {\n      if (i < currentValueType.size) vt = currentValueType.get(i);\n    } else if (operatorCardinality == 1 && firstWidgetConfig && firstWidgetConfig.type !== undefined) {\n      vt = firstWidgetConfig.type;\n    } else if (operatorCardinality == 1 && newFieldConfig && newFieldConfig.type !== undefined) {\n      vt = newFieldConfig.type == \"!group\" ? \"number\" : newFieldConfig.type;\n    }\n    return vt;\n  }));\n  return {\n    canReuseValue: canReuseValue,\n    newValue: newValue,\n    newValueSrc: newValueSrc,\n    newValueType: newValueType,\n    newValueError: newValueError,\n    operatorCardinality: operatorCardinality\n  };\n};\nexport var getFirstField = function getFirstField(config) {\n  var parentRuleGroupPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var fieldSeparator = config.settings.fieldSeparator;\n  var parentPathArr = typeof parentRuleGroupPath == \"string\" ? parentRuleGroupPath.split(fieldSeparator) : parentRuleGroupPath;\n  var parentField = parentRuleGroupPath ? getFieldRawConfig(config, parentRuleGroupPath) : config;\n  var firstField = parentField,\n    key = null,\n    keysPath = [];\n  do {\n    var subfields = firstField === config ? config.fields : firstField.subfields;\n    if (!subfields || !Object.keys(subfields).length) {\n      firstField = key = null;\n      break;\n    }\n    key = Object.keys(subfields)[0];\n    keysPath.push(key);\n    firstField = subfields[key];\n  } while (firstField.type == \"!struct\" || firstField.type == \"!group\");\n  return (parentPathArr || []).concat(keysPath).join(fieldSeparator);\n};\nexport var getOperatorsForField = function getOperatorsForField(config, field) {\n  var fieldConfig = getFieldConfig(config, field);\n  var fieldOps = fieldConfig ? fieldConfig.operators : [];\n  return fieldOps;\n};\nexport var getFirstOperator = function getFirstOperator(config, field) {\n  var fieldOps = getOperatorsForField(config, field);\n  return fieldOps ? fieldOps[0] : null;\n};\nexport var getFieldPath = function getFieldPath(field, config) {\n  var onlyKeys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  if (!field) return null;\n  var fieldSeparator = config.settings.fieldSeparator;\n  var parts = Array.isArray(field) ? field : field.split(fieldSeparator);\n  if (onlyKeys) return parts;else return parts.map(function (_curr, ind, arr) {\n    return arr.slice(0, ind + 1);\n  }).map(function (parts) {\n    return parts.join(fieldSeparator);\n  });\n};\nexport var getFuncPathLabels = function getFuncPathLabels(field, config) {\n  var parentField = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  return getFieldPathLabels(field, config, parentField, \"funcs\", \"subfields\");\n};\nexport var getFieldPathLabels = function getFieldPathLabels(field, config) {\n  var parentField = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var fieldsKey = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"fields\";\n  var subfieldsKey = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : \"subfields\";\n  if (!field) return null;\n  var fieldSeparator = config.settings.fieldSeparator;\n  var parts = Array.isArray(field) ? field : field.split(fieldSeparator);\n  var parentParts = parentField ? Array.isArray(parentField) ? parentField : parentField.split(fieldSeparator) : [];\n  return parts.slice(parentParts.length).map(function (_curr, ind, arr) {\n    return arr.slice(0, ind + 1);\n  }).map(function (parts) {\n    return [].concat(_toConsumableArray(parentParts), _toConsumableArray(parts)).join(fieldSeparator);\n  }).map(function (part) {\n    var cnf = getFieldRawConfig(config, part, fieldsKey, subfieldsKey);\n    return cnf && cnf.label || cnf && last(part.split(fieldSeparator));\n  }).filter(function (label) {\n    return label != null;\n  });\n};\nexport var getFieldPartsConfigs = function getFieldPartsConfigs(field, config) {\n  var parentField = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  if (!field) return null;\n  var parentFieldDef = parentField && getFieldRawConfig(config, parentField) || null;\n  var fieldSeparator = config.settings.fieldSeparator;\n  var parts = Array.isArray(field) ? field : field.split(fieldSeparator);\n  var parentParts = parentField ? Array.isArray(parentField) ? parentField : parentField.split(fieldSeparator) : [];\n  return parts.slice(parentParts.length).map(function (_curr, ind, arr) {\n    return arr.slice(0, ind + 1);\n  }).map(function (parts) {\n    return {\n      part: [].concat(_toConsumableArray(parentParts), _toConsumableArray(parts)).join(fieldSeparator),\n      key: parts[parts.length - 1]\n    };\n  }).map(function (_ref) {\n    var part = _ref.part,\n      key = _ref.key;\n    var cnf = getFieldRawConfig(config, part);\n    return {\n      key: key,\n      cnf: cnf\n    };\n  }).map(function (_ref2, ind, arr) {\n    var key = _ref2.key,\n      cnf = _ref2.cnf;\n    var parentCnf = ind > 0 ? arr[ind - 1].cnf : parentFieldDef;\n    return [key, cnf, parentCnf];\n  });\n};\nexport var getValueLabel = function getValueLabel(config, field, operator, delta) {\n  var valueSrc = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  var isSpecialRange = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  var isFuncArg = field && _typeof(field) == \"object\" && !!field.func && !!field.arg;\n  var showLabels = config.settings.showLabels;\n  var fieldConfig = getFieldConfig(config, field);\n  var fieldWidgetConfig = getFieldWidgetConfig(config, field, operator, null, valueSrc) || {};\n  var mergedOpConfig = getOperatorConfig(config, operator, field) || {};\n  var cardinality = isSpecialRange ? 1 : mergedOpConfig.cardinality;\n  var ret = null;\n  if (cardinality > 1) {\n    var valueLabels = fieldWidgetConfig.valueLabels || mergedOpConfig.valueLabels;\n    if (valueLabels) ret = valueLabels[delta];\n    if (ret && _typeof(ret) != \"object\") {\n      ret = {\n        label: ret,\n        placeholder: ret\n      };\n    }\n    if (!ret) {\n      ret = {\n        label: config.settings.valueLabel + \" \" + (delta + 1),\n        placeholder: config.settings.valuePlaceholder + \" \" + (delta + 1)\n      };\n    }\n  } else {\n    var label = fieldWidgetConfig.valueLabel;\n    var placeholder = fieldWidgetConfig.valuePlaceholder;\n    if (isFuncArg) {\n      if (!label) label = fieldConfig.label || field.arg;\n      if (!placeholder && !showLabels) placeholder = fieldConfig.label || field.arg;\n    }\n    ret = {\n      label: label || config.settings.valueLabel,\n      placeholder: placeholder || config.settings.valuePlaceholder\n    };\n  }\n  return ret;\n};\nfunction _getWidgetsAndSrcsForFieldOp(config, field) {\n  var operator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var valueSrc = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var widgets = [];\n  var valueSrcs = [];\n  if (!field) return {\n    widgets: widgets,\n    valueSrcs: valueSrcs\n  };\n  var isFuncArg = _typeof(field) == \"object\" && (!!field.func && !!field.arg || field._isFuncArg);\n  var fieldConfig = getFieldConfig(config, field);\n  var opConfig = operator ? config.operators[operator] : null;\n  if (fieldConfig && fieldConfig.widgets) {\n    var _loop2 = function _loop2() {\n      var widgetConfig = fieldConfig.widgets[widget];\n      // if (!config.widgets[widget]) {\n      //   continue;\n      // }\n      var widgetValueSrc = config.widgets[widget].valueSrc || \"value\";\n      var canAdd = true;\n      if (widget == \"field\") {\n        canAdd = canAdd && filterValueSourcesForField(config, [\"field\"], fieldConfig).length > 0;\n      }\n      if (widget == \"func\") {\n        canAdd = canAdd && filterValueSourcesForField(config, [\"func\"], fieldConfig).length > 0;\n      }\n      // If can't check operators, don't add\n      // Func args don't have operators\n      if (valueSrc == \"value\" && !widgetConfig.operators && !isFuncArg && field != \"!case_value\") canAdd = false;\n      if (widgetConfig.operators && operator) canAdd = canAdd && widgetConfig.operators.indexOf(operator) != -1;\n      if (valueSrc && valueSrc != widgetValueSrc && valueSrc != \"const\") canAdd = false;\n      if (opConfig && opConfig.cardinality == 0 && widgetValueSrc != \"value\") canAdd = false;\n      if (canAdd) {\n        widgets.push(widget);\n        var canAddValueSrc = fieldConfig.valueSources && fieldConfig.valueSources.indexOf(widgetValueSrc) != -1;\n        if (opConfig && opConfig.valueSources && opConfig.valueSources.indexOf(widgetValueSrc) == -1) canAddValueSrc = false;\n        if (canAddValueSrc && !valueSrcs.find(function (v) {\n          return v == widgetValueSrc;\n        })) valueSrcs.push(widgetValueSrc);\n      }\n    };\n    for (var widget in fieldConfig.widgets) {\n      _loop2();\n    }\n  }\n  var widgetWeight = function widgetWeight(w) {\n    var wg = 0;\n    if (fieldConfig.preferWidgets) {\n      if (fieldConfig.preferWidgets.includes(w)) wg += 10 - fieldConfig.preferWidgets.indexOf(w);\n    } else if (w == fieldConfig.mainWidget) {\n      wg += 100;\n    }\n    if (w == \"field\") {\n      wg -= 1;\n    }\n    if (w == \"func\") {\n      wg -= 2;\n    }\n    return wg;\n  };\n  widgets.sort(function (w1, w2) {\n    return widgetWeight(w2) - widgetWeight(w1);\n  });\n  return {\n    widgets: widgets,\n    valueSrcs: valueSrcs\n  };\n}\nexport var getWidgetsForFieldOp = function getWidgetsForFieldOp(config, field, operator) {\n  var valueSrc = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var _getWidgetsAndSrcsFor = _getWidgetsAndSrcsForFieldOp(config, field, operator, valueSrc),\n    widgets = _getWidgetsAndSrcsFor.widgets;\n  return widgets;\n};\nexport var filterValueSourcesForField = function filterValueSourcesForField(config, valueSrcs, fieldDefinition) {\n  if (!fieldDefinition) return valueSrcs;\n  return valueSrcs.filter(function (vs) {\n    var canAdd = true;\n    if (vs == \"field\") {\n      if (config._fieldsCntByType) {\n        // tip: LHS field can be used as arg in RHS function\n        var minCnt = fieldDefinition._isFuncArg ? 0 : 1;\n        canAdd = canAdd && config._fieldsCntByType[fieldDefinition.type] > minCnt;\n      }\n    }\n    if (vs == \"func\") {\n      if (config._funcsCntByType) canAdd = canAdd && !!config._funcsCntByType[fieldDefinition.type];\n      if (fieldDefinition.funcs) canAdd = canAdd && fieldDefinition.funcs.length > 0;\n    }\n    return canAdd;\n  });\n};\nexport var getValueSourcesForFieldOp = function getValueSourcesForFieldOp(config, field, operator) {\n  var fieldDefinition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var leftFieldForFunc = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  var _getWidgetsAndSrcsFor2 = _getWidgetsAndSrcsForFieldOp(config, field, operator, null),\n    valueSrcs = _getWidgetsAndSrcsFor2.valueSrcs;\n  var filteredValueSrcs = filterValueSourcesForField(config, valueSrcs, fieldDefinition);\n  return filteredValueSrcs;\n};\nexport var getWidgetForFieldOp = function getWidgetForFieldOp(config, field, operator) {\n  var valueSrc = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var _getWidgetsAndSrcsFor3 = _getWidgetsAndSrcsForFieldOp(config, field, operator, valueSrc),\n    widgets = _getWidgetsAndSrcsFor3.widgets;\n  var widget = null;\n  if (widgets.length) widget = widgets[0];\n  return widget;\n};\nexport var formatFieldName = function formatFieldName(field, config, meta) {\n  var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  if (!field) return;\n  var fieldDef = getFieldConfig(config, field) || {};\n  var fieldSeparator = config.settings.fieldSeparator;\n  var fieldParts = Array.isArray(field) ? field : field.split(fieldSeparator);\n  var fieldName = Array.isArray(field) ? field.join(fieldSeparator) : field;\n  if (fieldDef.tableName) {\n    // legacy\n    var fieldPartsCopy = _toConsumableArray(fieldParts);\n    fieldPartsCopy[0] = fieldDef.tableName;\n    fieldName = fieldPartsCopy.join(fieldSeparator);\n  }\n  if (fieldDef.fieldName) {\n    fieldName = fieldDef.fieldName;\n  }\n  if (parentField) {\n    var parentFieldDef = getFieldConfig(config, parentField) || {};\n    var parentFieldName = parentField;\n    if (parentFieldDef.fieldName) {\n      parentFieldName = parentFieldDef.fieldName;\n    }\n    if (fieldName.indexOf(parentFieldName + fieldSeparator) == 0) {\n      fieldName = fieldName.slice((parentFieldName + fieldSeparator).length);\n    } else {\n      meta.errors.push(\"Can't cut group \".concat(parentFieldName, \" from field \").concat(fieldName));\n    }\n  }\n  return fieldName;\n};"]},"metadata":{},"sourceType":"module"}