{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.jsonLogicFormat = void 0;\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _toArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toArray\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _stuff = require(\"../utils/stuff\");\n\nvar _configUtils = require(\"../utils/configUtils\");\n\nvar _ruleUtils = require(\"../utils/ruleUtils\");\n\nvar _defaultUtils = require(\"../utils/defaultUtils\");\n\nvar _funcUtils = require(\"../utils/funcUtils\");\n\nvar _immutable = require(\"immutable\");\n\nvar _omit = _interopRequireDefault(require(\"lodash/omit\"));\n\nvar _pick = _interopRequireDefault(require(\"lodash/pick\"));\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      (0, _defineProperty2[\"default\"])(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n  if (!it) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n} // http://jsonlogic.com/\n\n\nvar jsonLogicFormat = function jsonLogicFormat(item, config) {\n  //meta is mutable\n  var meta = {\n    usedFields: [],\n    errors: []\n  };\n  var logic = formatItem(item, config, meta, true); // build empty data\n\n  var errors = meta.errors,\n      usedFields = meta.usedFields;\n  var fieldSeparator = config.settings.fieldSeparator;\n  var data = {};\n\n  var _iterator = _createForOfIteratorHelper(usedFields),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var ff = _step.value;\n      var def = (0, _configUtils.getFieldConfig)(config, ff) || {};\n      var parts = ff.split(fieldSeparator);\n      var tmp = data;\n\n      for (var i = 0; i < parts.length; i++) {\n        var p = parts[i];\n        var pdef = (0, _configUtils.getFieldConfig)(config, parts.slice(0, i + 1)) || {};\n\n        if (i != parts.length - 1) {\n          if (pdef.type == \"!group\" && pdef.mode != \"struct\") {\n            if (!tmp[p]) tmp[p] = [{}];\n            tmp = tmp[p][0];\n          } else {\n            if (!tmp[p]) tmp[p] = {};\n            tmp = tmp[p];\n          }\n        } else {\n          if (!tmp[p]) tmp[p] = null; // can use def.type for sample values\n        }\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return {\n    errors: errors,\n    logic: logic,\n    data: data\n  };\n};\n\nexports.jsonLogicFormat = jsonLogicFormat;\n\nvar formatItem = function formatItem(item, config, meta, isRoot) {\n  var parentField = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  if (!item) return undefined;\n  var type = item.get(\"type\");\n  var properties = item.get(\"properties\") || new _immutable.Map();\n  var isLocked = properties.get(\"isLocked\");\n  var lockedOp = config.settings.jsonLogic.lockedOp;\n  var ret;\n\n  if (type === \"group\" || type === \"rule_group\") {\n    ret = formatGroup(item, config, meta, isRoot, parentField);\n  } else if (type === \"rule\") {\n    ret = formatRule(item, config, meta, parentField);\n  }\n\n  if (isLocked && ret && lockedOp) {\n    ret = (0, _defineProperty2[\"default\"])({}, lockedOp, ret);\n  }\n\n  return ret;\n};\n\nvar formatGroup = function formatGroup(item, config, meta, isRoot) {\n  var parentField = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  var type = item.get(\"type\");\n  var properties = item.get(\"properties\") || new _immutable.Map();\n  var mode = properties.get(\"mode\");\n  var children = item.get(\"children1\");\n  var field = properties.get(\"field\");\n  if (!children) return undefined;\n  var conjunction = properties.get(\"conjunction\");\n  if (!conjunction) conjunction = (0, _defaultUtils.defaultConjunction)(config);\n  var conj = conjunction.toLowerCase();\n  var not = properties.get(\"not\");\n\n  if (conj != \"and\" && conj != \"or\") {\n    meta.errors.push(\"Conjunction \".concat(conj, \" is not supported\"));\n    return undefined;\n  }\n\n  var isRuleGroup = type === \"rule_group\" && !isRoot;\n  var groupField = isRuleGroup && mode != \"struct\" ? field : parentField;\n  var groupOperator = properties.get(\"operator\");\n  var groupOperatorDefinition = groupOperator && (0, _configUtils.getOperatorConfig)(config, groupOperator, field) || null;\n  var groupValue = properties.get(\"value\");\n  var formattedValue = formatItemValue(config, properties, meta, groupOperator, parentField);\n  var isGroup0 = isRuleGroup && (!groupOperator || groupOperatorDefinition.cardinality == 0);\n  var list = children.map(function (currentChild) {\n    return formatItem(currentChild, config, meta, false, groupField);\n  }).filter(function (currentChild) {\n    return typeof currentChild !== \"undefined\";\n  });\n\n  if (isRuleGroup && mode != \"struct\" && !isGroup0) {\n    // \"count\" rule can have no \"having\" children, but should have number value\n    if (formattedValue == undefined) return undefined;\n  } else {\n    if (!list.size) return undefined;\n  }\n\n  var resultQuery = {};\n  if (list.size == 1 && !isRoot) resultQuery = list.first();else resultQuery[conj] = list.toList().toJS(); // revert\n\n  if (not) {\n    resultQuery = {\n      \"!\": resultQuery\n    };\n  } // rule_group (issue #246)\n\n\n  if (isRuleGroup && mode != \"struct\") {\n    if (isGroup0) {\n      // config.settings.groupOperators\n      var op = groupOperator || \"some\";\n      resultQuery = (0, _defineProperty2[\"default\"])({}, op, [formatField(meta, config, field, parentField), resultQuery]);\n    } else {\n      // there is rule for count\n      var filter = !list.size ? formatField(meta, config, field, parentField) : {\n        \"filter\": [formatField(meta, config, field, parentField), resultQuery]\n      };\n      var count = {\n        \"reduce\": [filter, {\n          \"+\": [1, {\n            \"var\": \"accumulator\"\n          }]\n        }, 0]\n      };\n      resultQuery = formatLogic(config, properties, count, formattedValue, groupOperator);\n    }\n  }\n\n  return resultQuery;\n};\n\nvar formatRule = function formatRule(item, config, meta) {\n  var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var properties = item.get(\"properties\") || new _immutable.Map();\n  var field = properties.get(\"field\");\n  var operator = properties.get(\"operator\");\n  var operatorOptions = properties.get(\"operatorOptions\");\n  operatorOptions = operatorOptions ? operatorOptions.toJS() : null;\n  if (operatorOptions && !Object.keys(operatorOptions).length) operatorOptions = null;\n  if (field == null || operator == null) return undefined;\n  var fieldDefinition = (0, _configUtils.getFieldConfig)(config, field) || {};\n  var operatorDefinition = (0, _configUtils.getOperatorConfig)(config, operator, field) || {};\n  var reversedOp = operatorDefinition.reversedOp;\n  var revOperatorDefinition = (0, _configUtils.getOperatorConfig)(config, reversedOp, field) || {};\n\n  var _fieldType = fieldDefinition.type || \"undefined\";\n\n  var cardinality = (0, _stuff.defaultValue)(operatorDefinition.cardinality, 1); // check op\n\n  var isRev = false;\n\n  if (!operatorDefinition.jsonLogic && !revOperatorDefinition.jsonLogic) {\n    meta.errors.push(\"Operator \".concat(operator, \" is not supported\"));\n    return undefined;\n  }\n\n  if (!operatorDefinition.jsonLogic && revOperatorDefinition.jsonLogic) {\n    isRev = true;\n    var _ref = [reversedOp, operator];\n    operator = _ref[0];\n    reversedOp = _ref[1];\n    var _ref2 = [revOperatorDefinition, operatorDefinition];\n    operatorDefinition = _ref2[0];\n    revOperatorDefinition = _ref2[1];\n  }\n\n  var formattedValue = formatItemValue(config, properties, meta, operator, parentField);\n  if (formattedValue === undefined) return undefined;\n  var formattedField = formatField(meta, config, field, parentField);\n  return formatLogic(config, properties, formattedField, formattedValue, operator, operatorOptions, fieldDefinition, isRev);\n};\n\nvar formatItemValue = function formatItemValue(config, properties, meta, operator, parentField) {\n  var field = properties.get(\"field\");\n  var iValueSrc = properties.get(\"valueSrc\");\n  var iValueType = properties.get(\"valueType\");\n  var fieldDefinition = (0, _configUtils.getFieldConfig)(config, field) || {};\n  var operatorDefinition = (0, _configUtils.getOperatorConfig)(config, operator, field) || {};\n  var cardinality = (0, _stuff.defaultValue)(operatorDefinition.cardinality, 1);\n  var iValue = properties.get(\"value\");\n  var asyncListValues = properties.get(\"asyncListValues\");\n  if (iValue == undefined) return undefined;\n  var valueSrcs = [];\n  var valueTypes = [];\n  var oldUsedFields = meta.usedFields;\n  var fvalue = iValue.map(function (currentValue, ind) {\n    var valueSrc = iValueSrc ? iValueSrc.get(ind) : null;\n    var valueType = iValueType ? iValueType.get(ind) : null;\n    var cValue = (0, _funcUtils.completeValue)(currentValue, valueSrc, config);\n    var widget = (0, _ruleUtils.getWidgetForFieldOp)(config, field, operator, valueSrc);\n    var fieldWidgetDef = (0, _omit[\"default\"])((0, _configUtils.getFieldWidgetConfig)(config, field, operator, widget, valueSrc), [\"factory\"]);\n    var fv = formatValue(meta, config, cValue, valueSrc, valueType, fieldWidgetDef, fieldDefinition, operator, operatorDefinition, parentField, asyncListValues);\n\n    if (fv !== undefined) {\n      valueSrcs.push(valueSrc);\n      valueTypes.push(valueType);\n    }\n\n    return fv;\n  });\n  var hasUndefinedValues = fvalue.filter(function (v) {\n    return v === undefined;\n  }).size > 0;\n\n  if (fvalue.size < cardinality || hasUndefinedValues) {\n    meta.usedFields = oldUsedFields; // restore\n\n    return undefined;\n  }\n\n  return cardinality > 1 ? fvalue.toArray() : cardinality == 1 ? fvalue.first() : null;\n};\n\nvar formatValue = function formatValue(meta, config, currentValue, valueSrc, valueType, fieldWidgetDef, fieldDef, operator, operatorDef) {\n  var parentField = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : null;\n  var asyncListValues = arguments.length > 10 ? arguments[10] : undefined;\n  if (currentValue === undefined) return undefined;\n  var ret;\n\n  if (valueSrc == \"field\") {\n    ret = formatField(meta, config, currentValue, parentField);\n  } else if (valueSrc == \"func\") {\n    ret = formatFunc(meta, config, currentValue, parentField);\n  } else if (typeof fieldWidgetDef.jsonLogic === \"function\") {\n    var fn = fieldWidgetDef.jsonLogic;\n    var args = [currentValue, _objectSpread(_objectSpread({}, (0, _pick[\"default\"])(fieldDef, [\"fieldSettings\", \"listValues\"])), {}, {\n      asyncListValues: asyncListValues\n    }), //useful options: valueFormat for date/time\n    (0, _omit[\"default\"])(fieldWidgetDef, [\"formatValue\", \"mongoFormatValue\", \"sqlFormatValue\", \"jsonLogic\", \"elasticSearchFormatValue\"])];\n\n    if (operator) {\n      args.push(operator);\n      args.push(operatorDef);\n    }\n\n    ret = fn.apply(void 0, args);\n  } else {\n    ret = currentValue;\n  }\n\n  return ret;\n};\n\nvar formatFunc = function formatFunc(meta, config, currentValue) {\n  var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var funcKey = currentValue.get(\"func\");\n  var args = currentValue.get(\"args\");\n  var funcConfig = (0, _configUtils.getFuncConfig)(config, funcKey);\n\n  if (!funcConfig.jsonLogic) {\n    meta.errors.push(\"Func \".concat(funcKey, \" is not supported\"));\n    return undefined;\n  }\n\n  var formattedArgs = {};\n\n  for (var argKey in funcConfig.args) {\n    var argConfig = funcConfig.args[argKey];\n    var fieldDef = (0, _configUtils.getFieldConfig)(config, argConfig);\n    var argVal = args ? args.get(argKey) : undefined;\n    var argValue = argVal ? argVal.get(\"value\") : undefined;\n    var argValueSrc = argVal ? argVal.get(\"valueSrc\") : undefined;\n    var formattedArgVal = formatValue(meta, config, argValue, argValueSrc, argConfig.type, fieldDef, argConfig, null, null, parentField);\n\n    if (argValue != undefined && formattedArgVal === undefined) {\n      meta.errors.push(\"Can't format value of arg \".concat(argKey, \" for func \").concat(funcKey));\n      return undefined;\n    }\n\n    if (formattedArgVal !== undefined) {\n      // skip optional in the end\n      formattedArgs[argKey] = formattedArgVal;\n    }\n  }\n\n  var formattedArgsArr = Object.values(formattedArgs);\n  var ret;\n\n  if (typeof funcConfig.jsonLogic === \"function\") {\n    var fn = funcConfig.jsonLogic;\n    var _args = [formattedArgs];\n    ret = fn.apply(void 0, _args);\n  } else {\n    var funcName = funcConfig.jsonLogic || funcKey;\n    var isMethod = !!funcConfig.jsonLogicIsMethod;\n\n    if (isMethod) {\n      var _formattedArgsArr = (0, _toArray2[\"default\"])(formattedArgsArr),\n          obj = _formattedArgsArr[0],\n          params = _formattedArgsArr.slice(1);\n\n      if (params.length) {\n        ret = {\n          \"method\": [obj, funcName, params]\n        };\n      } else {\n        ret = {\n          \"method\": [obj, funcName]\n        };\n      }\n    } else {\n      ret = (0, _defineProperty2[\"default\"])({}, funcName, formattedArgsArr);\n    }\n  }\n\n  return ret;\n};\n\nvar formatField = function formatField(meta, config, field) {\n  var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var _config$settings = config.settings,\n      fieldSeparator = _config$settings.fieldSeparator,\n      jsonLogic = _config$settings.jsonLogic;\n  var ret;\n\n  if (field) {\n    if (Array.isArray(field)) field = field.join(fieldSeparator);\n    var fieldDef = (0, _configUtils.getFieldConfig)(config, field) || {};\n    var fieldName = field;\n\n    if (fieldDef.fieldName) {\n      fieldName = fieldDef.fieldName;\n    }\n\n    if (parentField) {\n      var parentFieldDef = (0, _configUtils.getFieldConfig)(config, parentField) || {};\n      var parentFieldName = parentField;\n\n      if (parentFieldDef.fieldName) {\n        parentFieldName = parentFieldDef.fieldName;\n      }\n\n      if (fieldName.indexOf(parentFieldName + fieldSeparator) == 0) {\n        fieldName = fieldName.slice((parentFieldName + fieldSeparator).length);\n      } else {\n        meta.errors.push(\"Can't cut group \".concat(parentFieldName, \" from field \").concat(fieldName));\n      }\n    }\n\n    var varName = fieldDef.jsonLogicVar || (fieldDef.type == \"!group\" ? jsonLogic.groupVarKey : \"var\");\n    ret = (0, _defineProperty2[\"default\"])({}, varName, fieldName);\n    if (meta.usedFields.indexOf(field) == -1) meta.usedFields.push(field);\n  }\n\n  return ret;\n};\n\nvar formatLogic = function formatLogic(config, properties, formattedField, formattedValue, operator) {\n  var operatorOptions = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n  var fieldDefinition = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n  var isRev = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;\n  var field = properties.get(\"field\");\n  var operatorDefinition = (0, _configUtils.getOperatorConfig)(config, operator, field) || {};\n  var cardinality = (0, _stuff.defaultValue)(operatorDefinition.cardinality, 1);\n  var isReverseArgs = (0, _stuff.defaultValue)(operatorDefinition._jsonLogicIsRevArgs, false);\n  var formatteOp = operator;\n  if (typeof operatorDefinition.jsonLogic == \"string\") formatteOp = operatorDefinition.jsonLogic;\n  var fn = typeof operatorDefinition.jsonLogic == \"function\" ? operatorDefinition.jsonLogic : null;\n\n  if (!fn) {\n    var rangeOps = [\"<\", \"<=\", \">\", \">=\"];\n    var eqOps = [\"==\", \"!=\"];\n\n    fn = function fn(field, op, val, opDef, opOpts) {\n      if (cardinality == 0 && eqOps.includes(formatteOp)) return (0, _defineProperty2[\"default\"])({}, formatteOp, [formattedField, null]);else if (cardinality == 0) return (0, _defineProperty2[\"default\"])({}, formatteOp, formattedField);else if (cardinality == 1 && isReverseArgs) return (0, _defineProperty2[\"default\"])({}, formatteOp, [formattedValue, formattedField]);else if (cardinality == 1) return (0, _defineProperty2[\"default\"])({}, formatteOp, [formattedField, formattedValue]);else if (cardinality == 2 && rangeOps.includes(formatteOp)) return (0, _defineProperty2[\"default\"])({}, formatteOp, [formattedValue[0], formattedField, formattedValue[1]]);else return (0, _defineProperty2[\"default\"])({}, formatteOp, [formattedField].concat((0, _toConsumableArray2[\"default\"])(formattedValue)));\n    };\n  }\n\n  var args = [formattedField, operator, formattedValue, (0, _omit[\"default\"])(operatorDefinition, [\"formatOp\", \"mongoFormatOp\", \"sqlFormatOp\", \"jsonLogic\"]), operatorOptions, fieldDefinition];\n  var ruleQuery = fn.apply(void 0, args);\n\n  if (isRev) {\n    ruleQuery = {\n      \"!\": ruleQuery\n    };\n  }\n\n  return ruleQuery;\n};","map":{"version":3,"sources":["D:/LIMSWFH/LIMSPOSTGRESQL/QuaLISWeb/node_modules/react-awesome-query-builder/lib/export/jsonLogic.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","jsonLogicFormat","_toConsumableArray2","_toArray2","_defineProperty2","_stuff","_configUtils","_ruleUtils","_defaultUtils","_funcUtils","_immutable","_omit","_pick","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","_createForOfIteratorHelper","o","allowArrayLike","it","Symbol","iterator","Array","isArray","_unsupportedIterableToArray","F","s","n","done","e","_e","f","TypeError","normalCompletion","didErr","err","call","step","next","_e2","minLen","_arrayLikeToArray","prototype","toString","slice","constructor","name","from","test","arr","len","arr2","item","config","meta","usedFields","errors","logic","formatItem","fieldSeparator","settings","data","_iterator","_step","ff","def","getFieldConfig","parts","split","tmp","p","pdef","type","mode","isRoot","parentField","undefined","get","properties","Map","isLocked","lockedOp","jsonLogic","ret","formatGroup","formatRule","children","field","conjunction","defaultConjunction","conj","toLowerCase","not","concat","isRuleGroup","groupField","groupOperator","groupOperatorDefinition","getOperatorConfig","groupValue","formattedValue","formatItemValue","isGroup0","cardinality","list","map","currentChild","size","resultQuery","first","toList","toJS","op","formatField","count","formatLogic","operator","operatorOptions","fieldDefinition","operatorDefinition","reversedOp","revOperatorDefinition","_fieldType","defaultValue","isRev","_ref","_ref2","formattedField","iValueSrc","iValueType","iValue","asyncListValues","valueSrcs","valueTypes","oldUsedFields","fvalue","currentValue","ind","valueSrc","valueType","cValue","completeValue","widget","getWidgetForFieldOp","fieldWidgetDef","getFieldWidgetConfig","fv","formatValue","hasUndefinedValues","v","toArray","fieldDef","operatorDef","formatFunc","fn","args","funcKey","funcConfig","getFuncConfig","formattedArgs","argKey","argConfig","argVal","argValue","argValueSrc","formattedArgVal","formattedArgsArr","values","_args","funcName","isMethod","jsonLogicIsMethod","_formattedArgsArr","obj","params","_config$settings","join","fieldName","parentFieldDef","parentFieldName","indexOf","varName","jsonLogicVar","groupVarKey","isReverseArgs","_jsonLogicIsRevArgs","formatteOp","rangeOps","eqOps","val","opDef","opOpts","includes","ruleQuery"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.jsonLogicFormat = void 0;\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _toArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toArray\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _stuff = require(\"../utils/stuff\");\n\nvar _configUtils = require(\"../utils/configUtils\");\n\nvar _ruleUtils = require(\"../utils/ruleUtils\");\n\nvar _defaultUtils = require(\"../utils/defaultUtils\");\n\nvar _funcUtils = require(\"../utils/funcUtils\");\n\nvar _immutable = require(\"immutable\");\n\nvar _omit = _interopRequireDefault(require(\"lodash/omit\"));\n\nvar _pick = _interopRequireDefault(require(\"lodash/pick\"));\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2[\"default\"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n// http://jsonlogic.com/\nvar jsonLogicFormat = function jsonLogicFormat(item, config) {\n  //meta is mutable\n  var meta = {\n    usedFields: [],\n    errors: []\n  };\n  var logic = formatItem(item, config, meta, true); // build empty data\n\n  var errors = meta.errors,\n      usedFields = meta.usedFields;\n  var fieldSeparator = config.settings.fieldSeparator;\n  var data = {};\n\n  var _iterator = _createForOfIteratorHelper(usedFields),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var ff = _step.value;\n      var def = (0, _configUtils.getFieldConfig)(config, ff) || {};\n      var parts = ff.split(fieldSeparator);\n      var tmp = data;\n\n      for (var i = 0; i < parts.length; i++) {\n        var p = parts[i];\n        var pdef = (0, _configUtils.getFieldConfig)(config, parts.slice(0, i + 1)) || {};\n\n        if (i != parts.length - 1) {\n          if (pdef.type == \"!group\" && pdef.mode != \"struct\") {\n            if (!tmp[p]) tmp[p] = [{}];\n            tmp = tmp[p][0];\n          } else {\n            if (!tmp[p]) tmp[p] = {};\n            tmp = tmp[p];\n          }\n        } else {\n          if (!tmp[p]) tmp[p] = null; // can use def.type for sample values\n        }\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return {\n    errors: errors,\n    logic: logic,\n    data: data\n  };\n};\n\nexports.jsonLogicFormat = jsonLogicFormat;\n\nvar formatItem = function formatItem(item, config, meta, isRoot) {\n  var parentField = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  if (!item) return undefined;\n  var type = item.get(\"type\");\n  var properties = item.get(\"properties\") || new _immutable.Map();\n  var isLocked = properties.get(\"isLocked\");\n  var lockedOp = config.settings.jsonLogic.lockedOp;\n  var ret;\n\n  if (type === \"group\" || type === \"rule_group\") {\n    ret = formatGroup(item, config, meta, isRoot, parentField);\n  } else if (type === \"rule\") {\n    ret = formatRule(item, config, meta, parentField);\n  }\n\n  if (isLocked && ret && lockedOp) {\n    ret = (0, _defineProperty2[\"default\"])({}, lockedOp, ret);\n  }\n\n  return ret;\n};\n\nvar formatGroup = function formatGroup(item, config, meta, isRoot) {\n  var parentField = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  var type = item.get(\"type\");\n  var properties = item.get(\"properties\") || new _immutable.Map();\n  var mode = properties.get(\"mode\");\n  var children = item.get(\"children1\");\n  var field = properties.get(\"field\");\n  if (!children) return undefined;\n  var conjunction = properties.get(\"conjunction\");\n  if (!conjunction) conjunction = (0, _defaultUtils.defaultConjunction)(config);\n  var conj = conjunction.toLowerCase();\n  var not = properties.get(\"not\");\n\n  if (conj != \"and\" && conj != \"or\") {\n    meta.errors.push(\"Conjunction \".concat(conj, \" is not supported\"));\n    return undefined;\n  }\n\n  var isRuleGroup = type === \"rule_group\" && !isRoot;\n  var groupField = isRuleGroup && mode != \"struct\" ? field : parentField;\n  var groupOperator = properties.get(\"operator\");\n  var groupOperatorDefinition = groupOperator && (0, _configUtils.getOperatorConfig)(config, groupOperator, field) || null;\n  var groupValue = properties.get(\"value\");\n  var formattedValue = formatItemValue(config, properties, meta, groupOperator, parentField);\n  var isGroup0 = isRuleGroup && (!groupOperator || groupOperatorDefinition.cardinality == 0);\n  var list = children.map(function (currentChild) {\n    return formatItem(currentChild, config, meta, false, groupField);\n  }).filter(function (currentChild) {\n    return typeof currentChild !== \"undefined\";\n  });\n\n  if (isRuleGroup && mode != \"struct\" && !isGroup0) {\n    // \"count\" rule can have no \"having\" children, but should have number value\n    if (formattedValue == undefined) return undefined;\n  } else {\n    if (!list.size) return undefined;\n  }\n\n  var resultQuery = {};\n  if (list.size == 1 && !isRoot) resultQuery = list.first();else resultQuery[conj] = list.toList().toJS(); // revert\n\n  if (not) {\n    resultQuery = {\n      \"!\": resultQuery\n    };\n  } // rule_group (issue #246)\n\n\n  if (isRuleGroup && mode != \"struct\") {\n    if (isGroup0) {\n      // config.settings.groupOperators\n      var op = groupOperator || \"some\";\n      resultQuery = (0, _defineProperty2[\"default\"])({}, op, [formatField(meta, config, field, parentField), resultQuery]);\n    } else {\n      // there is rule for count\n      var filter = !list.size ? formatField(meta, config, field, parentField) : {\n        \"filter\": [formatField(meta, config, field, parentField), resultQuery]\n      };\n      var count = {\n        \"reduce\": [filter, {\n          \"+\": [1, {\n            \"var\": \"accumulator\"\n          }]\n        }, 0]\n      };\n      resultQuery = formatLogic(config, properties, count, formattedValue, groupOperator);\n    }\n  }\n\n  return resultQuery;\n};\n\nvar formatRule = function formatRule(item, config, meta) {\n  var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var properties = item.get(\"properties\") || new _immutable.Map();\n  var field = properties.get(\"field\");\n  var operator = properties.get(\"operator\");\n  var operatorOptions = properties.get(\"operatorOptions\");\n  operatorOptions = operatorOptions ? operatorOptions.toJS() : null;\n  if (operatorOptions && !Object.keys(operatorOptions).length) operatorOptions = null;\n  if (field == null || operator == null) return undefined;\n  var fieldDefinition = (0, _configUtils.getFieldConfig)(config, field) || {};\n  var operatorDefinition = (0, _configUtils.getOperatorConfig)(config, operator, field) || {};\n  var reversedOp = operatorDefinition.reversedOp;\n  var revOperatorDefinition = (0, _configUtils.getOperatorConfig)(config, reversedOp, field) || {};\n\n  var _fieldType = fieldDefinition.type || \"undefined\";\n\n  var cardinality = (0, _stuff.defaultValue)(operatorDefinition.cardinality, 1); // check op\n\n  var isRev = false;\n\n  if (!operatorDefinition.jsonLogic && !revOperatorDefinition.jsonLogic) {\n    meta.errors.push(\"Operator \".concat(operator, \" is not supported\"));\n    return undefined;\n  }\n\n  if (!operatorDefinition.jsonLogic && revOperatorDefinition.jsonLogic) {\n    isRev = true;\n    var _ref = [reversedOp, operator];\n    operator = _ref[0];\n    reversedOp = _ref[1];\n    var _ref2 = [revOperatorDefinition, operatorDefinition];\n    operatorDefinition = _ref2[0];\n    revOperatorDefinition = _ref2[1];\n  }\n\n  var formattedValue = formatItemValue(config, properties, meta, operator, parentField);\n  if (formattedValue === undefined) return undefined;\n  var formattedField = formatField(meta, config, field, parentField);\n  return formatLogic(config, properties, formattedField, formattedValue, operator, operatorOptions, fieldDefinition, isRev);\n};\n\nvar formatItemValue = function formatItemValue(config, properties, meta, operator, parentField) {\n  var field = properties.get(\"field\");\n  var iValueSrc = properties.get(\"valueSrc\");\n  var iValueType = properties.get(\"valueType\");\n  var fieldDefinition = (0, _configUtils.getFieldConfig)(config, field) || {};\n  var operatorDefinition = (0, _configUtils.getOperatorConfig)(config, operator, field) || {};\n  var cardinality = (0, _stuff.defaultValue)(operatorDefinition.cardinality, 1);\n  var iValue = properties.get(\"value\");\n  var asyncListValues = properties.get(\"asyncListValues\");\n  if (iValue == undefined) return undefined;\n  var valueSrcs = [];\n  var valueTypes = [];\n  var oldUsedFields = meta.usedFields;\n  var fvalue = iValue.map(function (currentValue, ind) {\n    var valueSrc = iValueSrc ? iValueSrc.get(ind) : null;\n    var valueType = iValueType ? iValueType.get(ind) : null;\n    var cValue = (0, _funcUtils.completeValue)(currentValue, valueSrc, config);\n    var widget = (0, _ruleUtils.getWidgetForFieldOp)(config, field, operator, valueSrc);\n    var fieldWidgetDef = (0, _omit[\"default\"])((0, _configUtils.getFieldWidgetConfig)(config, field, operator, widget, valueSrc), [\"factory\"]);\n    var fv = formatValue(meta, config, cValue, valueSrc, valueType, fieldWidgetDef, fieldDefinition, operator, operatorDefinition, parentField, asyncListValues);\n\n    if (fv !== undefined) {\n      valueSrcs.push(valueSrc);\n      valueTypes.push(valueType);\n    }\n\n    return fv;\n  });\n  var hasUndefinedValues = fvalue.filter(function (v) {\n    return v === undefined;\n  }).size > 0;\n\n  if (fvalue.size < cardinality || hasUndefinedValues) {\n    meta.usedFields = oldUsedFields; // restore\n\n    return undefined;\n  }\n\n  return cardinality > 1 ? fvalue.toArray() : cardinality == 1 ? fvalue.first() : null;\n};\n\nvar formatValue = function formatValue(meta, config, currentValue, valueSrc, valueType, fieldWidgetDef, fieldDef, operator, operatorDef) {\n  var parentField = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : null;\n  var asyncListValues = arguments.length > 10 ? arguments[10] : undefined;\n  if (currentValue === undefined) return undefined;\n  var ret;\n\n  if (valueSrc == \"field\") {\n    ret = formatField(meta, config, currentValue, parentField);\n  } else if (valueSrc == \"func\") {\n    ret = formatFunc(meta, config, currentValue, parentField);\n  } else if (typeof fieldWidgetDef.jsonLogic === \"function\") {\n    var fn = fieldWidgetDef.jsonLogic;\n    var args = [currentValue, _objectSpread(_objectSpread({}, (0, _pick[\"default\"])(fieldDef, [\"fieldSettings\", \"listValues\"])), {}, {\n      asyncListValues: asyncListValues\n    }), //useful options: valueFormat for date/time\n    (0, _omit[\"default\"])(fieldWidgetDef, [\"formatValue\", \"mongoFormatValue\", \"sqlFormatValue\", \"jsonLogic\", \"elasticSearchFormatValue\"])];\n\n    if (operator) {\n      args.push(operator);\n      args.push(operatorDef);\n    }\n\n    ret = fn.apply(void 0, args);\n  } else {\n    ret = currentValue;\n  }\n\n  return ret;\n};\n\nvar formatFunc = function formatFunc(meta, config, currentValue) {\n  var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var funcKey = currentValue.get(\"func\");\n  var args = currentValue.get(\"args\");\n  var funcConfig = (0, _configUtils.getFuncConfig)(config, funcKey);\n\n  if (!funcConfig.jsonLogic) {\n    meta.errors.push(\"Func \".concat(funcKey, \" is not supported\"));\n    return undefined;\n  }\n\n  var formattedArgs = {};\n\n  for (var argKey in funcConfig.args) {\n    var argConfig = funcConfig.args[argKey];\n    var fieldDef = (0, _configUtils.getFieldConfig)(config, argConfig);\n    var argVal = args ? args.get(argKey) : undefined;\n    var argValue = argVal ? argVal.get(\"value\") : undefined;\n    var argValueSrc = argVal ? argVal.get(\"valueSrc\") : undefined;\n    var formattedArgVal = formatValue(meta, config, argValue, argValueSrc, argConfig.type, fieldDef, argConfig, null, null, parentField);\n\n    if (argValue != undefined && formattedArgVal === undefined) {\n      meta.errors.push(\"Can't format value of arg \".concat(argKey, \" for func \").concat(funcKey));\n      return undefined;\n    }\n\n    if (formattedArgVal !== undefined) {\n      // skip optional in the end\n      formattedArgs[argKey] = formattedArgVal;\n    }\n  }\n\n  var formattedArgsArr = Object.values(formattedArgs);\n  var ret;\n\n  if (typeof funcConfig.jsonLogic === \"function\") {\n    var fn = funcConfig.jsonLogic;\n    var _args = [formattedArgs];\n    ret = fn.apply(void 0, _args);\n  } else {\n    var funcName = funcConfig.jsonLogic || funcKey;\n    var isMethod = !!funcConfig.jsonLogicIsMethod;\n\n    if (isMethod) {\n      var _formattedArgsArr = (0, _toArray2[\"default\"])(formattedArgsArr),\n          obj = _formattedArgsArr[0],\n          params = _formattedArgsArr.slice(1);\n\n      if (params.length) {\n        ret = {\n          \"method\": [obj, funcName, params]\n        };\n      } else {\n        ret = {\n          \"method\": [obj, funcName]\n        };\n      }\n    } else {\n      ret = (0, _defineProperty2[\"default\"])({}, funcName, formattedArgsArr);\n    }\n  }\n\n  return ret;\n};\n\nvar formatField = function formatField(meta, config, field) {\n  var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var _config$settings = config.settings,\n      fieldSeparator = _config$settings.fieldSeparator,\n      jsonLogic = _config$settings.jsonLogic;\n  var ret;\n\n  if (field) {\n    if (Array.isArray(field)) field = field.join(fieldSeparator);\n    var fieldDef = (0, _configUtils.getFieldConfig)(config, field) || {};\n    var fieldName = field;\n\n    if (fieldDef.fieldName) {\n      fieldName = fieldDef.fieldName;\n    }\n\n    if (parentField) {\n      var parentFieldDef = (0, _configUtils.getFieldConfig)(config, parentField) || {};\n      var parentFieldName = parentField;\n\n      if (parentFieldDef.fieldName) {\n        parentFieldName = parentFieldDef.fieldName;\n      }\n\n      if (fieldName.indexOf(parentFieldName + fieldSeparator) == 0) {\n        fieldName = fieldName.slice((parentFieldName + fieldSeparator).length);\n      } else {\n        meta.errors.push(\"Can't cut group \".concat(parentFieldName, \" from field \").concat(fieldName));\n      }\n    }\n\n    var varName = fieldDef.jsonLogicVar || (fieldDef.type == \"!group\" ? jsonLogic.groupVarKey : \"var\");\n    ret = (0, _defineProperty2[\"default\"])({}, varName, fieldName);\n    if (meta.usedFields.indexOf(field) == -1) meta.usedFields.push(field);\n  }\n\n  return ret;\n};\n\nvar formatLogic = function formatLogic(config, properties, formattedField, formattedValue, operator) {\n  var operatorOptions = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n  var fieldDefinition = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n  var isRev = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;\n  var field = properties.get(\"field\");\n  var operatorDefinition = (0, _configUtils.getOperatorConfig)(config, operator, field) || {};\n  var cardinality = (0, _stuff.defaultValue)(operatorDefinition.cardinality, 1);\n  var isReverseArgs = (0, _stuff.defaultValue)(operatorDefinition._jsonLogicIsRevArgs, false);\n  var formatteOp = operator;\n  if (typeof operatorDefinition.jsonLogic == \"string\") formatteOp = operatorDefinition.jsonLogic;\n  var fn = typeof operatorDefinition.jsonLogic == \"function\" ? operatorDefinition.jsonLogic : null;\n\n  if (!fn) {\n    var rangeOps = [\"<\", \"<=\", \">\", \">=\"];\n    var eqOps = [\"==\", \"!=\"];\n\n    fn = function fn(field, op, val, opDef, opOpts) {\n      if (cardinality == 0 && eqOps.includes(formatteOp)) return (0, _defineProperty2[\"default\"])({}, formatteOp, [formattedField, null]);else if (cardinality == 0) return (0, _defineProperty2[\"default\"])({}, formatteOp, formattedField);else if (cardinality == 1 && isReverseArgs) return (0, _defineProperty2[\"default\"])({}, formatteOp, [formattedValue, formattedField]);else if (cardinality == 1) return (0, _defineProperty2[\"default\"])({}, formatteOp, [formattedField, formattedValue]);else if (cardinality == 2 && rangeOps.includes(formatteOp)) return (0, _defineProperty2[\"default\"])({}, formatteOp, [formattedValue[0], formattedField, formattedValue[1]]);else return (0, _defineProperty2[\"default\"])({}, formatteOp, [formattedField].concat((0, _toConsumableArray2[\"default\"])(formattedValue)));\n    };\n  }\n\n  var args = [formattedField, operator, formattedValue, (0, _omit[\"default\"])(operatorDefinition, [\"formatOp\", \"mongoFormatOp\", \"sqlFormatOp\", \"jsonLogic\"]), operatorOptions, fieldDefinition];\n  var ruleQuery = fn.apply(void 0, args);\n\n  if (isRev) {\n    ruleQuery = {\n      \"!\": ruleQuery\n    };\n  }\n\n  return ruleQuery;\n};"]},"metadata":{},"sourceType":"script"}