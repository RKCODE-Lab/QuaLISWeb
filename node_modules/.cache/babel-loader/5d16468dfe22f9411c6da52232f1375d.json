{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.sqlFormat = exports._sqlFormat = void 0;\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _configUtils = require(\"../utils/configUtils\");\n\nvar _ruleUtils = require(\"../utils/ruleUtils\");\n\nvar _omit = _interopRequireDefault(require(\"lodash/omit\"));\n\nvar _pick = _interopRequireDefault(require(\"lodash/pick\"));\n\nvar _stuff = require(\"../utils/stuff\");\n\nvar _defaultUtils = require(\"../utils/defaultUtils\");\n\nvar _default = require(\"../config/default\");\n\nvar _funcUtils = require(\"../utils/funcUtils\");\n\nvar _immutable = require(\"immutable\");\n\nvar _export = require(\"../utils/export\");\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      (0, _defineProperty2[\"default\"])(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nvar sqlFormat = function sqlFormat(tree, config) {\n  return _sqlFormat(tree, config, false);\n};\n\nexports.sqlFormat = sqlFormat;\n\nvar _sqlFormat = function _sqlFormat(tree, config) {\n  var returnErrors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true; //meta is mutable\n\n  var meta = {\n    errors: []\n  };\n  var res = formatItem(tree, config, meta);\n\n  if (returnErrors) {\n    return [res, meta.errors];\n  } else {\n    if (meta.errors.length) console.warn(\"Errors while exporting to SQL:\", meta.errors);\n    return res;\n  }\n};\n\nexports._sqlFormat = _sqlFormat;\n\nvar formatItem = function formatItem(item, config, meta) {\n  if (!item) return undefined;\n  var type = item.get(\"type\");\n  var children = item.get(\"children1\");\n\n  if ((type === \"group\" || type === \"rule_group\") && children && children.size) {\n    return formatGroup(item, config, meta);\n  } else if (type === \"rule\") {\n    return formatRule(item, config, meta);\n  }\n\n  return undefined;\n};\n\nvar formatGroup = function formatGroup(item, config, meta) {\n  var type = item.get(\"type\");\n  var properties = item.get(\"properties\") || new _immutable.Map();\n  var children = item.get(\"children1\");\n  var groupField = type === \"rule_group\" ? properties.get(\"field\") : null;\n  var groupFieldDef = (0, _configUtils.getFieldConfig)(config, groupField) || {};\n\n  if (groupFieldDef.mode == \"array\") {\n    meta.errors.push(\"Aggregation is not supported for \".concat(groupField));\n  }\n\n  var not = properties.get(\"not\");\n  var list = children.map(function (currentChild) {\n    return formatItem(currentChild, config, meta);\n  }).filter(function (currentChild) {\n    return typeof currentChild !== \"undefined\";\n  });\n  if (!list.size) return undefined;\n  var conjunction = properties.get(\"conjunction\");\n  if (!conjunction) conjunction = (0, _defaultUtils.defaultConjunction)(config);\n  var conjunctionDefinition = config.conjunctions[conjunction];\n  return conjunctionDefinition.sqlFormatConj(list, conjunction, not);\n};\n\nvar buildFnToFormatOp = function buildFnToFormatOp(operator, operatorDefinition) {\n  var sqlOp = operatorDefinition.sqlOp || operator;\n  var cardinality = (0, _stuff.defaultValue)(operatorDefinition.cardinality, 1);\n  var fn;\n\n  if (cardinality == 0) {\n    fn = function fn(field, op, values, valueSrc, valueType, opDef, operatorOptions, fieldDef) {\n      return \"\".concat(field, \" \").concat(sqlOp);\n    };\n  } else if (cardinality == 1) {\n    fn = function fn(field, op, value, valueSrc, valueType, opDef, operatorOptions, fieldDef) {\n      return \"\".concat(field, \" \").concat(sqlOp, \" \").concat(value);\n    };\n  } else if (cardinality == 2) {\n    // between\n    fn = function fn(field, op, values, valueSrc, valueType, opDef, operatorOptions, fieldDef) {\n      var valFrom = values.first();\n      var valTo = values.get(1);\n      return \"\".concat(field, \" \").concat(sqlOp, \" \").concat(valFrom, \" AND \").concat(valTo);\n    };\n  }\n\n  return fn;\n};\n\nvar formatRule = function formatRule(item, config, meta) {\n  var properties = item.get(\"properties\") || new _immutable.Map();\n  var field = properties.get(\"field\");\n  var operator = properties.get(\"operator\");\n  var operatorOptions = properties.get(\"operatorOptions\");\n  var iValueSrc = properties.get(\"valueSrc\");\n  var iValueType = properties.get(\"valueType\");\n  var iValue = properties.get(\"value\");\n  var asyncListValues = properties.get(\"asyncListValues\");\n  if (field == null || operator == null) return undefined;\n  var fieldDefinition = (0, _configUtils.getFieldConfig)(config, field) || {};\n  var opDef = (0, _configUtils.getOperatorConfig)(config, operator, field) || {};\n  var reversedOp = opDef.reversedOp;\n  var revOpDef = (0, _configUtils.getOperatorConfig)(config, reversedOp, field) || {};\n  var cardinality = (0, _stuff.defaultValue)(opDef.cardinality, 1); // check op\n\n  var isRev = false;\n  var canFormatOp = opDef.sqlOp || opDef.sqlFormatOp;\n  var canFormatRevOp = revOpDef.sqlOp || revOpDef.sqlFormatOp;\n\n  if (!canFormatOp && !canFormatRevOp) {\n    meta.errors.push(\"Operator \".concat(operator, \" is not supported\"));\n    return undefined;\n  }\n\n  if (!canFormatRevOp && canFormatRevOp) {\n    isRev = true;\n    var _ref = [reversedOp, operator];\n    operator = _ref[0];\n    reversedOp = _ref[1];\n    var _ref2 = [revOpDef, opDef];\n    opDef = _ref2[0];\n    revOpDef = _ref2[1];\n  } //format value\n\n\n  var valueSrcs = [];\n  var valueTypes = [];\n  var fvalue = iValue.map(function (currentValue, ind) {\n    var valueSrc = iValueSrc ? iValueSrc.get(ind) : null;\n    var valueType = iValueType ? iValueType.get(ind) : null;\n    var cValue = (0, _funcUtils.completeValue)(currentValue, valueSrc, config);\n    var widget = (0, _ruleUtils.getWidgetForFieldOp)(config, field, operator, valueSrc);\n    var fieldWidgetDefinition = (0, _omit[\"default\"])((0, _configUtils.getFieldWidgetConfig)(config, field, operator, widget, valueSrc), [\"factory\"]);\n    var fv = formatValue(meta, config, cValue, valueSrc, valueType, fieldWidgetDefinition, fieldDefinition, operator, opDef, asyncListValues);\n\n    if (fv !== undefined) {\n      valueSrcs.push(valueSrc);\n      valueTypes.push(valueType);\n    }\n\n    return fv;\n  });\n  var hasUndefinedValues = fvalue.filter(function (v) {\n    return v === undefined;\n  }).size > 0;\n  if (hasUndefinedValues || fvalue.size < cardinality) return undefined;\n  var formattedValue = cardinality == 1 ? fvalue.first() : fvalue; //find fn to format expr\n\n  var fn = opDef.sqlFormatOp || buildFnToFormatOp(operator, opDef);\n\n  if (!fn) {\n    meta.errors.push(\"Operator \".concat(operator, \" is not supported\"));\n    return undefined;\n  } //format field\n\n\n  var formattedField = formatField(meta, config, field); //format expr\n\n  var args = [formattedField, operator, formattedValue, valueSrcs.length > 1 ? valueSrcs : valueSrcs[0], valueTypes.length > 1 ? valueTypes : valueTypes[0], (0, _omit[\"default\"])(opDef, [\"formatOp\", \"mongoFormatOp\", \"sqlFormatOp\", \"jsonLogic\", \"spelFormatOp\"]), operatorOptions, fieldDefinition];\n  var ret;\n  ret = fn.apply(void 0, args);\n\n  if (isRev) {\n    ret = config.settings.sqlFormatReverse(ret);\n  }\n\n  if (ret === undefined) {\n    meta.errors.push(\"Operator \".concat(operator, \" is not supported for value source \").concat(valueSrcs.join(\", \")));\n    return undefined;\n  }\n\n  return ret;\n};\n\nvar formatValue = function formatValue(meta, config, currentValue, valueSrc, valueType, fieldWidgetDef, fieldDef, operator, operatorDef, asyncListValues) {\n  if (currentValue === undefined) return undefined;\n  var ret;\n\n  if (valueSrc == \"field\") {\n    ret = formatField(meta, config, currentValue);\n  } else if (valueSrc == \"func\") {\n    ret = formatFunc(meta, config, currentValue);\n  } else {\n    if (typeof fieldWidgetDef.sqlFormatValue === \"function\") {\n      var fn = fieldWidgetDef.sqlFormatValue;\n      var args = [currentValue, _objectSpread(_objectSpread({}, (0, _pick[\"default\"])(fieldDef, [\"fieldSettings\", \"listValues\"])), {}, {\n        asyncListValues: asyncListValues\n      }), //useful options: valueFormat for date/time\n      (0, _omit[\"default\"])(fieldWidgetDef, [\"formatValue\", \"mongoFormatValue\", \"sqlFormatValue\", \"jsonLogic\", \"elasticSearchFormatValue\", \"spelFormatValue\"])];\n\n      if (operator) {\n        args.push(operator);\n        args.push(operatorDef);\n      }\n\n      if (valueSrc == \"field\") {\n        var valFieldDefinition = (0, _configUtils.getFieldConfig)(config, currentValue) || {};\n        args.push(valFieldDefinition);\n      }\n\n      ret = fn.apply(void 0, args);\n    } else {\n      ret = _export.SqlString.escape(currentValue);\n    }\n  }\n\n  return ret;\n};\n\nvar formatField = function formatField(meta, config, field) {\n  if (!field) return;\n  var fieldSeparator = config.settings.fieldSeparator;\n  var fieldDefinition = (0, _configUtils.getFieldConfig)(config, field) || {};\n  var fieldParts = Array.isArray(field) ? field : field.split(fieldSeparator);\n\n  var _fieldKeys = (0, _ruleUtils.getFieldPath)(field, config);\n\n  var fieldPartsLabels = (0, _ruleUtils.getFieldPathLabels)(field, config);\n  var fieldFullLabel = fieldPartsLabels ? fieldPartsLabels.join(fieldSeparator) : null;\n  var formatFieldFn = config.settings.formatField || _default.settings.formatField;\n  var fieldName = (0, _ruleUtils.formatFieldName)(field, config, meta);\n  var formattedField = formatFieldFn(fieldName, fieldParts, fieldFullLabel, fieldDefinition, config);\n  return formattedField;\n};\n\nvar formatFunc = function formatFunc(meta, config, currentValue) {\n  var funcKey = currentValue.get(\"func\");\n  var args = currentValue.get(\"args\");\n  var funcConfig = (0, _configUtils.getFuncConfig)(config, funcKey);\n  var funcName = funcConfig.sqlFunc || funcKey;\n  var formattedArgs = {};\n\n  for (var argKey in funcConfig.args) {\n    var argConfig = funcConfig.args[argKey];\n    var fieldDef = (0, _configUtils.getFieldConfig)(config, argConfig);\n    var argVal = args ? args.get(argKey) : undefined;\n    var argValue = argVal ? argVal.get(\"value\") : undefined;\n    var argValueSrc = argVal ? argVal.get(\"valueSrc\") : undefined;\n    var argAsyncListValues = argVal ? argVal.get(\"asyncListValues\") : undefined;\n    var formattedArgVal = formatValue(meta, config, argValue, argValueSrc, argConfig.type, fieldDef, argConfig, null, null, argAsyncListValues);\n\n    if (argValue != undefined && formattedArgVal === undefined) {\n      meta.errors.push(\"Can't format value of arg \".concat(argKey, \" for func \").concat(funcKey));\n      return undefined;\n    }\n\n    if (formattedArgVal !== undefined) {\n      // skip optional in the end\n      formattedArgs[argKey] = formattedArgVal;\n    }\n  }\n\n  var ret;\n\n  if (typeof funcConfig.sqlFormatFunc === \"function\") {\n    var fn = funcConfig.sqlFormatFunc;\n    var _args = [formattedArgs];\n    ret = fn.apply(void 0, _args);\n  } else {\n    var argsStr = Object.entries(formattedArgs).map(function (_ref3) {\n      var _ref4 = (0, _slicedToArray2[\"default\"])(_ref3, 2),\n          k = _ref4[0],\n          v = _ref4[1];\n\n      return v;\n    }).join(\", \");\n    ret = \"\".concat(funcName, \"(\").concat(argsStr, \")\");\n  }\n\n  return ret;\n};","map":{"version":3,"sources":["D:/LIMSWFH/LIMSPOSTGRESQL/QuaLISWeb/node_modules/react-awesome-query-builder/lib/export/sql.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","sqlFormat","_sqlFormat","_slicedToArray2","_defineProperty2","_configUtils","_ruleUtils","_omit","_pick","_stuff","_defaultUtils","_default","_funcUtils","_immutable","_export","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","tree","config","returnErrors","undefined","meta","errors","res","formatItem","console","warn","item","type","get","children","size","formatGroup","formatRule","properties","Map","groupField","groupFieldDef","getFieldConfig","mode","concat","not","list","map","currentChild","conjunction","defaultConjunction","conjunctionDefinition","conjunctions","sqlFormatConj","buildFnToFormatOp","operator","operatorDefinition","sqlOp","cardinality","defaultValue","fn","field","op","values","valueSrc","valueType","opDef","operatorOptions","fieldDef","valFrom","first","valTo","iValueSrc","iValueType","iValue","asyncListValues","fieldDefinition","getOperatorConfig","reversedOp","revOpDef","isRev","canFormatOp","sqlFormatOp","canFormatRevOp","_ref","_ref2","valueSrcs","valueTypes","fvalue","currentValue","ind","cValue","completeValue","widget","getWidgetForFieldOp","fieldWidgetDefinition","getFieldWidgetConfig","fv","formatValue","hasUndefinedValues","v","formattedValue","formattedField","formatField","args","ret","settings","sqlFormatReverse","join","fieldWidgetDef","operatorDef","formatFunc","sqlFormatValue","valFieldDefinition","SqlString","escape","fieldSeparator","fieldParts","Array","isArray","split","_fieldKeys","getFieldPath","fieldPartsLabels","getFieldPathLabels","fieldFullLabel","formatFieldFn","fieldName","formatFieldName","funcKey","funcConfig","getFuncConfig","funcName","sqlFunc","formattedArgs","argKey","argConfig","argVal","argValue","argValueSrc","argAsyncListValues","formattedArgVal","sqlFormatFunc","_args","argsStr","entries","_ref3","_ref4","k"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.sqlFormat = exports._sqlFormat = void 0;\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _configUtils = require(\"../utils/configUtils\");\n\nvar _ruleUtils = require(\"../utils/ruleUtils\");\n\nvar _omit = _interopRequireDefault(require(\"lodash/omit\"));\n\nvar _pick = _interopRequireDefault(require(\"lodash/pick\"));\n\nvar _stuff = require(\"../utils/stuff\");\n\nvar _defaultUtils = require(\"../utils/defaultUtils\");\n\nvar _default = require(\"../config/default\");\n\nvar _funcUtils = require(\"../utils/funcUtils\");\n\nvar _immutable = require(\"immutable\");\n\nvar _export = require(\"../utils/export\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2[\"default\"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nvar sqlFormat = function sqlFormat(tree, config) {\n  return _sqlFormat(tree, config, false);\n};\n\nexports.sqlFormat = sqlFormat;\n\nvar _sqlFormat = function _sqlFormat(tree, config) {\n  var returnErrors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  //meta is mutable\n  var meta = {\n    errors: []\n  };\n  var res = formatItem(tree, config, meta);\n\n  if (returnErrors) {\n    return [res, meta.errors];\n  } else {\n    if (meta.errors.length) console.warn(\"Errors while exporting to SQL:\", meta.errors);\n    return res;\n  }\n};\n\nexports._sqlFormat = _sqlFormat;\n\nvar formatItem = function formatItem(item, config, meta) {\n  if (!item) return undefined;\n  var type = item.get(\"type\");\n  var children = item.get(\"children1\");\n\n  if ((type === \"group\" || type === \"rule_group\") && children && children.size) {\n    return formatGroup(item, config, meta);\n  } else if (type === \"rule\") {\n    return formatRule(item, config, meta);\n  }\n\n  return undefined;\n};\n\nvar formatGroup = function formatGroup(item, config, meta) {\n  var type = item.get(\"type\");\n  var properties = item.get(\"properties\") || new _immutable.Map();\n  var children = item.get(\"children1\");\n  var groupField = type === \"rule_group\" ? properties.get(\"field\") : null;\n  var groupFieldDef = (0, _configUtils.getFieldConfig)(config, groupField) || {};\n\n  if (groupFieldDef.mode == \"array\") {\n    meta.errors.push(\"Aggregation is not supported for \".concat(groupField));\n  }\n\n  var not = properties.get(\"not\");\n  var list = children.map(function (currentChild) {\n    return formatItem(currentChild, config, meta);\n  }).filter(function (currentChild) {\n    return typeof currentChild !== \"undefined\";\n  });\n  if (!list.size) return undefined;\n  var conjunction = properties.get(\"conjunction\");\n  if (!conjunction) conjunction = (0, _defaultUtils.defaultConjunction)(config);\n  var conjunctionDefinition = config.conjunctions[conjunction];\n  return conjunctionDefinition.sqlFormatConj(list, conjunction, not);\n};\n\nvar buildFnToFormatOp = function buildFnToFormatOp(operator, operatorDefinition) {\n  var sqlOp = operatorDefinition.sqlOp || operator;\n  var cardinality = (0, _stuff.defaultValue)(operatorDefinition.cardinality, 1);\n  var fn;\n\n  if (cardinality == 0) {\n    fn = function fn(field, op, values, valueSrc, valueType, opDef, operatorOptions, fieldDef) {\n      return \"\".concat(field, \" \").concat(sqlOp);\n    };\n  } else if (cardinality == 1) {\n    fn = function fn(field, op, value, valueSrc, valueType, opDef, operatorOptions, fieldDef) {\n      return \"\".concat(field, \" \").concat(sqlOp, \" \").concat(value);\n    };\n  } else if (cardinality == 2) {\n    // between\n    fn = function fn(field, op, values, valueSrc, valueType, opDef, operatorOptions, fieldDef) {\n      var valFrom = values.first();\n      var valTo = values.get(1);\n      return \"\".concat(field, \" \").concat(sqlOp, \" \").concat(valFrom, \" AND \").concat(valTo);\n    };\n  }\n\n  return fn;\n};\n\nvar formatRule = function formatRule(item, config, meta) {\n  var properties = item.get(\"properties\") || new _immutable.Map();\n  var field = properties.get(\"field\");\n  var operator = properties.get(\"operator\");\n  var operatorOptions = properties.get(\"operatorOptions\");\n  var iValueSrc = properties.get(\"valueSrc\");\n  var iValueType = properties.get(\"valueType\");\n  var iValue = properties.get(\"value\");\n  var asyncListValues = properties.get(\"asyncListValues\");\n  if (field == null || operator == null) return undefined;\n  var fieldDefinition = (0, _configUtils.getFieldConfig)(config, field) || {};\n  var opDef = (0, _configUtils.getOperatorConfig)(config, operator, field) || {};\n  var reversedOp = opDef.reversedOp;\n  var revOpDef = (0, _configUtils.getOperatorConfig)(config, reversedOp, field) || {};\n  var cardinality = (0, _stuff.defaultValue)(opDef.cardinality, 1); // check op\n\n  var isRev = false;\n  var canFormatOp = opDef.sqlOp || opDef.sqlFormatOp;\n  var canFormatRevOp = revOpDef.sqlOp || revOpDef.sqlFormatOp;\n\n  if (!canFormatOp && !canFormatRevOp) {\n    meta.errors.push(\"Operator \".concat(operator, \" is not supported\"));\n    return undefined;\n  }\n\n  if (!canFormatRevOp && canFormatRevOp) {\n    isRev = true;\n    var _ref = [reversedOp, operator];\n    operator = _ref[0];\n    reversedOp = _ref[1];\n    var _ref2 = [revOpDef, opDef];\n    opDef = _ref2[0];\n    revOpDef = _ref2[1];\n  } //format value\n\n\n  var valueSrcs = [];\n  var valueTypes = [];\n  var fvalue = iValue.map(function (currentValue, ind) {\n    var valueSrc = iValueSrc ? iValueSrc.get(ind) : null;\n    var valueType = iValueType ? iValueType.get(ind) : null;\n    var cValue = (0, _funcUtils.completeValue)(currentValue, valueSrc, config);\n    var widget = (0, _ruleUtils.getWidgetForFieldOp)(config, field, operator, valueSrc);\n    var fieldWidgetDefinition = (0, _omit[\"default\"])((0, _configUtils.getFieldWidgetConfig)(config, field, operator, widget, valueSrc), [\"factory\"]);\n    var fv = formatValue(meta, config, cValue, valueSrc, valueType, fieldWidgetDefinition, fieldDefinition, operator, opDef, asyncListValues);\n\n    if (fv !== undefined) {\n      valueSrcs.push(valueSrc);\n      valueTypes.push(valueType);\n    }\n\n    return fv;\n  });\n  var hasUndefinedValues = fvalue.filter(function (v) {\n    return v === undefined;\n  }).size > 0;\n  if (hasUndefinedValues || fvalue.size < cardinality) return undefined;\n  var formattedValue = cardinality == 1 ? fvalue.first() : fvalue; //find fn to format expr\n\n  var fn = opDef.sqlFormatOp || buildFnToFormatOp(operator, opDef);\n\n  if (!fn) {\n    meta.errors.push(\"Operator \".concat(operator, \" is not supported\"));\n    return undefined;\n  } //format field\n\n\n  var formattedField = formatField(meta, config, field); //format expr\n\n  var args = [formattedField, operator, formattedValue, valueSrcs.length > 1 ? valueSrcs : valueSrcs[0], valueTypes.length > 1 ? valueTypes : valueTypes[0], (0, _omit[\"default\"])(opDef, [\"formatOp\", \"mongoFormatOp\", \"sqlFormatOp\", \"jsonLogic\", \"spelFormatOp\"]), operatorOptions, fieldDefinition];\n  var ret;\n  ret = fn.apply(void 0, args);\n\n  if (isRev) {\n    ret = config.settings.sqlFormatReverse(ret);\n  }\n\n  if (ret === undefined) {\n    meta.errors.push(\"Operator \".concat(operator, \" is not supported for value source \").concat(valueSrcs.join(\", \")));\n    return undefined;\n  }\n\n  return ret;\n};\n\nvar formatValue = function formatValue(meta, config, currentValue, valueSrc, valueType, fieldWidgetDef, fieldDef, operator, operatorDef, asyncListValues) {\n  if (currentValue === undefined) return undefined;\n  var ret;\n\n  if (valueSrc == \"field\") {\n    ret = formatField(meta, config, currentValue);\n  } else if (valueSrc == \"func\") {\n    ret = formatFunc(meta, config, currentValue);\n  } else {\n    if (typeof fieldWidgetDef.sqlFormatValue === \"function\") {\n      var fn = fieldWidgetDef.sqlFormatValue;\n      var args = [currentValue, _objectSpread(_objectSpread({}, (0, _pick[\"default\"])(fieldDef, [\"fieldSettings\", \"listValues\"])), {}, {\n        asyncListValues: asyncListValues\n      }), //useful options: valueFormat for date/time\n      (0, _omit[\"default\"])(fieldWidgetDef, [\"formatValue\", \"mongoFormatValue\", \"sqlFormatValue\", \"jsonLogic\", \"elasticSearchFormatValue\", \"spelFormatValue\"])];\n\n      if (operator) {\n        args.push(operator);\n        args.push(operatorDef);\n      }\n\n      if (valueSrc == \"field\") {\n        var valFieldDefinition = (0, _configUtils.getFieldConfig)(config, currentValue) || {};\n        args.push(valFieldDefinition);\n      }\n\n      ret = fn.apply(void 0, args);\n    } else {\n      ret = _export.SqlString.escape(currentValue);\n    }\n  }\n\n  return ret;\n};\n\nvar formatField = function formatField(meta, config, field) {\n  if (!field) return;\n  var fieldSeparator = config.settings.fieldSeparator;\n  var fieldDefinition = (0, _configUtils.getFieldConfig)(config, field) || {};\n  var fieldParts = Array.isArray(field) ? field : field.split(fieldSeparator);\n\n  var _fieldKeys = (0, _ruleUtils.getFieldPath)(field, config);\n\n  var fieldPartsLabels = (0, _ruleUtils.getFieldPathLabels)(field, config);\n  var fieldFullLabel = fieldPartsLabels ? fieldPartsLabels.join(fieldSeparator) : null;\n  var formatFieldFn = config.settings.formatField || _default.settings.formatField;\n  var fieldName = (0, _ruleUtils.formatFieldName)(field, config, meta);\n  var formattedField = formatFieldFn(fieldName, fieldParts, fieldFullLabel, fieldDefinition, config);\n  return formattedField;\n};\n\nvar formatFunc = function formatFunc(meta, config, currentValue) {\n  var funcKey = currentValue.get(\"func\");\n  var args = currentValue.get(\"args\");\n  var funcConfig = (0, _configUtils.getFuncConfig)(config, funcKey);\n  var funcName = funcConfig.sqlFunc || funcKey;\n  var formattedArgs = {};\n\n  for (var argKey in funcConfig.args) {\n    var argConfig = funcConfig.args[argKey];\n    var fieldDef = (0, _configUtils.getFieldConfig)(config, argConfig);\n    var argVal = args ? args.get(argKey) : undefined;\n    var argValue = argVal ? argVal.get(\"value\") : undefined;\n    var argValueSrc = argVal ? argVal.get(\"valueSrc\") : undefined;\n    var argAsyncListValues = argVal ? argVal.get(\"asyncListValues\") : undefined;\n    var formattedArgVal = formatValue(meta, config, argValue, argValueSrc, argConfig.type, fieldDef, argConfig, null, null, argAsyncListValues);\n\n    if (argValue != undefined && formattedArgVal === undefined) {\n      meta.errors.push(\"Can't format value of arg \".concat(argKey, \" for func \").concat(funcKey));\n      return undefined;\n    }\n\n    if (formattedArgVal !== undefined) {\n      // skip optional in the end\n      formattedArgs[argKey] = formattedArgVal;\n    }\n  }\n\n  var ret;\n\n  if (typeof funcConfig.sqlFormatFunc === \"function\") {\n    var fn = funcConfig.sqlFormatFunc;\n    var _args = [formattedArgs];\n    ret = fn.apply(void 0, _args);\n  } else {\n    var argsStr = Object.entries(formattedArgs).map(function (_ref3) {\n      var _ref4 = (0, _slicedToArray2[\"default\"])(_ref3, 2),\n          k = _ref4[0],\n          v = _ref4[1];\n\n      return v;\n    }).join(\", \");\n    ret = \"\".concat(funcName, \"(\").concat(argsStr, \")\");\n  }\n\n  return ret;\n};"]},"metadata":{},"sourceType":"script"}