{"ast":null,"code":"import _toArray from \"@babel/runtime/helpers/toArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nimport { getFieldConfig, getOperatorConfig, getFieldWidgetConfig, getFuncConfig } from \"../utils/configUtils\";\nimport { getFieldPath, getWidgetForFieldOp, formatFieldName, getFieldPartsConfigs } from \"../utils/ruleUtils\";\nimport omit from \"lodash/omit\";\nimport pick from \"lodash/pick\";\nimport { defaultValue, logger } from \"../utils/stuff\";\nimport { defaultConjunction } from \"../utils/defaultUtils\";\nimport { completeValue } from \"../utils/funcUtils\";\nimport { List, Map } from \"immutable\";\nimport { spelEscape } from \"../utils/export\";\nexport var spelFormat = function spelFormat(tree, config) {\n  return _spelFormat(tree, config, false);\n};\nexport var _spelFormat = function _spelFormat(tree, config) {\n  var returnErrors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true; //meta is mutable\n\n  var meta = {\n    errors: []\n  };\n  var res = formatItem(tree, config, meta, null);\n\n  if (returnErrors) {\n    return [res, meta.errors];\n  } else {\n    if (meta.errors.length) console.warn(\"Errors while exporting to SpEL:\", meta.errors);\n    return res;\n  }\n};\n\nvar formatItem = function formatItem(item, config, meta) {\n  var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  if (!item) return undefined;\n  var type = item.get(\"type\");\n\n  if (type === \"group\" || type === \"rule_group\") {\n    return formatGroup(item, config, meta, parentField);\n  } else if (type === \"rule\") {\n    return formatRule(item, config, meta, parentField);\n  } else if (type == \"switch_group\") {\n    return formatSwitch(item, config, meta, parentField);\n  } else if (type == \"case_group\") {\n    return formatCase(item, config, meta, parentField);\n  }\n\n  return undefined;\n};\n\nvar formatCase = function formatCase(item, config, meta) {\n  var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var type = item.get(\"type\");\n\n  if (type != \"case_group\") {\n    meta.errors.push(\"Unexpected child of type \".concat(type, \" inside switch\"));\n    return undefined;\n  }\n\n  var properties = item.get(\"properties\") || new Map();\n\n  var _formatItemValue = formatItemValue(config, properties, meta, null, parentField, \"!case_value\"),\n      _formatItemValue2 = _slicedToArray(_formatItemValue, 3),\n      formattedValue = _formatItemValue2[0],\n      valueSrc = _formatItemValue2[1],\n      valueType = _formatItemValue2[2];\n\n  var cond = formatGroup(item, config, meta, parentField);\n  return [cond, formattedValue];\n};\n\nvar formatSwitch = function formatSwitch(item, config, meta) {\n  var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var properties = item.get(\"properties\") || new Map();\n  var children = item.get(\"children1\");\n  if (!children) return undefined;\n  var cases = children.map(function (currentChild) {\n    return formatCase(currentChild, config, meta, null);\n  }).filter(function (currentChild) {\n    return typeof currentChild !== \"undefined\";\n  }).toArray();\n  if (!cases.length) return undefined;\n\n  if (cases.length == 1 && !cases[0][0]) {\n    // only 1 case without condition\n    return cases[0][1];\n  }\n\n  var filteredCases = [];\n\n  for (var i = 0; i < cases.length; i++) {\n    if (i != cases.length - 1 && !cases[i][0]) {\n      meta.errors.push(\"No condition for case \".concat(i));\n    } else {\n      filteredCases.push(cases[i]);\n\n      if (i == cases.length - 1 && cases[i][0]) {\n        // no default - add null as default\n        filteredCases.push([undefined, null]);\n      }\n    }\n  }\n\n  var left = \"\",\n      right = \"\";\n\n  for (var _i = 0; _i < filteredCases.length; _i++) {\n    var _filteredCases$_i = _slicedToArray(filteredCases[_i], 2),\n        cond = _filteredCases$_i[0],\n        value = _filteredCases$_i[1];\n\n    if (value == undefined) value = \"null\";\n    if (cond == undefined) cond = \"true\";\n\n    if (_i != filteredCases.length - 1) {\n      left += \"(\".concat(cond, \" ? \").concat(value, \" : \");\n      right += \")\";\n    } else {\n      left += \"\".concat(value);\n    }\n  }\n\n  return left + right;\n};\n\nvar formatGroup = function formatGroup(item, config, meta) {\n  var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var type = item.get(\"type\");\n  var properties = item.get(\"properties\") || new Map();\n  var mode = properties.get(\"mode\");\n  var children = item.get(\"children1\") || new List();\n  var field = properties.get(\"field\");\n  var conjunction = properties.get(\"conjunction\");\n  if (!conjunction) conjunction = defaultConjunction(config);\n  var conjunctionDefinition = config.conjunctions[conjunction];\n  var not = properties.get(\"not\");\n  var isRuleGroup = type === \"rule_group\";\n  var isRuleGroupArray = isRuleGroup && mode != \"struct\";\n  var groupField = isRuleGroupArray ? field : parentField;\n  var groupFieldDef = getFieldConfig(config, groupField) || {};\n  var isSpelArray = groupFieldDef.isSpelArray; // check op for reverse\n\n  var groupOperator = properties.get(\"operator\");\n\n  if (!groupOperator && (!mode || mode == \"some\")) {\n    groupOperator = \"some\";\n  }\n\n  var realGroupOperator = checkOp(config, groupOperator, field);\n  var isGroupOpRev = realGroupOperator != groupOperator;\n  var realGroupOperatorDefinition = groupOperator && getOperatorConfig(config, realGroupOperator, field) || null;\n  var isGroup0 = isRuleGroup && (!realGroupOperator || realGroupOperatorDefinition.cardinality == 0); // build value for aggregation op\n\n  var _formatItemValue3 = formatItemValue(config, properties, meta, realGroupOperator, parentField, null),\n      _formatItemValue4 = _slicedToArray(_formatItemValue3, 3),\n      formattedValue = _formatItemValue4[0],\n      valueSrc = _formatItemValue4[1],\n      valueType = _formatItemValue4[2]; // build filter in aggregation\n\n\n  var list = children.map(function (currentChild) {\n    return formatItem(currentChild, config, meta, groupField);\n  }).filter(function (currentChild) {\n    return typeof currentChild !== \"undefined\";\n  });\n\n  if (isRuleGroupArray && !isGroup0) {\n    // \"count\" rule can have no \"having\" children, but should have number value\n    if (formattedValue == undefined) return undefined;\n  } else {\n    if (!list.size) return undefined;\n  }\n\n  var omitBrackets = isRuleGroup;\n  var filter = list.size ? conjunctionDefinition.spelFormatConj(list, conjunction, not, omitBrackets) : null; // build result\n\n  var ret;\n\n  if (isRuleGroupArray) {\n    var formattedField = formatField(meta, config, field, parentField);\n    var getSize = isSpelArray ? \".length\" : \".size()\";\n    var fullSize = \"\".concat(formattedField).concat(getSize); // https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html#expressions-collection-selection\n\n    var filteredSize = filter ? \"\".concat(formattedField, \".?[\").concat(filter, \"]\").concat(getSize) : fullSize;\n    var groupValue = isGroup0 ? fullSize : formattedValue; // format expression\n\n    ret = formatExpression(meta, config, properties, filteredSize, groupValue, realGroupOperator, valueSrc, valueType, isGroupOpRev);\n  } else {\n    ret = filter;\n  }\n\n  return ret;\n};\n\nvar buildFnToFormatOp = function buildFnToFormatOp(operator, operatorDefinition) {\n  var spelOp = operatorDefinition.spelOp;\n  if (!spelOp) return undefined;\n  var objectIsFirstArg = spelOp[0] == \"$\";\n  var isMethod = spelOp[0] == \".\" || objectIsFirstArg;\n  var isFunction = spelOp.substring(spelOp.length - 2) == \"()\";\n  var sop = isMethod ? spelOp.slice(1) : isFunction ? spelOp.substring(0, spelOp.length - 2) : spelOp;\n  var fn;\n  var cardinality = defaultValue(operatorDefinition.cardinality, 1);\n\n  if (cardinality == 0) {\n    fn = function fn(field, op, values, valueSrc, valueType, opDef, operatorOptions, fieldDef) {\n      if (isMethod) return \"\".concat(field, \".\").concat(sop, \"()\");else return \"\".concat(field, \" \").concat(sop);\n    };\n  } else if (cardinality == 1) {\n    fn = function fn(field, op, values, valueSrc, valueType, opDef, operatorOptions, fieldDef) {\n      if (objectIsFirstArg) return \"\".concat(values, \".\").concat(sop, \"(\").concat(field, \")\");else if (isFunction) return \"\".concat(sop, \"(\").concat(field, \", \").concat(values, \")\");else if (isMethod) return \"\".concat(field, \".\").concat(sop, \"(\").concat(values, \")\");else return \"\".concat(field, \" \").concat(sop, \" \").concat(values);\n    };\n  }\n\n  return fn;\n};\n\nvar formatExpression = function formatExpression(meta, config, properties, formattedField, formattedValue, operator, valueSrc, valueType) {\n  var isRev = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : false;\n  var field = properties.get(\"field\");\n  var opDef = getOperatorConfig(config, operator, field) || {};\n  var fieldDef = getFieldConfig(config, field) || {};\n  var operatorOptions = properties.get(\"operatorOptions\"); //find fn to format expr\n\n  var fn = opDef.spelFormatOp || buildFnToFormatOp(operator, opDef);\n\n  if (!fn) {\n    meta.errors.push(\"Operator \".concat(operator, \" is not supported\"));\n    return undefined;\n  } //format expr\n\n\n  var args = [formattedField, operator, formattedValue, valueSrc, valueType, omit(opDef, [\"formatOp\", \"mongoFormatOp\", \"sqlFormatOp\", \"jsonLogic\", \"spelFormatOp\"]), operatorOptions, fieldDef];\n  var ret;\n  ret = fn.apply(void 0, args); //rev\n\n  if (isRev) {\n    ret = config.settings.spelFormatReverse(ret);\n  }\n\n  if (ret === undefined) {\n    meta.errors.push(\"Operator \".concat(operator, \" is not supported for value source \").concat(valueSrc));\n  }\n\n  return ret;\n};\n\nvar checkOp = function checkOp(config, operator, field) {\n  if (!operator) return undefined;\n  var opDef = getOperatorConfig(config, operator, field) || {};\n  var reversedOp = opDef.reversedOp;\n  var revOpDef = getOperatorConfig(config, reversedOp, field) || {};\n  var isRev = false;\n  var canFormatOp = opDef.spelOp || opDef.spelFormatOp;\n  var canFormatRevOp = revOpDef.spelOp || revOpDef.spelFormatOp;\n\n  if (!canFormatOp && !canFormatRevOp) {\n    return undefined;\n  }\n\n  if (!canFormatOp && canFormatRevOp) {\n    isRev = true;\n    var _ref = [reversedOp, operator];\n    operator = _ref[0];\n    reversedOp = _ref[1];\n    var _ref2 = [revOpDef, opDef];\n    opDef = _ref2[0];\n    revOpDef = _ref2[1];\n  }\n\n  return operator;\n};\n\nvar formatRule = function formatRule(item, config, meta) {\n  var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var properties = item.get(\"properties\") || new Map();\n  var field = properties.get(\"field\");\n  var operator = properties.get(\"operator\");\n  if (field == null || operator == null) return undefined; // check op for reverse\n\n  var realOp = checkOp(config, operator, field);\n\n  if (!realOp) {\n    meta.errors.push(\"Operator \".concat(operator, \" is not supported\"));\n    return undefined;\n  }\n\n  var isRev = realOp != operator; //format value\n\n  var _formatItemValue5 = formatItemValue(config, properties, meta, realOp, parentField, null),\n      _formatItemValue6 = _slicedToArray(_formatItemValue5, 3),\n      formattedValue = _formatItemValue6[0],\n      valueSrc = _formatItemValue6[1],\n      valueType = _formatItemValue6[2];\n\n  if (formattedValue === undefined) return undefined; //format field\n\n  var formattedField = formatField(meta, config, field, parentField); // format expression\n\n  var res = formatExpression(meta, config, properties, formattedField, formattedValue, realOp, valueSrc, valueType, isRev);\n  return res;\n};\n\nvar formatItemValue = function formatItemValue(config, properties, meta, operator, parentField) {\n  var expectedValueType = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n  var field = properties.get(\"field\");\n  var iValueSrc = properties.get(\"valueSrc\");\n  var iValueType = properties.get(\"valueType\");\n\n  if (expectedValueType == \"!case_value\" || iValueType && iValueType.get(0) == \"case_value\") {\n    field = \"!case_value\";\n  }\n\n  var fieldDef = getFieldConfig(config, field) || {};\n  var operatorDefinition = getOperatorConfig(config, operator, field) || {};\n  var cardinality = defaultValue(operatorDefinition.cardinality, 1);\n  var iValue = properties.get(\"value\");\n  var asyncListValues = properties.get(\"asyncListValues\");\n  var valueSrcs = [];\n  var valueTypes = [];\n  var formattedValue;\n\n  if (iValue != undefined) {\n    var fvalue = iValue.map(function (currentValue, ind) {\n      var valueSrc = iValueSrc ? iValueSrc.get(ind) : null;\n      var valueType = iValueType ? iValueType.get(ind) : null;\n      var cValue = completeValue(currentValue, valueSrc, config);\n      var widget = getWidgetForFieldOp(config, field, operator, valueSrc);\n      var fieldWidgetDef = omit(getFieldWidgetConfig(config, field, operator, widget, valueSrc), [\"factory\"]);\n      var fv = formatValue(meta, config, cValue, valueSrc, valueType, fieldWidgetDef, fieldDef, operator, operatorDefinition, parentField, asyncListValues);\n\n      if (fv !== undefined) {\n        valueSrcs.push(valueSrc);\n        valueTypes.push(valueType);\n      }\n\n      return fv;\n    });\n    var hasUndefinedValues = fvalue.filter(function (v) {\n      return v === undefined;\n    }).size > 0;\n\n    if (!(fvalue.size < cardinality || hasUndefinedValues)) {\n      formattedValue = cardinality > 1 ? fvalue.toArray() : cardinality == 1 ? fvalue.first() : null;\n    }\n  }\n\n  return [formattedValue, valueSrcs.length > 1 ? valueSrcs : valueSrcs[0], valueTypes.length > 1 ? valueTypes : valueTypes[0]];\n};\n\nvar formatValue = function formatValue(meta, config, currentValue, valueSrc, valueType, fieldWidgetDef, fieldDef, operator, operatorDef) {\n  var parentField = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : null;\n  var asyncListValues = arguments.length > 10 ? arguments[10] : undefined;\n  if (currentValue === undefined) return undefined;\n  var ret;\n\n  if (valueSrc == \"field\") {\n    ret = formatField(meta, config, currentValue, parentField);\n  } else if (valueSrc == \"func\") {\n    ret = formatFunc(meta, config, currentValue, parentField);\n  } else {\n    if (typeof fieldWidgetDef.spelFormatValue === \"function\") {\n      var fn = fieldWidgetDef.spelFormatValue;\n      var args = [currentValue, _objectSpread(_objectSpread({}, pick(fieldDef, [\"fieldSettings\", \"listValues\"])), {}, {\n        asyncListValues: asyncListValues\n      }), //useful options: valueFormat for date/time\n      omit(fieldWidgetDef, [\"formatValue\", \"mongoFormatValue\", \"sqlFormatValue\", \"jsonLogic\", \"elasticSearchFormatValue\", \"spelFormatValue\"])];\n\n      if (operator) {\n        args.push(operator);\n        args.push(operatorDef);\n      }\n\n      if (valueSrc == \"field\") {\n        var valFieldDefinition = getFieldConfig(config, currentValue) || {};\n        args.push(valFieldDefinition);\n      }\n\n      ret = fn.apply(void 0, args);\n    } else {\n      ret = spelEscape(currentValue);\n    }\n  }\n\n  return ret;\n};\n\nvar formatField = function formatField(meta, config, field) {\n  var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  if (!field) return;\n  var fieldSeparator = config.settings.fieldSeparator;\n  var fieldDefinition = getFieldConfig(config, field) || {};\n  var fieldParts = Array.isArray(field) ? field : field.split(fieldSeparator);\n\n  var _fieldKeys = getFieldPath(field, config, parentField);\n\n  var fieldPartsConfigs = getFieldPartsConfigs(field, config, parentField);\n  var formatFieldFn = config.settings.formatSpelField;\n  var fieldName = formatFieldName(field, config, meta);\n\n  if (parentField) {\n    var parentFieldDef = getFieldConfig(config, parentField) || {};\n    var parentFieldName = parentField;\n\n    if (parentFieldDef.fieldName) {\n      parentFieldName = parentFieldDef.fieldName;\n    }\n\n    if (fieldName.indexOf(parentFieldName + fieldSeparator) == 0) {\n      fieldName = fieldName.slice((parentFieldName + fieldSeparator).length); // fieldName = \"#this.\" + fieldName;\n    } else {\n      meta.errors.push(\"Can't cut group \".concat(parentFieldName, \" from field \").concat(fieldName));\n    }\n  }\n\n  var fieldPartsMeta = fieldPartsConfigs.map(function (_ref3) {\n    var _ref4 = _slicedToArray(_ref3, 3),\n        key = _ref4[0],\n        cnf = _ref4[1],\n        parentCnf = _ref4[2];\n\n    var parent;\n\n    if (parentCnf) {\n      if (parentCnf.type == \"!struct\" || parentCnf.type == \"!group\" && parentCnf.mode == \"struct\") parent = cnf.isSpelMap ? \"map\" : \"class\";else if (parentCnf.type == \"!group\") parent = cnf.isSpelItemMap ? \"[map]\" : \"[class]\";else parent = \"class\";\n    }\n\n    var isSpelVariable = cnf === null || cnf === void 0 ? void 0 : cnf.isSpelVariable;\n    return {\n      key: key,\n      parent: parent,\n      isSpelVariable: isSpelVariable\n    };\n  });\n  var formattedField = formatFieldFn(fieldName, parentField, fieldParts, fieldPartsMeta, fieldDefinition, config);\n  return formattedField;\n};\n\nvar formatFunc = function formatFunc(meta, config, currentValue) {\n  var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var funcKey = currentValue.get(\"func\");\n  var args = currentValue.get(\"args\");\n  var funcConfig = getFuncConfig(config, funcKey);\n  var funcName = funcConfig.spelFunc || funcKey;\n  var formattedArgs = {};\n\n  for (var argKey in funcConfig.args) {\n    var argConfig = funcConfig.args[argKey];\n    var fieldDef = getFieldConfig(config, argConfig);\n    var argVal = args ? args.get(argKey) : undefined;\n    var argValue = argVal ? argVal.get(\"value\") : undefined;\n    var argValueSrc = argVal ? argVal.get(\"valueSrc\") : undefined;\n    var argAsyncListValues = argVal ? argVal.get(\"asyncListValues\") : undefined;\n    var formattedArgVal = formatValue(meta, config, argValue, argValueSrc, argConfig.type, fieldDef, argConfig, null, null, parentField, argAsyncListValues);\n\n    if (argValue != undefined && formattedArgVal === undefined) {\n      meta.errors.push(\"Can't format value of arg \".concat(argKey, \" for func \").concat(funcKey));\n      return undefined;\n    }\n\n    if (formattedArgVal !== undefined) {\n      // skip optional in the end\n      formattedArgs[argKey] = formattedArgVal;\n    }\n  }\n\n  var ret;\n\n  if (typeof funcConfig.spelFormatFunc === \"function\") {\n    var fn = funcConfig.spelFormatFunc;\n    var _args = [formattedArgs];\n    ret = fn.apply(void 0, _args);\n  } else {\n    var _args2 = Object.entries(formattedArgs).map(function (_ref5) {\n      var _ref6 = _slicedToArray(_ref5, 2),\n          k = _ref6[0],\n          v = _ref6[1];\n\n      return v;\n    });\n\n    if (funcName[0] == \".\" && _args2.length) {\n      var _args3 = _toArray(_args2),\n          obj = _args3[0],\n          params = _args3.slice(1);\n\n      ret = \"\".concat(obj).concat(funcName, \"(\").concat(params.join(\", \"), \")\");\n    } else {\n      ret = \"\".concat(funcName, \"(\").concat(_args2.join(\", \"), \")\");\n    }\n  }\n\n  return ret;\n};","map":{"version":3,"sources":["D:/LIMSWFH/LIMSPOSTGRESQL/QuaLISWeb/node_modules/@react-awesome-query-builder/core/esm/export/spel.js"],"names":["_toArray","_defineProperty","_slicedToArray","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","getFieldConfig","getOperatorConfig","getFieldWidgetConfig","getFuncConfig","getFieldPath","getWidgetForFieldOp","formatFieldName","getFieldPartsConfigs","omit","pick","defaultValue","logger","defaultConjunction","completeValue","List","Map","spelEscape","spelFormat","tree","config","_spelFormat","returnErrors","undefined","meta","errors","res","formatItem","console","warn","item","parentField","type","get","formatGroup","formatRule","formatSwitch","formatCase","concat","properties","_formatItemValue","formatItemValue","_formatItemValue2","formattedValue","valueSrc","valueType","cond","children","cases","map","currentChild","toArray","filteredCases","left","right","_i","_filteredCases$_i","value","mode","field","conjunction","conjunctionDefinition","conjunctions","not","isRuleGroup","isRuleGroupArray","groupField","groupFieldDef","isSpelArray","groupOperator","realGroupOperator","checkOp","isGroupOpRev","realGroupOperatorDefinition","isGroup0","cardinality","_formatItemValue3","_formatItemValue4","list","size","omitBrackets","spelFormatConj","ret","formattedField","formatField","getSize","fullSize","filteredSize","groupValue","formatExpression","buildFnToFormatOp","operator","operatorDefinition","spelOp","objectIsFirstArg","isMethod","isFunction","substring","sop","slice","fn","op","values","opDef","operatorOptions","fieldDef","isRev","spelFormatOp","args","settings","spelFormatReverse","reversedOp","revOpDef","canFormatOp","canFormatRevOp","_ref","_ref2","realOp","_formatItemValue5","_formatItemValue6","expectedValueType","iValueSrc","iValueType","iValue","asyncListValues","valueSrcs","valueTypes","fvalue","currentValue","ind","cValue","widget","fieldWidgetDef","fv","formatValue","hasUndefinedValues","v","first","operatorDef","formatFunc","spelFormatValue","valFieldDefinition","fieldSeparator","fieldDefinition","fieldParts","Array","isArray","split","_fieldKeys","fieldPartsConfigs","formatFieldFn","formatSpelField","fieldName","parentFieldDef","parentFieldName","indexOf","fieldPartsMeta","_ref3","_ref4","cnf","parentCnf","parent","isSpelMap","isSpelItemMap","isSpelVariable","funcKey","funcConfig","funcName","spelFunc","formattedArgs","argKey","argConfig","argVal","argValue","argValueSrc","argAsyncListValues","formattedArgVal","spelFormatFunc","_args","_args2","entries","_ref5","_ref6","k","_args3","obj","params","join"],"mappings":"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","sourcesContent":["import _toArray from \"@babel/runtime/helpers/toArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nimport { getFieldConfig, getOperatorConfig, getFieldWidgetConfig, getFuncConfig } from \"../utils/configUtils\";\nimport { getFieldPath, getWidgetForFieldOp, formatFieldName, getFieldPartsConfigs } from \"../utils/ruleUtils\";\nimport omit from \"lodash/omit\";\nimport pick from \"lodash/pick\";\nimport { defaultValue, logger } from \"../utils/stuff\";\nimport { defaultConjunction } from \"../utils/defaultUtils\";\nimport { completeValue } from \"../utils/funcUtils\";\nimport { List, Map } from \"immutable\";\nimport { spelEscape } from \"../utils/export\";\nexport var spelFormat = function spelFormat(tree, config) {\n  return _spelFormat(tree, config, false);\n};\nexport var _spelFormat = function _spelFormat(tree, config) {\n  var returnErrors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  //meta is mutable\n  var meta = {\n    errors: []\n  };\n  var res = formatItem(tree, config, meta, null);\n  if (returnErrors) {\n    return [res, meta.errors];\n  } else {\n    if (meta.errors.length) console.warn(\"Errors while exporting to SpEL:\", meta.errors);\n    return res;\n  }\n};\nvar formatItem = function formatItem(item, config, meta) {\n  var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  if (!item) return undefined;\n  var type = item.get(\"type\");\n  if (type === \"group\" || type === \"rule_group\") {\n    return formatGroup(item, config, meta, parentField);\n  } else if (type === \"rule\") {\n    return formatRule(item, config, meta, parentField);\n  } else if (type == \"switch_group\") {\n    return formatSwitch(item, config, meta, parentField);\n  } else if (type == \"case_group\") {\n    return formatCase(item, config, meta, parentField);\n  }\n  return undefined;\n};\nvar formatCase = function formatCase(item, config, meta) {\n  var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var type = item.get(\"type\");\n  if (type != \"case_group\") {\n    meta.errors.push(\"Unexpected child of type \".concat(type, \" inside switch\"));\n    return undefined;\n  }\n  var properties = item.get(\"properties\") || new Map();\n  var _formatItemValue = formatItemValue(config, properties, meta, null, parentField, \"!case_value\"),\n    _formatItemValue2 = _slicedToArray(_formatItemValue, 3),\n    formattedValue = _formatItemValue2[0],\n    valueSrc = _formatItemValue2[1],\n    valueType = _formatItemValue2[2];\n  var cond = formatGroup(item, config, meta, parentField);\n  return [cond, formattedValue];\n};\nvar formatSwitch = function formatSwitch(item, config, meta) {\n  var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var properties = item.get(\"properties\") || new Map();\n  var children = item.get(\"children1\");\n  if (!children) return undefined;\n  var cases = children.map(function (currentChild) {\n    return formatCase(currentChild, config, meta, null);\n  }).filter(function (currentChild) {\n    return typeof currentChild !== \"undefined\";\n  }).toArray();\n  if (!cases.length) return undefined;\n  if (cases.length == 1 && !cases[0][0]) {\n    // only 1 case without condition\n    return cases[0][1];\n  }\n  var filteredCases = [];\n  for (var i = 0; i < cases.length; i++) {\n    if (i != cases.length - 1 && !cases[i][0]) {\n      meta.errors.push(\"No condition for case \".concat(i));\n    } else {\n      filteredCases.push(cases[i]);\n      if (i == cases.length - 1 && cases[i][0]) {\n        // no default - add null as default\n        filteredCases.push([undefined, null]);\n      }\n    }\n  }\n  var left = \"\",\n    right = \"\";\n  for (var _i = 0; _i < filteredCases.length; _i++) {\n    var _filteredCases$_i = _slicedToArray(filteredCases[_i], 2),\n      cond = _filteredCases$_i[0],\n      value = _filteredCases$_i[1];\n    if (value == undefined) value = \"null\";\n    if (cond == undefined) cond = \"true\";\n    if (_i != filteredCases.length - 1) {\n      left += \"(\".concat(cond, \" ? \").concat(value, \" : \");\n      right += \")\";\n    } else {\n      left += \"\".concat(value);\n    }\n  }\n  return left + right;\n};\nvar formatGroup = function formatGroup(item, config, meta) {\n  var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var type = item.get(\"type\");\n  var properties = item.get(\"properties\") || new Map();\n  var mode = properties.get(\"mode\");\n  var children = item.get(\"children1\") || new List();\n  var field = properties.get(\"field\");\n  var conjunction = properties.get(\"conjunction\");\n  if (!conjunction) conjunction = defaultConjunction(config);\n  var conjunctionDefinition = config.conjunctions[conjunction];\n  var not = properties.get(\"not\");\n  var isRuleGroup = type === \"rule_group\";\n  var isRuleGroupArray = isRuleGroup && mode != \"struct\";\n  var groupField = isRuleGroupArray ? field : parentField;\n  var groupFieldDef = getFieldConfig(config, groupField) || {};\n  var isSpelArray = groupFieldDef.isSpelArray;\n\n  // check op for reverse\n  var groupOperator = properties.get(\"operator\");\n  if (!groupOperator && (!mode || mode == \"some\")) {\n    groupOperator = \"some\";\n  }\n  var realGroupOperator = checkOp(config, groupOperator, field);\n  var isGroupOpRev = realGroupOperator != groupOperator;\n  var realGroupOperatorDefinition = groupOperator && getOperatorConfig(config, realGroupOperator, field) || null;\n  var isGroup0 = isRuleGroup && (!realGroupOperator || realGroupOperatorDefinition.cardinality == 0);\n\n  // build value for aggregation op\n  var _formatItemValue3 = formatItemValue(config, properties, meta, realGroupOperator, parentField, null),\n    _formatItemValue4 = _slicedToArray(_formatItemValue3, 3),\n    formattedValue = _formatItemValue4[0],\n    valueSrc = _formatItemValue4[1],\n    valueType = _formatItemValue4[2];\n\n  // build filter in aggregation\n  var list = children.map(function (currentChild) {\n    return formatItem(currentChild, config, meta, groupField);\n  }).filter(function (currentChild) {\n    return typeof currentChild !== \"undefined\";\n  });\n  if (isRuleGroupArray && !isGroup0) {\n    // \"count\" rule can have no \"having\" children, but should have number value\n    if (formattedValue == undefined) return undefined;\n  } else {\n    if (!list.size) return undefined;\n  }\n  var omitBrackets = isRuleGroup;\n  var filter = list.size ? conjunctionDefinition.spelFormatConj(list, conjunction, not, omitBrackets) : null;\n\n  // build result\n  var ret;\n  if (isRuleGroupArray) {\n    var formattedField = formatField(meta, config, field, parentField);\n    var getSize = isSpelArray ? \".length\" : \".size()\";\n    var fullSize = \"\".concat(formattedField).concat(getSize);\n    // https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html#expressions-collection-selection\n    var filteredSize = filter ? \"\".concat(formattedField, \".?[\").concat(filter, \"]\").concat(getSize) : fullSize;\n    var groupValue = isGroup0 ? fullSize : formattedValue;\n    // format expression\n    ret = formatExpression(meta, config, properties, filteredSize, groupValue, realGroupOperator, valueSrc, valueType, isGroupOpRev);\n  } else {\n    ret = filter;\n  }\n  return ret;\n};\nvar buildFnToFormatOp = function buildFnToFormatOp(operator, operatorDefinition) {\n  var spelOp = operatorDefinition.spelOp;\n  if (!spelOp) return undefined;\n  var objectIsFirstArg = spelOp[0] == \"$\";\n  var isMethod = spelOp[0] == \".\" || objectIsFirstArg;\n  var isFunction = spelOp.substring(spelOp.length - 2) == \"()\";\n  var sop = isMethod ? spelOp.slice(1) : isFunction ? spelOp.substring(0, spelOp.length - 2) : spelOp;\n  var fn;\n  var cardinality = defaultValue(operatorDefinition.cardinality, 1);\n  if (cardinality == 0) {\n    fn = function fn(field, op, values, valueSrc, valueType, opDef, operatorOptions, fieldDef) {\n      if (isMethod) return \"\".concat(field, \".\").concat(sop, \"()\");else return \"\".concat(field, \" \").concat(sop);\n    };\n  } else if (cardinality == 1) {\n    fn = function fn(field, op, values, valueSrc, valueType, opDef, operatorOptions, fieldDef) {\n      if (objectIsFirstArg) return \"\".concat(values, \".\").concat(sop, \"(\").concat(field, \")\");else if (isFunction) return \"\".concat(sop, \"(\").concat(field, \", \").concat(values, \")\");else if (isMethod) return \"\".concat(field, \".\").concat(sop, \"(\").concat(values, \")\");else return \"\".concat(field, \" \").concat(sop, \" \").concat(values);\n    };\n  }\n  return fn;\n};\nvar formatExpression = function formatExpression(meta, config, properties, formattedField, formattedValue, operator, valueSrc, valueType) {\n  var isRev = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : false;\n  var field = properties.get(\"field\");\n  var opDef = getOperatorConfig(config, operator, field) || {};\n  var fieldDef = getFieldConfig(config, field) || {};\n  var operatorOptions = properties.get(\"operatorOptions\");\n\n  //find fn to format expr\n  var fn = opDef.spelFormatOp || buildFnToFormatOp(operator, opDef);\n  if (!fn) {\n    meta.errors.push(\"Operator \".concat(operator, \" is not supported\"));\n    return undefined;\n  }\n\n  //format expr\n  var args = [formattedField, operator, formattedValue, valueSrc, valueType, omit(opDef, [\"formatOp\", \"mongoFormatOp\", \"sqlFormatOp\", \"jsonLogic\", \"spelFormatOp\"]), operatorOptions, fieldDef];\n  var ret;\n  ret = fn.apply(void 0, args);\n\n  //rev\n  if (isRev) {\n    ret = config.settings.spelFormatReverse(ret);\n  }\n  if (ret === undefined) {\n    meta.errors.push(\"Operator \".concat(operator, \" is not supported for value source \").concat(valueSrc));\n  }\n  return ret;\n};\nvar checkOp = function checkOp(config, operator, field) {\n  if (!operator) return undefined;\n  var opDef = getOperatorConfig(config, operator, field) || {};\n  var reversedOp = opDef.reversedOp;\n  var revOpDef = getOperatorConfig(config, reversedOp, field) || {};\n  var isRev = false;\n  var canFormatOp = opDef.spelOp || opDef.spelFormatOp;\n  var canFormatRevOp = revOpDef.spelOp || revOpDef.spelFormatOp;\n  if (!canFormatOp && !canFormatRevOp) {\n    return undefined;\n  }\n  if (!canFormatOp && canFormatRevOp) {\n    isRev = true;\n    var _ref = [reversedOp, operator];\n    operator = _ref[0];\n    reversedOp = _ref[1];\n    var _ref2 = [revOpDef, opDef];\n    opDef = _ref2[0];\n    revOpDef = _ref2[1];\n  }\n  return operator;\n};\nvar formatRule = function formatRule(item, config, meta) {\n  var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var properties = item.get(\"properties\") || new Map();\n  var field = properties.get(\"field\");\n  var operator = properties.get(\"operator\");\n  if (field == null || operator == null) return undefined;\n\n  // check op for reverse\n  var realOp = checkOp(config, operator, field);\n  if (!realOp) {\n    meta.errors.push(\"Operator \".concat(operator, \" is not supported\"));\n    return undefined;\n  }\n  var isRev = realOp != operator;\n\n  //format value\n  var _formatItemValue5 = formatItemValue(config, properties, meta, realOp, parentField, null),\n    _formatItemValue6 = _slicedToArray(_formatItemValue5, 3),\n    formattedValue = _formatItemValue6[0],\n    valueSrc = _formatItemValue6[1],\n    valueType = _formatItemValue6[2];\n  if (formattedValue === undefined) return undefined;\n\n  //format field\n  var formattedField = formatField(meta, config, field, parentField);\n\n  // format expression\n  var res = formatExpression(meta, config, properties, formattedField, formattedValue, realOp, valueSrc, valueType, isRev);\n  return res;\n};\nvar formatItemValue = function formatItemValue(config, properties, meta, operator, parentField) {\n  var expectedValueType = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n  var field = properties.get(\"field\");\n  var iValueSrc = properties.get(\"valueSrc\");\n  var iValueType = properties.get(\"valueType\");\n  if (expectedValueType == \"!case_value\" || iValueType && iValueType.get(0) == \"case_value\") {\n    field = \"!case_value\";\n  }\n  var fieldDef = getFieldConfig(config, field) || {};\n  var operatorDefinition = getOperatorConfig(config, operator, field) || {};\n  var cardinality = defaultValue(operatorDefinition.cardinality, 1);\n  var iValue = properties.get(\"value\");\n  var asyncListValues = properties.get(\"asyncListValues\");\n  var valueSrcs = [];\n  var valueTypes = [];\n  var formattedValue;\n  if (iValue != undefined) {\n    var fvalue = iValue.map(function (currentValue, ind) {\n      var valueSrc = iValueSrc ? iValueSrc.get(ind) : null;\n      var valueType = iValueType ? iValueType.get(ind) : null;\n      var cValue = completeValue(currentValue, valueSrc, config);\n      var widget = getWidgetForFieldOp(config, field, operator, valueSrc);\n      var fieldWidgetDef = omit(getFieldWidgetConfig(config, field, operator, widget, valueSrc), [\"factory\"]);\n      var fv = formatValue(meta, config, cValue, valueSrc, valueType, fieldWidgetDef, fieldDef, operator, operatorDefinition, parentField, asyncListValues);\n      if (fv !== undefined) {\n        valueSrcs.push(valueSrc);\n        valueTypes.push(valueType);\n      }\n      return fv;\n    });\n    var hasUndefinedValues = fvalue.filter(function (v) {\n      return v === undefined;\n    }).size > 0;\n    if (!(fvalue.size < cardinality || hasUndefinedValues)) {\n      formattedValue = cardinality > 1 ? fvalue.toArray() : cardinality == 1 ? fvalue.first() : null;\n    }\n  }\n  return [formattedValue, valueSrcs.length > 1 ? valueSrcs : valueSrcs[0], valueTypes.length > 1 ? valueTypes : valueTypes[0]];\n};\nvar formatValue = function formatValue(meta, config, currentValue, valueSrc, valueType, fieldWidgetDef, fieldDef, operator, operatorDef) {\n  var parentField = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : null;\n  var asyncListValues = arguments.length > 10 ? arguments[10] : undefined;\n  if (currentValue === undefined) return undefined;\n  var ret;\n  if (valueSrc == \"field\") {\n    ret = formatField(meta, config, currentValue, parentField);\n  } else if (valueSrc == \"func\") {\n    ret = formatFunc(meta, config, currentValue, parentField);\n  } else {\n    if (typeof fieldWidgetDef.spelFormatValue === \"function\") {\n      var fn = fieldWidgetDef.spelFormatValue;\n      var args = [currentValue, _objectSpread(_objectSpread({}, pick(fieldDef, [\"fieldSettings\", \"listValues\"])), {}, {\n        asyncListValues: asyncListValues\n      }),\n      //useful options: valueFormat for date/time\n      omit(fieldWidgetDef, [\"formatValue\", \"mongoFormatValue\", \"sqlFormatValue\", \"jsonLogic\", \"elasticSearchFormatValue\", \"spelFormatValue\"])];\n      if (operator) {\n        args.push(operator);\n        args.push(operatorDef);\n      }\n      if (valueSrc == \"field\") {\n        var valFieldDefinition = getFieldConfig(config, currentValue) || {};\n        args.push(valFieldDefinition);\n      }\n      ret = fn.apply(void 0, args);\n    } else {\n      ret = spelEscape(currentValue);\n    }\n  }\n  return ret;\n};\nvar formatField = function formatField(meta, config, field) {\n  var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  if (!field) return;\n  var fieldSeparator = config.settings.fieldSeparator;\n  var fieldDefinition = getFieldConfig(config, field) || {};\n  var fieldParts = Array.isArray(field) ? field : field.split(fieldSeparator);\n  var _fieldKeys = getFieldPath(field, config, parentField);\n  var fieldPartsConfigs = getFieldPartsConfigs(field, config, parentField);\n  var formatFieldFn = config.settings.formatSpelField;\n  var fieldName = formatFieldName(field, config, meta);\n  if (parentField) {\n    var parentFieldDef = getFieldConfig(config, parentField) || {};\n    var parentFieldName = parentField;\n    if (parentFieldDef.fieldName) {\n      parentFieldName = parentFieldDef.fieldName;\n    }\n    if (fieldName.indexOf(parentFieldName + fieldSeparator) == 0) {\n      fieldName = fieldName.slice((parentFieldName + fieldSeparator).length);\n      // fieldName = \"#this.\" + fieldName;\n    } else {\n      meta.errors.push(\"Can't cut group \".concat(parentFieldName, \" from field \").concat(fieldName));\n    }\n  }\n  var fieldPartsMeta = fieldPartsConfigs.map(function (_ref3) {\n    var _ref4 = _slicedToArray(_ref3, 3),\n      key = _ref4[0],\n      cnf = _ref4[1],\n      parentCnf = _ref4[2];\n    var parent;\n    if (parentCnf) {\n      if (parentCnf.type == \"!struct\" || parentCnf.type == \"!group\" && parentCnf.mode == \"struct\") parent = cnf.isSpelMap ? \"map\" : \"class\";else if (parentCnf.type == \"!group\") parent = cnf.isSpelItemMap ? \"[map]\" : \"[class]\";else parent = \"class\";\n    }\n    var isSpelVariable = cnf === null || cnf === void 0 ? void 0 : cnf.isSpelVariable;\n    return {\n      key: key,\n      parent: parent,\n      isSpelVariable: isSpelVariable\n    };\n  });\n  var formattedField = formatFieldFn(fieldName, parentField, fieldParts, fieldPartsMeta, fieldDefinition, config);\n  return formattedField;\n};\nvar formatFunc = function formatFunc(meta, config, currentValue) {\n  var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var funcKey = currentValue.get(\"func\");\n  var args = currentValue.get(\"args\");\n  var funcConfig = getFuncConfig(config, funcKey);\n  var funcName = funcConfig.spelFunc || funcKey;\n  var formattedArgs = {};\n  for (var argKey in funcConfig.args) {\n    var argConfig = funcConfig.args[argKey];\n    var fieldDef = getFieldConfig(config, argConfig);\n    var argVal = args ? args.get(argKey) : undefined;\n    var argValue = argVal ? argVal.get(\"value\") : undefined;\n    var argValueSrc = argVal ? argVal.get(\"valueSrc\") : undefined;\n    var argAsyncListValues = argVal ? argVal.get(\"asyncListValues\") : undefined;\n    var formattedArgVal = formatValue(meta, config, argValue, argValueSrc, argConfig.type, fieldDef, argConfig, null, null, parentField, argAsyncListValues);\n    if (argValue != undefined && formattedArgVal === undefined) {\n      meta.errors.push(\"Can't format value of arg \".concat(argKey, \" for func \").concat(funcKey));\n      return undefined;\n    }\n    if (formattedArgVal !== undefined) {\n      // skip optional in the end\n      formattedArgs[argKey] = formattedArgVal;\n    }\n  }\n  var ret;\n  if (typeof funcConfig.spelFormatFunc === \"function\") {\n    var fn = funcConfig.spelFormatFunc;\n    var _args = [formattedArgs];\n    ret = fn.apply(void 0, _args);\n  } else {\n    var _args2 = Object.entries(formattedArgs).map(function (_ref5) {\n      var _ref6 = _slicedToArray(_ref5, 2),\n        k = _ref6[0],\n        v = _ref6[1];\n      return v;\n    });\n    if (funcName[0] == \".\" && _args2.length) {\n      var _args3 = _toArray(_args2),\n        obj = _args3[0],\n        params = _args3.slice(1);\n      ret = \"\".concat(obj).concat(funcName, \"(\").concat(params.join(\", \"), \")\");\n    } else {\n      ret = \"\".concat(funcName, \"(\").concat(_args2.join(\", \"), \")\");\n    }\n  }\n  return ret;\n};"]},"metadata":{},"sourceType":"module"}