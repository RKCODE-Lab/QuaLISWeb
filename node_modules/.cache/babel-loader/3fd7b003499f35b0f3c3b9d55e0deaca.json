{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.removePathsInTree = exports.removeIsLockedInTree = exports.isEmptyTree = exports.hasChildren = exports.getTreeBadFields = exports.getTotalRulesCountInTree = exports.getTotalReordableNodesCountInTree = exports.getSwitchValues = exports.getLightTree = exports.getItemByPath = exports.getFlatTree = exports.fixPathsInTree = exports.fixEmptyGroupsInTree = exports.expandTreeSubpath = exports.expandTreePath = void 0;\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _immutable = _interopRequireDefault(require(\"immutable\"));\n/**\n * @param {Immutable.List} path\n * @param {...string} suffix\n * @return {Immutable.List}\n */\n\n\nvar expandTreePath = function expandTreePath(path) {\n  for (var _len = arguments.length, suffix = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    suffix[_key - 1] = arguments[_key];\n  }\n\n  return path.interpose(\"children1\").withMutations(function (list) {\n    list.skip(1);\n    list.push.apply(list, suffix);\n    return list;\n  });\n};\n/**\n * @param {Immutable.List} path\n * @param {...string} suffix\n * @return {Immutable.List}\n */\n\n\nexports.expandTreePath = expandTreePath;\n\nvar expandTreeSubpath = function expandTreeSubpath(path) {\n  for (var _len2 = arguments.length, suffix = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    suffix[_key2 - 1] = arguments[_key2];\n  }\n\n  return path.interpose(\"children1\").withMutations(function (list) {\n    list.push.apply(list, suffix);\n    return list;\n  });\n};\n/**\n * @param {Immutable.Map} path\n * @param {Immutable.List} path\n * @return {Immutable.Map}\n */\n\n\nexports.expandTreeSubpath = expandTreeSubpath;\n\nvar getItemByPath = function getItemByPath(tree, path) {\n  var children = new _immutable[\"default\"].OrderedMap((0, _defineProperty2[\"default\"])({}, tree.get(\"id\"), tree));\n  var res = tree;\n  path.forEach(function (id) {\n    res = children.get(id);\n    children = res.get(\"children1\");\n  });\n  return res;\n};\n/**\n * Remove `path` in every item\n * @param {Immutable.Map} tree\n * @return {Immutable.Map} tree\n */\n\n\nexports.getItemByPath = getItemByPath;\n\nvar removePathsInTree = function removePathsInTree(tree) {\n  var newTree = tree;\n\n  function _processNode(item, path) {\n    var itemPath = path.push(item.get(\"id\"));\n\n    if (item.get(\"path\")) {\n      newTree = newTree.removeIn(expandTreePath(itemPath, \"path\"));\n    }\n\n    var children = item.get(\"children1\");\n\n    if (children) {\n      children.map(function (child, _childId) {\n        _processNode(child, itemPath);\n      });\n    }\n  }\n\n  _processNode(tree, new _immutable[\"default\"].List());\n\n  return newTree;\n};\n/**\n * Remove `isLocked` in items that inherit parent's `isLocked`\n * @param {Immutable.Map} tree\n * @return {Immutable.Map} tree\n */\n\n\nexports.removePathsInTree = removePathsInTree;\n\nvar removeIsLockedInTree = function removeIsLockedInTree(tree) {\n  var newTree = tree;\n\n  function _processNode(item, path) {\n    var isParentLocked = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var itemPath = path.push(item.get(\"id\"));\n    var isLocked = item.getIn([\"properties\", \"isLocked\"]);\n\n    if (isParentLocked && isLocked) {\n      newTree = newTree.deleteIn(expandTreePath(itemPath, \"properties\", \"isLocked\"));\n    }\n\n    var children = item.get(\"children1\");\n\n    if (children) {\n      children.map(function (child, _childId) {\n        _processNode(child, itemPath, isLocked || isParentLocked);\n      });\n    }\n  }\n\n  _processNode(tree, new _immutable[\"default\"].List());\n\n  return newTree;\n};\n/**\n * Set correct `path` and `id` in every item\n * @param {Immutable.Map} tree\n * @return {Immutable.Map} tree\n */\n\n\nexports.removeIsLockedInTree = removeIsLockedInTree;\n\nvar fixPathsInTree = function fixPathsInTree(tree) {\n  var newTree = tree;\n\n  function _processNode(item, path, lev, nodeId) {\n    if (!item) return;\n    var currPath = item.get(\"path\");\n    var currId = item.get(\"id\");\n    var itemId = currId || nodeId;\n    var itemPath = path.push(itemId);\n\n    if (!currPath || !currPath.equals(itemPath)) {\n      newTree = newTree.setIn(expandTreePath(itemPath, \"path\"), itemPath);\n    }\n\n    if (!currId) {\n      newTree = newTree.setIn(expandTreePath(itemPath, \"id\"), itemId);\n    }\n\n    var children = item.get(\"children1\");\n\n    if (children) {\n      if (children.constructor.name == \"Map\") {\n        // protect: should me OrderedMap, not Map (issue #501)\n        newTree = newTree.setIn(expandTreePath(itemPath, \"children1\"), new _immutable[\"default\"].OrderedMap(children));\n      }\n\n      children.map(function (child, childId) {\n        _processNode(child, itemPath, lev + 1, childId);\n      });\n    }\n  }\n\n  _processNode(tree, new _immutable[\"default\"].List(), 0);\n\n  return newTree;\n};\n\nexports.fixPathsInTree = fixPathsInTree;\n\nvar fixEmptyGroupsInTree = function fixEmptyGroupsInTree(tree) {\n  var newTree = tree;\n\n  function _processNode(item, path, lev, nodeId) {\n    if (!item) return false;\n    var itemId = item.get(\"id\") || nodeId;\n    var itemPath = path.push(itemId);\n    var children = item.get(\"children1\");\n\n    if (children) {\n      var allChildrenGone = children.map(function (child, childId) {\n        return _processNode(child, itemPath, lev + 1, childId);\n      }).reduce(function (curr, v) {\n        return curr && v;\n      }, true);\n\n      if ((children.size == 0 || allChildrenGone) && lev > 0) {\n        newTree = newTree.deleteIn(expandTreePath(itemPath));\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  _processNode(tree, new _immutable[\"default\"].List(), 0);\n\n  return newTree;\n};\n/**\n * @param {Immutable.Map} tree\n * @return {Object} {flat, items}\n */\n\n\nexports.fixEmptyGroupsInTree = fixEmptyGroupsInTree;\n\nvar getFlatTree = function getFlatTree(tree) {\n  var flat = [];\n  var items = {};\n  var realHeight = 0;\n\n  function _flatizeTree(item, path, insideCollapsed, insideLocked, insideRuleGroup, lev, info, parentType, caseId) {\n    var type = item.get(\"type\");\n    var collapsed = item.get(\"collapsed\");\n    var id = item.get(\"id\");\n    var children = item.get(\"children1\");\n    var isLocked = item.getIn([\"properties\", \"isLocked\"]);\n    var childrenIds = children ? children.map(function (_child, childId) {\n      return childId;\n    }) : null;\n    var isRuleGroup = type == \"rule_group\"; // tip: count rule_group as 1 rule\n\n    var isLeaf = !insideRuleGroup && (!children || isRuleGroup);\n    var itemsBefore = flat.length;\n    var top = realHeight;\n    flat.push(id);\n    if (!insideCollapsed) realHeight += 1;\n    info.height = (info.height || 0) + 1;\n    items[id] = {\n      type: type,\n      parent: path.length ? path[path.length - 1] : null,\n      parentType: parentType,\n      caseId: type == \"case_group\" ? id : caseId,\n      isDefaultCase: type == \"case_group\" && !children,\n      path: path.concat(id),\n      lev: lev,\n      leaf: !children,\n      index: itemsBefore,\n      id: id,\n      children: childrenIds,\n      leafsCount: 0,\n      _top: itemsBefore,\n      _height: itemsAfter - itemsBefore,\n      top: insideCollapsed ? null : top,\n      height: height,\n      bottom: (insideCollapsed ? null : top) + height,\n      collapsed: collapsed,\n      node: item,\n      isLocked: isLocked || insideLocked\n    };\n\n    if (children) {\n      var subinfo = {};\n      children.map(function (child, _childId) {\n        _flatizeTree(child, path.concat(id), insideCollapsed || collapsed, insideLocked || isLocked, insideRuleGroup || isRuleGroup, lev + 1, subinfo, type, type == \"case_group\" ? id : caseId);\n      });\n\n      if (!collapsed) {\n        info.height = (info.height || 0) + (subinfo.height || 0);\n      }\n    }\n\n    if (caseId && isLeaf) {\n      items[caseId].leafsCount++;\n    }\n\n    var itemsAfter = flat.length;\n    var _bottom = realHeight;\n    var height = info.height;\n    Object.assign(items[id], {\n      _height: itemsAfter - itemsBefore,\n      height: height,\n      bottom: (insideCollapsed ? null : top) + height\n    });\n  }\n\n  _flatizeTree(tree, [], false, false, false, 0, {}, null, null);\n\n  for (var i = 0; i < flat.length; i++) {\n    var prevId = i > 0 ? flat[i - 1] : null;\n    var nextId = i < flat.length - 1 ? flat[i + 1] : null;\n    var item = items[flat[i]];\n    item.prev = prevId;\n    item.next = nextId;\n  }\n\n  return {\n    flat: flat,\n    items: items\n  };\n};\n/**\n * Returns count of reorderable(!) nodes\n * @param {Immutable.Map} tree\n * @return {Integer}\n */\n\n\nexports.getFlatTree = getFlatTree;\n\nvar getTotalReordableNodesCountInTree = function getTotalReordableNodesCountInTree(tree) {\n  if (!tree) return -1;\n  var cnt = 0;\n\n  function _processNode(item, path, lev) {\n    var id, children, type;\n\n    if (typeof item.get === \"function\") {\n      id = item.get(\"id\");\n      children = item.get(\"children1\");\n      type = item.get(\"type\");\n    } else {\n      id = item.id;\n      children = item.children1;\n      type = item.type;\n    }\n\n    var isRuleGroup = type == \"rule_group\";\n    cnt++; //tip: rules in rule-group can be reordered only inside\n\n    if (children && !isRuleGroup) {\n      children.map(function (child, _childId) {\n        _processNode(child, path.concat(id), lev + 1);\n      });\n    }\n  }\n\n  _processNode(tree, [], 0);\n\n  return cnt - 1; // -1 for root\n};\n/**\n * Returns count of rules (leafs, i.e. don't count groups)\n * @param {Immutable.Map} tree\n * @return {Integer}\n */\n\n\nexports.getTotalReordableNodesCountInTree = getTotalReordableNodesCountInTree;\n\nvar getTotalRulesCountInTree = function getTotalRulesCountInTree(tree) {\n  if (!tree) return -1;\n  var cnt = 0;\n\n  function _processNode(item, path, lev) {\n    var id, children, type;\n\n    if (typeof item.get === \"function\") {\n      id = item.get(\"id\");\n      children = item.get(\"children1\");\n      type = item.get(\"type\");\n    } else {\n      id = item.id;\n      children = item.children1;\n      type = item.type;\n    }\n\n    var isRuleGroup = type == \"rule_group\";\n\n    if (children && !isRuleGroup) {\n      children.map(function (child, _childId) {\n        _processNode(child, path.concat(id), lev + 1);\n      });\n    } else {\n      // tip: count rule_group as 1 rule\n      cnt++;\n    }\n  }\n\n  _processNode(tree, [], 0);\n\n  return cnt;\n};\n\nexports.getTotalRulesCountInTree = getTotalRulesCountInTree;\n\nvar getTreeBadFields = function getTreeBadFields(tree) {\n  var badFields = [];\n\n  function _processNode(item, path, lev) {\n    var id = item.get(\"id\");\n    var children = item.get(\"children1\");\n    var valueError = item.getIn([\"properties\", \"valueError\"]);\n    var field = item.getIn([\"properties\", \"field\"]);\n\n    if (valueError && valueError.size > 0 && valueError.filter(function (v) {\n      return v != null;\n    }).size > 0) {\n      badFields.push(field);\n    }\n\n    if (children) {\n      children.map(function (child, _childId) {\n        _processNode(child, path.concat(id), lev + 1);\n      });\n    }\n  }\n\n  if (tree) _processNode(tree, [], 0);\n  return Array.from(new Set(badFields));\n}; // Remove fields that can be calced: \"id\", \"path\"\n// Remove empty fields: \"operatorOptions\"\n\n\nexports.getTreeBadFields = getTreeBadFields;\n\nvar getLightTree = function getLightTree(tree) {\n  var newTree = tree;\n\n  function _processNode(item, itemId) {\n    if (item.path) delete item.path;\n    if (itemId) delete item.id;\n    var properties = item.properties;\n\n    if (properties) {\n      if (properties.operatorOptions == null) delete properties.operatorOptions;\n    }\n\n    var children = item.children1;\n\n    if (children) {\n      for (var id in children) {\n        _processNode(children[id], id);\n      }\n    }\n  }\n\n  _processNode(tree, null);\n\n  return newTree;\n};\n\nexports.getLightTree = getLightTree;\n\nvar getSwitchValues = function getSwitchValues(tree) {\n  var vals = [];\n  var children = tree.get(\"children1\");\n\n  if (children) {\n    children.map(function (child) {\n      var value = child.getIn([\"properties\", \"value\"]);\n      var caseValue;\n\n      if (value && value.size == 1) {\n        caseValue = value.get(0);\n\n        if (Array.isArray(caseValue) && caseValue.length == 0) {\n          caseValue = null;\n        }\n      } else {\n        caseValue = null;\n      }\n\n      vals = [].concat((0, _toConsumableArray2[\"default\"])(vals), [caseValue]);\n    });\n  }\n\n  return vals;\n};\n\nexports.getSwitchValues = getSwitchValues;\n\nvar isEmptyTree = function isEmptyTree(tree) {\n  return !tree.get(\"children1\") || tree.get(\"children1\").size == 0;\n};\n\nexports.isEmptyTree = isEmptyTree;\n\nvar hasChildren = function hasChildren(tree, path) {\n  return tree.getIn(expandTreePath(path, \"children1\")).size > 0;\n};\n\nexports.hasChildren = hasChildren;","map":{"version":3,"sources":["D:/LIMSWFH/LIMSPOSTGRESQL/QuaLISWeb/node_modules/react-awesome-query-builder/lib/utils/treeUtils.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","removePathsInTree","removeIsLockedInTree","isEmptyTree","hasChildren","getTreeBadFields","getTotalRulesCountInTree","getTotalReordableNodesCountInTree","getSwitchValues","getLightTree","getItemByPath","getFlatTree","fixPathsInTree","fixEmptyGroupsInTree","expandTreeSubpath","expandTreePath","_toConsumableArray2","_defineProperty2","_immutable","path","_len","arguments","length","suffix","Array","_key","interpose","withMutations","list","skip","push","apply","_len2","_key2","tree","children","OrderedMap","get","res","forEach","id","newTree","_processNode","item","itemPath","removeIn","map","child","_childId","List","isParentLocked","undefined","isLocked","getIn","deleteIn","lev","nodeId","currPath","currId","itemId","equals","setIn","constructor","name","childId","allChildrenGone","reduce","curr","v","size","flat","items","realHeight","_flatizeTree","insideCollapsed","insideLocked","insideRuleGroup","info","parentType","caseId","type","collapsed","childrenIds","_child","isRuleGroup","isLeaf","itemsBefore","top","height","parent","isDefaultCase","concat","leaf","index","leafsCount","_top","_height","itemsAfter","bottom","node","subinfo","_bottom","assign","i","prevId","nextId","prev","next","cnt","children1","badFields","valueError","field","filter","from","Set","properties","operatorOptions","vals","caseValue","isArray"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.removePathsInTree = exports.removeIsLockedInTree = exports.isEmptyTree = exports.hasChildren = exports.getTreeBadFields = exports.getTotalRulesCountInTree = exports.getTotalReordableNodesCountInTree = exports.getSwitchValues = exports.getLightTree = exports.getItemByPath = exports.getFlatTree = exports.fixPathsInTree = exports.fixEmptyGroupsInTree = exports.expandTreeSubpath = exports.expandTreePath = void 0;\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _immutable = _interopRequireDefault(require(\"immutable\"));\n\n/**\n * @param {Immutable.List} path\n * @param {...string} suffix\n * @return {Immutable.List}\n */\nvar expandTreePath = function expandTreePath(path) {\n  for (var _len = arguments.length, suffix = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    suffix[_key - 1] = arguments[_key];\n  }\n\n  return path.interpose(\"children1\").withMutations(function (list) {\n    list.skip(1);\n    list.push.apply(list, suffix);\n    return list;\n  });\n};\n/**\n * @param {Immutable.List} path\n * @param {...string} suffix\n * @return {Immutable.List}\n */\n\n\nexports.expandTreePath = expandTreePath;\n\nvar expandTreeSubpath = function expandTreeSubpath(path) {\n  for (var _len2 = arguments.length, suffix = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    suffix[_key2 - 1] = arguments[_key2];\n  }\n\n  return path.interpose(\"children1\").withMutations(function (list) {\n    list.push.apply(list, suffix);\n    return list;\n  });\n};\n/**\n * @param {Immutable.Map} path\n * @param {Immutable.List} path\n * @return {Immutable.Map}\n */\n\n\nexports.expandTreeSubpath = expandTreeSubpath;\n\nvar getItemByPath = function getItemByPath(tree, path) {\n  var children = new _immutable[\"default\"].OrderedMap((0, _defineProperty2[\"default\"])({}, tree.get(\"id\"), tree));\n  var res = tree;\n  path.forEach(function (id) {\n    res = children.get(id);\n    children = res.get(\"children1\");\n  });\n  return res;\n};\n/**\n * Remove `path` in every item\n * @param {Immutable.Map} tree\n * @return {Immutable.Map} tree\n */\n\n\nexports.getItemByPath = getItemByPath;\n\nvar removePathsInTree = function removePathsInTree(tree) {\n  var newTree = tree;\n\n  function _processNode(item, path) {\n    var itemPath = path.push(item.get(\"id\"));\n\n    if (item.get(\"path\")) {\n      newTree = newTree.removeIn(expandTreePath(itemPath, \"path\"));\n    }\n\n    var children = item.get(\"children1\");\n\n    if (children) {\n      children.map(function (child, _childId) {\n        _processNode(child, itemPath);\n      });\n    }\n  }\n\n  _processNode(tree, new _immutable[\"default\"].List());\n\n  return newTree;\n};\n/**\n * Remove `isLocked` in items that inherit parent's `isLocked`\n * @param {Immutable.Map} tree\n * @return {Immutable.Map} tree\n */\n\n\nexports.removePathsInTree = removePathsInTree;\n\nvar removeIsLockedInTree = function removeIsLockedInTree(tree) {\n  var newTree = tree;\n\n  function _processNode(item, path) {\n    var isParentLocked = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var itemPath = path.push(item.get(\"id\"));\n    var isLocked = item.getIn([\"properties\", \"isLocked\"]);\n\n    if (isParentLocked && isLocked) {\n      newTree = newTree.deleteIn(expandTreePath(itemPath, \"properties\", \"isLocked\"));\n    }\n\n    var children = item.get(\"children1\");\n\n    if (children) {\n      children.map(function (child, _childId) {\n        _processNode(child, itemPath, isLocked || isParentLocked);\n      });\n    }\n  }\n\n  _processNode(tree, new _immutable[\"default\"].List());\n\n  return newTree;\n};\n/**\n * Set correct `path` and `id` in every item\n * @param {Immutable.Map} tree\n * @return {Immutable.Map} tree\n */\n\n\nexports.removeIsLockedInTree = removeIsLockedInTree;\n\nvar fixPathsInTree = function fixPathsInTree(tree) {\n  var newTree = tree;\n\n  function _processNode(item, path, lev, nodeId) {\n    if (!item) return;\n    var currPath = item.get(\"path\");\n    var currId = item.get(\"id\");\n    var itemId = currId || nodeId;\n    var itemPath = path.push(itemId);\n\n    if (!currPath || !currPath.equals(itemPath)) {\n      newTree = newTree.setIn(expandTreePath(itemPath, \"path\"), itemPath);\n    }\n\n    if (!currId) {\n      newTree = newTree.setIn(expandTreePath(itemPath, \"id\"), itemId);\n    }\n\n    var children = item.get(\"children1\");\n\n    if (children) {\n      if (children.constructor.name == \"Map\") {\n        // protect: should me OrderedMap, not Map (issue #501)\n        newTree = newTree.setIn(expandTreePath(itemPath, \"children1\"), new _immutable[\"default\"].OrderedMap(children));\n      }\n\n      children.map(function (child, childId) {\n        _processNode(child, itemPath, lev + 1, childId);\n      });\n    }\n  }\n\n  _processNode(tree, new _immutable[\"default\"].List(), 0);\n\n  return newTree;\n};\n\nexports.fixPathsInTree = fixPathsInTree;\n\nvar fixEmptyGroupsInTree = function fixEmptyGroupsInTree(tree) {\n  var newTree = tree;\n\n  function _processNode(item, path, lev, nodeId) {\n    if (!item) return false;\n    var itemId = item.get(\"id\") || nodeId;\n    var itemPath = path.push(itemId);\n    var children = item.get(\"children1\");\n\n    if (children) {\n      var allChildrenGone = children.map(function (child, childId) {\n        return _processNode(child, itemPath, lev + 1, childId);\n      }).reduce(function (curr, v) {\n        return curr && v;\n      }, true);\n\n      if ((children.size == 0 || allChildrenGone) && lev > 0) {\n        newTree = newTree.deleteIn(expandTreePath(itemPath));\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  _processNode(tree, new _immutable[\"default\"].List(), 0);\n\n  return newTree;\n};\n/**\n * @param {Immutable.Map} tree\n * @return {Object} {flat, items}\n */\n\n\nexports.fixEmptyGroupsInTree = fixEmptyGroupsInTree;\n\nvar getFlatTree = function getFlatTree(tree) {\n  var flat = [];\n  var items = {};\n  var realHeight = 0;\n\n  function _flatizeTree(item, path, insideCollapsed, insideLocked, insideRuleGroup, lev, info, parentType, caseId) {\n    var type = item.get(\"type\");\n    var collapsed = item.get(\"collapsed\");\n    var id = item.get(\"id\");\n    var children = item.get(\"children1\");\n    var isLocked = item.getIn([\"properties\", \"isLocked\"]);\n    var childrenIds = children ? children.map(function (_child, childId) {\n      return childId;\n    }) : null;\n    var isRuleGroup = type == \"rule_group\"; // tip: count rule_group as 1 rule\n\n    var isLeaf = !insideRuleGroup && (!children || isRuleGroup);\n    var itemsBefore = flat.length;\n    var top = realHeight;\n    flat.push(id);\n    if (!insideCollapsed) realHeight += 1;\n    info.height = (info.height || 0) + 1;\n    items[id] = {\n      type: type,\n      parent: path.length ? path[path.length - 1] : null,\n      parentType: parentType,\n      caseId: type == \"case_group\" ? id : caseId,\n      isDefaultCase: type == \"case_group\" && !children,\n      path: path.concat(id),\n      lev: lev,\n      leaf: !children,\n      index: itemsBefore,\n      id: id,\n      children: childrenIds,\n      leafsCount: 0,\n      _top: itemsBefore,\n      _height: itemsAfter - itemsBefore,\n      top: insideCollapsed ? null : top,\n      height: height,\n      bottom: (insideCollapsed ? null : top) + height,\n      collapsed: collapsed,\n      node: item,\n      isLocked: isLocked || insideLocked\n    };\n\n    if (children) {\n      var subinfo = {};\n      children.map(function (child, _childId) {\n        _flatizeTree(child, path.concat(id), insideCollapsed || collapsed, insideLocked || isLocked, insideRuleGroup || isRuleGroup, lev + 1, subinfo, type, type == \"case_group\" ? id : caseId);\n      });\n\n      if (!collapsed) {\n        info.height = (info.height || 0) + (subinfo.height || 0);\n      }\n    }\n\n    if (caseId && isLeaf) {\n      items[caseId].leafsCount++;\n    }\n\n    var itemsAfter = flat.length;\n    var _bottom = realHeight;\n    var height = info.height;\n    Object.assign(items[id], {\n      _height: itemsAfter - itemsBefore,\n      height: height,\n      bottom: (insideCollapsed ? null : top) + height\n    });\n  }\n\n  _flatizeTree(tree, [], false, false, false, 0, {}, null, null);\n\n  for (var i = 0; i < flat.length; i++) {\n    var prevId = i > 0 ? flat[i - 1] : null;\n    var nextId = i < flat.length - 1 ? flat[i + 1] : null;\n    var item = items[flat[i]];\n    item.prev = prevId;\n    item.next = nextId;\n  }\n\n  return {\n    flat: flat,\n    items: items\n  };\n};\n/**\n * Returns count of reorderable(!) nodes\n * @param {Immutable.Map} tree\n * @return {Integer}\n */\n\n\nexports.getFlatTree = getFlatTree;\n\nvar getTotalReordableNodesCountInTree = function getTotalReordableNodesCountInTree(tree) {\n  if (!tree) return -1;\n  var cnt = 0;\n\n  function _processNode(item, path, lev) {\n    var id, children, type;\n\n    if (typeof item.get === \"function\") {\n      id = item.get(\"id\");\n      children = item.get(\"children1\");\n      type = item.get(\"type\");\n    } else {\n      id = item.id;\n      children = item.children1;\n      type = item.type;\n    }\n\n    var isRuleGroup = type == \"rule_group\";\n    cnt++; //tip: rules in rule-group can be reordered only inside\n\n    if (children && !isRuleGroup) {\n      children.map(function (child, _childId) {\n        _processNode(child, path.concat(id), lev + 1);\n      });\n    }\n  }\n\n  _processNode(tree, [], 0);\n\n  return cnt - 1; // -1 for root\n};\n/**\n * Returns count of rules (leafs, i.e. don't count groups)\n * @param {Immutable.Map} tree\n * @return {Integer}\n */\n\n\nexports.getTotalReordableNodesCountInTree = getTotalReordableNodesCountInTree;\n\nvar getTotalRulesCountInTree = function getTotalRulesCountInTree(tree) {\n  if (!tree) return -1;\n  var cnt = 0;\n\n  function _processNode(item, path, lev) {\n    var id, children, type;\n\n    if (typeof item.get === \"function\") {\n      id = item.get(\"id\");\n      children = item.get(\"children1\");\n      type = item.get(\"type\");\n    } else {\n      id = item.id;\n      children = item.children1;\n      type = item.type;\n    }\n\n    var isRuleGroup = type == \"rule_group\";\n\n    if (children && !isRuleGroup) {\n      children.map(function (child, _childId) {\n        _processNode(child, path.concat(id), lev + 1);\n      });\n    } else {\n      // tip: count rule_group as 1 rule\n      cnt++;\n    }\n  }\n\n  _processNode(tree, [], 0);\n\n  return cnt;\n};\n\nexports.getTotalRulesCountInTree = getTotalRulesCountInTree;\n\nvar getTreeBadFields = function getTreeBadFields(tree) {\n  var badFields = [];\n\n  function _processNode(item, path, lev) {\n    var id = item.get(\"id\");\n    var children = item.get(\"children1\");\n    var valueError = item.getIn([\"properties\", \"valueError\"]);\n    var field = item.getIn([\"properties\", \"field\"]);\n\n    if (valueError && valueError.size > 0 && valueError.filter(function (v) {\n      return v != null;\n    }).size > 0) {\n      badFields.push(field);\n    }\n\n    if (children) {\n      children.map(function (child, _childId) {\n        _processNode(child, path.concat(id), lev + 1);\n      });\n    }\n  }\n\n  if (tree) _processNode(tree, [], 0);\n  return Array.from(new Set(badFields));\n}; // Remove fields that can be calced: \"id\", \"path\"\n// Remove empty fields: \"operatorOptions\"\n\n\nexports.getTreeBadFields = getTreeBadFields;\n\nvar getLightTree = function getLightTree(tree) {\n  var newTree = tree;\n\n  function _processNode(item, itemId) {\n    if (item.path) delete item.path;\n    if (itemId) delete item.id;\n    var properties = item.properties;\n\n    if (properties) {\n      if (properties.operatorOptions == null) delete properties.operatorOptions;\n    }\n\n    var children = item.children1;\n\n    if (children) {\n      for (var id in children) {\n        _processNode(children[id], id);\n      }\n    }\n  }\n\n  _processNode(tree, null);\n\n  return newTree;\n};\n\nexports.getLightTree = getLightTree;\n\nvar getSwitchValues = function getSwitchValues(tree) {\n  var vals = [];\n  var children = tree.get(\"children1\");\n\n  if (children) {\n    children.map(function (child) {\n      var value = child.getIn([\"properties\", \"value\"]);\n      var caseValue;\n\n      if (value && value.size == 1) {\n        caseValue = value.get(0);\n\n        if (Array.isArray(caseValue) && caseValue.length == 0) {\n          caseValue = null;\n        }\n      } else {\n        caseValue = null;\n      }\n\n      vals = [].concat((0, _toConsumableArray2[\"default\"])(vals), [caseValue]);\n    });\n  }\n\n  return vals;\n};\n\nexports.getSwitchValues = getSwitchValues;\n\nvar isEmptyTree = function isEmptyTree(tree) {\n  return !tree.get(\"children1\") || tree.get(\"children1\").size == 0;\n};\n\nexports.isEmptyTree = isEmptyTree;\n\nvar hasChildren = function hasChildren(tree, path) {\n  return tree.getIn(expandTreePath(path, \"children1\")).size > 0;\n};\n\nexports.hasChildren = hasChildren;"]},"metadata":{},"sourceType":"script"}