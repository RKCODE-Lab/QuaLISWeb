{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport Immutable from \"immutable\";\n/**\n * @param {Immutable.List} path\n * @param {...string} suffix\n * @return {Immutable.List}\n */\n\nexport var expandTreePath = function expandTreePath(path) {\n  for (var _len = arguments.length, suffix = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    suffix[_key - 1] = arguments[_key];\n  }\n\n  return path.interpose(\"children1\").withMutations(function (list) {\n    list.skip(1);\n    list.push.apply(list, suffix);\n    return list;\n  });\n};\n/**\n * @param {Immutable.List} path\n * @param {...string} suffix\n * @return {Immutable.List}\n */\n\nexport var expandTreeSubpath = function expandTreeSubpath(path) {\n  for (var _len2 = arguments.length, suffix = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    suffix[_key2 - 1] = arguments[_key2];\n  }\n\n  return path.interpose(\"children1\").withMutations(function (list) {\n    list.push.apply(list, suffix);\n    return list;\n  });\n};\n/**\n * @param {Immutable.Map} path\n * @param {Immutable.List} path\n * @return {Immutable.Map}\n */\n\nexport var getItemByPath = function getItemByPath(tree, path) {\n  var children = new Immutable.OrderedMap(_defineProperty({}, tree.get(\"id\"), tree));\n  var res = tree;\n  path.forEach(function (id) {\n    res = children.get(id);\n    children = res.get(\"children1\");\n  });\n  return res;\n};\n/**\n * Remove `path` in every item\n * @param {Immutable.Map} tree\n * @return {Immutable.Map} tree\n */\n\nexport var removePathsInTree = function removePathsInTree(tree) {\n  var newTree = tree;\n\n  function _processNode(item, path) {\n    var itemPath = path.push(item.get(\"id\"));\n\n    if (item.get(\"path\")) {\n      newTree = newTree.removeIn(expandTreePath(itemPath, \"path\"));\n    }\n\n    var children = item.get(\"children1\");\n\n    if (children) {\n      children.map(function (child, _childId) {\n        _processNode(child, itemPath);\n      });\n    }\n  }\n\n  _processNode(tree, new Immutable.List());\n\n  return newTree;\n};\n/**\n * Remove `isLocked` in items that inherit parent's `isLocked`\n * @param {Immutable.Map} tree\n * @return {Immutable.Map} tree\n */\n\nexport var removeIsLockedInTree = function removeIsLockedInTree(tree) {\n  var newTree = tree;\n\n  function _processNode(item, path) {\n    var isParentLocked = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var itemPath = path.push(item.get(\"id\"));\n    var isLocked = item.getIn([\"properties\", \"isLocked\"]);\n\n    if (isParentLocked && isLocked) {\n      newTree = newTree.deleteIn(expandTreePath(itemPath, \"properties\", \"isLocked\"));\n    }\n\n    var children = item.get(\"children1\");\n\n    if (children) {\n      children.map(function (child, _childId) {\n        _processNode(child, itemPath, isLocked || isParentLocked);\n      });\n    }\n  }\n\n  _processNode(tree, new Immutable.List());\n\n  return newTree;\n};\n/**\n * Set correct `path` and `id` in every item\n * @param {Immutable.Map} tree\n * @return {Immutable.Map} tree\n */\n\nexport var fixPathsInTree = function fixPathsInTree(tree) {\n  var newTree = tree;\n\n  function _processNode(item, path, lev, nodeId) {\n    if (!item) return;\n    var currPath = item.get(\"path\");\n    var currId = item.get(\"id\");\n    var itemId = currId || nodeId;\n    var itemPath = path.push(itemId);\n\n    if (!currPath || !currPath.equals(itemPath)) {\n      newTree = newTree.setIn(expandTreePath(itemPath, \"path\"), itemPath);\n    }\n\n    if (!currId) {\n      newTree = newTree.setIn(expandTreePath(itemPath, \"id\"), itemId);\n    }\n\n    var children = item.get(\"children1\");\n\n    if (children) {\n      if (children.constructor.name == \"Map\") {\n        // protect: should me OrderedMap, not Map (issue #501)\n        newTree = newTree.setIn(expandTreePath(itemPath, \"children1\"), new Immutable.OrderedMap(children));\n      }\n\n      children.map(function (child, childId) {\n        _processNode(child, itemPath, lev + 1, childId);\n      });\n    }\n  }\n\n  _processNode(tree, new Immutable.List(), 0);\n\n  return newTree;\n};\nexport var fixEmptyGroupsInTree = function fixEmptyGroupsInTree(tree) {\n  var newTree = tree;\n\n  function _processNode(item, path, lev, nodeId) {\n    if (!item) return false;\n    var itemId = item.get(\"id\") || nodeId;\n    var itemPath = path.push(itemId);\n    var children = item.get(\"children1\");\n\n    if (children) {\n      var allChildrenGone = children.map(function (child, childId) {\n        return _processNode(child, itemPath, lev + 1, childId);\n      }).reduce(function (curr, v) {\n        return curr && v;\n      }, true);\n\n      if ((children.size == 0 || allChildrenGone) && lev > 0) {\n        newTree = newTree.deleteIn(expandTreePath(itemPath));\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  _processNode(tree, new Immutable.List(), 0);\n\n  return newTree;\n};\n/**\n * @param {Immutable.Map} tree\n * @return {Object} {flat, items}\n */\n\nexport var getFlatTree = function getFlatTree(tree) {\n  var flat = [];\n  var items = {};\n  var realHeight = 0;\n\n  function _flatizeTree(item, path, insideCollapsed, insideLocked, insideRuleGroup, lev, info, parentType, caseId) {\n    var type = item.get(\"type\");\n    var collapsed = item.get(\"collapsed\");\n    var id = item.get(\"id\");\n    var children = item.get(\"children1\");\n    var isLocked = item.getIn([\"properties\", \"isLocked\"]);\n    var childrenIds = children ? children.map(function (_child, childId) {\n      return childId;\n    }) : null;\n    var isRuleGroup = type == \"rule_group\"; // tip: count rule_group as 1 rule\n\n    var isLeaf = !insideRuleGroup && (!children || isRuleGroup);\n    var itemsBefore = flat.length;\n    var top = realHeight;\n    flat.push(id);\n    if (!insideCollapsed) realHeight += 1;\n    info.height = (info.height || 0) + 1;\n    items[id] = {\n      type: type,\n      parent: path.length ? path[path.length - 1] : null,\n      parentType: parentType,\n      caseId: type == \"case_group\" ? id : caseId,\n      isDefaultCase: type == \"case_group\" && !children,\n      path: path.concat(id),\n      lev: lev,\n      leaf: !children,\n      index: itemsBefore,\n      id: id,\n      children: childrenIds,\n      leafsCount: 0,\n      _top: itemsBefore,\n      //_height: (itemsAfter - itemsBefore),\n      top: insideCollapsed ? null : top,\n      //height: height,\n      //bottom: (insideCollapsed ? null : top) + height,\n      collapsed: collapsed,\n      node: item,\n      isLocked: isLocked || insideLocked\n    };\n\n    if (children) {\n      var subinfo = {};\n      children.map(function (child, _childId) {\n        _flatizeTree(child, path.concat(id), insideCollapsed || collapsed, insideLocked || isLocked, insideRuleGroup || isRuleGroup, lev + 1, subinfo, type, type == \"case_group\" ? id : caseId);\n      });\n\n      if (!collapsed) {\n        info.height = (info.height || 0) + (subinfo.height || 0);\n      }\n    }\n\n    if (caseId && isLeaf) {\n      items[caseId].leafsCount++;\n    }\n\n    var itemsAfter = flat.length;\n    var _bottom = realHeight;\n    var height = info.height;\n    Object.assign(items[id], {\n      _height: itemsAfter - itemsBefore,\n      height: height,\n      bottom: (insideCollapsed ? null : top) + height\n    });\n  }\n\n  _flatizeTree(tree, [], false, false, false, 0, {}, null, null);\n\n  for (var i = 0; i < flat.length; i++) {\n    var prevId = i > 0 ? flat[i - 1] : null;\n    var nextId = i < flat.length - 1 ? flat[i + 1] : null;\n    var item = items[flat[i]];\n    item.prev = prevId;\n    item.next = nextId;\n  }\n\n  return {\n    flat: flat,\n    items: items\n  };\n};\n/**\n * Returns count of reorderable(!) nodes\n * @param {Immutable.Map} tree\n * @return {Integer}\n */\n\nexport var getTotalReordableNodesCountInTree = function getTotalReordableNodesCountInTree(tree) {\n  if (!tree) return -1;\n  var cnt = 0;\n\n  function _processNode(item, path, lev) {\n    var id, children, type;\n\n    if (typeof item.get === \"function\") {\n      id = item.get(\"id\");\n      children = item.get(\"children1\");\n      type = item.get(\"type\");\n    } else {\n      id = item.id;\n      children = item.children1;\n      type = item.type;\n    }\n\n    var isRuleGroup = type == \"rule_group\";\n    cnt++; //tip: rules in rule-group can be reordered only inside\n\n    if (children && !isRuleGroup) {\n      children.map(function (child, _childId) {\n        _processNode(child, path.concat(id), lev + 1);\n      });\n    }\n  }\n\n  _processNode(tree, [], 0);\n\n  return cnt - 1; // -1 for root\n};\n/**\n * Returns count of rules (leafs, i.e. don't count groups)\n * @param {Immutable.Map} tree\n * @return {Integer}\n */\n\nexport var getTotalRulesCountInTree = function getTotalRulesCountInTree(tree) {\n  if (!tree) return -1;\n  var cnt = 0;\n\n  function _processNode(item, path, lev) {\n    var id, children, type;\n\n    if (typeof item.get === \"function\") {\n      id = item.get(\"id\");\n      children = item.get(\"children1\");\n      type = item.get(\"type\");\n    } else {\n      id = item.id;\n      children = item.children1;\n      type = item.type;\n    }\n\n    if (type == \"rule\" || type == \"rule_group\") {\n      // tip: count rule_group as 1 rule\n      cnt++;\n    } else if (children) {\n      children.map(function (child, _childId) {\n        _processNode(child, path.concat(id), lev + 1);\n      });\n    }\n  }\n\n  _processNode(tree, [], 0);\n\n  return cnt;\n};\nexport var getTreeBadFields = function getTreeBadFields(tree) {\n  var badFields = [];\n\n  function _processNode(item, path, lev) {\n    var id = item.get(\"id\");\n    var children = item.get(\"children1\");\n    var valueError = item.getIn([\"properties\", \"valueError\"]);\n    var field = item.getIn([\"properties\", \"field\"]);\n\n    if (valueError && valueError.size > 0 && valueError.filter(function (v) {\n      return v != null;\n    }).size > 0) {\n      badFields.push(field);\n    }\n\n    if (children) {\n      children.map(function (child, _childId) {\n        _processNode(child, path.concat(id), lev + 1);\n      });\n    }\n  }\n\n  if (tree) _processNode(tree, [], 0);\n  return Array.from(new Set(badFields));\n}; // Remove fields that can be calced: \"id\", \"path\"\n// Remove empty fields: \"operatorOptions\"\n\nexport var getLightTree = function getLightTree(tree) {\n  var children1AsArray = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var newTree = tree;\n\n  function _processNode(item, itemId) {\n    if (item.path) delete item.path;\n    if (!children1AsArray && itemId) delete item.id;\n    var properties = item.properties;\n\n    if (properties) {\n      if (properties.operatorOptions == null) delete properties.operatorOptions;\n    }\n\n    var children = item.children1;\n\n    if (children) {\n      for (var id in children) {\n        _processNode(children[id], id);\n      }\n\n      if (children1AsArray) {\n        item.children1 = Object.values(children);\n      }\n    }\n  }\n\n  _processNode(tree, null);\n\n  return newTree;\n};\nexport var getSwitchValues = function getSwitchValues(tree) {\n  var vals = [];\n  var children = tree.get(\"children1\");\n\n  if (children) {\n    children.map(function (child) {\n      var value = child.getIn([\"properties\", \"value\"]);\n      var caseValue;\n\n      if (value && value.size == 1) {\n        caseValue = value.get(0);\n\n        if (Array.isArray(caseValue) && caseValue.length == 0) {\n          caseValue = null;\n        }\n      } else {\n        caseValue = null;\n      }\n\n      vals = [].concat(_toConsumableArray(vals), [caseValue]);\n    });\n  }\n\n  return vals;\n};\nexport var isEmptyTree = function isEmptyTree(tree) {\n  return !tree.get(\"children1\") || tree.get(\"children1\").size == 0;\n};\nexport var hasChildren = function hasChildren(tree, path) {\n  return tree.getIn(expandTreePath(path, \"children1\")).size > 0;\n};","map":{"version":3,"sources":["E:/WorkingFolder/React_Postgres/ALPD/SOURCE-512/QuaLISWeb/node_modules/@react-awesome-query-builder/core/esm/utils/treeUtils.js"],"names":["_toConsumableArray","_defineProperty","Immutable","expandTreePath","path","_len","arguments","length","suffix","Array","_key","interpose","withMutations","list","skip","push","apply","expandTreeSubpath","_len2","_key2","getItemByPath","tree","children","OrderedMap","get","res","forEach","id","removePathsInTree","newTree","_processNode","item","itemPath","removeIn","map","child","_childId","List","removeIsLockedInTree","isParentLocked","undefined","isLocked","getIn","deleteIn","fixPathsInTree","lev","nodeId","currPath","currId","itemId","equals","setIn","constructor","name","childId","fixEmptyGroupsInTree","allChildrenGone","reduce","curr","v","size","getFlatTree","flat","items","realHeight","_flatizeTree","insideCollapsed","insideLocked","insideRuleGroup","info","parentType","caseId","type","collapsed","childrenIds","_child","isRuleGroup","isLeaf","itemsBefore","top","height","parent","isDefaultCase","concat","leaf","index","leafsCount","_top","node","subinfo","itemsAfter","_bottom","Object","assign","_height","bottom","i","prevId","nextId","prev","next","getTotalReordableNodesCountInTree","cnt","children1","getTotalRulesCountInTree","getTreeBadFields","badFields","valueError","field","filter","from","Set","getLightTree","children1AsArray","properties","operatorOptions","values","getSwitchValues","vals","value","caseValue","isArray","isEmptyTree","hasChildren"],"mappings":"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","sourcesContent":["import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport Immutable from \"immutable\";\n\n/**\n * @param {Immutable.List} path\n * @param {...string} suffix\n * @return {Immutable.List}\n */\nexport var expandTreePath = function expandTreePath(path) {\n  for (var _len = arguments.length, suffix = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    suffix[_key - 1] = arguments[_key];\n  }\n  return path.interpose(\"children1\").withMutations(function (list) {\n    list.skip(1);\n    list.push.apply(list, suffix);\n    return list;\n  });\n};\n\n/**\n * @param {Immutable.List} path\n * @param {...string} suffix\n * @return {Immutable.List}\n */\nexport var expandTreeSubpath = function expandTreeSubpath(path) {\n  for (var _len2 = arguments.length, suffix = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    suffix[_key2 - 1] = arguments[_key2];\n  }\n  return path.interpose(\"children1\").withMutations(function (list) {\n    list.push.apply(list, suffix);\n    return list;\n  });\n};\n\n/**\n * @param {Immutable.Map} path\n * @param {Immutable.List} path\n * @return {Immutable.Map}\n */\nexport var getItemByPath = function getItemByPath(tree, path) {\n  var children = new Immutable.OrderedMap(_defineProperty({}, tree.get(\"id\"), tree));\n  var res = tree;\n  path.forEach(function (id) {\n    res = children.get(id);\n    children = res.get(\"children1\");\n  });\n  return res;\n};\n\n/**\n * Remove `path` in every item\n * @param {Immutable.Map} tree\n * @return {Immutable.Map} tree\n */\nexport var removePathsInTree = function removePathsInTree(tree) {\n  var newTree = tree;\n  function _processNode(item, path) {\n    var itemPath = path.push(item.get(\"id\"));\n    if (item.get(\"path\")) {\n      newTree = newTree.removeIn(expandTreePath(itemPath, \"path\"));\n    }\n    var children = item.get(\"children1\");\n    if (children) {\n      children.map(function (child, _childId) {\n        _processNode(child, itemPath);\n      });\n    }\n  }\n  _processNode(tree, new Immutable.List());\n  return newTree;\n};\n\n/**\n * Remove `isLocked` in items that inherit parent's `isLocked`\n * @param {Immutable.Map} tree\n * @return {Immutable.Map} tree\n */\nexport var removeIsLockedInTree = function removeIsLockedInTree(tree) {\n  var newTree = tree;\n  function _processNode(item, path) {\n    var isParentLocked = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var itemPath = path.push(item.get(\"id\"));\n    var isLocked = item.getIn([\"properties\", \"isLocked\"]);\n    if (isParentLocked && isLocked) {\n      newTree = newTree.deleteIn(expandTreePath(itemPath, \"properties\", \"isLocked\"));\n    }\n    var children = item.get(\"children1\");\n    if (children) {\n      children.map(function (child, _childId) {\n        _processNode(child, itemPath, isLocked || isParentLocked);\n      });\n    }\n  }\n  _processNode(tree, new Immutable.List());\n  return newTree;\n};\n\n/**\n * Set correct `path` and `id` in every item\n * @param {Immutable.Map} tree\n * @return {Immutable.Map} tree\n */\nexport var fixPathsInTree = function fixPathsInTree(tree) {\n  var newTree = tree;\n  function _processNode(item, path, lev, nodeId) {\n    if (!item) return;\n    var currPath = item.get(\"path\");\n    var currId = item.get(\"id\");\n    var itemId = currId || nodeId;\n    var itemPath = path.push(itemId);\n    if (!currPath || !currPath.equals(itemPath)) {\n      newTree = newTree.setIn(expandTreePath(itemPath, \"path\"), itemPath);\n    }\n    if (!currId) {\n      newTree = newTree.setIn(expandTreePath(itemPath, \"id\"), itemId);\n    }\n    var children = item.get(\"children1\");\n    if (children) {\n      if (children.constructor.name == \"Map\") {\n        // protect: should me OrderedMap, not Map (issue #501)\n        newTree = newTree.setIn(expandTreePath(itemPath, \"children1\"), new Immutable.OrderedMap(children));\n      }\n      children.map(function (child, childId) {\n        _processNode(child, itemPath, lev + 1, childId);\n      });\n    }\n  }\n  _processNode(tree, new Immutable.List(), 0);\n  return newTree;\n};\nexport var fixEmptyGroupsInTree = function fixEmptyGroupsInTree(tree) {\n  var newTree = tree;\n  function _processNode(item, path, lev, nodeId) {\n    if (!item) return false;\n    var itemId = item.get(\"id\") || nodeId;\n    var itemPath = path.push(itemId);\n    var children = item.get(\"children1\");\n    if (children) {\n      var allChildrenGone = children.map(function (child, childId) {\n        return _processNode(child, itemPath, lev + 1, childId);\n      }).reduce(function (curr, v) {\n        return curr && v;\n      }, true);\n      if ((children.size == 0 || allChildrenGone) && lev > 0) {\n        newTree = newTree.deleteIn(expandTreePath(itemPath));\n        return true;\n      }\n    }\n    return false;\n  }\n  _processNode(tree, new Immutable.List(), 0);\n  return newTree;\n};\n\n/**\n * @param {Immutable.Map} tree\n * @return {Object} {flat, items}\n */\nexport var getFlatTree = function getFlatTree(tree) {\n  var flat = [];\n  var items = {};\n  var realHeight = 0;\n  function _flatizeTree(item, path, insideCollapsed, insideLocked, insideRuleGroup, lev, info, parentType, caseId) {\n    var type = item.get(\"type\");\n    var collapsed = item.get(\"collapsed\");\n    var id = item.get(\"id\");\n    var children = item.get(\"children1\");\n    var isLocked = item.getIn([\"properties\", \"isLocked\"]);\n    var childrenIds = children ? children.map(function (_child, childId) {\n      return childId;\n    }) : null;\n    var isRuleGroup = type == \"rule_group\";\n    // tip: count rule_group as 1 rule\n    var isLeaf = !insideRuleGroup && (!children || isRuleGroup);\n    var itemsBefore = flat.length;\n    var top = realHeight;\n    flat.push(id);\n    if (!insideCollapsed) realHeight += 1;\n    info.height = (info.height || 0) + 1;\n    items[id] = {\n      type: type,\n      parent: path.length ? path[path.length - 1] : null,\n      parentType: parentType,\n      caseId: type == \"case_group\" ? id : caseId,\n      isDefaultCase: type == \"case_group\" && !children,\n      path: path.concat(id),\n      lev: lev,\n      leaf: !children,\n      index: itemsBefore,\n      id: id,\n      children: childrenIds,\n      leafsCount: 0,\n      _top: itemsBefore,\n      //_height: (itemsAfter - itemsBefore),\n      top: insideCollapsed ? null : top,\n      //height: height,\n      //bottom: (insideCollapsed ? null : top) + height,\n      collapsed: collapsed,\n      node: item,\n      isLocked: isLocked || insideLocked\n    };\n    if (children) {\n      var subinfo = {};\n      children.map(function (child, _childId) {\n        _flatizeTree(child, path.concat(id), insideCollapsed || collapsed, insideLocked || isLocked, insideRuleGroup || isRuleGroup, lev + 1, subinfo, type, type == \"case_group\" ? id : caseId);\n      });\n      if (!collapsed) {\n        info.height = (info.height || 0) + (subinfo.height || 0);\n      }\n    }\n    if (caseId && isLeaf) {\n      items[caseId].leafsCount++;\n    }\n    var itemsAfter = flat.length;\n    var _bottom = realHeight;\n    var height = info.height;\n    Object.assign(items[id], {\n      _height: itemsAfter - itemsBefore,\n      height: height,\n      bottom: (insideCollapsed ? null : top) + height\n    });\n  }\n  _flatizeTree(tree, [], false, false, false, 0, {}, null, null);\n  for (var i = 0; i < flat.length; i++) {\n    var prevId = i > 0 ? flat[i - 1] : null;\n    var nextId = i < flat.length - 1 ? flat[i + 1] : null;\n    var item = items[flat[i]];\n    item.prev = prevId;\n    item.next = nextId;\n  }\n  return {\n    flat: flat,\n    items: items\n  };\n};\n\n/**\n * Returns count of reorderable(!) nodes\n * @param {Immutable.Map} tree\n * @return {Integer}\n */\nexport var getTotalReordableNodesCountInTree = function getTotalReordableNodesCountInTree(tree) {\n  if (!tree) return -1;\n  var cnt = 0;\n  function _processNode(item, path, lev) {\n    var id, children, type;\n    if (typeof item.get === \"function\") {\n      id = item.get(\"id\");\n      children = item.get(\"children1\");\n      type = item.get(\"type\");\n    } else {\n      id = item.id;\n      children = item.children1;\n      type = item.type;\n    }\n    var isRuleGroup = type == \"rule_group\";\n    cnt++;\n    //tip: rules in rule-group can be reordered only inside\n    if (children && !isRuleGroup) {\n      children.map(function (child, _childId) {\n        _processNode(child, path.concat(id), lev + 1);\n      });\n    }\n  }\n  _processNode(tree, [], 0);\n  return cnt - 1; // -1 for root\n};\n\n/**\n * Returns count of rules (leafs, i.e. don't count groups)\n * @param {Immutable.Map} tree\n * @return {Integer}\n */\nexport var getTotalRulesCountInTree = function getTotalRulesCountInTree(tree) {\n  if (!tree) return -1;\n  var cnt = 0;\n  function _processNode(item, path, lev) {\n    var id, children, type;\n    if (typeof item.get === \"function\") {\n      id = item.get(\"id\");\n      children = item.get(\"children1\");\n      type = item.get(\"type\");\n    } else {\n      id = item.id;\n      children = item.children1;\n      type = item.type;\n    }\n    if (type == \"rule\" || type == \"rule_group\") {\n      // tip: count rule_group as 1 rule\n      cnt++;\n    } else if (children) {\n      children.map(function (child, _childId) {\n        _processNode(child, path.concat(id), lev + 1);\n      });\n    }\n  }\n  _processNode(tree, [], 0);\n  return cnt;\n};\nexport var getTreeBadFields = function getTreeBadFields(tree) {\n  var badFields = [];\n  function _processNode(item, path, lev) {\n    var id = item.get(\"id\");\n    var children = item.get(\"children1\");\n    var valueError = item.getIn([\"properties\", \"valueError\"]);\n    var field = item.getIn([\"properties\", \"field\"]);\n    if (valueError && valueError.size > 0 && valueError.filter(function (v) {\n      return v != null;\n    }).size > 0) {\n      badFields.push(field);\n    }\n    if (children) {\n      children.map(function (child, _childId) {\n        _processNode(child, path.concat(id), lev + 1);\n      });\n    }\n  }\n  if (tree) _processNode(tree, [], 0);\n  return Array.from(new Set(badFields));\n};\n\n// Remove fields that can be calced: \"id\", \"path\"\n// Remove empty fields: \"operatorOptions\"\nexport var getLightTree = function getLightTree(tree) {\n  var children1AsArray = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var newTree = tree;\n  function _processNode(item, itemId) {\n    if (item.path) delete item.path;\n    if (!children1AsArray && itemId) delete item.id;\n    var properties = item.properties;\n    if (properties) {\n      if (properties.operatorOptions == null) delete properties.operatorOptions;\n    }\n    var children = item.children1;\n    if (children) {\n      for (var id in children) {\n        _processNode(children[id], id);\n      }\n      if (children1AsArray) {\n        item.children1 = Object.values(children);\n      }\n    }\n  }\n  _processNode(tree, null);\n  return newTree;\n};\nexport var getSwitchValues = function getSwitchValues(tree) {\n  var vals = [];\n  var children = tree.get(\"children1\");\n  if (children) {\n    children.map(function (child) {\n      var value = child.getIn([\"properties\", \"value\"]);\n      var caseValue;\n      if (value && value.size == 1) {\n        caseValue = value.get(0);\n        if (Array.isArray(caseValue) && caseValue.length == 0) {\n          caseValue = null;\n        }\n      } else {\n        caseValue = null;\n      }\n      vals = [].concat(_toConsumableArray(vals), [caseValue]);\n    });\n  }\n  return vals;\n};\nexport var isEmptyTree = function isEmptyTree(tree) {\n  return !tree.get(\"children1\") || tree.get(\"children1\").size == 0;\n};\nexport var hasChildren = function hasChildren(tree, path) {\n  return tree.getIn(expandTreePath(path, \"children1\")).size > 0;\n};"]},"metadata":{},"sourceType":"module"}