{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.jsonLogicFormat = void 0;\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _toArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toArray\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _stuff = require(\"../utils/stuff\");\n\nvar _configUtils = require(\"../utils/configUtils\");\n\nvar _ruleUtils = require(\"../utils/ruleUtils\");\n\nvar _defaultUtils = require(\"../utils/defaultUtils\");\n\nvar _funcUtils = require(\"../utils/funcUtils\");\n\nvar _immutable = require(\"immutable\");\n\nvar _omit = _interopRequireDefault(require(\"lodash/omit\"));\n\nvar _pick = _interopRequireDefault(require(\"lodash/pick\"));\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      (0, _defineProperty2[\"default\"])(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n  if (!it) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n} // http://jsonlogic.com/\n\n\nvar jsonLogicFormat = function jsonLogicFormat(item, config) {\n  //meta is mutable\n  var meta = {\n    usedFields: [],\n    errors: []\n  };\n  var logic = formatItem(item, config, meta, true); // build empty data\n\n  var errors = meta.errors,\n      usedFields = meta.usedFields;\n  var fieldSeparator = config.settings.fieldSeparator;\n  var data = {};\n\n  var _iterator = _createForOfIteratorHelper(usedFields),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var ff = _step.value;\n      var def = (0, _configUtils.getFieldConfig)(config, ff) || {};\n      var parts = ff.split(fieldSeparator);\n      var tmp = data;\n\n      for (var i = 0; i < parts.length; i++) {\n        var p = parts[i];\n        var pdef = (0, _configUtils.getFieldConfig)(config, parts.slice(0, i + 1)) || {};\n\n        if (i != parts.length - 1) {\n          if (pdef.type == \"!group\" && pdef.mode != \"struct\") {\n            if (!tmp[p]) tmp[p] = [{}];\n            tmp = tmp[p][0];\n          } else {\n            if (!tmp[p]) tmp[p] = {};\n            tmp = tmp[p];\n          }\n        } else {\n          if (!tmp[p]) tmp[p] = null; // can use def.type for sample values\n        }\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return {\n    errors: errors,\n    logic: logic,\n    data: data\n  };\n};\n\nexports.jsonLogicFormat = jsonLogicFormat;\n\nvar formatItem = function formatItem(item, config, meta, isRoot) {\n  var parentField = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  if (!item) return undefined;\n  var type = item.get(\"type\");\n  var properties = item.get(\"properties\") || new _immutable.Map();\n  var isLocked = properties.get(\"isLocked\");\n  var lockedOp = config.settings.jsonLogic.lockedOp;\n  var ret;\n\n  if (type === \"group\" || type === \"rule_group\") {\n    ret = formatGroup(item, config, meta, isRoot, parentField);\n  } else if (type === \"rule\") {\n    ret = formatRule(item, config, meta, parentField);\n  }\n\n  if (isLocked && ret && lockedOp) {\n    ret = (0, _defineProperty2[\"default\"])({}, lockedOp, ret);\n  }\n\n  return ret;\n};\n\nvar formatGroup = function formatGroup(item, config, meta, isRoot) {\n  var parentField = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  var type = item.get(\"type\");\n  var properties = item.get(\"properties\") || new _immutable.Map();\n  var mode = properties.get(\"mode\");\n  var children = item.get(\"children1\");\n  var field = properties.get(\"field\");\n  if (!children) return undefined;\n  var conjunction = properties.get(\"conjunction\");\n  if (!conjunction) conjunction = (0, _defaultUtils.defaultConjunction)(config);\n  var conjunctionDefinition = config.conjunctions[conjunction];\n  var conj = conjunctionDefinition.jsonLogicConj || conjunction.toLowerCase();\n  var not = properties.get(\"not\");\n\n  if (conj != \"and\" && conj != \"or\") {\n    meta.errors.push(\"Conjunction \".concat(conj, \" is not supported\"));\n    return undefined;\n  }\n\n  var isRuleGroup = type === \"rule_group\" && !isRoot;\n  var groupField = isRuleGroup && mode != \"struct\" ? field : parentField;\n  var groupOperator = properties.get(\"operator\");\n  var groupOperatorDefinition = groupOperator && (0, _configUtils.getOperatorConfig)(config, groupOperator, field) || null;\n  var formattedValue = formatItemValue(config, properties, meta, groupOperator, parentField);\n  var isGroup0 = isRuleGroup && (!groupOperator || groupOperatorDefinition.cardinality == 0);\n  var list = children.map(function (currentChild) {\n    return formatItem(currentChild, config, meta, false, groupField);\n  }).filter(function (currentChild) {\n    return typeof currentChild !== \"undefined\";\n  });\n\n  if (isRuleGroup && mode != \"struct\" && !isGroup0) {\n    // \"count\" rule can have no \"having\" children, but should have number value\n    if (formattedValue == undefined) return undefined;\n  } else {\n    if (!list.size) return undefined;\n  }\n\n  var resultQuery = {};\n  if (list.size == 1 && !isRoot) resultQuery = list.first();else resultQuery[conj] = list.toList().toJS(); // revert\n\n  if (not) {\n    resultQuery = {\n      \"!\": resultQuery\n    };\n  } // rule_group (issue #246)\n\n\n  if (isRuleGroup && mode != \"struct\") {\n    var formattedField = formatField(meta, config, field, parentField);\n\n    if (isGroup0) {\n      // config.settings.groupOperators\n      var op = groupOperator || \"some\";\n      resultQuery = (0, _defineProperty2[\"default\"])({}, op, [formattedField, resultQuery]);\n    } else {\n      // there is rule for count\n      var filter = !list.size ? formattedField : {\n        \"filter\": [formattedField, resultQuery]\n      };\n      var count = {\n        \"reduce\": [filter, {\n          \"+\": [1, {\n            \"var\": \"accumulator\"\n          }]\n        }, 0]\n      };\n      resultQuery = formatLogic(config, properties, count, formattedValue, groupOperator);\n    }\n  }\n\n  return resultQuery;\n};\n\nvar formatRule = function formatRule(item, config, meta) {\n  var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var properties = item.get(\"properties\") || new _immutable.Map();\n  var field = properties.get(\"field\");\n  var operator = properties.get(\"operator\");\n  var operatorOptions = properties.get(\"operatorOptions\");\n  operatorOptions = operatorOptions ? operatorOptions.toJS() : null;\n  if (operatorOptions && !Object.keys(operatorOptions).length) operatorOptions = null;\n  if (field == null || operator == null) return undefined;\n  var fieldDefinition = (0, _configUtils.getFieldConfig)(config, field) || {};\n  var operatorDefinition = (0, _configUtils.getOperatorConfig)(config, operator, field) || {};\n  var reversedOp = operatorDefinition.reversedOp;\n  var revOperatorDefinition = (0, _configUtils.getOperatorConfig)(config, reversedOp, field) || {}; // check op\n\n  var isRev = false;\n\n  if (!operatorDefinition.jsonLogic && !revOperatorDefinition.jsonLogic) {\n    meta.errors.push(\"Operator \".concat(operator, \" is not supported\"));\n    return undefined;\n  }\n\n  if (!operatorDefinition.jsonLogic && revOperatorDefinition.jsonLogic) {\n    isRev = true;\n    var _ref = [reversedOp, operator];\n    operator = _ref[0];\n    reversedOp = _ref[1];\n    var _ref2 = [revOperatorDefinition, operatorDefinition];\n    operatorDefinition = _ref2[0];\n    revOperatorDefinition = _ref2[1];\n  }\n\n  var formattedValue = formatItemValue(config, properties, meta, operator, parentField);\n  if (formattedValue === undefined) return undefined;\n  var formattedField = formatField(meta, config, field, parentField);\n  return formatLogic(config, properties, formattedField, formattedValue, operator, operatorOptions, fieldDefinition, isRev);\n};\n\nvar formatItemValue = function formatItemValue(config, properties, meta, operator, parentField) {\n  var field = properties.get(\"field\");\n  var iValueSrc = properties.get(\"valueSrc\");\n  var iValueType = properties.get(\"valueType\");\n  var fieldDefinition = (0, _configUtils.getFieldConfig)(config, field) || {};\n  var operatorDefinition = (0, _configUtils.getOperatorConfig)(config, operator, field) || {};\n  var cardinality = (0, _stuff.defaultValue)(operatorDefinition.cardinality, 1);\n  var iValue = properties.get(\"value\");\n  var asyncListValues = properties.get(\"asyncListValues\");\n  if (iValue == undefined) return undefined;\n  var valueSrcs = [];\n  var valueTypes = [];\n  var oldUsedFields = meta.usedFields;\n  var fvalue = iValue.map(function (currentValue, ind) {\n    var valueSrc = iValueSrc ? iValueSrc.get(ind) : null;\n    var valueType = iValueType ? iValueType.get(ind) : null;\n    var cValue = (0, _funcUtils.completeValue)(currentValue, valueSrc, config);\n    var widget = (0, _ruleUtils.getWidgetForFieldOp)(config, field, operator, valueSrc);\n    var fieldWidgetDef = (0, _omit[\"default\"])((0, _configUtils.getFieldWidgetConfig)(config, field, operator, widget, valueSrc), [\"factory\"]);\n    var fv = formatValue(meta, config, cValue, valueSrc, valueType, fieldWidgetDef, fieldDefinition, operator, operatorDefinition, parentField, asyncListValues);\n\n    if (fv !== undefined) {\n      valueSrcs.push(valueSrc);\n      valueTypes.push(valueType);\n    }\n\n    return fv;\n  });\n  var hasUndefinedValues = fvalue.filter(function (v) {\n    return v === undefined;\n  }).size > 0;\n\n  if (fvalue.size < cardinality || hasUndefinedValues) {\n    meta.usedFields = oldUsedFields; // restore\n\n    return undefined;\n  }\n\n  return cardinality > 1 ? fvalue.toArray() : cardinality == 1 ? fvalue.first() : null;\n};\n\nvar formatValue = function formatValue(meta, config, currentValue, valueSrc, valueType, fieldWidgetDef, fieldDef, operator, operatorDef) {\n  var parentField = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : null;\n  var asyncListValues = arguments.length > 10 ? arguments[10] : undefined;\n  if (currentValue === undefined) return undefined;\n  var ret;\n\n  if (valueSrc == \"field\") {\n    ret = formatField(meta, config, currentValue, parentField);\n  } else if (valueSrc == \"func\") {\n    ret = formatFunc(meta, config, currentValue, parentField);\n  } else if (typeof fieldWidgetDef.jsonLogic === \"function\") {\n    var fn = fieldWidgetDef.jsonLogic;\n    var args = [currentValue, _objectSpread(_objectSpread({}, (0, _pick[\"default\"])(fieldDef, [\"fieldSettings\", \"listValues\"])), {}, {\n      asyncListValues: asyncListValues\n    }), //useful options: valueFormat for date/time\n    (0, _omit[\"default\"])(fieldWidgetDef, [\"formatValue\", \"mongoFormatValue\", \"sqlFormatValue\", \"jsonLogic\", \"elasticSearchFormatValue\", \"spelFormatValue\"])];\n\n    if (operator) {\n      args.push(operator);\n      args.push(operatorDef);\n    }\n\n    ret = fn.apply(void 0, args);\n  } else {\n    ret = currentValue;\n  }\n\n  return ret;\n};\n\nvar formatFunc = function formatFunc(meta, config, currentValue) {\n  var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var funcKey = currentValue.get(\"func\");\n  var args = currentValue.get(\"args\");\n  var funcConfig = (0, _configUtils.getFuncConfig)(config, funcKey);\n\n  if (!funcConfig.jsonLogic) {\n    meta.errors.push(\"Func \".concat(funcKey, \" is not supported\"));\n    return undefined;\n  }\n\n  var formattedArgs = {};\n\n  for (var argKey in funcConfig.args) {\n    var argConfig = funcConfig.args[argKey];\n    var fieldDef = (0, _configUtils.getFieldConfig)(config, argConfig);\n    var argVal = args ? args.get(argKey) : undefined;\n    var argValue = argVal ? argVal.get(\"value\") : undefined;\n    var argValueSrc = argVal ? argVal.get(\"valueSrc\") : undefined;\n    var formattedArgVal = formatValue(meta, config, argValue, argValueSrc, argConfig.type, fieldDef, argConfig, null, null, parentField);\n\n    if (argValue != undefined && formattedArgVal === undefined) {\n      meta.errors.push(\"Can't format value of arg \".concat(argKey, \" for func \").concat(funcKey));\n      return undefined;\n    }\n\n    if (formattedArgVal !== undefined) {\n      // skip optional in the end\n      formattedArgs[argKey] = formattedArgVal;\n    }\n  }\n\n  var formattedArgsArr = Object.values(formattedArgs);\n  var ret;\n\n  if (typeof funcConfig.jsonLogic === \"function\") {\n    var fn = funcConfig.jsonLogic;\n    var _args = [formattedArgs];\n    ret = fn.apply(void 0, _args);\n  } else {\n    var funcName = funcConfig.jsonLogic || funcKey;\n    var isMethod = !!funcConfig.jsonLogicIsMethod;\n\n    if (isMethod) {\n      var _formattedArgsArr = (0, _toArray2[\"default\"])(formattedArgsArr),\n          obj = _formattedArgsArr[0],\n          params = _formattedArgsArr.slice(1);\n\n      if (params.length) {\n        ret = {\n          \"method\": [obj, funcName, params]\n        };\n      } else {\n        ret = {\n          \"method\": [obj, funcName]\n        };\n      }\n    } else {\n      ret = (0, _defineProperty2[\"default\"])({}, funcName, formattedArgsArr);\n    }\n  }\n\n  return ret;\n};\n\nvar formatField = function formatField(meta, config, field) {\n  var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var _config$settings = config.settings,\n      fieldSeparator = _config$settings.fieldSeparator,\n      jsonLogic = _config$settings.jsonLogic;\n  var ret;\n\n  if (field) {\n    if (Array.isArray(field)) field = field.join(fieldSeparator);\n    var fieldDef = (0, _configUtils.getFieldConfig)(config, field) || {};\n    var fieldName = field;\n\n    if (fieldDef.fieldName) {\n      fieldName = fieldDef.fieldName;\n    }\n\n    if (parentField) {\n      var parentFieldDef = (0, _configUtils.getFieldConfig)(config, parentField) || {};\n      var parentFieldName = parentField;\n\n      if (parentFieldDef.fieldName) {\n        parentFieldName = parentFieldDef.fieldName;\n      }\n\n      if (fieldName.indexOf(parentFieldName + fieldSeparator) == 0) {\n        fieldName = fieldName.slice((parentFieldName + fieldSeparator).length);\n      } else {\n        meta.errors.push(\"Can't cut group \".concat(parentFieldName, \" from field \").concat(fieldName));\n      }\n    }\n\n    var varName = fieldDef.jsonLogicVar || (fieldDef.type == \"!group\" ? jsonLogic.groupVarKey : \"var\");\n    ret = (0, _defineProperty2[\"default\"])({}, varName, fieldName);\n    if (meta.usedFields.indexOf(field) == -1) meta.usedFields.push(field);\n  }\n\n  return ret;\n};\n\nvar buildFnToFormatOp = function buildFnToFormatOp(operator, operatorDefinition, formattedField, formattedValue) {\n  var formatteOp = operator;\n  var cardinality = (0, _stuff.defaultValue)(operatorDefinition.cardinality, 1);\n  var isReverseArgs = (0, _stuff.defaultValue)(operatorDefinition._jsonLogicIsRevArgs, false);\n  if (typeof operatorDefinition.jsonLogic == \"string\") formatteOp = operatorDefinition.jsonLogic;\n  var rangeOps = [\"<\", \"<=\", \">\", \">=\"];\n  var eqOps = [\"==\", \"!=\"];\n\n  var fn = function fn(field, op, val, opDef, opOpts) {\n    if (cardinality == 0 && eqOps.includes(formatteOp)) return (0, _defineProperty2[\"default\"])({}, formatteOp, [formattedField, null]);else if (cardinality == 0) return (0, _defineProperty2[\"default\"])({}, formatteOp, formattedField);else if (cardinality == 1 && isReverseArgs) return (0, _defineProperty2[\"default\"])({}, formatteOp, [formattedValue, formattedField]);else if (cardinality == 1) return (0, _defineProperty2[\"default\"])({}, formatteOp, [formattedField, formattedValue]);else if (cardinality == 2 && rangeOps.includes(formatteOp)) return (0, _defineProperty2[\"default\"])({}, formatteOp, [formattedValue[0], formattedField, formattedValue[1]]);else return (0, _defineProperty2[\"default\"])({}, formatteOp, [formattedField].concat((0, _toConsumableArray2[\"default\"])(formattedValue)));\n  };\n\n  return fn;\n};\n\nvar formatLogic = function formatLogic(config, properties, formattedField, formattedValue, operator) {\n  var operatorOptions = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n  var fieldDefinition = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n  var isRev = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;\n  var field = properties.get(\"field\");\n  var operatorDefinition = (0, _configUtils.getOperatorConfig)(config, operator, field) || {};\n  var fn = typeof operatorDefinition.jsonLogic == \"function\" ? operatorDefinition.jsonLogic : buildFnToFormatOp(operator, operatorDefinition, formattedField, formattedValue);\n  var args = [formattedField, operator, formattedValue, (0, _omit[\"default\"])(operatorDefinition, [\"formatOp\", \"mongoFormatOp\", \"sqlFormatOp\", \"jsonLogic\", \"spelFormatOp\"]), operatorOptions, fieldDefinition];\n  var ruleQuery = fn.apply(void 0, args);\n\n  if (isRev) {\n    ruleQuery = {\n      \"!\": ruleQuery\n    };\n  }\n\n  return ruleQuery;\n};","map":{"version":3,"sources":["D:/LIMSWFH/LIMSPOSTGRESQL/QuaLISWeb/node_modules/react-awesome-query-builder/lib/export/jsonLogic.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","jsonLogicFormat","_toConsumableArray2","_toArray2","_defineProperty2","_stuff","_configUtils","_ruleUtils","_defaultUtils","_funcUtils","_immutable","_omit","_pick","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","_createForOfIteratorHelper","o","allowArrayLike","it","Symbol","iterator","Array","isArray","_unsupportedIterableToArray","F","s","n","done","e","_e","f","TypeError","normalCompletion","didErr","err","call","step","next","_e2","minLen","_arrayLikeToArray","prototype","toString","slice","constructor","name","from","test","arr","len","arr2","item","config","meta","usedFields","errors","logic","formatItem","fieldSeparator","settings","data","_iterator","_step","ff","def","getFieldConfig","parts","split","tmp","p","pdef","type","mode","isRoot","parentField","undefined","get","properties","Map","isLocked","lockedOp","jsonLogic","ret","formatGroup","formatRule","children","field","conjunction","defaultConjunction","conjunctionDefinition","conjunctions","conj","jsonLogicConj","toLowerCase","not","concat","isRuleGroup","groupField","groupOperator","groupOperatorDefinition","getOperatorConfig","formattedValue","formatItemValue","isGroup0","cardinality","list","map","currentChild","size","resultQuery","first","toList","toJS","formattedField","formatField","op","count","formatLogic","operator","operatorOptions","fieldDefinition","operatorDefinition","reversedOp","revOperatorDefinition","isRev","_ref","_ref2","iValueSrc","iValueType","defaultValue","iValue","asyncListValues","valueSrcs","valueTypes","oldUsedFields","fvalue","currentValue","ind","valueSrc","valueType","cValue","completeValue","widget","getWidgetForFieldOp","fieldWidgetDef","getFieldWidgetConfig","fv","formatValue","hasUndefinedValues","v","toArray","fieldDef","operatorDef","formatFunc","fn","args","funcKey","funcConfig","getFuncConfig","formattedArgs","argKey","argConfig","argVal","argValue","argValueSrc","formattedArgVal","formattedArgsArr","values","_args","funcName","isMethod","jsonLogicIsMethod","_formattedArgsArr","obj","params","_config$settings","join","fieldName","parentFieldDef","parentFieldName","indexOf","varName","jsonLogicVar","groupVarKey","buildFnToFormatOp","formatteOp","isReverseArgs","_jsonLogicIsRevArgs","rangeOps","eqOps","val","opDef","opOpts","includes","ruleQuery"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.jsonLogicFormat = void 0;\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _toArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toArray\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _stuff = require(\"../utils/stuff\");\n\nvar _configUtils = require(\"../utils/configUtils\");\n\nvar _ruleUtils = require(\"../utils/ruleUtils\");\n\nvar _defaultUtils = require(\"../utils/defaultUtils\");\n\nvar _funcUtils = require(\"../utils/funcUtils\");\n\nvar _immutable = require(\"immutable\");\n\nvar _omit = _interopRequireDefault(require(\"lodash/omit\"));\n\nvar _pick = _interopRequireDefault(require(\"lodash/pick\"));\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2[\"default\"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n// http://jsonlogic.com/\nvar jsonLogicFormat = function jsonLogicFormat(item, config) {\n  //meta is mutable\n  var meta = {\n    usedFields: [],\n    errors: []\n  };\n  var logic = formatItem(item, config, meta, true); // build empty data\n\n  var errors = meta.errors,\n      usedFields = meta.usedFields;\n  var fieldSeparator = config.settings.fieldSeparator;\n  var data = {};\n\n  var _iterator = _createForOfIteratorHelper(usedFields),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var ff = _step.value;\n      var def = (0, _configUtils.getFieldConfig)(config, ff) || {};\n      var parts = ff.split(fieldSeparator);\n      var tmp = data;\n\n      for (var i = 0; i < parts.length; i++) {\n        var p = parts[i];\n        var pdef = (0, _configUtils.getFieldConfig)(config, parts.slice(0, i + 1)) || {};\n\n        if (i != parts.length - 1) {\n          if (pdef.type == \"!group\" && pdef.mode != \"struct\") {\n            if (!tmp[p]) tmp[p] = [{}];\n            tmp = tmp[p][0];\n          } else {\n            if (!tmp[p]) tmp[p] = {};\n            tmp = tmp[p];\n          }\n        } else {\n          if (!tmp[p]) tmp[p] = null; // can use def.type for sample values\n        }\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return {\n    errors: errors,\n    logic: logic,\n    data: data\n  };\n};\n\nexports.jsonLogicFormat = jsonLogicFormat;\n\nvar formatItem = function formatItem(item, config, meta, isRoot) {\n  var parentField = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  if (!item) return undefined;\n  var type = item.get(\"type\");\n  var properties = item.get(\"properties\") || new _immutable.Map();\n  var isLocked = properties.get(\"isLocked\");\n  var lockedOp = config.settings.jsonLogic.lockedOp;\n  var ret;\n\n  if (type === \"group\" || type === \"rule_group\") {\n    ret = formatGroup(item, config, meta, isRoot, parentField);\n  } else if (type === \"rule\") {\n    ret = formatRule(item, config, meta, parentField);\n  }\n\n  if (isLocked && ret && lockedOp) {\n    ret = (0, _defineProperty2[\"default\"])({}, lockedOp, ret);\n  }\n\n  return ret;\n};\n\nvar formatGroup = function formatGroup(item, config, meta, isRoot) {\n  var parentField = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  var type = item.get(\"type\");\n  var properties = item.get(\"properties\") || new _immutable.Map();\n  var mode = properties.get(\"mode\");\n  var children = item.get(\"children1\");\n  var field = properties.get(\"field\");\n  if (!children) return undefined;\n  var conjunction = properties.get(\"conjunction\");\n  if (!conjunction) conjunction = (0, _defaultUtils.defaultConjunction)(config);\n  var conjunctionDefinition = config.conjunctions[conjunction];\n  var conj = conjunctionDefinition.jsonLogicConj || conjunction.toLowerCase();\n  var not = properties.get(\"not\");\n\n  if (conj != \"and\" && conj != \"or\") {\n    meta.errors.push(\"Conjunction \".concat(conj, \" is not supported\"));\n    return undefined;\n  }\n\n  var isRuleGroup = type === \"rule_group\" && !isRoot;\n  var groupField = isRuleGroup && mode != \"struct\" ? field : parentField;\n  var groupOperator = properties.get(\"operator\");\n  var groupOperatorDefinition = groupOperator && (0, _configUtils.getOperatorConfig)(config, groupOperator, field) || null;\n  var formattedValue = formatItemValue(config, properties, meta, groupOperator, parentField);\n  var isGroup0 = isRuleGroup && (!groupOperator || groupOperatorDefinition.cardinality == 0);\n  var list = children.map(function (currentChild) {\n    return formatItem(currentChild, config, meta, false, groupField);\n  }).filter(function (currentChild) {\n    return typeof currentChild !== \"undefined\";\n  });\n\n  if (isRuleGroup && mode != \"struct\" && !isGroup0) {\n    // \"count\" rule can have no \"having\" children, but should have number value\n    if (formattedValue == undefined) return undefined;\n  } else {\n    if (!list.size) return undefined;\n  }\n\n  var resultQuery = {};\n  if (list.size == 1 && !isRoot) resultQuery = list.first();else resultQuery[conj] = list.toList().toJS(); // revert\n\n  if (not) {\n    resultQuery = {\n      \"!\": resultQuery\n    };\n  } // rule_group (issue #246)\n\n\n  if (isRuleGroup && mode != \"struct\") {\n    var formattedField = formatField(meta, config, field, parentField);\n\n    if (isGroup0) {\n      // config.settings.groupOperators\n      var op = groupOperator || \"some\";\n      resultQuery = (0, _defineProperty2[\"default\"])({}, op, [formattedField, resultQuery]);\n    } else {\n      // there is rule for count\n      var filter = !list.size ? formattedField : {\n        \"filter\": [formattedField, resultQuery]\n      };\n      var count = {\n        \"reduce\": [filter, {\n          \"+\": [1, {\n            \"var\": \"accumulator\"\n          }]\n        }, 0]\n      };\n      resultQuery = formatLogic(config, properties, count, formattedValue, groupOperator);\n    }\n  }\n\n  return resultQuery;\n};\n\nvar formatRule = function formatRule(item, config, meta) {\n  var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var properties = item.get(\"properties\") || new _immutable.Map();\n  var field = properties.get(\"field\");\n  var operator = properties.get(\"operator\");\n  var operatorOptions = properties.get(\"operatorOptions\");\n  operatorOptions = operatorOptions ? operatorOptions.toJS() : null;\n  if (operatorOptions && !Object.keys(operatorOptions).length) operatorOptions = null;\n  if (field == null || operator == null) return undefined;\n  var fieldDefinition = (0, _configUtils.getFieldConfig)(config, field) || {};\n  var operatorDefinition = (0, _configUtils.getOperatorConfig)(config, operator, field) || {};\n  var reversedOp = operatorDefinition.reversedOp;\n  var revOperatorDefinition = (0, _configUtils.getOperatorConfig)(config, reversedOp, field) || {}; // check op\n\n  var isRev = false;\n\n  if (!operatorDefinition.jsonLogic && !revOperatorDefinition.jsonLogic) {\n    meta.errors.push(\"Operator \".concat(operator, \" is not supported\"));\n    return undefined;\n  }\n\n  if (!operatorDefinition.jsonLogic && revOperatorDefinition.jsonLogic) {\n    isRev = true;\n    var _ref = [reversedOp, operator];\n    operator = _ref[0];\n    reversedOp = _ref[1];\n    var _ref2 = [revOperatorDefinition, operatorDefinition];\n    operatorDefinition = _ref2[0];\n    revOperatorDefinition = _ref2[1];\n  }\n\n  var formattedValue = formatItemValue(config, properties, meta, operator, parentField);\n  if (formattedValue === undefined) return undefined;\n  var formattedField = formatField(meta, config, field, parentField);\n  return formatLogic(config, properties, formattedField, formattedValue, operator, operatorOptions, fieldDefinition, isRev);\n};\n\nvar formatItemValue = function formatItemValue(config, properties, meta, operator, parentField) {\n  var field = properties.get(\"field\");\n  var iValueSrc = properties.get(\"valueSrc\");\n  var iValueType = properties.get(\"valueType\");\n  var fieldDefinition = (0, _configUtils.getFieldConfig)(config, field) || {};\n  var operatorDefinition = (0, _configUtils.getOperatorConfig)(config, operator, field) || {};\n  var cardinality = (0, _stuff.defaultValue)(operatorDefinition.cardinality, 1);\n  var iValue = properties.get(\"value\");\n  var asyncListValues = properties.get(\"asyncListValues\");\n  if (iValue == undefined) return undefined;\n  var valueSrcs = [];\n  var valueTypes = [];\n  var oldUsedFields = meta.usedFields;\n  var fvalue = iValue.map(function (currentValue, ind) {\n    var valueSrc = iValueSrc ? iValueSrc.get(ind) : null;\n    var valueType = iValueType ? iValueType.get(ind) : null;\n    var cValue = (0, _funcUtils.completeValue)(currentValue, valueSrc, config);\n    var widget = (0, _ruleUtils.getWidgetForFieldOp)(config, field, operator, valueSrc);\n    var fieldWidgetDef = (0, _omit[\"default\"])((0, _configUtils.getFieldWidgetConfig)(config, field, operator, widget, valueSrc), [\"factory\"]);\n    var fv = formatValue(meta, config, cValue, valueSrc, valueType, fieldWidgetDef, fieldDefinition, operator, operatorDefinition, parentField, asyncListValues);\n\n    if (fv !== undefined) {\n      valueSrcs.push(valueSrc);\n      valueTypes.push(valueType);\n    }\n\n    return fv;\n  });\n  var hasUndefinedValues = fvalue.filter(function (v) {\n    return v === undefined;\n  }).size > 0;\n\n  if (fvalue.size < cardinality || hasUndefinedValues) {\n    meta.usedFields = oldUsedFields; // restore\n\n    return undefined;\n  }\n\n  return cardinality > 1 ? fvalue.toArray() : cardinality == 1 ? fvalue.first() : null;\n};\n\nvar formatValue = function formatValue(meta, config, currentValue, valueSrc, valueType, fieldWidgetDef, fieldDef, operator, operatorDef) {\n  var parentField = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : null;\n  var asyncListValues = arguments.length > 10 ? arguments[10] : undefined;\n  if (currentValue === undefined) return undefined;\n  var ret;\n\n  if (valueSrc == \"field\") {\n    ret = formatField(meta, config, currentValue, parentField);\n  } else if (valueSrc == \"func\") {\n    ret = formatFunc(meta, config, currentValue, parentField);\n  } else if (typeof fieldWidgetDef.jsonLogic === \"function\") {\n    var fn = fieldWidgetDef.jsonLogic;\n    var args = [currentValue, _objectSpread(_objectSpread({}, (0, _pick[\"default\"])(fieldDef, [\"fieldSettings\", \"listValues\"])), {}, {\n      asyncListValues: asyncListValues\n    }), //useful options: valueFormat for date/time\n    (0, _omit[\"default\"])(fieldWidgetDef, [\"formatValue\", \"mongoFormatValue\", \"sqlFormatValue\", \"jsonLogic\", \"elasticSearchFormatValue\", \"spelFormatValue\"])];\n\n    if (operator) {\n      args.push(operator);\n      args.push(operatorDef);\n    }\n\n    ret = fn.apply(void 0, args);\n  } else {\n    ret = currentValue;\n  }\n\n  return ret;\n};\n\nvar formatFunc = function formatFunc(meta, config, currentValue) {\n  var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var funcKey = currentValue.get(\"func\");\n  var args = currentValue.get(\"args\");\n  var funcConfig = (0, _configUtils.getFuncConfig)(config, funcKey);\n\n  if (!funcConfig.jsonLogic) {\n    meta.errors.push(\"Func \".concat(funcKey, \" is not supported\"));\n    return undefined;\n  }\n\n  var formattedArgs = {};\n\n  for (var argKey in funcConfig.args) {\n    var argConfig = funcConfig.args[argKey];\n    var fieldDef = (0, _configUtils.getFieldConfig)(config, argConfig);\n    var argVal = args ? args.get(argKey) : undefined;\n    var argValue = argVal ? argVal.get(\"value\") : undefined;\n    var argValueSrc = argVal ? argVal.get(\"valueSrc\") : undefined;\n    var formattedArgVal = formatValue(meta, config, argValue, argValueSrc, argConfig.type, fieldDef, argConfig, null, null, parentField);\n\n    if (argValue != undefined && formattedArgVal === undefined) {\n      meta.errors.push(\"Can't format value of arg \".concat(argKey, \" for func \").concat(funcKey));\n      return undefined;\n    }\n\n    if (formattedArgVal !== undefined) {\n      // skip optional in the end\n      formattedArgs[argKey] = formattedArgVal;\n    }\n  }\n\n  var formattedArgsArr = Object.values(formattedArgs);\n  var ret;\n\n  if (typeof funcConfig.jsonLogic === \"function\") {\n    var fn = funcConfig.jsonLogic;\n    var _args = [formattedArgs];\n    ret = fn.apply(void 0, _args);\n  } else {\n    var funcName = funcConfig.jsonLogic || funcKey;\n    var isMethod = !!funcConfig.jsonLogicIsMethod;\n\n    if (isMethod) {\n      var _formattedArgsArr = (0, _toArray2[\"default\"])(formattedArgsArr),\n          obj = _formattedArgsArr[0],\n          params = _formattedArgsArr.slice(1);\n\n      if (params.length) {\n        ret = {\n          \"method\": [obj, funcName, params]\n        };\n      } else {\n        ret = {\n          \"method\": [obj, funcName]\n        };\n      }\n    } else {\n      ret = (0, _defineProperty2[\"default\"])({}, funcName, formattedArgsArr);\n    }\n  }\n\n  return ret;\n};\n\nvar formatField = function formatField(meta, config, field) {\n  var parentField = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var _config$settings = config.settings,\n      fieldSeparator = _config$settings.fieldSeparator,\n      jsonLogic = _config$settings.jsonLogic;\n  var ret;\n\n  if (field) {\n    if (Array.isArray(field)) field = field.join(fieldSeparator);\n    var fieldDef = (0, _configUtils.getFieldConfig)(config, field) || {};\n    var fieldName = field;\n\n    if (fieldDef.fieldName) {\n      fieldName = fieldDef.fieldName;\n    }\n\n    if (parentField) {\n      var parentFieldDef = (0, _configUtils.getFieldConfig)(config, parentField) || {};\n      var parentFieldName = parentField;\n\n      if (parentFieldDef.fieldName) {\n        parentFieldName = parentFieldDef.fieldName;\n      }\n\n      if (fieldName.indexOf(parentFieldName + fieldSeparator) == 0) {\n        fieldName = fieldName.slice((parentFieldName + fieldSeparator).length);\n      } else {\n        meta.errors.push(\"Can't cut group \".concat(parentFieldName, \" from field \").concat(fieldName));\n      }\n    }\n\n    var varName = fieldDef.jsonLogicVar || (fieldDef.type == \"!group\" ? jsonLogic.groupVarKey : \"var\");\n    ret = (0, _defineProperty2[\"default\"])({}, varName, fieldName);\n    if (meta.usedFields.indexOf(field) == -1) meta.usedFields.push(field);\n  }\n\n  return ret;\n};\n\nvar buildFnToFormatOp = function buildFnToFormatOp(operator, operatorDefinition, formattedField, formattedValue) {\n  var formatteOp = operator;\n  var cardinality = (0, _stuff.defaultValue)(operatorDefinition.cardinality, 1);\n  var isReverseArgs = (0, _stuff.defaultValue)(operatorDefinition._jsonLogicIsRevArgs, false);\n  if (typeof operatorDefinition.jsonLogic == \"string\") formatteOp = operatorDefinition.jsonLogic;\n  var rangeOps = [\"<\", \"<=\", \">\", \">=\"];\n  var eqOps = [\"==\", \"!=\"];\n\n  var fn = function fn(field, op, val, opDef, opOpts) {\n    if (cardinality == 0 && eqOps.includes(formatteOp)) return (0, _defineProperty2[\"default\"])({}, formatteOp, [formattedField, null]);else if (cardinality == 0) return (0, _defineProperty2[\"default\"])({}, formatteOp, formattedField);else if (cardinality == 1 && isReverseArgs) return (0, _defineProperty2[\"default\"])({}, formatteOp, [formattedValue, formattedField]);else if (cardinality == 1) return (0, _defineProperty2[\"default\"])({}, formatteOp, [formattedField, formattedValue]);else if (cardinality == 2 && rangeOps.includes(formatteOp)) return (0, _defineProperty2[\"default\"])({}, formatteOp, [formattedValue[0], formattedField, formattedValue[1]]);else return (0, _defineProperty2[\"default\"])({}, formatteOp, [formattedField].concat((0, _toConsumableArray2[\"default\"])(formattedValue)));\n  };\n\n  return fn;\n};\n\nvar formatLogic = function formatLogic(config, properties, formattedField, formattedValue, operator) {\n  var operatorOptions = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n  var fieldDefinition = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n  var isRev = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;\n  var field = properties.get(\"field\");\n  var operatorDefinition = (0, _configUtils.getOperatorConfig)(config, operator, field) || {};\n  var fn = typeof operatorDefinition.jsonLogic == \"function\" ? operatorDefinition.jsonLogic : buildFnToFormatOp(operator, operatorDefinition, formattedField, formattedValue);\n  var args = [formattedField, operator, formattedValue, (0, _omit[\"default\"])(operatorDefinition, [\"formatOp\", \"mongoFormatOp\", \"sqlFormatOp\", \"jsonLogic\", \"spelFormatOp\"]), operatorOptions, fieldDefinition];\n  var ruleQuery = fn.apply(void 0, args);\n\n  if (isRev) {\n    ruleQuery = {\n      \"!\": ruleQuery\n    };\n  }\n\n  return ruleQuery;\n};"]},"metadata":{},"sourceType":"script"}