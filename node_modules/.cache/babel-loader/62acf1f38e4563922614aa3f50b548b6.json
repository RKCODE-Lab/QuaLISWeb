{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.mongodbFormat = void 0;\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nvar _stuff = require(\"../utils/stuff\");\n\nvar _configUtils = require(\"../utils/configUtils\");\n\nvar _ruleUtils = require(\"../utils/ruleUtils\");\n\nvar _defaultUtils = require(\"../utils/defaultUtils\");\n\nvar _funcUtils = require(\"../utils/funcUtils\");\n\nvar _omit = _interopRequireDefault(require(\"lodash/omit\"));\n\nvar _pick = _interopRequireDefault(require(\"lodash/pick\"));\n\nvar _immutable = require(\"immutable\");\n\nvar _default = require(\"../config/default\");\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      (0, _defineProperty2[\"default\"])(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n} // helpers\n\n\nvar isObject = function isObject(v) {\n  return (0, _typeof2[\"default\"])(v) == \"object\" && v !== null && !Array.isArray(v);\n};\n\nvar mongodbFormat = function mongodbFormat(tree, config) {\n  //meta is mutable\n  var meta = {\n    errors: []\n  };\n  var res = formatItem([], tree, config, meta);\n  if (meta.errors.length) console.warn(\"Errors while exporting to MongoDb:\", meta.errors);\n  return res;\n};\n\nexports.mongodbFormat = mongodbFormat;\n\nvar formatItem = function formatItem(parents, item, config, meta) {\n  var _not = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n  var _canWrapExpr = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n\n  var _fieldName = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : undefined;\n\n  var _value = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : undefined;\n\n  if (!item) return undefined;\n  var type = item.get(\"type\");\n  var children = item.get(\"children1\");\n\n  if ((type === \"group\" || type === \"rule_group\") && children && children.size) {\n    return formatGroup(parents, item, config, meta, _not, _canWrapExpr, _fieldName, _value);\n  } else if (type === \"rule\") {\n    return formatRule(parents, item, config, meta, _not, _canWrapExpr, _fieldName, _value);\n  }\n\n  return undefined;\n};\n\nvar formatGroup = function formatGroup(parents, item, config, meta) {\n  var _not = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n  var _canWrapExpr = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n\n  var _fieldName = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : undefined;\n\n  var _value = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : undefined;\n\n  var type = item.get(\"type\");\n  var properties = item.get(\"properties\") || new _immutable.Map();\n  var children = item.get(\"children1\");\n  var canShortMongoQuery = config.settings.canShortMongoQuery;\n  var hasParentRuleGroup = parents.filter(function (it) {\n    return it.get(\"type\") == \"rule_group\";\n  }).length > 0;\n  var parentPath = parents.filter(function (it) {\n    return it.get(\"type\") == \"rule_group\";\n  }).map(function (it) {\n    return it.get(\"properties\").get(\"field\");\n  }).slice(-1).pop();\n  var realParentPath = hasParentRuleGroup && parentPath;\n  var groupField = type === \"rule_group\" ? properties.get(\"field\") : null;\n  var groupFieldName = formatFieldName(groupField, config, meta, realParentPath);\n  var groupFieldDef = (0, _configUtils.getFieldConfig)(config, groupField) || {};\n  var mode = groupFieldDef.mode; //properties.get(\"mode\");\n\n  var not = _not ? !properties.get(\"not\") : properties.get(\"not\");\n  var list = children.map(function (currentChild) {\n    return formatItem([].concat((0, _toConsumableArray2[\"default\"])(parents), [item]), currentChild, config, meta, not, true, mode == \"array\" ? function (f) {\n      return \"$$el.\".concat(f);\n    } : undefined);\n  }).filter(function (currentChild) {\n    return typeof currentChild !== \"undefined\";\n  });\n  if (!list.size) return undefined;\n  var conjunction = properties.get(\"conjunction\");\n  if (!conjunction) conjunction = (0, _defaultUtils.defaultConjunction)(config);\n  var conjunctionDefinition = config.conjunctions[conjunction];\n  var reversedConj = conjunctionDefinition.reversedConj;\n\n  if (not && reversedConj) {\n    conjunction = reversedConj;\n    conjunctionDefinition = config.conjunctions[conjunction];\n  }\n\n  var mongoConj = conjunctionDefinition.mongoConj;\n  var resultQuery;\n  if (list.size == 1) resultQuery = list.first();else {\n    var rules = list.toList().toJS();\n    var canShort = canShortMongoQuery && mongoConj == \"$and\";\n\n    if (canShort) {\n      resultQuery = rules.reduce(function (acc, rule) {\n        if (!acc) return undefined;\n\n        for (var k in rule) {\n          if (k[0] == \"$\") {\n            acc = undefined;\n            break;\n          }\n\n          if (acc[k] == undefined) {\n            acc[k] = rule[k];\n          } else {\n            // https://github.com/ukrbublik/react-awesome-query-builder/issues/182\n            var prev = acc[k],\n                next = rule[k];\n\n            if (!isObject(prev)) {\n              prev = {\n                \"$eq\": prev\n              };\n            }\n\n            if (!isObject(next)) {\n              next = {\n                \"$eq\": next\n              };\n            }\n\n            var prevOp = Object.keys(prev)[0],\n                nextOp = Object.keys(next)[0];\n\n            if (prevOp == nextOp) {\n              acc = undefined;\n              break;\n            }\n\n            acc[k] = Object.assign({}, prev, next);\n          }\n        }\n\n        return acc;\n      }, {});\n    }\n\n    if (!resultQuery) // can't be shorten\n      resultQuery = (0, _defineProperty2[\"default\"])({}, mongoConj, rules);\n  }\n\n  if (groupField) {\n    if (mode == \"array\") {\n      var filterQuery = {\n        \"$size\": {\n          \"$filter\": {\n            input: \"$\" + groupFieldName,\n            as: \"el\",\n            cond: resultQuery\n          }\n        }\n      };\n      var totalQuery = {\n        \"$size\": groupFieldName\n      };\n      resultQuery = formatItem(parents, item.set(\"type\", \"rule\"), config, meta, false, false, function (_f) {\n        return filterQuery;\n      }, totalQuery);\n      resultQuery = {\n        \"$expr\": resultQuery\n      };\n    } else {\n      resultQuery = (0, _defineProperty2[\"default\"])({}, groupFieldName, {\n        \"$elemMatch\": resultQuery\n      });\n    }\n  }\n\n  return resultQuery;\n};\n\nvar formatRule = function formatRule(parents, item, config, meta) {\n  var _not = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n  var _canWrapExpr = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n\n  var _fieldName = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : undefined;\n\n  var _value = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : undefined;\n\n  var properties = item.get(\"properties\") || new _immutable.Map();\n  var hasParentRuleGroup = parents.filter(function (it) {\n    return it.get(\"type\") == \"rule_group\";\n  }).length > 0;\n  var parentPath = parents.filter(function (it) {\n    return it.get(\"type\") == \"rule_group\";\n  }).map(function (it) {\n    return it.get(\"properties\").get(\"field\");\n  }).slice(-1).pop();\n  var realParentPath = hasParentRuleGroup && parentPath;\n  var operator = properties.get(\"operator\");\n  var operatorOptions = properties.get(\"operatorOptions\");\n  var field = properties.get(\"field\");\n  var iValue = properties.get(\"value\");\n  var iValueSrc = properties.get(\"valueSrc\");\n  var iValueType = properties.get(\"valueType\");\n  var asyncListValues = properties.get(\"asyncListValues\");\n  if (field == null || operator == null || iValue === undefined) return undefined;\n  var fieldDef = (0, _configUtils.getFieldConfig)(config, field) || {};\n  var operatorDefinition = (0, _configUtils.getOperatorConfig)(config, operator, field) || {};\n  var reversedOp = operatorDefinition.reversedOp;\n  var revOperatorDefinition = (0, _configUtils.getOperatorConfig)(config, reversedOp, field) || {};\n  var cardinality = (0, _stuff.defaultValue)(operatorDefinition.cardinality, 1);\n  var not = _not;\n\n  if (not && reversedOp) {\n    var _ref = [reversedOp, operator];\n    operator = _ref[0];\n    reversedOp = _ref[1];\n    var _ref2 = [revOperatorDefinition, operatorDefinition];\n    operatorDefinition = _ref2[0];\n    revOperatorDefinition = _ref2[1];\n    not = false;\n  }\n\n  var fieldName = formatFieldName(field, config, meta, realParentPath); //format value\n\n  var valueSrcs = [];\n  var valueTypes = [];\n  var useExpr = false;\n  var fvalue = iValue.map(function (currentValue, ind) {\n    var valueSrc = iValueSrc ? iValueSrc.get(ind) : null;\n    var valueType = iValueType ? iValueType.get(ind) : null;\n    var cValue = (0, _funcUtils.completeValue)(currentValue, valueSrc, config);\n    var widget = (0, _ruleUtils.getWidgetForFieldOp)(config, field, operator, valueSrc);\n    var fieldWidgetDef = (0, _omit[\"default\"])((0, _configUtils.getFieldWidgetConfig)(config, field, operator, widget, valueSrc), [\"factory\"]);\n\n    var _formatValue = formatValue(meta, config, cValue, valueSrc, valueType, fieldWidgetDef, fieldDef, realParentPath, operator, operatorDefinition, asyncListValues),\n        _formatValue2 = (0, _slicedToArray2[\"default\"])(_formatValue, 2),\n        fv = _formatValue2[0],\n        fvUseExpr = _formatValue2[1];\n\n    if (fv !== undefined) {\n      useExpr = useExpr || fvUseExpr;\n      valueSrcs.push(valueSrc);\n      valueTypes.push(valueType);\n    }\n\n    return fv;\n  });\n  if (_fieldName) useExpr = true;\n  var wrapExpr = useExpr && _canWrapExpr;\n  var hasUndefinedValues = fvalue.filter(function (v) {\n    return v === undefined;\n  }).size > 0;\n  if (fvalue.size < cardinality || hasUndefinedValues) return undefined;\n  var formattedValue = cardinality > 1 ? fvalue.toArray() : cardinality == 1 ? fvalue.first() : null; //build rule\n\n  var fn = operatorDefinition.mongoFormatOp;\n\n  if (!fn) {\n    meta.errors.push(\"Operator \".concat(operator, \" is not supported\"));\n    return undefined;\n  }\n\n  var args = [_fieldName ? _fieldName(fieldName) : fieldName, operator, _value !== undefined && formattedValue == null ? _value : formattedValue, useExpr, valueSrcs.length > 1 ? valueSrcs : valueSrcs[0], valueTypes.length > 1 ? valueTypes : valueTypes[0], (0, _omit[\"default\"])(operatorDefinition, [\"formatOp\", \"mongoFormatOp\", \"sqlFormatOp\", \"jsonLogic\"]), operatorOptions, fieldDef];\n  var ruleQuery = fn.apply(void 0, args);\n\n  if (wrapExpr) {\n    ruleQuery = {\n      \"$expr\": ruleQuery\n    };\n  }\n\n  if (not) {\n    ruleQuery = {\n      \"$not\": ruleQuery\n    };\n  }\n\n  return ruleQuery;\n};\n\nvar formatValue = function formatValue(meta, config, currentValue, valueSrc, valueType, fieldWidgetDef, fieldDef, parentPath, operator, operatorDef, asyncListValues) {\n  if (currentValue === undefined) return [undefined, false];\n  var ret;\n  var useExpr = false;\n\n  if (valueSrc == \"field\") {\n    var _formatRightField = formatRightField(meta, config, currentValue, parentPath);\n\n    var _formatRightField2 = (0, _slicedToArray2[\"default\"])(_formatRightField, 2);\n\n    ret = _formatRightField2[0];\n    useExpr = _formatRightField2[1];\n  } else if (valueSrc == \"func\") {\n    var _formatFunc = formatFunc(meta, config, currentValue, parentPath);\n\n    var _formatFunc2 = (0, _slicedToArray2[\"default\"])(_formatFunc, 2);\n\n    ret = _formatFunc2[0];\n    useExpr = _formatFunc2[1];\n  } else {\n    if (typeof fieldWidgetDef.mongoFormatValue === \"function\") {\n      var fn = fieldWidgetDef.mongoFormatValue;\n      var args = [currentValue, _objectSpread(_objectSpread({}, (0, _pick[\"default\"])(fieldDef, [\"fieldSettings\", \"listValues\"])), {}, {\n        asyncListValues: asyncListValues\n      }), //useful options: valueFormat for date/time\n      (0, _omit[\"default\"])(fieldWidgetDef, [\"formatValue\", \"mongoFormatValue\", \"sqlFormatValue\", \"jsonLogic\", \"elasticSearchFormatValue\"])];\n\n      if (operator) {\n        args.push(operator);\n        args.push(operatorDef);\n      }\n\n      ret = fn.apply(void 0, args);\n    } else {\n      ret = currentValue;\n    }\n  }\n\n  return [ret, useExpr];\n};\n\nvar formatFieldName = function formatFieldName(field, config, meta, parentPath) {\n  if (!field) return;\n  var fieldDef = (0, _configUtils.getFieldConfig)(config, field) || {};\n  var fieldSeparator = config.settings.fieldSeparator;\n  var fieldParts = Array.isArray(field) ? field : field.split(fieldSeparator);\n  var fieldName = Array.isArray(field) ? field.join(fieldSeparator) : field; // if (fieldDef.tableName) { // legacy\n  //     const fieldPartsCopy = [...fieldParts];\n  //     fieldPartsCopy[0] = fieldDef.tableName;\n  //     fieldName = fieldPartsCopy.join(fieldSeparator);\n  // }\n\n  if (fieldDef.fieldName) {\n    fieldName = fieldDef.fieldName;\n  }\n\n  if (parentPath) {\n    var parentFieldDef = (0, _configUtils.getFieldConfig)(config, parentPath) || {};\n    var parentFieldName = parentPath;\n\n    if (parentFieldDef.fieldName) {\n      parentFieldName = parentFieldDef.fieldName;\n    }\n\n    if (fieldName.indexOf(parentFieldName + \".\") == 0) {\n      fieldName = fieldName.slice((parentFieldName + \".\").length);\n    } else {\n      meta.errors.push(\"Can't cut group \".concat(parentFieldName, \" from field \").concat(fieldName));\n    }\n  }\n\n  return fieldName;\n};\n\nvar formatRightField = function formatRightField(meta, config, rightField, parentPath) {\n  var fieldSeparator = config.settings.fieldSeparator;\n  var ret;\n  var useExpr = true;\n\n  if (rightField) {\n    var rightFieldDefinition = (0, _configUtils.getFieldConfig)(config, rightField) || {};\n    var fieldParts = Array.isArray(rightField) ? rightField : rightField.split(fieldSeparator);\n\n    var _fieldKeys = (0, _ruleUtils.getFieldPath)(rightField, config);\n\n    var fieldPartsLabels = (0, _ruleUtils.getFieldPathLabels)(rightField, config);\n    var fieldFullLabel = fieldPartsLabels ? fieldPartsLabels.join(fieldSeparator) : null;\n    var formatFieldFn = config.settings.formatField || _default.settings.formatField;\n    var rightFieldName = formatFieldName(rightField, config, meta, parentPath);\n    var formattedField = formatFieldFn(rightFieldName, fieldParts, fieldFullLabel, rightFieldDefinition, config, false);\n    ret = \"$\" + formattedField;\n  }\n\n  return [ret, useExpr];\n};\n\nvar formatFunc = function formatFunc(meta, config, currentValue, parentPath) {\n  var useExpr = true;\n  var ret;\n  var funcKey = currentValue.get(\"func\");\n  var args = currentValue.get(\"args\");\n  var funcConfig = (0, _configUtils.getFuncConfig)(config, funcKey);\n  var funcName = funcConfig.mongoFunc || funcKey;\n  var mongoArgsAsObject = funcConfig.mongoArgsAsObject;\n  var formattedArgs = {};\n  var argsCnt = 0;\n  var lastArg = undefined;\n\n  for (var argKey in funcConfig.args) {\n    var argConfig = funcConfig.args[argKey];\n    var fieldDef = (0, _configUtils.getFieldConfig)(config, argConfig);\n    var argVal = args ? args.get(argKey) : undefined;\n    var argValue = argVal ? argVal.get(\"value\") : undefined;\n    var argValueSrc = argVal ? argVal.get(\"valueSrc\") : undefined;\n    var argAsyncListValues = argVal ? argVal.get(\"asyncListValues\") : undefined;\n    var widget = (0, _ruleUtils.getWidgetForFieldOp)(config, fieldDef, null, argValueSrc);\n    var fieldWidgetDef = (0, _omit[\"default\"])((0, _configUtils.getFieldWidgetConfig)(config, fieldDef, null, widget, argValueSrc), [\"factory\"]);\n\n    var _formatValue3 = formatValue(meta, config, argValue, argValueSrc, argConfig.type, fieldWidgetDef, fieldDef, parentPath, null, null, argAsyncListValues),\n        _formatValue4 = (0, _slicedToArray2[\"default\"])(_formatValue3, 2),\n        formattedArgVal = _formatValue4[0],\n        _argUseExpr = _formatValue4[1];\n\n    if (argValue != undefined && formattedArgVal === undefined) {\n      meta.errors.push(\"Can't format value of arg \".concat(argKey, \" for func \").concat(funcKey));\n      return [undefined, false];\n    }\n\n    argsCnt++;\n\n    if (formattedArgVal !== undefined) {\n      // skip optional in the end\n      formattedArgs[argKey] = formattedArgVal;\n      lastArg = formattedArgVal;\n    }\n  }\n\n  if (typeof funcConfig.mongoFormatFunc === \"function\") {\n    var fn = funcConfig.mongoFormatFunc;\n    var _args = [formattedArgs];\n    ret = fn.apply(void 0, _args);\n  } else if (funcConfig.mongoFormatFunc === null) {\n    meta.errors.push(\"Functon \".concat(funcName, \" is not supported\"));\n    return [undefined, false];\n  } else {\n    if (mongoArgsAsObject) ret = (0, _defineProperty2[\"default\"])({}, funcName, formattedArgs);else if (argsCnt == 1 && lastArg !== undefined) ret = (0, _defineProperty2[\"default\"])({}, funcName, lastArg);else ret = (0, _defineProperty2[\"default\"])({}, funcName, Object.values(formattedArgs));\n  }\n\n  return [ret, useExpr];\n};","map":{"version":3,"sources":["D:/LIMSWFH/LIMSPOSTGRESQL/QuaLISWeb/node_modules/react-awesome-query-builder/lib/export/mongoDb.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","mongodbFormat","_slicedToArray2","_defineProperty2","_toConsumableArray2","_typeof2","_stuff","_configUtils","_ruleUtils","_defaultUtils","_funcUtils","_omit","_pick","_immutable","_default","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","isObject","v","Array","isArray","tree","config","meta","errors","res","formatItem","console","warn","parents","item","_not","undefined","_canWrapExpr","_fieldName","_value","type","get","children","size","formatGroup","formatRule","properties","Map","canShortMongoQuery","settings","hasParentRuleGroup","it","parentPath","map","slice","pop","realParentPath","groupField","groupFieldName","formatFieldName","groupFieldDef","getFieldConfig","mode","not","list","currentChild","concat","f","conjunction","defaultConjunction","conjunctionDefinition","conjunctions","reversedConj","mongoConj","resultQuery","first","rules","toList","toJS","canShort","reduce","acc","rule","k","prev","next","prevOp","nextOp","assign","filterQuery","input","as","cond","totalQuery","set","_f","operator","operatorOptions","field","iValue","iValueSrc","iValueType","asyncListValues","fieldDef","operatorDefinition","getOperatorConfig","reversedOp","revOperatorDefinition","cardinality","defaultValue","_ref","_ref2","fieldName","valueSrcs","valueTypes","useExpr","fvalue","currentValue","ind","valueSrc","valueType","cValue","completeValue","widget","getWidgetForFieldOp","fieldWidgetDef","getFieldWidgetConfig","_formatValue","formatValue","_formatValue2","fv","fvUseExpr","wrapExpr","hasUndefinedValues","formattedValue","toArray","fn","mongoFormatOp","args","ruleQuery","operatorDef","ret","_formatRightField","formatRightField","_formatRightField2","_formatFunc","formatFunc","_formatFunc2","mongoFormatValue","fieldSeparator","fieldParts","split","join","parentFieldDef","parentFieldName","indexOf","rightField","rightFieldDefinition","_fieldKeys","getFieldPath","fieldPartsLabels","getFieldPathLabels","fieldFullLabel","formatFieldFn","formatField","rightFieldName","formattedField","funcKey","funcConfig","getFuncConfig","funcName","mongoFunc","mongoArgsAsObject","formattedArgs","argsCnt","lastArg","argKey","argConfig","argVal","argValue","argValueSrc","argAsyncListValues","_formatValue3","_formatValue4","formattedArgVal","_argUseExpr","mongoFormatFunc","_args","values"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.mongodbFormat = void 0;\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nvar _stuff = require(\"../utils/stuff\");\n\nvar _configUtils = require(\"../utils/configUtils\");\n\nvar _ruleUtils = require(\"../utils/ruleUtils\");\n\nvar _defaultUtils = require(\"../utils/defaultUtils\");\n\nvar _funcUtils = require(\"../utils/funcUtils\");\n\nvar _omit = _interopRequireDefault(require(\"lodash/omit\"));\n\nvar _pick = _interopRequireDefault(require(\"lodash/pick\"));\n\nvar _immutable = require(\"immutable\");\n\nvar _default = require(\"../config/default\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2[\"default\"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\n// helpers\nvar isObject = function isObject(v) {\n  return (0, _typeof2[\"default\"])(v) == \"object\" && v !== null && !Array.isArray(v);\n};\n\nvar mongodbFormat = function mongodbFormat(tree, config) {\n  //meta is mutable\n  var meta = {\n    errors: []\n  };\n  var res = formatItem([], tree, config, meta);\n  if (meta.errors.length) console.warn(\"Errors while exporting to MongoDb:\", meta.errors);\n  return res;\n};\n\nexports.mongodbFormat = mongodbFormat;\n\nvar formatItem = function formatItem(parents, item, config, meta) {\n  var _not = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n  var _canWrapExpr = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n\n  var _fieldName = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : undefined;\n\n  var _value = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : undefined;\n\n  if (!item) return undefined;\n  var type = item.get(\"type\");\n  var children = item.get(\"children1\");\n\n  if ((type === \"group\" || type === \"rule_group\") && children && children.size) {\n    return formatGroup(parents, item, config, meta, _not, _canWrapExpr, _fieldName, _value);\n  } else if (type === \"rule\") {\n    return formatRule(parents, item, config, meta, _not, _canWrapExpr, _fieldName, _value);\n  }\n\n  return undefined;\n};\n\nvar formatGroup = function formatGroup(parents, item, config, meta) {\n  var _not = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n  var _canWrapExpr = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n\n  var _fieldName = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : undefined;\n\n  var _value = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : undefined;\n\n  var type = item.get(\"type\");\n  var properties = item.get(\"properties\") || new _immutable.Map();\n  var children = item.get(\"children1\");\n  var canShortMongoQuery = config.settings.canShortMongoQuery;\n  var hasParentRuleGroup = parents.filter(function (it) {\n    return it.get(\"type\") == \"rule_group\";\n  }).length > 0;\n  var parentPath = parents.filter(function (it) {\n    return it.get(\"type\") == \"rule_group\";\n  }).map(function (it) {\n    return it.get(\"properties\").get(\"field\");\n  }).slice(-1).pop();\n  var realParentPath = hasParentRuleGroup && parentPath;\n  var groupField = type === \"rule_group\" ? properties.get(\"field\") : null;\n  var groupFieldName = formatFieldName(groupField, config, meta, realParentPath);\n  var groupFieldDef = (0, _configUtils.getFieldConfig)(config, groupField) || {};\n  var mode = groupFieldDef.mode; //properties.get(\"mode\");\n\n  var not = _not ? !properties.get(\"not\") : properties.get(\"not\");\n  var list = children.map(function (currentChild) {\n    return formatItem([].concat((0, _toConsumableArray2[\"default\"])(parents), [item]), currentChild, config, meta, not, true, mode == \"array\" ? function (f) {\n      return \"$$el.\".concat(f);\n    } : undefined);\n  }).filter(function (currentChild) {\n    return typeof currentChild !== \"undefined\";\n  });\n  if (!list.size) return undefined;\n  var conjunction = properties.get(\"conjunction\");\n  if (!conjunction) conjunction = (0, _defaultUtils.defaultConjunction)(config);\n  var conjunctionDefinition = config.conjunctions[conjunction];\n  var reversedConj = conjunctionDefinition.reversedConj;\n\n  if (not && reversedConj) {\n    conjunction = reversedConj;\n    conjunctionDefinition = config.conjunctions[conjunction];\n  }\n\n  var mongoConj = conjunctionDefinition.mongoConj;\n  var resultQuery;\n  if (list.size == 1) resultQuery = list.first();else {\n    var rules = list.toList().toJS();\n    var canShort = canShortMongoQuery && mongoConj == \"$and\";\n\n    if (canShort) {\n      resultQuery = rules.reduce(function (acc, rule) {\n        if (!acc) return undefined;\n\n        for (var k in rule) {\n          if (k[0] == \"$\") {\n            acc = undefined;\n            break;\n          }\n\n          if (acc[k] == undefined) {\n            acc[k] = rule[k];\n          } else {\n            // https://github.com/ukrbublik/react-awesome-query-builder/issues/182\n            var prev = acc[k],\n                next = rule[k];\n\n            if (!isObject(prev)) {\n              prev = {\n                \"$eq\": prev\n              };\n            }\n\n            if (!isObject(next)) {\n              next = {\n                \"$eq\": next\n              };\n            }\n\n            var prevOp = Object.keys(prev)[0],\n                nextOp = Object.keys(next)[0];\n\n            if (prevOp == nextOp) {\n              acc = undefined;\n              break;\n            }\n\n            acc[k] = Object.assign({}, prev, next);\n          }\n        }\n\n        return acc;\n      }, {});\n    }\n\n    if (!resultQuery) // can't be shorten\n      resultQuery = (0, _defineProperty2[\"default\"])({}, mongoConj, rules);\n  }\n\n  if (groupField) {\n    if (mode == \"array\") {\n      var filterQuery = {\n        \"$size\": {\n          \"$filter\": {\n            input: \"$\" + groupFieldName,\n            as: \"el\",\n            cond: resultQuery\n          }\n        }\n      };\n      var totalQuery = {\n        \"$size\": groupFieldName\n      };\n      resultQuery = formatItem(parents, item.set(\"type\", \"rule\"), config, meta, false, false, function (_f) {\n        return filterQuery;\n      }, totalQuery);\n      resultQuery = {\n        \"$expr\": resultQuery\n      };\n    } else {\n      resultQuery = (0, _defineProperty2[\"default\"])({}, groupFieldName, {\n        \"$elemMatch\": resultQuery\n      });\n    }\n  }\n\n  return resultQuery;\n};\n\nvar formatRule = function formatRule(parents, item, config, meta) {\n  var _not = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n  var _canWrapExpr = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n\n  var _fieldName = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : undefined;\n\n  var _value = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : undefined;\n\n  var properties = item.get(\"properties\") || new _immutable.Map();\n  var hasParentRuleGroup = parents.filter(function (it) {\n    return it.get(\"type\") == \"rule_group\";\n  }).length > 0;\n  var parentPath = parents.filter(function (it) {\n    return it.get(\"type\") == \"rule_group\";\n  }).map(function (it) {\n    return it.get(\"properties\").get(\"field\");\n  }).slice(-1).pop();\n  var realParentPath = hasParentRuleGroup && parentPath;\n  var operator = properties.get(\"operator\");\n  var operatorOptions = properties.get(\"operatorOptions\");\n  var field = properties.get(\"field\");\n  var iValue = properties.get(\"value\");\n  var iValueSrc = properties.get(\"valueSrc\");\n  var iValueType = properties.get(\"valueType\");\n  var asyncListValues = properties.get(\"asyncListValues\");\n  if (field == null || operator == null || iValue === undefined) return undefined;\n  var fieldDef = (0, _configUtils.getFieldConfig)(config, field) || {};\n  var operatorDefinition = (0, _configUtils.getOperatorConfig)(config, operator, field) || {};\n  var reversedOp = operatorDefinition.reversedOp;\n  var revOperatorDefinition = (0, _configUtils.getOperatorConfig)(config, reversedOp, field) || {};\n  var cardinality = (0, _stuff.defaultValue)(operatorDefinition.cardinality, 1);\n  var not = _not;\n\n  if (not && reversedOp) {\n    var _ref = [reversedOp, operator];\n    operator = _ref[0];\n    reversedOp = _ref[1];\n    var _ref2 = [revOperatorDefinition, operatorDefinition];\n    operatorDefinition = _ref2[0];\n    revOperatorDefinition = _ref2[1];\n    not = false;\n  }\n\n  var fieldName = formatFieldName(field, config, meta, realParentPath); //format value\n\n  var valueSrcs = [];\n  var valueTypes = [];\n  var useExpr = false;\n  var fvalue = iValue.map(function (currentValue, ind) {\n    var valueSrc = iValueSrc ? iValueSrc.get(ind) : null;\n    var valueType = iValueType ? iValueType.get(ind) : null;\n    var cValue = (0, _funcUtils.completeValue)(currentValue, valueSrc, config);\n    var widget = (0, _ruleUtils.getWidgetForFieldOp)(config, field, operator, valueSrc);\n    var fieldWidgetDef = (0, _omit[\"default\"])((0, _configUtils.getFieldWidgetConfig)(config, field, operator, widget, valueSrc), [\"factory\"]);\n\n    var _formatValue = formatValue(meta, config, cValue, valueSrc, valueType, fieldWidgetDef, fieldDef, realParentPath, operator, operatorDefinition, asyncListValues),\n        _formatValue2 = (0, _slicedToArray2[\"default\"])(_formatValue, 2),\n        fv = _formatValue2[0],\n        fvUseExpr = _formatValue2[1];\n\n    if (fv !== undefined) {\n      useExpr = useExpr || fvUseExpr;\n      valueSrcs.push(valueSrc);\n      valueTypes.push(valueType);\n    }\n\n    return fv;\n  });\n  if (_fieldName) useExpr = true;\n  var wrapExpr = useExpr && _canWrapExpr;\n  var hasUndefinedValues = fvalue.filter(function (v) {\n    return v === undefined;\n  }).size > 0;\n  if (fvalue.size < cardinality || hasUndefinedValues) return undefined;\n  var formattedValue = cardinality > 1 ? fvalue.toArray() : cardinality == 1 ? fvalue.first() : null; //build rule\n\n  var fn = operatorDefinition.mongoFormatOp;\n\n  if (!fn) {\n    meta.errors.push(\"Operator \".concat(operator, \" is not supported\"));\n    return undefined;\n  }\n\n  var args = [_fieldName ? _fieldName(fieldName) : fieldName, operator, _value !== undefined && formattedValue == null ? _value : formattedValue, useExpr, valueSrcs.length > 1 ? valueSrcs : valueSrcs[0], valueTypes.length > 1 ? valueTypes : valueTypes[0], (0, _omit[\"default\"])(operatorDefinition, [\"formatOp\", \"mongoFormatOp\", \"sqlFormatOp\", \"jsonLogic\"]), operatorOptions, fieldDef];\n  var ruleQuery = fn.apply(void 0, args);\n\n  if (wrapExpr) {\n    ruleQuery = {\n      \"$expr\": ruleQuery\n    };\n  }\n\n  if (not) {\n    ruleQuery = {\n      \"$not\": ruleQuery\n    };\n  }\n\n  return ruleQuery;\n};\n\nvar formatValue = function formatValue(meta, config, currentValue, valueSrc, valueType, fieldWidgetDef, fieldDef, parentPath, operator, operatorDef, asyncListValues) {\n  if (currentValue === undefined) return [undefined, false];\n  var ret;\n  var useExpr = false;\n\n  if (valueSrc == \"field\") {\n    var _formatRightField = formatRightField(meta, config, currentValue, parentPath);\n\n    var _formatRightField2 = (0, _slicedToArray2[\"default\"])(_formatRightField, 2);\n\n    ret = _formatRightField2[0];\n    useExpr = _formatRightField2[1];\n  } else if (valueSrc == \"func\") {\n    var _formatFunc = formatFunc(meta, config, currentValue, parentPath);\n\n    var _formatFunc2 = (0, _slicedToArray2[\"default\"])(_formatFunc, 2);\n\n    ret = _formatFunc2[0];\n    useExpr = _formatFunc2[1];\n  } else {\n    if (typeof fieldWidgetDef.mongoFormatValue === \"function\") {\n      var fn = fieldWidgetDef.mongoFormatValue;\n      var args = [currentValue, _objectSpread(_objectSpread({}, (0, _pick[\"default\"])(fieldDef, [\"fieldSettings\", \"listValues\"])), {}, {\n        asyncListValues: asyncListValues\n      }), //useful options: valueFormat for date/time\n      (0, _omit[\"default\"])(fieldWidgetDef, [\"formatValue\", \"mongoFormatValue\", \"sqlFormatValue\", \"jsonLogic\", \"elasticSearchFormatValue\"])];\n\n      if (operator) {\n        args.push(operator);\n        args.push(operatorDef);\n      }\n\n      ret = fn.apply(void 0, args);\n    } else {\n      ret = currentValue;\n    }\n  }\n\n  return [ret, useExpr];\n};\n\nvar formatFieldName = function formatFieldName(field, config, meta, parentPath) {\n  if (!field) return;\n  var fieldDef = (0, _configUtils.getFieldConfig)(config, field) || {};\n  var fieldSeparator = config.settings.fieldSeparator;\n  var fieldParts = Array.isArray(field) ? field : field.split(fieldSeparator);\n  var fieldName = Array.isArray(field) ? field.join(fieldSeparator) : field; // if (fieldDef.tableName) { // legacy\n  //     const fieldPartsCopy = [...fieldParts];\n  //     fieldPartsCopy[0] = fieldDef.tableName;\n  //     fieldName = fieldPartsCopy.join(fieldSeparator);\n  // }\n\n  if (fieldDef.fieldName) {\n    fieldName = fieldDef.fieldName;\n  }\n\n  if (parentPath) {\n    var parentFieldDef = (0, _configUtils.getFieldConfig)(config, parentPath) || {};\n    var parentFieldName = parentPath;\n\n    if (parentFieldDef.fieldName) {\n      parentFieldName = parentFieldDef.fieldName;\n    }\n\n    if (fieldName.indexOf(parentFieldName + \".\") == 0) {\n      fieldName = fieldName.slice((parentFieldName + \".\").length);\n    } else {\n      meta.errors.push(\"Can't cut group \".concat(parentFieldName, \" from field \").concat(fieldName));\n    }\n  }\n\n  return fieldName;\n};\n\nvar formatRightField = function formatRightField(meta, config, rightField, parentPath) {\n  var fieldSeparator = config.settings.fieldSeparator;\n  var ret;\n  var useExpr = true;\n\n  if (rightField) {\n    var rightFieldDefinition = (0, _configUtils.getFieldConfig)(config, rightField) || {};\n    var fieldParts = Array.isArray(rightField) ? rightField : rightField.split(fieldSeparator);\n\n    var _fieldKeys = (0, _ruleUtils.getFieldPath)(rightField, config);\n\n    var fieldPartsLabels = (0, _ruleUtils.getFieldPathLabels)(rightField, config);\n    var fieldFullLabel = fieldPartsLabels ? fieldPartsLabels.join(fieldSeparator) : null;\n    var formatFieldFn = config.settings.formatField || _default.settings.formatField;\n    var rightFieldName = formatFieldName(rightField, config, meta, parentPath);\n    var formattedField = formatFieldFn(rightFieldName, fieldParts, fieldFullLabel, rightFieldDefinition, config, false);\n    ret = \"$\" + formattedField;\n  }\n\n  return [ret, useExpr];\n};\n\nvar formatFunc = function formatFunc(meta, config, currentValue, parentPath) {\n  var useExpr = true;\n  var ret;\n  var funcKey = currentValue.get(\"func\");\n  var args = currentValue.get(\"args\");\n  var funcConfig = (0, _configUtils.getFuncConfig)(config, funcKey);\n  var funcName = funcConfig.mongoFunc || funcKey;\n  var mongoArgsAsObject = funcConfig.mongoArgsAsObject;\n  var formattedArgs = {};\n  var argsCnt = 0;\n  var lastArg = undefined;\n\n  for (var argKey in funcConfig.args) {\n    var argConfig = funcConfig.args[argKey];\n    var fieldDef = (0, _configUtils.getFieldConfig)(config, argConfig);\n    var argVal = args ? args.get(argKey) : undefined;\n    var argValue = argVal ? argVal.get(\"value\") : undefined;\n    var argValueSrc = argVal ? argVal.get(\"valueSrc\") : undefined;\n    var argAsyncListValues = argVal ? argVal.get(\"asyncListValues\") : undefined;\n    var widget = (0, _ruleUtils.getWidgetForFieldOp)(config, fieldDef, null, argValueSrc);\n    var fieldWidgetDef = (0, _omit[\"default\"])((0, _configUtils.getFieldWidgetConfig)(config, fieldDef, null, widget, argValueSrc), [\"factory\"]);\n\n    var _formatValue3 = formatValue(meta, config, argValue, argValueSrc, argConfig.type, fieldWidgetDef, fieldDef, parentPath, null, null, argAsyncListValues),\n        _formatValue4 = (0, _slicedToArray2[\"default\"])(_formatValue3, 2),\n        formattedArgVal = _formatValue4[0],\n        _argUseExpr = _formatValue4[1];\n\n    if (argValue != undefined && formattedArgVal === undefined) {\n      meta.errors.push(\"Can't format value of arg \".concat(argKey, \" for func \").concat(funcKey));\n      return [undefined, false];\n    }\n\n    argsCnt++;\n\n    if (formattedArgVal !== undefined) {\n      // skip optional in the end\n      formattedArgs[argKey] = formattedArgVal;\n      lastArg = formattedArgVal;\n    }\n  }\n\n  if (typeof funcConfig.mongoFormatFunc === \"function\") {\n    var fn = funcConfig.mongoFormatFunc;\n    var _args = [formattedArgs];\n    ret = fn.apply(void 0, _args);\n  } else if (funcConfig.mongoFormatFunc === null) {\n    meta.errors.push(\"Functon \".concat(funcName, \" is not supported\"));\n    return [undefined, false];\n  } else {\n    if (mongoArgsAsObject) ret = (0, _defineProperty2[\"default\"])({}, funcName, formattedArgs);else if (argsCnt == 1 && lastArg !== undefined) ret = (0, _defineProperty2[\"default\"])({}, funcName, lastArg);else ret = (0, _defineProperty2[\"default\"])({}, funcName, Object.values(formattedArgs));\n  }\n\n  return [ret, useExpr];\n};"]},"metadata":{},"sourceType":"script"}