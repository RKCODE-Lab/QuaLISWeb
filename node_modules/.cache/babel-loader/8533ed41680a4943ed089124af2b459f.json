{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.loadFromJsonLogic = void 0;\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _toArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toArray\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _uuid = _interopRequireDefault(require(\"../utils/uuid\"));\n\nvar _stuff = require(\"../utils/stuff\");\n\nvar _configUtils = require(\"../utils/configUtils\");\n\nvar _ruleUtils = require(\"../utils/ruleUtils\");\n\nvar _tree = require(\"./tree\");\n\nvar _defaultUtils = require(\"../utils/defaultUtils\");\n\nvar _moment = _interopRequireDefault(require(\"moment\"));\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      (0, _defineProperty2[\"default\"])(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n} // http://jsonlogic.com/\n// helpers\n\n\nvar arrayUniq = function arrayUniq(arr) {\n  return Array.from(new Set(arr));\n};\n\nvar arrayToObject = function arrayToObject(arr) {\n  return arr.reduce(function (acc, _ref) {\n    var _ref2 = (0, _slicedToArray2[\"default\"])(_ref, 2),\n        f = _ref2[0],\n        fc = _ref2[1];\n\n    return _objectSpread(_objectSpread({}, acc), {}, (0, _defineProperty2[\"default\"])({}, f, fc));\n  }, {});\n};\n\nvar loadFromJsonLogic = function loadFromJsonLogic(logicTree, config) {\n  //meta is mutable\n  var meta = {\n    errors: []\n  };\n  var extendedConfig = (0, _configUtils.extendConfig)(config);\n  var conv = buildConv(extendedConfig);\n  var jsTree = logicTree ? convertFromLogic(logicTree, conv, extendedConfig, \"rule\", meta) : undefined;\n\n  if (jsTree && jsTree.type != \"group\") {\n    jsTree = wrapInDefaultConj(jsTree, extendedConfig);\n  }\n\n  var immTree = jsTree ? (0, _tree.loadTree)(jsTree) : undefined;\n  if (meta.errors.length) console.warn(\"Errors while importing from JsonLogic:\", meta.errors);\n  return immTree;\n};\n\nexports.loadFromJsonLogic = loadFromJsonLogic;\n\nvar buildConv = function buildConv(config) {\n  var operators = {};\n\n  for (var opKey in config.operators) {\n    var opConfig = config.operators[opKey];\n\n    if (typeof opConfig.jsonLogic == \"string\") {\n      // example: \"</2\", \"#in/1\"\n      var opk = (opConfig._jsonLogicIsRevArgs ? \"#\" : \"\") + opConfig.jsonLogic + \"/\" + (0, _stuff.defaultValue)(opConfig.cardinality, 1);\n      if (!operators[opk]) operators[opk] = [];\n      operators[opk].push(opKey);\n    } else if (typeof opConfig.jsonLogic2 == \"string\") {\n      // example: all-in/1\"\n      var _opk = opConfig.jsonLogic2 + \"/\" + (0, _stuff.defaultValue)(opConfig.cardinality, 1);\n\n      if (!operators[_opk]) operators[_opk] = [];\n\n      operators[_opk].push(opKey);\n    }\n  }\n\n  var conjunctions = {};\n\n  for (var conjKey in config.conjunctions) {\n    var ck = conjKey.toLowerCase();\n    conjunctions[ck] = conjKey;\n  }\n\n  var funcs = {};\n\n  for (var funcKey in config.funcs) {\n    var funcConfig = config.funcs[funcKey];\n    var fk = void 0;\n\n    if (funcConfig.jsonLogicIsMethod) {\n      fk = \"#\" + funcConfig.jsonLogic;\n    } else if (typeof funcConfig.jsonLogic == \"string\") {\n      fk = funcConfig.jsonLogic;\n    }\n\n    if (fk) {\n      if (!funcs[fk]) funcs[fk] = [];\n      funcs[fk].push(funcKey);\n    }\n  }\n\n  var _config$settings$json = config.settings.jsonLogic,\n      groupVarKey = _config$settings$json.groupVarKey,\n      altVarKey = _config$settings$json.altVarKey;\n  return {\n    operators: operators,\n    conjunctions: conjunctions,\n    funcs: funcs,\n    varKeys: [\"var\", groupVarKey, altVarKey]\n  };\n};\n\nvar convertFromLogic = function convertFromLogic(logic, conv, config, expectedType, meta) {\n  var not = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  var fieldConfig = arguments.length > 6 ? arguments[6] : undefined;\n  var widget = arguments.length > 7 ? arguments[7] : undefined;\n  var parentField = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : null;\n\n  var _isLockedLogic = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : false;\n\n  var op, vals;\n\n  if ((0, _stuff.isJsonLogic)(logic)) {\n    op = Object.keys(logic)[0];\n    vals = logic[op];\n    if (!Array.isArray(vals)) vals = [vals];\n  }\n\n  var ret;\n  var beforeErrorsCnt = meta.errors.length;\n  var lockedOp = config.settings.jsonLogic.lockedOp;\n  var isEmptyOp = op == \"!\" && vals.length == 1 && vals[0] && (0, _stuff.isJsonLogic)(vals[0]) && conv.varKeys.includes(Object.keys(vals[0])[0]);\n  var isRev = op == \"!\" && !isEmptyOp;\n  var isLocked = lockedOp && op == lockedOp;\n\n  if (isLocked) {\n    ret = convertFromLogic(vals[0], conv, config, expectedType, meta, not, fieldConfig, widget, parentField, true);\n  } else if (isRev) {\n    // reverse with not\n    ret = convertFromLogic(vals[0], conv, config, expectedType, meta, !not, fieldConfig, widget, parentField);\n  } else if (expectedType == \"val\") {\n    // not is not used here\n    ret = convertField(op, vals, conv, config, not, meta, parentField) || convertFunc(op, vals, conv, config, not, fieldConfig, meta, parentField) || convertVal(logic, fieldConfig, widget, config, meta);\n  } else if (expectedType == \"rule\") {\n    ret = convertConj(op, vals, conv, config, not, meta, parentField, false) || convertOp(op, vals, conv, config, not, meta, parentField);\n  }\n\n  var afterErrorsCnt = meta.errors.length;\n\n  if (op != \"!\" && ret === undefined && afterErrorsCnt == beforeErrorsCnt) {\n    meta.errors.push(\"Can't parse logic \".concat(JSON.stringify(logic)));\n  }\n\n  if (isLocked) {\n    ret.properties.isLocked = true;\n  }\n\n  return ret;\n};\n\nvar convertVal = function convertVal(val, fieldConfig, widget, config, meta) {\n  if (val === undefined) return undefined;\n  var widgetConfig = config.widgets[widget || fieldConfig.mainWidget];\n\n  if (!widgetConfig) {\n    meta.errors.push(\"No widget for type \".concat(fieldConfig.type));\n    return undefined;\n  }\n\n  if ((0, _stuff.isJsonLogic)(val)) {\n    meta.errors.push(\"Unexpected logic in value: \".concat(JSON.stringify(val)));\n    return undefined;\n  } // number of seconds -> time string\n\n\n  if (fieldConfig && fieldConfig.type == \"time\" && typeof val == \"number\") {\n    var h = Math.floor(val / 60 / 60) % 24,\n        m = Math.floor(val / 60) % 60,\n        s = val % 60;\n    var valueFormat = widgetConfig.valueFormat;\n\n    if (valueFormat) {\n      var dateVal = new Date(val);\n      dateVal.setMilliseconds(0);\n      dateVal.setHours(h);\n      dateVal.setMinutes(m);\n      dateVal.setSeconds(s);\n      val = (0, _moment[\"default\"])(dateVal).format(valueFormat);\n    } else {\n      val = \"\".concat(h, \":\").concat(m, \":\").concat(s);\n    }\n  } // \"2020-01-08T22:00:00.000Z\" -> Date object\n\n\n  if (fieldConfig && [\"date\", \"datetime\"].includes(fieldConfig.type) && val && !(val instanceof Date)) {\n    try {\n      var _dateVal = new Date(val);\n\n      if (_dateVal instanceof Date && _dateVal.toISOString() === val) {\n        val = _dateVal;\n      }\n    } catch (e) {\n      meta.errors.push(\"Can't convert value \".concat(val, \" as Date\"));\n      val = undefined;\n    }\n  } // Date object -> formatted string\n\n\n  if (val instanceof Date && fieldConfig) {\n    var _valueFormat = widgetConfig.valueFormat;\n\n    if (_valueFormat) {\n      val = (0, _moment[\"default\"])(val).format(_valueFormat);\n    }\n  }\n\n  var asyncListValues;\n\n  if (val && fieldConfig.fieldSettings && fieldConfig.fieldSettings.asyncFetch) {\n    var vals = Array.isArray(val) ? val : [val];\n    asyncListValues = vals;\n  }\n\n  return {\n    valueSrc: \"value\",\n    value: val,\n    valueType: widgetConfig.type,\n    asyncListValues: asyncListValues\n  };\n};\n\nvar convertField = function convertField(op, vals, conv, config, not, meta) {\n  var parentField = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n  var fieldSeparator = config.settings.fieldSeparator;\n\n  if (conv.varKeys.includes(op) && typeof vals[0] == \"string\") {\n    var field = vals[0];\n    if (parentField) field = [parentField, field].join(fieldSeparator);\n    field = (0, _configUtils.normalizeField)(config, field);\n    var fieldConfig = (0, _configUtils.getFieldConfig)(config, field);\n\n    if (!fieldConfig) {\n      meta.errors.push(\"No config for field \".concat(field));\n      return undefined;\n    }\n\n    return {\n      valueSrc: \"field\",\n      value: field,\n      valueType: fieldConfig.type\n    };\n  }\n\n  return undefined;\n};\n\nvar convertFunc = function convertFunc(op, vals, conv, config, not, fieldConfig, meta) {\n  var parentField = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;\n  if (!op) return undefined;\n  var func, argsArr, funcKey;\n  var jsonLogicIsMethod = op == \"method\";\n\n  if (jsonLogicIsMethod) {\n    var obj, opts;\n\n    var _vals = (0, _toArray2[\"default\"])(vals);\n\n    obj = _vals[0];\n    func = _vals[1];\n    opts = _vals.slice(2);\n    argsArr = [obj].concat((0, _toConsumableArray2[\"default\"])(opts));\n  } else {\n    func = op;\n    argsArr = vals;\n  }\n\n  var fk = (jsonLogicIsMethod ? \"#\" : \"\") + func;\n  var funcKeys = (conv.funcs[fk] || []).filter(function (k) {\n    return fieldConfig ? config.funcs[k].returnType == fieldConfig.type : true;\n  });\n\n  if (funcKeys.length) {\n    funcKey = funcKeys[0];\n  } else {\n    var v = (0, _defineProperty2[\"default\"])({}, op, vals);\n\n    for (var _i = 0, _Object$entries = Object.entries(config.funcs || {}); _i < _Object$entries.length; _i++) {\n      var _Object$entries$_i = (0, _slicedToArray2[\"default\"])(_Object$entries[_i], 2),\n          f = _Object$entries$_i[0],\n          fc = _Object$entries$_i[1];\n\n      if (fc.jsonLogicImport && fc.returnType == fieldConfig.type) {\n        var parsed = void 0;\n\n        try {\n          parsed = fc.jsonLogicImport(v);\n        } catch (_e) {// given expression `v` can't be parsed into function\n        }\n\n        if (parsed) {\n          funcKey = f;\n          argsArr = parsed;\n        }\n      }\n    }\n  }\n\n  if (!funcKey) return undefined;\n\n  if (funcKey) {\n    var funcConfig = config.funcs[funcKey];\n    var argKeys = Object.keys(funcConfig.args || {});\n    var args = argsArr.reduce(function (acc, val, ind) {\n      var argKey = argKeys[ind];\n      var argConfig = funcConfig.args[argKey];\n      var argVal = convertFromLogic(val, conv, config, \"val\", meta, false, argConfig, null, parentField);\n\n      if (argVal === undefined) {\n        argVal = argConfig.defaultValue;\n\n        if (argVal === undefined) {\n          meta.errors.push(\"No value for arg \".concat(argKey, \" of func \").concat(funcKey));\n          return undefined;\n        }\n      }\n\n      return _objectSpread(_objectSpread({}, acc), {}, (0, _defineProperty2[\"default\"])({}, argKey, argVal));\n    }, {});\n    return {\n      valueSrc: \"func\",\n      value: {\n        func: funcKey,\n        args: args\n      },\n      valueType: funcConfig.returnType\n    };\n  }\n\n  return undefined;\n};\n\nvar convertConj = function convertConj(op, vals, conv, config, not, meta) {\n  var parentField = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n  var isRuleGroup = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;\n  var conjKey = conv.conjunctions[op];\n  var fieldSeparator = config.settings.fieldSeparator;\n  var parentFieldConfig = parentField ? (0, _configUtils.getFieldConfig)(config, parentField) : null;\n  var isParentGroup = (parentFieldConfig === null || parentFieldConfig === void 0 ? void 0 : parentFieldConfig.type) == \"!group\";\n\n  if (conjKey) {\n    var type = \"group\";\n    var children = vals.map(function (v) {\n      return convertFromLogic(v, conv, config, \"rule\", meta, false, null, null, parentField);\n    }).filter(function (r) {\n      return r !== undefined;\n    }).reduce(function (acc, r) {\n      return _objectSpread(_objectSpread({}, acc), {}, (0, _defineProperty2[\"default\"])({}, r.id, r));\n    }, {});\n    var complexFields = Object.values(children).map(function (v) {\n      var _v$properties;\n\n      return v === null || v === void 0 ? void 0 : (_v$properties = v.properties) === null || _v$properties === void 0 ? void 0 : _v$properties.field;\n    }).filter(function (f) {\n      return f && f.includes(fieldSeparator);\n    });\n    var complexFieldsGroupAncestors = Object.fromEntries(arrayUniq(complexFields).map(function (f) {\n      var parts = f.split(fieldSeparator);\n      var ancs = Object.fromEntries(parts.slice(0, -1).map(function (f, i, parts) {\n        return [].concat((0, _toConsumableArray2[\"default\"])(parts.slice(0, i)), [f]);\n      }).map(function (fp) {\n        return [fp.join(fieldSeparator), (0, _configUtils.getFieldConfig)(config, fp)];\n      }).filter(function (_ref3) {\n        var _ref4 = (0, _slicedToArray2[\"default\"])(_ref3, 2),\n            _f = _ref4[0],\n            fc = _ref4[1];\n\n        return fc.type == \"!group\";\n      }));\n      return [f, Object.keys(ancs)];\n    }));\n    var childrenInRuleGroup = Object.values(children).map(function (v) {\n      var _v$properties2;\n\n      return v === null || v === void 0 ? void 0 : (_v$properties2 = v.properties) === null || _v$properties2 === void 0 ? void 0 : _v$properties2.field;\n    }).map(function (f) {\n      return complexFieldsGroupAncestors[f];\n    }).filter(function (ancs) {\n      return ancs && ancs.length;\n    });\n    var usedRuleGroups = arrayUniq(Object.values(complexFieldsGroupAncestors).flat());\n    var usedTopRuleGroups = topLevelFieldsFilter(usedRuleGroups);\n    var properties = {\n      conjunction: conjKey,\n      not: not\n    };\n    var id = (0, _uuid[\"default\"])();\n    var children1 = {};\n    var groupToId = {};\n    Object.entries(children).map(function (_ref5) {\n      var _ref6 = (0, _slicedToArray2[\"default\"])(_ref5, 2),\n          k = _ref6[0],\n          v = _ref6[1];\n\n      if (v.type == \"group\" || v.type == \"rule_group\") {\n        // put as-is\n        children1[k] = v;\n      } else {\n        var _v$properties3;\n\n        var field = v === null || v === void 0 ? void 0 : (_v$properties3 = v.properties) === null || _v$properties3 === void 0 ? void 0 : _v$properties3.field;\n        var groupAncestors = complexFieldsGroupAncestors[field];\n        var groupField = groupAncestors === null || groupAncestors === void 0 ? void 0 : groupAncestors.at(-1);\n\n        if (!groupField) {\n          // not in rule_group (can be simple field or in struct) - put as-is\n          children1[k] = v;\n        } else {\n          // wrap field in rule_group (with creating hierarchy if need)\n          var ch = children1;\n          var parentFieldParts = parentField ? parentField.split(fieldSeparator) : [];\n          var isInParent = (0, _stuff.shallowEqual)(parentFieldParts, groupField.split(fieldSeparator).slice(0, parentFieldParts.length));\n          if (!isInParent) parentFieldParts = []; // should not be\n\n          var traverseGroupFields = groupField.split(fieldSeparator).slice(parentFieldParts.length).map(function (f, i, parts) {\n            return [].concat((0, _toConsumableArray2[\"default\"])(parentFieldParts), (0, _toConsumableArray2[\"default\"])(parts.slice(0, i)), [f]).join(fieldSeparator);\n          }).map(function (f) {\n            return (0, _configUtils.normalizeField)(config, f);\n          }).map(function (f) {\n            return {\n              f: f,\n              fc: (0, _configUtils.getFieldConfig)(config, f) || {}\n            };\n          }).filter(function (_ref7) {\n            var fc = _ref7.fc;\n            return fc.type != \"!struct\";\n          });\n          traverseGroupFields.map(function (_ref8, i) {\n            var gf = _ref8.f,\n                gfc = _ref8.fc;\n            var groupId = groupToId[gf];\n\n            if (!groupId) {\n              groupId = (0, _uuid[\"default\"])();\n              groupToId[gf] = groupId;\n              ch[groupId] = {\n                type: \"rule_group\",\n                id: groupId,\n                children1: {},\n                properties: {\n                  conjunction: conjKey,\n                  not: false,\n                  field: gf,\n                  mode: gfc.mode\n                }\n              };\n            }\n\n            ch = ch[groupId].children1;\n          });\n          ch[k] = v;\n        }\n      }\n    }); // tip: for isRuleGroup=true correct type and properties will be set out of this func\n\n    return {\n      type: type,\n      id: id,\n      children1: children1,\n      properties: properties\n    };\n  }\n\n  return undefined;\n};\n\nvar topLevelFieldsFilter = function topLevelFieldsFilter(fields) {\n  var arr = (0, _toConsumableArray2[\"default\"])(fields).sort(function (a, b) {\n    return a.length - b.length;\n  });\n\n  for (var i = 0; i < arr.length; i++) {\n    for (var j = i + 1; j < arr.length; j++) {\n      if (arr[j].indexOf(arr[i]) == 0) {\n        // arr[j] is inside arr[i] (eg. \"a.b\" inside \"a\")\n        arr.splice(j, 1);\n        j--;\n      }\n    }\n  }\n\n  return arr;\n};\n\nvar wrapInDefaultConjRuleGroup = function wrapInDefaultConjRuleGroup(rule, parentField, parentFieldConfig, config, conj) {\n  if (!rule) return undefined;\n  return {\n    type: \"rule_group\",\n    id: (0, _uuid[\"default\"])(),\n    children1: (0, _defineProperty2[\"default\"])({}, rule.id, rule),\n    properties: {\n      conjunction: conj || (0, _defaultUtils.defaultGroupConjunction)(config, parentFieldConfig),\n      not: false,\n      field: parentField\n    }\n  };\n};\n\nvar wrapInDefaultConj = function wrapInDefaultConj(rule, config) {\n  var not = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  return {\n    type: \"group\",\n    id: (0, _uuid[\"default\"])(),\n    children1: (0, _defineProperty2[\"default\"])({}, rule.id, rule),\n    properties: {\n      conjunction: (0, _defaultUtils.defaultConjunction)(config),\n      not: not\n    }\n  };\n};\n\nvar parseRule = function parseRule(op, arity, vals, parentField, conv, config, meta) {\n  var errors = [];\n\n  var res = _parseRule(op, arity, vals, parentField, conv, config, errors, false) || _parseRule(op, arity, vals, parentField, conv, config, errors, true);\n\n  if (!res) {\n    meta.errors.push(errors.join(\"; \") || \"Unknown op \".concat(op, \"/\").concat(arity));\n    return undefined;\n  }\n\n  return res;\n};\n\nvar _parseRule = function _parseRule(op, arity, vals, parentField, conv, config, errors, isRevArgs) {\n  // config.settings.groupOperators are used for group count (cardinality = 0 is exception)\n  // but don't confuse with \"all-in\" for multiselect\n  var isAllInForMultiselect = op == \"all\" && (0, _stuff.isJsonLogic)(vals[1]) && Object.keys(vals[1])[0] == \"in\";\n  var isGroup0 = !isAllInForMultiselect && config.settings.groupOperators.includes(op);\n  var eqOps = [\"==\", \"!=\"];\n  var cardinality = isGroup0 ? 0 : arity - 1;\n  if (isGroup0) cardinality = 0;else if (eqOps.includes(op) && cardinality == 1 && vals[1] === null) cardinality = 0;\n  var opk = op + \"/\" + cardinality;\n  var fieldSeparator = config.settings.fieldSeparator;\n  var opKeys = conv.operators[(isRevArgs ? \"#\" : \"\") + opk];\n  if (!opKeys) return;\n  var jlField,\n      args = [];\n  var rangeOps = [\"<\", \"<=\", \">\", \">=\"];\n\n  if (rangeOps.includes(op) && arity == 3) {\n    jlField = vals[1];\n    args = [vals[0], vals[2]];\n  } else if (isRevArgs) {\n    jlField = vals[1];\n    args = [vals[0]];\n  } else {\n    var _vals2 = (0, _toArray2[\"default\"])(vals);\n\n    jlField = _vals2[0];\n    args = _vals2.slice(1);\n  }\n\n  if (!(0, _stuff.isJsonLogic)(jlField)) {\n    errors.push(\"Incorrect operands for \".concat(op, \": \").concat(JSON.stringify(vals)));\n    return;\n  }\n\n  var k = Object.keys(jlField)[0];\n  var v = Object.values(jlField)[0];\n  var field, having, isGroup;\n\n  if (conv.varKeys.includes(k) && typeof v == \"string\") {\n    field = v;\n  }\n\n  if (isGroup0) {\n    isGroup = true;\n    having = args[0];\n    args = [];\n  } // reduce/filter for group ext\n\n\n  if (k == \"reduce\" && Array.isArray(v) && v.length == 3) {\n    var _v2 = v,\n        _v3 = (0, _slicedToArray2[\"default\"])(_v2, 3),\n        filter = _v3[0],\n        acc = _v3[1],\n        init = _v3[2];\n\n    if ((0, _stuff.isJsonLogic)(filter) && init == 0 && (0, _stuff.isJsonLogic)(acc) && Array.isArray(acc[\"+\"]) && acc[\"+\"][0] == 1 && (0, _stuff.isJsonLogic)(acc[\"+\"][1]) && acc[\"+\"][1][\"var\"] == \"accumulator\") {\n      k = Object.keys(filter)[0];\n      v = Object.values(filter)[0];\n\n      if (k == \"filter\") {\n        var _v4 = v,\n            _v5 = (0, _slicedToArray2[\"default\"])(_v4, 2),\n            group = _v5[0],\n            _filter = _v5[1];\n\n        if ((0, _stuff.isJsonLogic)(group)) {\n          k = Object.keys(group)[0];\n          v = Object.values(group)[0];\n\n          if (conv.varKeys.includes(k) && typeof v == \"string\") {\n            field = v;\n            having = _filter;\n            isGroup = true;\n          }\n        }\n      } else if (conv.varKeys.includes(k) && typeof v == \"string\") {\n        field = v;\n        isGroup = true;\n      }\n    }\n  }\n\n  if (!field) {\n    errors.push(\"Unknown field \".concat(JSON.stringify(jlField)));\n    return;\n  }\n\n  if (parentField) field = [parentField, field].join(fieldSeparator);\n  field = (0, _configUtils.normalizeField)(config, field);\n  var fieldConfig = (0, _configUtils.getFieldConfig)(config, field);\n\n  if (!fieldConfig) {\n    errors.push(\"No config for field \".concat(field));\n    return;\n  }\n\n  var opKey = opKeys[0];\n\n  if (opKeys.length > 1 && fieldConfig && fieldConfig.operators) {\n    // eg. for \"equal\" and \"select_equals\"\n    opKeys = opKeys.filter(function (k) {\n      return fieldConfig.operators.includes(k);\n    });\n\n    if (opKeys.length == 0) {\n      errors.push(\"No corresponding ops for field \".concat(field));\n      return;\n    }\n\n    opKey = opKeys[0];\n  }\n\n  return {\n    field: field,\n    fieldConfig: fieldConfig,\n    opKey: opKey,\n    args: args,\n    having: having\n  };\n};\n\nvar convertOp = function convertOp(op, vals, conv, config, not, meta) {\n  var parentField = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n  if (!op) return undefined;\n  var arity = vals.length;\n\n  if (op == \"all\" && (0, _stuff.isJsonLogic)(vals[1])) {\n    // special case for \"all-in\"\n    var op2 = Object.keys(vals[1])[0];\n\n    if (op2 == \"in\") {\n      vals = [vals[0], vals[1][op2][1]];\n      op = op + \"-\" + op2; // \"all-in\"\n    }\n  }\n\n  var parseRes = parseRule(op, arity, vals, parentField, conv, config, meta);\n  if (!parseRes) return undefined;\n  var field = parseRes.field,\n      fieldConfig = parseRes.fieldConfig,\n      opKey = parseRes.opKey,\n      args = parseRes.args,\n      having = parseRes.having;\n  var opConfig = config.operators[opKey]; // Group component in array mode can show NOT checkbox, so do nothing in this case\n  // Otherwise try to revert\n\n  var showNot = fieldConfig.showNot !== undefined ? fieldConfig.showNot : config.settings.showNot;\n  var canRev = true; // if (fieldConfig.type == \"!group\" && fieldConfig.mode == \"array\" && showNot)\n  //   canRev = false;\n\n  var conj;\n  var havingVals;\n\n  if (fieldConfig.type == \"!group\" && having) {\n    conj = Object.keys(having)[0];\n    havingVals = having[conj];\n    if (!Array.isArray(havingVals)) havingVals = [havingVals]; // Preprocess \"!\": Try to reverse op in single rule in having\n    // Eg. use `not_equal` instead of `not` `equal`\n\n    var isEmptyOp = conj == \"!\" && havingVals.length == 1 && havingVals[0] && (0, _stuff.isJsonLogic)(havingVals[0]) && conv.varKeys.includes(Object.keys(havingVals[0])[0]);\n\n    if (conj == \"!\" && !isEmptyOp) {\n      not = !not;\n      having = having[\"!\"];\n      conj = Object.keys(having)[0];\n      havingVals = having[conj];\n      if (!Array.isArray(havingVals)) havingVals = [havingVals];\n    }\n  } // Use reversed op\n\n\n  if (not && canRev && opConfig.reversedOp) {\n    not = false;\n    opKey = opConfig.reversedOp;\n    opConfig = config.operators[opKey];\n  }\n\n  var widget = (0, _ruleUtils.getWidgetForFieldOp)(config, field, opKey);\n  var convertedArgs = args.map(function (v) {\n    return convertFromLogic(v, conv, config, \"val\", meta, false, fieldConfig, widget, parentField);\n  });\n\n  if (convertedArgs.filter(function (v) {\n    return v === undefined;\n  }).length) {\n    //meta.errors.push(`Undefined arg for field ${field} and op ${opKey}`);\n    return undefined;\n  }\n\n  var res;\n\n  if (fieldConfig.type == \"!group\" && having) {\n    if (conv.conjunctions[conj] !== undefined) {\n      res = convertConj(conj, havingVals, conv, config, not, meta, field, true);\n      not = false; // not was applied to group\n    } else {\n      var _rule$properties; // need to be wrapped in `rule_group`\n\n\n      var rule = convertOp(conj, havingVals, conv, config, not && canRev, meta, field);\n\n      if (not && canRev && !(rule !== null && rule !== void 0 && (_rule$properties = rule.properties) !== null && _rule$properties !== void 0 && _rule$properties.not)) {\n        not = false; // op was reversed in rule\n      }\n\n      res = wrapInDefaultConjRuleGroup(rule, field, fieldConfig, config, conv.conjunctions[\"and\"]);\n    }\n\n    if (!res) return undefined;\n    res.type = \"rule_group\";\n\n    if (not) {\n      Object.assign(res.properties, {\n        not: not\n      });\n    }\n\n    Object.assign(res.properties, {\n      field: field,\n      mode: fieldConfig.mode,\n      operator: opKey\n    });\n\n    if (fieldConfig.mode == \"array\") {\n      Object.assign(res.properties, {\n        value: convertedArgs.map(function (v) {\n          return v.value;\n        }),\n        valueSrc: convertedArgs.map(function (v) {\n          return v.valueSrc;\n        }),\n        valueType: convertedArgs.map(function (v) {\n          return v.valueType;\n        })\n      });\n    }\n  } else if (fieldConfig.type == \"!group\" && !having) {\n    res = {\n      type: \"rule_group\",\n      id: (0, _uuid[\"default\"])(),\n      children1: {},\n      properties: {\n        conjunction: (0, _defaultUtils.defaultGroupConjunction)(config, fieldConfig),\n        not: not,\n        mode: fieldConfig.mode,\n        field: field,\n        operator: opKey\n      }\n    };\n\n    if (fieldConfig.mode == \"array\") {\n      Object.assign(res.properties, {\n        value: convertedArgs.map(function (v) {\n          return v.value;\n        }),\n        valueSrc: convertedArgs.map(function (v) {\n          return v.valueSrc;\n        }),\n        valueType: convertedArgs.map(function (v) {\n          return v.valueType;\n        })\n      });\n    }\n  } else {\n    var asyncListValuesArr = convertedArgs.map(function (v) {\n      return v.asyncListValues;\n    }).filter(function (v) {\n      return v != undefined;\n    });\n    var asyncListValues = asyncListValuesArr.length ? asyncListValuesArr[0] : undefined;\n    res = {\n      type: \"rule\",\n      id: (0, _uuid[\"default\"])(),\n      properties: {\n        field: field,\n        operator: opKey,\n        value: convertedArgs.map(function (v) {\n          return v.value;\n        }),\n        valueSrc: convertedArgs.map(function (v) {\n          return v.valueSrc;\n        }),\n        valueType: convertedArgs.map(function (v) {\n          return v.valueType;\n        }),\n        asyncListValues: asyncListValues\n      }\n    };\n\n    if (not) {\n      //meta.errors.push(`No rev op for ${opKey}`);\n      res = wrapInDefaultConj(res, config, not);\n    }\n  }\n\n  return res;\n};","map":{"version":3,"sources":["D:/Postgres_workingFolder/QuaLISWeb/node_modules/react-awesome-query-builder/lib/import/jsonLogic.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","loadFromJsonLogic","_toConsumableArray2","_toArray2","_defineProperty2","_slicedToArray2","_uuid","_stuff","_configUtils","_ruleUtils","_tree","_defaultUtils","_moment","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","arrayUniq","arr","Array","from","Set","arrayToObject","reduce","acc","_ref","_ref2","f","fc","logicTree","config","meta","errors","extendedConfig","extendConfig","conv","buildConv","jsTree","convertFromLogic","undefined","type","wrapInDefaultConj","immTree","loadTree","console","warn","operators","opKey","opConfig","jsonLogic","opk","_jsonLogicIsRevArgs","defaultValue","cardinality","jsonLogic2","_opk","conjunctions","conjKey","ck","toLowerCase","funcs","funcKey","funcConfig","fk","jsonLogicIsMethod","_config$settings$json","settings","groupVarKey","altVarKey","varKeys","logic","expectedType","not","fieldConfig","widget","parentField","_isLockedLogic","op","vals","isJsonLogic","isArray","ret","beforeErrorsCnt","lockedOp","isEmptyOp","includes","isRev","isLocked","convertField","convertFunc","convertVal","convertConj","convertOp","afterErrorsCnt","concat","JSON","stringify","properties","val","widgetConfig","widgets","mainWidget","h","Math","floor","m","s","valueFormat","dateVal","Date","setMilliseconds","setHours","setMinutes","setSeconds","format","_dateVal","toISOString","e","_valueFormat","asyncListValues","fieldSettings","asyncFetch","valueSrc","valueType","fieldSeparator","field","join","normalizeField","getFieldConfig","func","argsArr","obj","opts","_vals","slice","funcKeys","k","returnType","v","_i","_Object$entries","entries","_Object$entries$_i","jsonLogicImport","parsed","_e","argKeys","args","ind","argKey","argConfig","argVal","isRuleGroup","parentFieldConfig","isParentGroup","children","map","r","id","complexFields","values","_v$properties","complexFieldsGroupAncestors","fromEntries","parts","split","ancs","fp","_ref3","_ref4","_f","childrenInRuleGroup","_v$properties2","usedRuleGroups","flat","usedTopRuleGroups","topLevelFieldsFilter","conjunction","children1","groupToId","_ref5","_ref6","_v$properties3","groupAncestors","groupField","at","ch","parentFieldParts","isInParent","shallowEqual","traverseGroupFields","_ref7","_ref8","gf","gfc","groupId","mode","fields","sort","a","b","j","indexOf","splice","wrapInDefaultConjRuleGroup","rule","conj","defaultGroupConjunction","defaultConjunction","parseRule","arity","res","_parseRule","isRevArgs","isAllInForMultiselect","isGroup0","groupOperators","eqOps","opKeys","jlField","rangeOps","_vals2","having","isGroup","_v2","_v3","init","_v4","_v5","group","_filter","op2","parseRes","showNot","canRev","havingVals","reversedOp","getWidgetForFieldOp","convertedArgs","_rule$properties","assign","operator","asyncListValuesArr"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.loadFromJsonLogic = void 0;\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _toArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toArray\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _uuid = _interopRequireDefault(require(\"../utils/uuid\"));\n\nvar _stuff = require(\"../utils/stuff\");\n\nvar _configUtils = require(\"../utils/configUtils\");\n\nvar _ruleUtils = require(\"../utils/ruleUtils\");\n\nvar _tree = require(\"./tree\");\n\nvar _defaultUtils = require(\"../utils/defaultUtils\");\n\nvar _moment = _interopRequireDefault(require(\"moment\"));\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2[\"default\"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\n// http://jsonlogic.com/\n// helpers\nvar arrayUniq = function arrayUniq(arr) {\n  return Array.from(new Set(arr));\n};\n\nvar arrayToObject = function arrayToObject(arr) {\n  return arr.reduce(function (acc, _ref) {\n    var _ref2 = (0, _slicedToArray2[\"default\"])(_ref, 2),\n        f = _ref2[0],\n        fc = _ref2[1];\n\n    return _objectSpread(_objectSpread({}, acc), {}, (0, _defineProperty2[\"default\"])({}, f, fc));\n  }, {});\n};\n\nvar loadFromJsonLogic = function loadFromJsonLogic(logicTree, config) {\n  //meta is mutable\n  var meta = {\n    errors: []\n  };\n  var extendedConfig = (0, _configUtils.extendConfig)(config);\n  var conv = buildConv(extendedConfig);\n  var jsTree = logicTree ? convertFromLogic(logicTree, conv, extendedConfig, \"rule\", meta) : undefined;\n\n  if (jsTree && jsTree.type != \"group\") {\n    jsTree = wrapInDefaultConj(jsTree, extendedConfig);\n  }\n\n  var immTree = jsTree ? (0, _tree.loadTree)(jsTree) : undefined;\n  if (meta.errors.length) console.warn(\"Errors while importing from JsonLogic:\", meta.errors);\n  return immTree;\n};\n\nexports.loadFromJsonLogic = loadFromJsonLogic;\n\nvar buildConv = function buildConv(config) {\n  var operators = {};\n\n  for (var opKey in config.operators) {\n    var opConfig = config.operators[opKey];\n\n    if (typeof opConfig.jsonLogic == \"string\") {\n      // example: \"</2\", \"#in/1\"\n      var opk = (opConfig._jsonLogicIsRevArgs ? \"#\" : \"\") + opConfig.jsonLogic + \"/\" + (0, _stuff.defaultValue)(opConfig.cardinality, 1);\n      if (!operators[opk]) operators[opk] = [];\n      operators[opk].push(opKey);\n    } else if (typeof opConfig.jsonLogic2 == \"string\") {\n      // example: all-in/1\"\n      var _opk = opConfig.jsonLogic2 + \"/\" + (0, _stuff.defaultValue)(opConfig.cardinality, 1);\n\n      if (!operators[_opk]) operators[_opk] = [];\n\n      operators[_opk].push(opKey);\n    }\n  }\n\n  var conjunctions = {};\n\n  for (var conjKey in config.conjunctions) {\n    var ck = conjKey.toLowerCase();\n    conjunctions[ck] = conjKey;\n  }\n\n  var funcs = {};\n\n  for (var funcKey in config.funcs) {\n    var funcConfig = config.funcs[funcKey];\n    var fk = void 0;\n\n    if (funcConfig.jsonLogicIsMethod) {\n      fk = \"#\" + funcConfig.jsonLogic;\n    } else if (typeof funcConfig.jsonLogic == \"string\") {\n      fk = funcConfig.jsonLogic;\n    }\n\n    if (fk) {\n      if (!funcs[fk]) funcs[fk] = [];\n      funcs[fk].push(funcKey);\n    }\n  }\n\n  var _config$settings$json = config.settings.jsonLogic,\n      groupVarKey = _config$settings$json.groupVarKey,\n      altVarKey = _config$settings$json.altVarKey;\n  return {\n    operators: operators,\n    conjunctions: conjunctions,\n    funcs: funcs,\n    varKeys: [\"var\", groupVarKey, altVarKey]\n  };\n};\n\nvar convertFromLogic = function convertFromLogic(logic, conv, config, expectedType, meta) {\n  var not = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  var fieldConfig = arguments.length > 6 ? arguments[6] : undefined;\n  var widget = arguments.length > 7 ? arguments[7] : undefined;\n  var parentField = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : null;\n\n  var _isLockedLogic = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : false;\n\n  var op, vals;\n\n  if ((0, _stuff.isJsonLogic)(logic)) {\n    op = Object.keys(logic)[0];\n    vals = logic[op];\n    if (!Array.isArray(vals)) vals = [vals];\n  }\n\n  var ret;\n  var beforeErrorsCnt = meta.errors.length;\n  var lockedOp = config.settings.jsonLogic.lockedOp;\n  var isEmptyOp = op == \"!\" && vals.length == 1 && vals[0] && (0, _stuff.isJsonLogic)(vals[0]) && conv.varKeys.includes(Object.keys(vals[0])[0]);\n  var isRev = op == \"!\" && !isEmptyOp;\n  var isLocked = lockedOp && op == lockedOp;\n\n  if (isLocked) {\n    ret = convertFromLogic(vals[0], conv, config, expectedType, meta, not, fieldConfig, widget, parentField, true);\n  } else if (isRev) {\n    // reverse with not\n    ret = convertFromLogic(vals[0], conv, config, expectedType, meta, !not, fieldConfig, widget, parentField);\n  } else if (expectedType == \"val\") {\n    // not is not used here\n    ret = convertField(op, vals, conv, config, not, meta, parentField) || convertFunc(op, vals, conv, config, not, fieldConfig, meta, parentField) || convertVal(logic, fieldConfig, widget, config, meta);\n  } else if (expectedType == \"rule\") {\n    ret = convertConj(op, vals, conv, config, not, meta, parentField, false) || convertOp(op, vals, conv, config, not, meta, parentField);\n  }\n\n  var afterErrorsCnt = meta.errors.length;\n\n  if (op != \"!\" && ret === undefined && afterErrorsCnt == beforeErrorsCnt) {\n    meta.errors.push(\"Can't parse logic \".concat(JSON.stringify(logic)));\n  }\n\n  if (isLocked) {\n    ret.properties.isLocked = true;\n  }\n\n  return ret;\n};\n\nvar convertVal = function convertVal(val, fieldConfig, widget, config, meta) {\n  if (val === undefined) return undefined;\n  var widgetConfig = config.widgets[widget || fieldConfig.mainWidget];\n\n  if (!widgetConfig) {\n    meta.errors.push(\"No widget for type \".concat(fieldConfig.type));\n    return undefined;\n  }\n\n  if ((0, _stuff.isJsonLogic)(val)) {\n    meta.errors.push(\"Unexpected logic in value: \".concat(JSON.stringify(val)));\n    return undefined;\n  } // number of seconds -> time string\n\n\n  if (fieldConfig && fieldConfig.type == \"time\" && typeof val == \"number\") {\n    var h = Math.floor(val / 60 / 60) % 24,\n        m = Math.floor(val / 60) % 60,\n        s = val % 60;\n    var valueFormat = widgetConfig.valueFormat;\n\n    if (valueFormat) {\n      var dateVal = new Date(val);\n      dateVal.setMilliseconds(0);\n      dateVal.setHours(h);\n      dateVal.setMinutes(m);\n      dateVal.setSeconds(s);\n      val = (0, _moment[\"default\"])(dateVal).format(valueFormat);\n    } else {\n      val = \"\".concat(h, \":\").concat(m, \":\").concat(s);\n    }\n  } // \"2020-01-08T22:00:00.000Z\" -> Date object\n\n\n  if (fieldConfig && [\"date\", \"datetime\"].includes(fieldConfig.type) && val && !(val instanceof Date)) {\n    try {\n      var _dateVal = new Date(val);\n\n      if (_dateVal instanceof Date && _dateVal.toISOString() === val) {\n        val = _dateVal;\n      }\n    } catch (e) {\n      meta.errors.push(\"Can't convert value \".concat(val, \" as Date\"));\n      val = undefined;\n    }\n  } // Date object -> formatted string\n\n\n  if (val instanceof Date && fieldConfig) {\n    var _valueFormat = widgetConfig.valueFormat;\n\n    if (_valueFormat) {\n      val = (0, _moment[\"default\"])(val).format(_valueFormat);\n    }\n  }\n\n  var asyncListValues;\n\n  if (val && fieldConfig.fieldSettings && fieldConfig.fieldSettings.asyncFetch) {\n    var vals = Array.isArray(val) ? val : [val];\n    asyncListValues = vals;\n  }\n\n  return {\n    valueSrc: \"value\",\n    value: val,\n    valueType: widgetConfig.type,\n    asyncListValues: asyncListValues\n  };\n};\n\nvar convertField = function convertField(op, vals, conv, config, not, meta) {\n  var parentField = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n  var fieldSeparator = config.settings.fieldSeparator;\n\n  if (conv.varKeys.includes(op) && typeof vals[0] == \"string\") {\n    var field = vals[0];\n    if (parentField) field = [parentField, field].join(fieldSeparator);\n    field = (0, _configUtils.normalizeField)(config, field);\n    var fieldConfig = (0, _configUtils.getFieldConfig)(config, field);\n\n    if (!fieldConfig) {\n      meta.errors.push(\"No config for field \".concat(field));\n      return undefined;\n    }\n\n    return {\n      valueSrc: \"field\",\n      value: field,\n      valueType: fieldConfig.type\n    };\n  }\n\n  return undefined;\n};\n\nvar convertFunc = function convertFunc(op, vals, conv, config, not, fieldConfig, meta) {\n  var parentField = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;\n  if (!op) return undefined;\n  var func, argsArr, funcKey;\n  var jsonLogicIsMethod = op == \"method\";\n\n  if (jsonLogicIsMethod) {\n    var obj, opts;\n\n    var _vals = (0, _toArray2[\"default\"])(vals);\n\n    obj = _vals[0];\n    func = _vals[1];\n    opts = _vals.slice(2);\n    argsArr = [obj].concat((0, _toConsumableArray2[\"default\"])(opts));\n  } else {\n    func = op;\n    argsArr = vals;\n  }\n\n  var fk = (jsonLogicIsMethod ? \"#\" : \"\") + func;\n  var funcKeys = (conv.funcs[fk] || []).filter(function (k) {\n    return fieldConfig ? config.funcs[k].returnType == fieldConfig.type : true;\n  });\n\n  if (funcKeys.length) {\n    funcKey = funcKeys[0];\n  } else {\n    var v = (0, _defineProperty2[\"default\"])({}, op, vals);\n\n    for (var _i = 0, _Object$entries = Object.entries(config.funcs || {}); _i < _Object$entries.length; _i++) {\n      var _Object$entries$_i = (0, _slicedToArray2[\"default\"])(_Object$entries[_i], 2),\n          f = _Object$entries$_i[0],\n          fc = _Object$entries$_i[1];\n\n      if (fc.jsonLogicImport && fc.returnType == fieldConfig.type) {\n        var parsed = void 0;\n\n        try {\n          parsed = fc.jsonLogicImport(v);\n        } catch (_e) {// given expression `v` can't be parsed into function\n        }\n\n        if (parsed) {\n          funcKey = f;\n          argsArr = parsed;\n        }\n      }\n    }\n  }\n\n  if (!funcKey) return undefined;\n\n  if (funcKey) {\n    var funcConfig = config.funcs[funcKey];\n    var argKeys = Object.keys(funcConfig.args || {});\n    var args = argsArr.reduce(function (acc, val, ind) {\n      var argKey = argKeys[ind];\n      var argConfig = funcConfig.args[argKey];\n      var argVal = convertFromLogic(val, conv, config, \"val\", meta, false, argConfig, null, parentField);\n\n      if (argVal === undefined) {\n        argVal = argConfig.defaultValue;\n\n        if (argVal === undefined) {\n          meta.errors.push(\"No value for arg \".concat(argKey, \" of func \").concat(funcKey));\n          return undefined;\n        }\n      }\n\n      return _objectSpread(_objectSpread({}, acc), {}, (0, _defineProperty2[\"default\"])({}, argKey, argVal));\n    }, {});\n    return {\n      valueSrc: \"func\",\n      value: {\n        func: funcKey,\n        args: args\n      },\n      valueType: funcConfig.returnType\n    };\n  }\n\n  return undefined;\n};\n\nvar convertConj = function convertConj(op, vals, conv, config, not, meta) {\n  var parentField = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n  var isRuleGroup = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;\n  var conjKey = conv.conjunctions[op];\n  var fieldSeparator = config.settings.fieldSeparator;\n  var parentFieldConfig = parentField ? (0, _configUtils.getFieldConfig)(config, parentField) : null;\n  var isParentGroup = (parentFieldConfig === null || parentFieldConfig === void 0 ? void 0 : parentFieldConfig.type) == \"!group\";\n\n  if (conjKey) {\n    var type = \"group\";\n    var children = vals.map(function (v) {\n      return convertFromLogic(v, conv, config, \"rule\", meta, false, null, null, parentField);\n    }).filter(function (r) {\n      return r !== undefined;\n    }).reduce(function (acc, r) {\n      return _objectSpread(_objectSpread({}, acc), {}, (0, _defineProperty2[\"default\"])({}, r.id, r));\n    }, {});\n    var complexFields = Object.values(children).map(function (v) {\n      var _v$properties;\n\n      return v === null || v === void 0 ? void 0 : (_v$properties = v.properties) === null || _v$properties === void 0 ? void 0 : _v$properties.field;\n    }).filter(function (f) {\n      return f && f.includes(fieldSeparator);\n    });\n    var complexFieldsGroupAncestors = Object.fromEntries(arrayUniq(complexFields).map(function (f) {\n      var parts = f.split(fieldSeparator);\n      var ancs = Object.fromEntries(parts.slice(0, -1).map(function (f, i, parts) {\n        return [].concat((0, _toConsumableArray2[\"default\"])(parts.slice(0, i)), [f]);\n      }).map(function (fp) {\n        return [fp.join(fieldSeparator), (0, _configUtils.getFieldConfig)(config, fp)];\n      }).filter(function (_ref3) {\n        var _ref4 = (0, _slicedToArray2[\"default\"])(_ref3, 2),\n            _f = _ref4[0],\n            fc = _ref4[1];\n\n        return fc.type == \"!group\";\n      }));\n      return [f, Object.keys(ancs)];\n    }));\n    var childrenInRuleGroup = Object.values(children).map(function (v) {\n      var _v$properties2;\n\n      return v === null || v === void 0 ? void 0 : (_v$properties2 = v.properties) === null || _v$properties2 === void 0 ? void 0 : _v$properties2.field;\n    }).map(function (f) {\n      return complexFieldsGroupAncestors[f];\n    }).filter(function (ancs) {\n      return ancs && ancs.length;\n    });\n    var usedRuleGroups = arrayUniq(Object.values(complexFieldsGroupAncestors).flat());\n    var usedTopRuleGroups = topLevelFieldsFilter(usedRuleGroups);\n    var properties = {\n      conjunction: conjKey,\n      not: not\n    };\n    var id = (0, _uuid[\"default\"])();\n    var children1 = {};\n    var groupToId = {};\n    Object.entries(children).map(function (_ref5) {\n      var _ref6 = (0, _slicedToArray2[\"default\"])(_ref5, 2),\n          k = _ref6[0],\n          v = _ref6[1];\n\n      if (v.type == \"group\" || v.type == \"rule_group\") {\n        // put as-is\n        children1[k] = v;\n      } else {\n        var _v$properties3;\n\n        var field = v === null || v === void 0 ? void 0 : (_v$properties3 = v.properties) === null || _v$properties3 === void 0 ? void 0 : _v$properties3.field;\n        var groupAncestors = complexFieldsGroupAncestors[field];\n        var groupField = groupAncestors === null || groupAncestors === void 0 ? void 0 : groupAncestors.at(-1);\n\n        if (!groupField) {\n          // not in rule_group (can be simple field or in struct) - put as-is\n          children1[k] = v;\n        } else {\n          // wrap field in rule_group (with creating hierarchy if need)\n          var ch = children1;\n          var parentFieldParts = parentField ? parentField.split(fieldSeparator) : [];\n          var isInParent = (0, _stuff.shallowEqual)(parentFieldParts, groupField.split(fieldSeparator).slice(0, parentFieldParts.length));\n          if (!isInParent) parentFieldParts = []; // should not be\n\n          var traverseGroupFields = groupField.split(fieldSeparator).slice(parentFieldParts.length).map(function (f, i, parts) {\n            return [].concat((0, _toConsumableArray2[\"default\"])(parentFieldParts), (0, _toConsumableArray2[\"default\"])(parts.slice(0, i)), [f]).join(fieldSeparator);\n          }).map(function (f) {\n            return (0, _configUtils.normalizeField)(config, f);\n          }).map(function (f) {\n            return {\n              f: f,\n              fc: (0, _configUtils.getFieldConfig)(config, f) || {}\n            };\n          }).filter(function (_ref7) {\n            var fc = _ref7.fc;\n            return fc.type != \"!struct\";\n          });\n          traverseGroupFields.map(function (_ref8, i) {\n            var gf = _ref8.f,\n                gfc = _ref8.fc;\n            var groupId = groupToId[gf];\n\n            if (!groupId) {\n              groupId = (0, _uuid[\"default\"])();\n              groupToId[gf] = groupId;\n              ch[groupId] = {\n                type: \"rule_group\",\n                id: groupId,\n                children1: {},\n                properties: {\n                  conjunction: conjKey,\n                  not: false,\n                  field: gf,\n                  mode: gfc.mode\n                }\n              };\n            }\n\n            ch = ch[groupId].children1;\n          });\n          ch[k] = v;\n        }\n      }\n    }); // tip: for isRuleGroup=true correct type and properties will be set out of this func\n\n    return {\n      type: type,\n      id: id,\n      children1: children1,\n      properties: properties\n    };\n  }\n\n  return undefined;\n};\n\nvar topLevelFieldsFilter = function topLevelFieldsFilter(fields) {\n  var arr = (0, _toConsumableArray2[\"default\"])(fields).sort(function (a, b) {\n    return a.length - b.length;\n  });\n\n  for (var i = 0; i < arr.length; i++) {\n    for (var j = i + 1; j < arr.length; j++) {\n      if (arr[j].indexOf(arr[i]) == 0) {\n        // arr[j] is inside arr[i] (eg. \"a.b\" inside \"a\")\n        arr.splice(j, 1);\n        j--;\n      }\n    }\n  }\n\n  return arr;\n};\n\nvar wrapInDefaultConjRuleGroup = function wrapInDefaultConjRuleGroup(rule, parentField, parentFieldConfig, config, conj) {\n  if (!rule) return undefined;\n  return {\n    type: \"rule_group\",\n    id: (0, _uuid[\"default\"])(),\n    children1: (0, _defineProperty2[\"default\"])({}, rule.id, rule),\n    properties: {\n      conjunction: conj || (0, _defaultUtils.defaultGroupConjunction)(config, parentFieldConfig),\n      not: false,\n      field: parentField\n    }\n  };\n};\n\nvar wrapInDefaultConj = function wrapInDefaultConj(rule, config) {\n  var not = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  return {\n    type: \"group\",\n    id: (0, _uuid[\"default\"])(),\n    children1: (0, _defineProperty2[\"default\"])({}, rule.id, rule),\n    properties: {\n      conjunction: (0, _defaultUtils.defaultConjunction)(config),\n      not: not\n    }\n  };\n};\n\nvar parseRule = function parseRule(op, arity, vals, parentField, conv, config, meta) {\n  var errors = [];\n\n  var res = _parseRule(op, arity, vals, parentField, conv, config, errors, false) || _parseRule(op, arity, vals, parentField, conv, config, errors, true);\n\n  if (!res) {\n    meta.errors.push(errors.join(\"; \") || \"Unknown op \".concat(op, \"/\").concat(arity));\n    return undefined;\n  }\n\n  return res;\n};\n\nvar _parseRule = function _parseRule(op, arity, vals, parentField, conv, config, errors, isRevArgs) {\n  // config.settings.groupOperators are used for group count (cardinality = 0 is exception)\n  // but don't confuse with \"all-in\" for multiselect\n  var isAllInForMultiselect = op == \"all\" && (0, _stuff.isJsonLogic)(vals[1]) && Object.keys(vals[1])[0] == \"in\";\n  var isGroup0 = !isAllInForMultiselect && config.settings.groupOperators.includes(op);\n  var eqOps = [\"==\", \"!=\"];\n  var cardinality = isGroup0 ? 0 : arity - 1;\n  if (isGroup0) cardinality = 0;else if (eqOps.includes(op) && cardinality == 1 && vals[1] === null) cardinality = 0;\n  var opk = op + \"/\" + cardinality;\n  var fieldSeparator = config.settings.fieldSeparator;\n  var opKeys = conv.operators[(isRevArgs ? \"#\" : \"\") + opk];\n  if (!opKeys) return;\n  var jlField,\n      args = [];\n  var rangeOps = [\"<\", \"<=\", \">\", \">=\"];\n\n  if (rangeOps.includes(op) && arity == 3) {\n    jlField = vals[1];\n    args = [vals[0], vals[2]];\n  } else if (isRevArgs) {\n    jlField = vals[1];\n    args = [vals[0]];\n  } else {\n    var _vals2 = (0, _toArray2[\"default\"])(vals);\n\n    jlField = _vals2[0];\n    args = _vals2.slice(1);\n  }\n\n  if (!(0, _stuff.isJsonLogic)(jlField)) {\n    errors.push(\"Incorrect operands for \".concat(op, \": \").concat(JSON.stringify(vals)));\n    return;\n  }\n\n  var k = Object.keys(jlField)[0];\n  var v = Object.values(jlField)[0];\n  var field, having, isGroup;\n\n  if (conv.varKeys.includes(k) && typeof v == \"string\") {\n    field = v;\n  }\n\n  if (isGroup0) {\n    isGroup = true;\n    having = args[0];\n    args = [];\n  } // reduce/filter for group ext\n\n\n  if (k == \"reduce\" && Array.isArray(v) && v.length == 3) {\n    var _v2 = v,\n        _v3 = (0, _slicedToArray2[\"default\"])(_v2, 3),\n        filter = _v3[0],\n        acc = _v3[1],\n        init = _v3[2];\n\n    if ((0, _stuff.isJsonLogic)(filter) && init == 0 && (0, _stuff.isJsonLogic)(acc) && Array.isArray(acc[\"+\"]) && acc[\"+\"][0] == 1 && (0, _stuff.isJsonLogic)(acc[\"+\"][1]) && acc[\"+\"][1][\"var\"] == \"accumulator\") {\n      k = Object.keys(filter)[0];\n      v = Object.values(filter)[0];\n\n      if (k == \"filter\") {\n        var _v4 = v,\n            _v5 = (0, _slicedToArray2[\"default\"])(_v4, 2),\n            group = _v5[0],\n            _filter = _v5[1];\n\n        if ((0, _stuff.isJsonLogic)(group)) {\n          k = Object.keys(group)[0];\n          v = Object.values(group)[0];\n\n          if (conv.varKeys.includes(k) && typeof v == \"string\") {\n            field = v;\n            having = _filter;\n            isGroup = true;\n          }\n        }\n      } else if (conv.varKeys.includes(k) && typeof v == \"string\") {\n        field = v;\n        isGroup = true;\n      }\n    }\n  }\n\n  if (!field) {\n    errors.push(\"Unknown field \".concat(JSON.stringify(jlField)));\n    return;\n  }\n\n  if (parentField) field = [parentField, field].join(fieldSeparator);\n  field = (0, _configUtils.normalizeField)(config, field);\n  var fieldConfig = (0, _configUtils.getFieldConfig)(config, field);\n\n  if (!fieldConfig) {\n    errors.push(\"No config for field \".concat(field));\n    return;\n  }\n\n  var opKey = opKeys[0];\n\n  if (opKeys.length > 1 && fieldConfig && fieldConfig.operators) {\n    // eg. for \"equal\" and \"select_equals\"\n    opKeys = opKeys.filter(function (k) {\n      return fieldConfig.operators.includes(k);\n    });\n\n    if (opKeys.length == 0) {\n      errors.push(\"No corresponding ops for field \".concat(field));\n      return;\n    }\n\n    opKey = opKeys[0];\n  }\n\n  return {\n    field: field,\n    fieldConfig: fieldConfig,\n    opKey: opKey,\n    args: args,\n    having: having\n  };\n};\n\nvar convertOp = function convertOp(op, vals, conv, config, not, meta) {\n  var parentField = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n  if (!op) return undefined;\n  var arity = vals.length;\n\n  if (op == \"all\" && (0, _stuff.isJsonLogic)(vals[1])) {\n    // special case for \"all-in\"\n    var op2 = Object.keys(vals[1])[0];\n\n    if (op2 == \"in\") {\n      vals = [vals[0], vals[1][op2][1]];\n      op = op + \"-\" + op2; // \"all-in\"\n    }\n  }\n\n  var parseRes = parseRule(op, arity, vals, parentField, conv, config, meta);\n  if (!parseRes) return undefined;\n  var field = parseRes.field,\n      fieldConfig = parseRes.fieldConfig,\n      opKey = parseRes.opKey,\n      args = parseRes.args,\n      having = parseRes.having;\n  var opConfig = config.operators[opKey]; // Group component in array mode can show NOT checkbox, so do nothing in this case\n  // Otherwise try to revert\n\n  var showNot = fieldConfig.showNot !== undefined ? fieldConfig.showNot : config.settings.showNot;\n  var canRev = true; // if (fieldConfig.type == \"!group\" && fieldConfig.mode == \"array\" && showNot)\n  //   canRev = false;\n\n  var conj;\n  var havingVals;\n\n  if (fieldConfig.type == \"!group\" && having) {\n    conj = Object.keys(having)[0];\n    havingVals = having[conj];\n    if (!Array.isArray(havingVals)) havingVals = [havingVals]; // Preprocess \"!\": Try to reverse op in single rule in having\n    // Eg. use `not_equal` instead of `not` `equal`\n\n    var isEmptyOp = conj == \"!\" && havingVals.length == 1 && havingVals[0] && (0, _stuff.isJsonLogic)(havingVals[0]) && conv.varKeys.includes(Object.keys(havingVals[0])[0]);\n\n    if (conj == \"!\" && !isEmptyOp) {\n      not = !not;\n      having = having[\"!\"];\n      conj = Object.keys(having)[0];\n      havingVals = having[conj];\n      if (!Array.isArray(havingVals)) havingVals = [havingVals];\n    }\n  } // Use reversed op\n\n\n  if (not && canRev && opConfig.reversedOp) {\n    not = false;\n    opKey = opConfig.reversedOp;\n    opConfig = config.operators[opKey];\n  }\n\n  var widget = (0, _ruleUtils.getWidgetForFieldOp)(config, field, opKey);\n  var convertedArgs = args.map(function (v) {\n    return convertFromLogic(v, conv, config, \"val\", meta, false, fieldConfig, widget, parentField);\n  });\n\n  if (convertedArgs.filter(function (v) {\n    return v === undefined;\n  }).length) {\n    //meta.errors.push(`Undefined arg for field ${field} and op ${opKey}`);\n    return undefined;\n  }\n\n  var res;\n\n  if (fieldConfig.type == \"!group\" && having) {\n    if (conv.conjunctions[conj] !== undefined) {\n      res = convertConj(conj, havingVals, conv, config, not, meta, field, true);\n      not = false; // not was applied to group\n    } else {\n      var _rule$properties;\n\n      // need to be wrapped in `rule_group`\n      var rule = convertOp(conj, havingVals, conv, config, not && canRev, meta, field);\n\n      if (not && canRev && !(rule !== null && rule !== void 0 && (_rule$properties = rule.properties) !== null && _rule$properties !== void 0 && _rule$properties.not)) {\n        not = false; // op was reversed in rule\n      }\n\n      res = wrapInDefaultConjRuleGroup(rule, field, fieldConfig, config, conv.conjunctions[\"and\"]);\n    }\n\n    if (!res) return undefined;\n    res.type = \"rule_group\";\n\n    if (not) {\n      Object.assign(res.properties, {\n        not: not\n      });\n    }\n\n    Object.assign(res.properties, {\n      field: field,\n      mode: fieldConfig.mode,\n      operator: opKey\n    });\n\n    if (fieldConfig.mode == \"array\") {\n      Object.assign(res.properties, {\n        value: convertedArgs.map(function (v) {\n          return v.value;\n        }),\n        valueSrc: convertedArgs.map(function (v) {\n          return v.valueSrc;\n        }),\n        valueType: convertedArgs.map(function (v) {\n          return v.valueType;\n        })\n      });\n    }\n  } else if (fieldConfig.type == \"!group\" && !having) {\n    res = {\n      type: \"rule_group\",\n      id: (0, _uuid[\"default\"])(),\n      children1: {},\n      properties: {\n        conjunction: (0, _defaultUtils.defaultGroupConjunction)(config, fieldConfig),\n        not: not,\n        mode: fieldConfig.mode,\n        field: field,\n        operator: opKey\n      }\n    };\n\n    if (fieldConfig.mode == \"array\") {\n      Object.assign(res.properties, {\n        value: convertedArgs.map(function (v) {\n          return v.value;\n        }),\n        valueSrc: convertedArgs.map(function (v) {\n          return v.valueSrc;\n        }),\n        valueType: convertedArgs.map(function (v) {\n          return v.valueType;\n        })\n      });\n    }\n  } else {\n    var asyncListValuesArr = convertedArgs.map(function (v) {\n      return v.asyncListValues;\n    }).filter(function (v) {\n      return v != undefined;\n    });\n    var asyncListValues = asyncListValuesArr.length ? asyncListValuesArr[0] : undefined;\n    res = {\n      type: \"rule\",\n      id: (0, _uuid[\"default\"])(),\n      properties: {\n        field: field,\n        operator: opKey,\n        value: convertedArgs.map(function (v) {\n          return v.value;\n        }),\n        valueSrc: convertedArgs.map(function (v) {\n          return v.valueSrc;\n        }),\n        valueType: convertedArgs.map(function (v) {\n          return v.valueType;\n        }),\n        asyncListValues: asyncListValues\n      }\n    };\n\n    if (not) {\n      //meta.errors.push(`No rev op for ${opKey}`);\n      res = wrapInDefaultConj(res, config, not);\n    }\n  }\n\n  return res;\n};"]},"metadata":{},"sourceType":"script"}