{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.normalizeField = exports.getOperatorConfig = exports.getFuncConfig = exports.getFuncArgConfig = exports.getFieldWidgetConfig = exports.getFieldRawConfig = exports.getFieldConfig = exports.extendConfig = void 0;\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _merge = _interopRequireDefault(require(\"lodash/merge\"));\n\nvar _mergeWith = _interopRequireDefault(require(\"lodash/mergeWith\"));\n\nvar _default = require(\"../config/default\");\n\nvar _moment = _interopRequireDefault(require(\"moment\"));\n\nvar _stuff = require(\"./stuff\");\n\nvar _ruleUtils = require(\"./ruleUtils\");\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n  if (!it) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nvar extendConfig = function extendConfig(config) {\n  //operators, defaultOperator - merge\n  //widgetProps (including valueLabel, valuePlaceholder, hideOperator, operatorInlineLabel) - concrete by widget\n  if (config.__extended) return config;\n  config.settings = (0, _merge[\"default\"])({}, _default.settings, config.settings);\n  config._fieldsCntByType = {};\n  config._funcsCntByType = {};\n\n  _extendTypesConfig(config.types, config);\n\n  config.__fieldNames = {};\n\n  _extendFieldsConfig(config.fields, config);\n\n  _extendFuncArgsConfig(config.funcs, config);\n\n  _moment[\"default\"].locale(config.settings.locale.moment);\n\n  Object.defineProperty(config, \"__extended\", {\n    enumerable: false,\n    writable: false,\n    value: true\n  });\n  return config;\n};\n\nexports.extendConfig = extendConfig;\n\nfunction _extendTypesConfig(typesConfig, config) {\n  for (var type in typesConfig) {\n    var typeConfig = typesConfig[type];\n\n    _extendTypeConfig(type, typeConfig, config);\n  }\n}\n\nfunction _extendTypeConfig(type, typeConfig, config) {\n  var operators = null,\n      defaultOperator = null;\n  typeConfig.mainWidget = typeConfig.mainWidget || Object.keys(typeConfig.widgets).filter(function (w) {\n    return w != \"field\" && w != \"func\";\n  })[0];\n\n  for (var widget in typeConfig.widgets) {\n    var typeWidgetConfig = typeConfig.widgets[widget];\n\n    if (typeWidgetConfig.operators) {\n      if (!operators) operators = [];\n      operators = operators.concat(typeWidgetConfig.operators.slice());\n    }\n\n    if (typeWidgetConfig.defaultOperator) defaultOperator = typeWidgetConfig.defaultOperator;\n\n    if (widget == typeConfig.mainWidget) {\n      typeWidgetConfig = (0, _merge[\"default\"])({}, {\n        widgetProps: typeConfig.mainWidgetProps || {}\n      }, typeWidgetConfig);\n    }\n\n    typeConfig.widgets[widget] = typeWidgetConfig;\n  }\n\n  if (!typeConfig.valueSources) typeConfig.valueSources = Object.keys(config.settings.valueSourcesInfo);\n\n  var _iterator = _createForOfIteratorHelper(typeConfig.valueSources),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var valueSrc = _step.value;\n\n      if (valueSrc != \"value\" && !typeConfig.widgets[valueSrc]) {\n        typeConfig.widgets[valueSrc] = {};\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  if (!typeConfig.operators && operators) typeConfig.operators = Array.from(new Set(operators)); //unique\n\n  if (!typeConfig.defaultOperator && defaultOperator) typeConfig.defaultOperator = defaultOperator;\n}\n\nfunction _extendFieldsConfig(subconfig, config) {\n  var path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n  for (var field in subconfig) {\n    _extendFieldConfig(subconfig[field], config, [].concat((0, _toConsumableArray2[\"default\"])(path), [field]));\n\n    if (subconfig[field].subfields) {\n      _extendFieldsConfig(subconfig[field].subfields, config, [].concat((0, _toConsumableArray2[\"default\"])(path), [field]));\n    }\n  }\n}\n\nfunction _extendFuncArgsConfig(subconfig, config) {\n  if (!subconfig) return;\n\n  for (var funcKey in subconfig) {\n    var funcDef = subconfig[funcKey];\n\n    if (funcDef.returnType) {\n      if (!config._funcsCntByType[funcDef.returnType]) config._funcsCntByType[funcDef.returnType] = 0;\n      config._funcsCntByType[funcDef.returnType]++;\n    }\n\n    for (var argKey in funcDef.args) {\n      _extendFieldConfig(funcDef.args[argKey], config, null, true);\n    } // isOptional can be only in the end\n\n\n    if (funcDef.args) {\n      var argKeys = Object.keys(funcDef.args);\n      var tmpIsOptional = true;\n\n      var _iterator2 = _createForOfIteratorHelper(argKeys.reverse()),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _argKey = _step2.value;\n          var argDef = funcDef.args[_argKey];\n\n          if (!tmpIsOptional && argDef.isOptional) {\n            delete argDef.isOptional;\n          }\n\n          if (!argDef.isOptional) tmpIsOptional = false;\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n\n    if (funcDef.subfields) {\n      _extendFuncArgsConfig(funcDef.subfields, config);\n    }\n  }\n}\n\nfunction _extendFieldConfig(fieldConfig, config) {\n  var path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var isFuncArg = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var operators = null,\n      defaultOperator = null;\n  var typeConfig = config.types[fieldConfig.type];\n  var excludeOperators = fieldConfig.excludeOperators || [];\n\n  if (fieldConfig.type != \"!struct\" && fieldConfig.type != \"!group\") {\n    if (!typeConfig) {\n      //console.warn(`No type config for ${fieldConfig.type}`);\n      fieldConfig.disabled = true;\n      return;\n    }\n\n    if (!isFuncArg) {\n      if (!config._fieldsCntByType[fieldConfig.type]) config._fieldsCntByType[fieldConfig.type] = 0;\n      config._fieldsCntByType[fieldConfig.type]++;\n    }\n\n    if (!fieldConfig.widgets) fieldConfig.widgets = {};\n    if (isFuncArg) fieldConfig._isFuncArg = true;\n    fieldConfig.mainWidget = fieldConfig.mainWidget || typeConfig.mainWidget;\n    fieldConfig.valueSources = fieldConfig.valueSources || typeConfig.valueSources;\n\n    for (var widget in typeConfig.widgets) {\n      var fieldWidgetConfig = fieldConfig.widgets[widget] || {};\n      var typeWidgetConfig = typeConfig.widgets[widget] || {};\n\n      if (!isFuncArg) {\n        //todo: why I've excluded isFuncArg ?\n        var shouldIncludeOperators = fieldConfig.preferWidgets && (widget == \"field\" || fieldConfig.preferWidgets.includes(widget)) || excludeOperators.length > 0;\n\n        if (fieldWidgetConfig.operators) {\n          if (!operators) operators = [];\n          operators = operators.concat(fieldWidgetConfig.operators.filter(function (o) {\n            return !excludeOperators.includes(o);\n          }));\n        } else if (shouldIncludeOperators && typeWidgetConfig.operators) {\n          if (!operators) operators = [];\n          operators = operators.concat(typeWidgetConfig.operators.filter(function (o) {\n            return !excludeOperators.includes(o);\n          }));\n        }\n\n        if (fieldWidgetConfig.defaultOperator) defaultOperator = fieldWidgetConfig.defaultOperator;\n      }\n\n      if (widget == fieldConfig.mainWidget) {\n        fieldWidgetConfig = (0, _merge[\"default\"])({}, {\n          widgetProps: fieldConfig.mainWidgetProps || {}\n        }, fieldWidgetConfig);\n      }\n\n      fieldConfig.widgets[widget] = fieldWidgetConfig;\n    }\n\n    if (!isFuncArg) {\n      if (!fieldConfig.operators && operators) fieldConfig.operators = Array.from(new Set(operators));\n      if (!fieldConfig.defaultOperator && defaultOperator) fieldConfig.defaultOperator = defaultOperator;\n    }\n\n    var keysToPutInFieldSettings = [\"listValues\", \"allowCustomValues\", \"validateValue\"];\n    if (!fieldConfig.fieldSettings) fieldConfig.fieldSettings = {};\n\n    for (var _i = 0, _keysToPutInFieldSett = keysToPutInFieldSettings; _i < _keysToPutInFieldSett.length; _i++) {\n      var k = _keysToPutInFieldSett[_i];\n\n      if (fieldConfig[k]) {\n        fieldConfig.fieldSettings[k] = fieldConfig[k];\n        delete fieldConfig[k];\n      }\n    }\n\n    if (fieldConfig.fieldSettings.listValues) {\n      fieldConfig.fieldSettings.listValues = (0, _stuff.normalizeListValues)(fieldConfig.fieldSettings.listValues, fieldConfig.type, fieldConfig.fieldSettings);\n    }\n  }\n\n  var computedFieldName = computeFieldName(config, path);\n\n  if (computedFieldName) {\n    fieldConfig.fieldName = computedFieldName;\n  }\n\n  if (path && fieldConfig.fieldName) {\n    config.__fieldNames[fieldConfig.fieldName] = path;\n  }\n}\n\nvar getFieldRawConfig = function getFieldRawConfig(config, field) {\n  var fieldsKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"fields\";\n  var subfieldsKey = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"subfields\";\n  if (!field) return null;\n  var fieldSeparator = config.settings.fieldSeparator; //field = normalizeField(config, field);\n\n  var parts = Array.isArray(field) ? field : field.split(fieldSeparator);\n  var targetFields = config[fieldsKey];\n  if (!targetFields) return null;\n  var fields = targetFields;\n  var fieldConfig = null;\n  var path = [];\n\n  for (var i = 0; i < parts.length; i++) {\n    var part = parts[i];\n    path.push(part);\n    var pathKey = path.join(fieldSeparator);\n    fieldConfig = fields[pathKey];\n\n    if (i < parts.length - 1) {\n      if (fieldConfig && fieldConfig[subfieldsKey]) {\n        fields = fieldConfig[subfieldsKey];\n        path = [];\n      } else {\n        fieldConfig = null;\n      }\n    }\n  }\n\n  return fieldConfig;\n};\n\nexports.getFieldRawConfig = getFieldRawConfig;\n\nvar computeFieldName = function computeFieldName(config, path) {\n  if (!path) return null;\n  var fieldSeparator = config.settings.fieldSeparator;\n  var l = (0, _toConsumableArray2[\"default\"])(path),\n      r = [],\n      f,\n      fConfig;\n\n  while ((f = l.pop()) !== undefined && l.length > 0) {\n    r.unshift(f);\n    fConfig = getFieldRawConfig(config, l);\n\n    if (fConfig.fieldName) {\n      return [fConfig.fieldName].concat(r).join(fieldSeparator);\n    }\n  }\n\n  return null;\n};\n\nvar normalizeField = function normalizeField(config, field) {\n  var fieldSeparator = config.settings.fieldSeparator;\n  var fieldStr = Array.isArray(field) ? field.join(fieldSeparator) : field;\n\n  if (config.__fieldNames[fieldStr]) {\n    return config.__fieldNames[fieldStr].join(fieldSeparator);\n  }\n\n  return fieldStr;\n};\n\nexports.normalizeField = normalizeField;\n\nvar getFuncConfig = function getFuncConfig(config, func) {\n  if (!func) return null;\n  var funcConfig = getFieldRawConfig(config, func, \"funcs\", \"subfields\");\n  if (!funcConfig) return null; //throw new Error(\"Can't find func \" + func + \", please check your config\");\n\n  return funcConfig;\n};\n\nexports.getFuncConfig = getFuncConfig;\n\nvar getFuncArgConfig = function getFuncArgConfig(config, funcKey, argKey) {\n  var funcConfig = getFuncConfig(config, funcKey);\n  if (!funcConfig) return null; //throw new Error(`Can't find func ${funcKey}, please check your config`);\n\n  var argConfig = funcConfig.args && funcConfig.args[argKey] || null;\n  if (!argConfig) return null; //throw new Error(`Can't find arg ${argKey} for func ${funcKey}, please check your config`);\n  //merge, but don't merge operators (rewrite instead)\n\n  var typeConfig = config.types[argConfig.type] || {};\n  var ret = (0, _mergeWith[\"default\"])({}, typeConfig, argConfig || {}, function (objValue, srcValue, _key, _object, _source, _stack) {\n    if (Array.isArray(objValue)) {\n      return srcValue;\n    }\n  });\n  return ret;\n};\n\nexports.getFuncArgConfig = getFuncArgConfig;\n\nvar getFieldConfig = function getFieldConfig(config, field) {\n  if (!field) return null;\n  if ((0, _typeof2[\"default\"])(field) == \"object\" && !field.func && !!field.type) return field;\n  if ((0, _typeof2[\"default\"])(field) == \"object\" && field.func && field.arg) return getFuncArgConfig(config, field.func, field.arg);\n  var fieldConfig = getFieldRawConfig(config, field);\n  if (!fieldConfig) return null; //throw new Error(\"Can't find field \" + field + \", please check your config\");\n  //merge, but don't merge operators (rewrite instead)\n\n  var typeConfig = config.types[fieldConfig.type] || {};\n  var ret = (0, _mergeWith[\"default\"])({}, typeConfig, fieldConfig || {}, function (objValue, srcValue, _key, _object, _source, _stack) {\n    if (Array.isArray(objValue)) {\n      return srcValue;\n    }\n  });\n  return ret;\n};\n\nexports.getFieldConfig = getFieldConfig;\n\nvar getOperatorConfig = function getOperatorConfig(config, operator) {\n  var field = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  if (!operator) return null;\n  var opConfig = config.operators[operator];\n\n  if (field) {\n    var fieldConfig = getFieldConfig(config, field);\n    var widget = (0, _ruleUtils.getWidgetForFieldOp)(config, field, operator);\n    var widgetConfig = config.widgets[widget] || {};\n    var fieldWidgetConfig = (fieldConfig && fieldConfig.widgets ? fieldConfig.widgets[widget] : {}) || {};\n    var widgetOpProps = (widgetConfig.opProps || {})[operator];\n    var fieldWidgetOpProps = (fieldWidgetConfig.opProps || {})[operator];\n    var mergedOpConfig = (0, _merge[\"default\"])({}, opConfig, widgetOpProps, fieldWidgetOpProps);\n    return mergedOpConfig;\n  } else {\n    return opConfig;\n  }\n};\n\nexports.getOperatorConfig = getOperatorConfig;\n\nvar getFieldWidgetConfig = function getFieldWidgetConfig(config, field, operator) {\n  var widget = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var valueSrc = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  if (!field) return null;\n  if (!(operator || widget) && valueSrc != \"const\") return null;\n  var fieldConfig = getFieldConfig(config, field);\n  if (!widget) widget = (0, _ruleUtils.getWidgetForFieldOp)(config, field, operator, valueSrc);\n  var widgetConfig = config.widgets[widget] || {};\n  var fieldWidgetConfig = (fieldConfig && fieldConfig.widgets ? fieldConfig.widgets[widget] : {}) || {};\n  var fieldWidgetProps = fieldWidgetConfig.widgetProps || {};\n  var valueFieldSettings = (valueSrc == \"value\" || !valueSrc) && fieldConfig && fieldConfig.fieldSettings || {}; // useful to take 'validateValue'\n\n  var mergedConfig = (0, _merge[\"default\"])({}, widgetConfig, fieldWidgetProps, valueFieldSettings);\n  return mergedConfig;\n};\n\nexports.getFieldWidgetConfig = getFieldWidgetConfig;","map":{"version":3,"sources":["D:/Postgres_workingFolder/QuaLISWeb/node_modules/react-awesome-query-builder/lib/utils/configUtils.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","normalizeField","getOperatorConfig","getFuncConfig","getFuncArgConfig","getFieldWidgetConfig","getFieldRawConfig","getFieldConfig","extendConfig","_typeof2","_toConsumableArray2","_merge","_mergeWith","_default","_moment","_stuff","_ruleUtils","_createForOfIteratorHelper","o","allowArrayLike","it","Symbol","iterator","Array","isArray","_unsupportedIterableToArray","length","i","F","s","n","done","e","_e","f","TypeError","normalCompletion","didErr","err","call","step","next","_e2","minLen","_arrayLikeToArray","prototype","toString","slice","constructor","name","from","test","arr","len","arr2","config","__extended","settings","_fieldsCntByType","_funcsCntByType","_extendTypesConfig","types","__fieldNames","_extendFieldsConfig","fields","_extendFuncArgsConfig","funcs","locale","moment","enumerable","writable","typesConfig","type","typeConfig","_extendTypeConfig","operators","defaultOperator","mainWidget","keys","widgets","filter","w","widget","typeWidgetConfig","concat","widgetProps","mainWidgetProps","valueSources","valueSourcesInfo","_iterator","_step","valueSrc","Set","subconfig","path","arguments","undefined","field","_extendFieldConfig","subfields","funcKey","funcDef","returnType","argKey","args","argKeys","tmpIsOptional","_iterator2","reverse","_step2","_argKey","argDef","isOptional","fieldConfig","isFuncArg","excludeOperators","disabled","_isFuncArg","fieldWidgetConfig","shouldIncludeOperators","preferWidgets","includes","keysToPutInFieldSettings","fieldSettings","_i","_keysToPutInFieldSett","k","listValues","normalizeListValues","computedFieldName","computeFieldName","fieldName","fieldsKey","subfieldsKey","fieldSeparator","parts","split","targetFields","part","push","pathKey","join","l","r","fConfig","pop","unshift","fieldStr","func","funcConfig","argConfig","ret","objValue","srcValue","_key","_object","_source","_stack","arg","operator","opConfig","getWidgetForFieldOp","widgetConfig","widgetOpProps","opProps","fieldWidgetOpProps","mergedOpConfig","fieldWidgetProps","valueFieldSettings","mergedConfig"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.normalizeField = exports.getOperatorConfig = exports.getFuncConfig = exports.getFuncArgConfig = exports.getFieldWidgetConfig = exports.getFieldRawConfig = exports.getFieldConfig = exports.extendConfig = void 0;\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _merge = _interopRequireDefault(require(\"lodash/merge\"));\n\nvar _mergeWith = _interopRequireDefault(require(\"lodash/mergeWith\"));\n\nvar _default = require(\"../config/default\");\n\nvar _moment = _interopRequireDefault(require(\"moment\"));\n\nvar _stuff = require(\"./stuff\");\n\nvar _ruleUtils = require(\"./ruleUtils\");\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar extendConfig = function extendConfig(config) {\n  //operators, defaultOperator - merge\n  //widgetProps (including valueLabel, valuePlaceholder, hideOperator, operatorInlineLabel) - concrete by widget\n  if (config.__extended) return config;\n  config.settings = (0, _merge[\"default\"])({}, _default.settings, config.settings);\n  config._fieldsCntByType = {};\n  config._funcsCntByType = {};\n\n  _extendTypesConfig(config.types, config);\n\n  config.__fieldNames = {};\n\n  _extendFieldsConfig(config.fields, config);\n\n  _extendFuncArgsConfig(config.funcs, config);\n\n  _moment[\"default\"].locale(config.settings.locale.moment);\n\n  Object.defineProperty(config, \"__extended\", {\n    enumerable: false,\n    writable: false,\n    value: true\n  });\n  return config;\n};\n\nexports.extendConfig = extendConfig;\n\nfunction _extendTypesConfig(typesConfig, config) {\n  for (var type in typesConfig) {\n    var typeConfig = typesConfig[type];\n\n    _extendTypeConfig(type, typeConfig, config);\n  }\n}\n\nfunction _extendTypeConfig(type, typeConfig, config) {\n  var operators = null,\n      defaultOperator = null;\n  typeConfig.mainWidget = typeConfig.mainWidget || Object.keys(typeConfig.widgets).filter(function (w) {\n    return w != \"field\" && w != \"func\";\n  })[0];\n\n  for (var widget in typeConfig.widgets) {\n    var typeWidgetConfig = typeConfig.widgets[widget];\n\n    if (typeWidgetConfig.operators) {\n      if (!operators) operators = [];\n      operators = operators.concat(typeWidgetConfig.operators.slice());\n    }\n\n    if (typeWidgetConfig.defaultOperator) defaultOperator = typeWidgetConfig.defaultOperator;\n\n    if (widget == typeConfig.mainWidget) {\n      typeWidgetConfig = (0, _merge[\"default\"])({}, {\n        widgetProps: typeConfig.mainWidgetProps || {}\n      }, typeWidgetConfig);\n    }\n\n    typeConfig.widgets[widget] = typeWidgetConfig;\n  }\n\n  if (!typeConfig.valueSources) typeConfig.valueSources = Object.keys(config.settings.valueSourcesInfo);\n\n  var _iterator = _createForOfIteratorHelper(typeConfig.valueSources),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var valueSrc = _step.value;\n\n      if (valueSrc != \"value\" && !typeConfig.widgets[valueSrc]) {\n        typeConfig.widgets[valueSrc] = {};\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  if (!typeConfig.operators && operators) typeConfig.operators = Array.from(new Set(operators)); //unique\n\n  if (!typeConfig.defaultOperator && defaultOperator) typeConfig.defaultOperator = defaultOperator;\n}\n\nfunction _extendFieldsConfig(subconfig, config) {\n  var path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n  for (var field in subconfig) {\n    _extendFieldConfig(subconfig[field], config, [].concat((0, _toConsumableArray2[\"default\"])(path), [field]));\n\n    if (subconfig[field].subfields) {\n      _extendFieldsConfig(subconfig[field].subfields, config, [].concat((0, _toConsumableArray2[\"default\"])(path), [field]));\n    }\n  }\n}\n\nfunction _extendFuncArgsConfig(subconfig, config) {\n  if (!subconfig) return;\n\n  for (var funcKey in subconfig) {\n    var funcDef = subconfig[funcKey];\n\n    if (funcDef.returnType) {\n      if (!config._funcsCntByType[funcDef.returnType]) config._funcsCntByType[funcDef.returnType] = 0;\n      config._funcsCntByType[funcDef.returnType]++;\n    }\n\n    for (var argKey in funcDef.args) {\n      _extendFieldConfig(funcDef.args[argKey], config, null, true);\n    } // isOptional can be only in the end\n\n\n    if (funcDef.args) {\n      var argKeys = Object.keys(funcDef.args);\n      var tmpIsOptional = true;\n\n      var _iterator2 = _createForOfIteratorHelper(argKeys.reverse()),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _argKey = _step2.value;\n          var argDef = funcDef.args[_argKey];\n\n          if (!tmpIsOptional && argDef.isOptional) {\n            delete argDef.isOptional;\n          }\n\n          if (!argDef.isOptional) tmpIsOptional = false;\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n\n    if (funcDef.subfields) {\n      _extendFuncArgsConfig(funcDef.subfields, config);\n    }\n  }\n}\n\nfunction _extendFieldConfig(fieldConfig, config) {\n  var path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var isFuncArg = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var operators = null,\n      defaultOperator = null;\n  var typeConfig = config.types[fieldConfig.type];\n  var excludeOperators = fieldConfig.excludeOperators || [];\n\n  if (fieldConfig.type != \"!struct\" && fieldConfig.type != \"!group\") {\n    if (!typeConfig) {\n      //console.warn(`No type config for ${fieldConfig.type}`);\n      fieldConfig.disabled = true;\n      return;\n    }\n\n    if (!isFuncArg) {\n      if (!config._fieldsCntByType[fieldConfig.type]) config._fieldsCntByType[fieldConfig.type] = 0;\n      config._fieldsCntByType[fieldConfig.type]++;\n    }\n\n    if (!fieldConfig.widgets) fieldConfig.widgets = {};\n    if (isFuncArg) fieldConfig._isFuncArg = true;\n    fieldConfig.mainWidget = fieldConfig.mainWidget || typeConfig.mainWidget;\n    fieldConfig.valueSources = fieldConfig.valueSources || typeConfig.valueSources;\n\n    for (var widget in typeConfig.widgets) {\n      var fieldWidgetConfig = fieldConfig.widgets[widget] || {};\n      var typeWidgetConfig = typeConfig.widgets[widget] || {};\n\n      if (!isFuncArg) {\n        //todo: why I've excluded isFuncArg ?\n        var shouldIncludeOperators = fieldConfig.preferWidgets && (widget == \"field\" || fieldConfig.preferWidgets.includes(widget)) || excludeOperators.length > 0;\n\n        if (fieldWidgetConfig.operators) {\n          if (!operators) operators = [];\n          operators = operators.concat(fieldWidgetConfig.operators.filter(function (o) {\n            return !excludeOperators.includes(o);\n          }));\n        } else if (shouldIncludeOperators && typeWidgetConfig.operators) {\n          if (!operators) operators = [];\n          operators = operators.concat(typeWidgetConfig.operators.filter(function (o) {\n            return !excludeOperators.includes(o);\n          }));\n        }\n\n        if (fieldWidgetConfig.defaultOperator) defaultOperator = fieldWidgetConfig.defaultOperator;\n      }\n\n      if (widget == fieldConfig.mainWidget) {\n        fieldWidgetConfig = (0, _merge[\"default\"])({}, {\n          widgetProps: fieldConfig.mainWidgetProps || {}\n        }, fieldWidgetConfig);\n      }\n\n      fieldConfig.widgets[widget] = fieldWidgetConfig;\n    }\n\n    if (!isFuncArg) {\n      if (!fieldConfig.operators && operators) fieldConfig.operators = Array.from(new Set(operators));\n      if (!fieldConfig.defaultOperator && defaultOperator) fieldConfig.defaultOperator = defaultOperator;\n    }\n\n    var keysToPutInFieldSettings = [\"listValues\", \"allowCustomValues\", \"validateValue\"];\n    if (!fieldConfig.fieldSettings) fieldConfig.fieldSettings = {};\n\n    for (var _i = 0, _keysToPutInFieldSett = keysToPutInFieldSettings; _i < _keysToPutInFieldSett.length; _i++) {\n      var k = _keysToPutInFieldSett[_i];\n\n      if (fieldConfig[k]) {\n        fieldConfig.fieldSettings[k] = fieldConfig[k];\n        delete fieldConfig[k];\n      }\n    }\n\n    if (fieldConfig.fieldSettings.listValues) {\n      fieldConfig.fieldSettings.listValues = (0, _stuff.normalizeListValues)(fieldConfig.fieldSettings.listValues, fieldConfig.type, fieldConfig.fieldSettings);\n    }\n  }\n\n  var computedFieldName = computeFieldName(config, path);\n\n  if (computedFieldName) {\n    fieldConfig.fieldName = computedFieldName;\n  }\n\n  if (path && fieldConfig.fieldName) {\n    config.__fieldNames[fieldConfig.fieldName] = path;\n  }\n}\n\nvar getFieldRawConfig = function getFieldRawConfig(config, field) {\n  var fieldsKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"fields\";\n  var subfieldsKey = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"subfields\";\n  if (!field) return null;\n  var fieldSeparator = config.settings.fieldSeparator; //field = normalizeField(config, field);\n\n  var parts = Array.isArray(field) ? field : field.split(fieldSeparator);\n  var targetFields = config[fieldsKey];\n  if (!targetFields) return null;\n  var fields = targetFields;\n  var fieldConfig = null;\n  var path = [];\n\n  for (var i = 0; i < parts.length; i++) {\n    var part = parts[i];\n    path.push(part);\n    var pathKey = path.join(fieldSeparator);\n    fieldConfig = fields[pathKey];\n\n    if (i < parts.length - 1) {\n      if (fieldConfig && fieldConfig[subfieldsKey]) {\n        fields = fieldConfig[subfieldsKey];\n        path = [];\n      } else {\n        fieldConfig = null;\n      }\n    }\n  }\n\n  return fieldConfig;\n};\n\nexports.getFieldRawConfig = getFieldRawConfig;\n\nvar computeFieldName = function computeFieldName(config, path) {\n  if (!path) return null;\n  var fieldSeparator = config.settings.fieldSeparator;\n  var l = (0, _toConsumableArray2[\"default\"])(path),\n      r = [],\n      f,\n      fConfig;\n\n  while ((f = l.pop()) !== undefined && l.length > 0) {\n    r.unshift(f);\n    fConfig = getFieldRawConfig(config, l);\n\n    if (fConfig.fieldName) {\n      return [fConfig.fieldName].concat(r).join(fieldSeparator);\n    }\n  }\n\n  return null;\n};\n\nvar normalizeField = function normalizeField(config, field) {\n  var fieldSeparator = config.settings.fieldSeparator;\n  var fieldStr = Array.isArray(field) ? field.join(fieldSeparator) : field;\n\n  if (config.__fieldNames[fieldStr]) {\n    return config.__fieldNames[fieldStr].join(fieldSeparator);\n  }\n\n  return fieldStr;\n};\n\nexports.normalizeField = normalizeField;\n\nvar getFuncConfig = function getFuncConfig(config, func) {\n  if (!func) return null;\n  var funcConfig = getFieldRawConfig(config, func, \"funcs\", \"subfields\");\n  if (!funcConfig) return null; //throw new Error(\"Can't find func \" + func + \", please check your config\");\n\n  return funcConfig;\n};\n\nexports.getFuncConfig = getFuncConfig;\n\nvar getFuncArgConfig = function getFuncArgConfig(config, funcKey, argKey) {\n  var funcConfig = getFuncConfig(config, funcKey);\n  if (!funcConfig) return null; //throw new Error(`Can't find func ${funcKey}, please check your config`);\n\n  var argConfig = funcConfig.args && funcConfig.args[argKey] || null;\n  if (!argConfig) return null; //throw new Error(`Can't find arg ${argKey} for func ${funcKey}, please check your config`);\n  //merge, but don't merge operators (rewrite instead)\n\n  var typeConfig = config.types[argConfig.type] || {};\n  var ret = (0, _mergeWith[\"default\"])({}, typeConfig, argConfig || {}, function (objValue, srcValue, _key, _object, _source, _stack) {\n    if (Array.isArray(objValue)) {\n      return srcValue;\n    }\n  });\n  return ret;\n};\n\nexports.getFuncArgConfig = getFuncArgConfig;\n\nvar getFieldConfig = function getFieldConfig(config, field) {\n  if (!field) return null;\n  if ((0, _typeof2[\"default\"])(field) == \"object\" && !field.func && !!field.type) return field;\n  if ((0, _typeof2[\"default\"])(field) == \"object\" && field.func && field.arg) return getFuncArgConfig(config, field.func, field.arg);\n  var fieldConfig = getFieldRawConfig(config, field);\n  if (!fieldConfig) return null; //throw new Error(\"Can't find field \" + field + \", please check your config\");\n  //merge, but don't merge operators (rewrite instead)\n\n  var typeConfig = config.types[fieldConfig.type] || {};\n  var ret = (0, _mergeWith[\"default\"])({}, typeConfig, fieldConfig || {}, function (objValue, srcValue, _key, _object, _source, _stack) {\n    if (Array.isArray(objValue)) {\n      return srcValue;\n    }\n  });\n  return ret;\n};\n\nexports.getFieldConfig = getFieldConfig;\n\nvar getOperatorConfig = function getOperatorConfig(config, operator) {\n  var field = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  if (!operator) return null;\n  var opConfig = config.operators[operator];\n\n  if (field) {\n    var fieldConfig = getFieldConfig(config, field);\n    var widget = (0, _ruleUtils.getWidgetForFieldOp)(config, field, operator);\n    var widgetConfig = config.widgets[widget] || {};\n    var fieldWidgetConfig = (fieldConfig && fieldConfig.widgets ? fieldConfig.widgets[widget] : {}) || {};\n    var widgetOpProps = (widgetConfig.opProps || {})[operator];\n    var fieldWidgetOpProps = (fieldWidgetConfig.opProps || {})[operator];\n    var mergedOpConfig = (0, _merge[\"default\"])({}, opConfig, widgetOpProps, fieldWidgetOpProps);\n    return mergedOpConfig;\n  } else {\n    return opConfig;\n  }\n};\n\nexports.getOperatorConfig = getOperatorConfig;\n\nvar getFieldWidgetConfig = function getFieldWidgetConfig(config, field, operator) {\n  var widget = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var valueSrc = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  if (!field) return null;\n  if (!(operator || widget) && valueSrc != \"const\") return null;\n  var fieldConfig = getFieldConfig(config, field);\n  if (!widget) widget = (0, _ruleUtils.getWidgetForFieldOp)(config, field, operator, valueSrc);\n  var widgetConfig = config.widgets[widget] || {};\n  var fieldWidgetConfig = (fieldConfig && fieldConfig.widgets ? fieldConfig.widgets[widget] : {}) || {};\n  var fieldWidgetProps = fieldWidgetConfig.widgetProps || {};\n  var valueFieldSettings = (valueSrc == \"value\" || !valueSrc) && fieldConfig && fieldConfig.fieldSettings || {}; // useful to take 'validateValue'\n\n  var mergedConfig = (0, _merge[\"default\"])({}, widgetConfig, fieldWidgetProps, valueFieldSettings);\n  return mergedConfig;\n};\n\nexports.getFieldWidgetConfig = getFieldWidgetConfig;"]},"metadata":{},"sourceType":"script"}